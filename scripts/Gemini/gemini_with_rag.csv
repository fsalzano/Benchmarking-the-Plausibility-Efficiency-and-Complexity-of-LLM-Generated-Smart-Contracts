ID,Comment,Contract,target_function,GeminiCognitiveComplexity,GeminiCyclomaticComplexity,ast,TED,SemanticSimilarity,BLEU,GeminiGenerated,Time,contract_with_constructor
3024,Announce that a particular future Ethereum fork will the one taken by the contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""Caller is not a role"");
        _;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",announceFork,"[{'function': 'announceFork', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}, {""type"": ""stringLiteral"", ""value"": ""Block number must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""url""}, {""type"": ""Identifier"", ""name"": ""blockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyPlatformOperatorRepresentative"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.9028899216342792,0.6632145183502179,"pragma solidity ^0.8.0;

contract ForkAnnouncer {

    bytes32 public constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = keccak256(""ROLE_PLATFORM_OPERATOR_REPRESENTATIVE"");

    string public _nextForkName;
    string public _nextForkUrl;
    uint256 public _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    modifier onlyPlatformOperatorRepresentative() {
        //  Implementation for role checking would go here.  This is placeholder code.
        //  Replace with your actual role-based access control mechanism.
        require(true, ""Caller is not a platform operator representative"");
        _;
    }


    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyPlatformOperatorRepresentative {
        require(blockNumber == 0 || blockNumber > block.number, ""Block number must be in the future"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(name, url, blockNumber);
    }
}",42.28128147125244,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ForkAnnouncer is Ownable {
    bytes32 public constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = keccak256(""ROLE_PLATFORM_OPERATOR_REPRESENTATIVE"");

    string public _nextForkName;
    string public _nextForkUrl;
    uint256 public _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    modifier onlyPlatformOperatorRepresentative() {
        require(true, ""Caller is not a platform operator representative"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _nextForkName = 'initialized';
        _nextForkUrl = 'initialized';
        _nextForkBlockNumber = 1;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyPlatformOperatorRepresentative {
        require(blockNumber == 0 || blockNumber > block.number, ""Block number must be in the future"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(name, url, blockNumber);
    }
}"
2295,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    constructor(address _tokenContract, uint256 _sellFloor, uint256 _sellCeiling) {
        tokenContract = ERC20Interface(_tokenContract);
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function sell(uint256 quantity, uint256 price, uint256 expiry) public {
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}",offerTokens,"[{'function': 'setSellCeiling', 'complexity': 0}, {'function': 'offerTokens', 'complexity': 7}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""offerTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Quantity must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""expiry""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Expiry date must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellFloor""}}, {""type"": ""stringLiteral"", ""value"": ""Price must meet or exceed the minimum allowed price""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}}, {""type"": ""stringLiteral"", ""value"": ""Price must not exceed the maximum allowed price""}], ""names"": []}}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TradeOrder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensOffered""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.9269506182458842,0.459047288712198,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenSale {

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;
    uint256 public sellFloor;
    uint256 public sellCeiling;
    IERC20 public token;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    constructor(address _tokenAddress, uint256 _sellFloor) {
        token = IERC20(_tokenAddress);
        sellFloor = _sellFloor;
    }

    function setSellCeiling(uint256 _sellCeiling) public {
        sellCeiling = _sellCeiling;
    }


    function offerTokens(uint256 quantity, uint256 price, uint256 expiry) public {
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(price > 0, ""Price must be greater than zero"");
        require(expiry > block.timestamp, ""Expiry date must be in the future"");
        require(price >= sellFloor, ""Price must meet or exceed the minimum allowed price"");
        if (sellCeiling > 0) require(price <= sellCeiling, ""Price must not exceed the maximum allowed price"");
        require(token.allowance(msg.sender, address(this)) >= quantity, ""Insufficient allowance"");
        require(token.balanceOf(msg.sender) >= quantity, ""Insufficient balance"");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}",44.31855154037476,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;
    uint256 public sellFloor;
    uint256 public sellCeiling;
    IERC20 public token;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress, uint256 _sellFloor) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        sellFloor = _sellFloor;
        sellCeiling = 0; // Default to zero as per initialization rules
    }

    function setSellCeiling(uint256 _sellCeiling) public {
        require(_sellCeiling > 0, ""Sell ceiling must be greater than zero"");
        sellCeiling = _sellCeiling;
    }

    function offerTokens(uint256 quantity, uint256 price, uint256 expiry) public {
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(price > 0, ""Price must be greater than zero"");
        require(expiry > block.timestamp, ""Expiry date must be in the future"");
        require(price >= sellFloor, ""Price must meet or exceed the minimum allowed price"");
        if (sellCeiling > 0) require(price <= sellCeiling, ""Price must not exceed the maximum allowed price"");
        require(token.allowance(msg.sender, address(this)) >= quantity, ""Insufficient allowance"");
        require(token.balanceOf(msg.sender) >= quantity, ""Insufficient balance"");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}"
1386,Set the minimum deposit amount required to depoist sUSD into the FIFO queue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol""; // Assuming this import is correct, adjust if necessary

abstract contract YourContract {
    using SafeMath for uint256;
    uint public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint indexed newAmount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        require(_amount > SafeDecimalMath.unit(), ""Minimum deposit amount must be greater than UNIT"");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(minimumDepositAmount);
    }
}",setMinimumDepositAmount,"[{'function': 'setMinimumDepositAmount', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinimumDepositAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than UNIT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minimumDepositAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MinimumDepositAmountUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.846588533501334,0.3873863170954998,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    uint256 public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint256 newAmount);

    function setMinimumDepositAmount(uint256 _amount) public onlyOwner {
        require(_amount > 10**18, ""Amount must be greater than UNIT""); // Assuming UNIT is 10**18. Adjust as needed based on your SafeDecimalMath library.
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(_amount);
    }
}",42.35216689109802,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {

    uint256 public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint256 newAmount);

    constructor() Ownable(msg.sender) {
        minimumDepositAmount = 1; // Set to a non-zero, safe value
    }

    function setMinimumDepositAmount(uint256 _amount) public onlyOwner {
        require(_amount > 10**18, ""Amount must be greater than UNIT""); // Assuming UNIT is 10**18. Adjust as needed based on your SafeDecimalMath library.
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(_amount);
    }
}"
6236,Helper function that checks for ERC777TokensSender on the sender and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensSender {
    function tokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function callSender(address _operator, address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) private whenNotPaused {
        address senderImplementation = interfaceAddr(_from, ""ERC777TokensSender"");
        if (senderImplementation != 0) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    function interfaceAddr(address contractAddress, string memory interfaceName) internal view returns (address) {
        // Implementation of the logic to retrieve the interface address
        return contractAddress;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}",_callTokensToSend,"[{'function': 'tokensToSend', 'complexity': 0}, {'function': 'interfaceAddr', 'complexity': 0}, {'function': '_callTokensToSend', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""_callTokensToSend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_userData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""senderImplementation"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""interfaceAddr""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""senderImplementation""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC777TokensSender""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""senderImplementation""}], ""names"": []}, ""memberName"": ""tokensToSend""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_userData""}, {""type"": ""Identifier"", ""name"": ""_operatorData""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""private"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.938385925228357,0.7850772002166553,"pragma solidity ^0.8.0;

interface ERC777TokensSender {
    function tokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;
}

contract MyContract {
    function interfaceAddr(address _addr) internal view returns (address) {
        //Implementation to retrieve interface address.  Replace with your actual logic.
        return address(0);
    }

    modifier whenNotPaused() {
        //Implementation for whenNotPaused modifier. Replace with your actual logic.
        _;
    }

    function _callTokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) private whenNotPaused {
        address senderImplementation = interfaceAddr(_from);
        if (senderImplementation != address(0)) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }
}",43.093191146850586,"pragma solidity ^0.8.0;

interface ERC777TokensSender {
    function tokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    // Fixed values for initialization
    uint256 public constant INIT_VALUE = 1;
    address public constant INIT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant INIT_BOOL = true;
    string public constant INIT_STRING = 'initialized';
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed values
        uint256[1] storage _uintStorage;
        _uintStorage[0] = INIT_VALUE;

        address[] storage _addressStorage;
        _addressStorage[0] = INIT_ADDRESS;

        bool[] storage _boolStorage;
        _boolStorage[0] = INIT_BOOL;

        string[] storage _stringStorage;
        _stringStorage[0] = INIT_STRING;

        bytes32[] storage _bytes32Storage;
        _bytes32Storage[0] = INIT_BYTES32;
    }

    function interfaceAddr(address _addr) internal view returns (address) {
        //Implementation to retrieve interface address.  Replace with your actual logic.
        return address(0);
    }

    modifier whenNotPaused() {
        //Implementation for whenNotPaused modifier. Replace with your actual logic.
        _;
    }

    function _callTokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) private whenNotPaused {
        address senderImplementation = interfaceAddr(_from);
        if (senderImplementation != address(0)) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }
}"
1700,This method will can be called by the controller after the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Tier {
        bool initialized;
        uint256 startTime;
        uint256 endTime;
        uint256 finalizedTime;
        bool finalized;
    }

    mapping(uint256 => Tier) public tiers;
    uint256 public tierCount;

    event FinalizedTier(uint256 indexed tierIndex, uint256 time);

    function finalize() public initialized {
        Tier storage tier = tiers[tierCount];
        require(!tier.finalized, ""Tier is already finalized"");
        require(block.timestamp >= tier.startTime, ""Start time has not been reached"");
        require(msg.sender == owner() || block.timestamp > tier.endTime || isCurrentTierCapReached(), ""Not authorized to finalize this tier"");
        tier.finalized = true;
        tier.finalizedTime = block.timestamp;
        emit FinalizedTier(tierCount, block.timestamp);
        tierCount++;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }

    // State variables for fork announcement
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string indexed name, string indexed url, uint256 indexed blockNumber);
}",finalize,"[{'function': 'finalize', 'complexity': 0}, {'function': 'addTier', 'complexity': 1}, {'function': 'finalize', 'complexity': 5}]",7.0,{},64.0,0.8935716078446453,0.3364666197722906,"pragma solidity ^0.8.0;

contract MultiTierSystem {
    uint256 public tierCount;
    Tier[] public tiers;
    address public controller;

    struct Tier {
        uint256 startTime;
        uint256 endTime;
        uint256 cap;
        uint256 finalizedTime;
        // Add other tier-specific properties as needed
        function finalize() internal {
            finalizedTime = block.timestamp;
        }
    }

    event FinalizedTier(uint256 tierCount, uint256 finalizedTime);

    constructor(address _controller) {
        controller = _controller;
        tierCount = 0;
    }

    function addTier(uint256 _startTime, uint256 _endTime, uint256 _cap) public {
        require(msg.sender == controller, ""Only the controller can add tiers"");
        tiers.push(Tier(_startTime, _endTime, _cap, 0));
        tierCount++;
    }


    function finalize() public {
        require(tierCount > 0, ""No tiers to finalize"");
        Tier storage currentTier = tiers[tierCount - 1];
        assert(currentTier.finalizedTime == 0);
        require(block.timestamp >= currentTier.startTime, ""Tier start time not reached"");
        require(msg.sender == controller || block.timestamp > currentTier.endTime || currentTier.cap == 0, ""Not authorized to finalize tier"");
        currentTier.finalize();
        tierCount++;
        emit FinalizedTier(tierCount, currentTier.finalizedTime);
    }
}",43.70417737960816,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiTierSystem is Ownable {
    uint256 public tierCount;
    Tier[] public tiers;
    address public controller;

    struct Tier {
        uint256 startTime;
        uint256 endTime;
        uint256 cap;
        uint256 finalizedTime;
        // Add other tier-specific properties as needed
        function finalize() internal {
            finalizedTime = block.timestamp;
        }
    }

    event FinalizedTier(uint256 tierCount, uint256 finalizedTime);

    constructor(address _controller) Ownable(msg.sender) {
        controller = _controller;
        tierCount = 0;
    }

    function addTier(uint256 _startTime, uint256 _endTime, uint256 _cap) public {
        require(msg.sender == controller, ""Only the controller can add tiers"");
        tiers.push(Tier(_startTime, _endTime, _cap, 0));
        tierCount++;
    }

    function finalize() public {
        require(tierCount > 0, ""No tiers to finalize"");
        Tier storage currentTier = tiers[tierCount - 1];
        assert(currentTier.finalizedTime == 0);
        require(block.timestamp >= currentTier.startTime, ""Tier start time not reached"");
        require(msg.sender == controller || block.timestamp > currentTier.endTime || currentTier.cap == 0, ""Not authorized to finalize tier"");
        currentTier.finalize();
        tierCount++;
        emit FinalizedTier(tierCount, currentTier.finalizedTime);
    }
}"
250,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public constant absoluteMinTimeLock = 1 days; // Example value, adjust as needed

    function setTimelock(uint _newTimeLock) external onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock);
        timeLock = _newTimeLock;
    }
}",setTimeLock,"[{'function': 'setTimeLock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimeLock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""New timelock must be greater than or equal to the minimum timelock""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9565633623823588,0.338225200211764,"pragma solidity ^0.8.0;

contract TimeLockContract {

    uint256 public timeLock;
    uint256 public absoluteMinTimeLock = 1 days; //Example value, adjust as needed

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setTimeLock(uint256 _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timelock must be greater than or equal to the minimum timelock"");
        timeLock = _newTimeLock;
    }
}",42.57744908332825,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TimeLockContract is Ownable {
    uint256 public timeLock = 1; // Set to 1 (never 0)
    uint256 public absoluteMinTimeLock = 1 days; // Example value, adjust as needed

    address public owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setTimeLock(uint256 _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timelock must be greater than or equal to the minimum timelock"");
        timeLock = _newTimeLock;
    }
}"
5791,Give melon tokens to receive shares of this fund,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceFeed {
    function getLastUpdateId() external view returns (uint);
}

interface ComplianceModule {
    function isInvestmentPermitted(address participant, uint giveQuantity, uint shareQuantity) external view returns (bool);
}

abstract contract InvestmentRequestManager is Ownable {
    using SafeMath for uint;

    enum RequestStatus { inactive, active, completed }

    struct Request {
        address participant;
        RequestStatus status;
        address requestAsset;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
    }

    Request[] public requests;
    mapping(address => bool) public isInvestAllowed;
    bool public isShutDown = false;
    PriceFeed public modules;

    event RequestUpdated(uint requestId);

    constructor(PriceFeed _modules) {
        modules = _modules;
    }

    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external pre_cond(!isShutDown) pre_cond(isInvestAllowed[investmentAsset]) pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity)) {
        requests.push(Request({
            participant: msg.sender,
            status: RequestStatus.active,
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity,
            timestamp: block.timestamp,
            atUpdateId: modules.getLastUpdateId()
        }));
        emit RequestUpdated(requests.length - 1);
    }
}",requestInvestment,"[{'function': 'requestInvestment', 'complexity': 4}, {'function': 'getLastRequestId', 'complexity': 0}, {'function': 'permitInvestment', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""requestInvestment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""giveQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""shareQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""investmentAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isShutDown""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""System is shut down""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isInvestAllowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""investmentAsset""}}, {""type"": ""stringLiteral"", ""value"": ""Investment not allowed for this asset""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""complianceModule""}, ""memberName"": ""permitInvestment""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""giveQuantity""}, {""type"": ""Identifier"", ""name"": ""shareQuantity""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Investment not permitted by compliance module""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Request""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""investmentAsset""}, {""type"": ""Identifier"", ""name"": ""shareQuantity""}, {""type"": ""Identifier"", ""name"": ""giveQuantity""}, {""type"": ""Identifier"", ""name"": ""shareQuantity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pricefeedModule""}, ""memberName"": ""getLastUpdateId""}, ""arguments"": [], ""names"": []}], ""names"": [""participant"", ""status"", ""requestAsset"", ""shareQuantity"", ""giveQuantity"", ""receiveQuantity"", ""timestamp"", ""atUpdateId""]}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestUpdated""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getLastRequestId""}, ""arguments"": [], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.9169772665592586,0.4891384165672518,"pragma solidity ^0.8.0;

// Assume necessary imports and interfaces for compliance module and pricefeed module are present.

contract InvestmentContract {
    // ... other contract elements ...

    struct Request {
        address participant;
        uint256 status; // Define status codes (e.g., 0: active, 1: completed, 2: rejected)
        address requestAsset;
        uint256 shareQuantity;
        uint256 giveQuantity;
        uint256 receiveQuantity;
        uint256 timestamp;
        uint256 atUpdateId;
    }

    Request[] public requests;
    mapping(address => bool) public isInvestAllowed;
    bool public isShutDown;
    // ... other state variables ...


    function requestInvestment(uint256 giveQuantity, uint256 shareQuantity, address investmentAsset) public {
        require(!isShutDown, ""System is shut down"");
        require(isInvestAllowed[investmentAsset], ""Investment not allowed for this asset"");
        require(complianceModule.permitInvestment(msg.sender, giveQuantity, shareQuantity), ""Investment not permitted by compliance module"");

        requests.push(Request({
            participant: msg.sender,
            status: 0, // Active
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity,
            timestamp: block.timestamp,
            atUpdateId: pricefeedModule.getLastUpdateId()
        }));

        emit RequestUpdated(getLastRequestId());
    }

    function getLastRequestId() public view returns (uint256) {
        return requests.length - 1;
    }

    // Assume necessary interfaces for complianceModule and pricefeedModule
    IComplianceModule complianceModule;
    IPricefeedModule pricefeedModule;

    // Events
    event RequestUpdated(uint256 requestId);

    // ... other contract elements ...
}

interface IComplianceModule {
    function permitInvestment(address participant, uint256 giveQuantity, uint256 shareQuantity) external view returns (bool);
}

interface IPricefeedModule {
    function getLastUpdateId() external view returns (uint256);
}",44.4717652797699,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract InvestmentContract is Ownable {
    struct Request {
        address participant;
        uint256 status; // Define status codes (e.g., 0: active, 1: completed, 2: rejected)
        address requestAsset;
        uint256 shareQuantity;
        uint256 giveQuantity;
        uint256 receiveQuantity;
        uint256 timestamp;
        uint256 atUpdateId;
    }

    Request[] public requests;
    mapping(address => bool) public isInvestAllowed;
    bool public isShutDown;
    IComplianceModule complianceModule;
    IPricefeedModule pricefeedModule;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        requests = [];
        isInvestAllowed[address(0x111)] = true;
        isInvestAllowed[address(0x222)] = true;
        isInvestAllowed[address(0x333)] = true;
        isShutDown = false;
    }

    function requestInvestment(uint256 giveQuantity, uint256 shareQuantity, address investmentAsset) public {
        require(!isShutDown, ""System is shut down"");
        require(isInvestAllowed[investmentAsset], ""Investment not allowed for this asset"");
        require(complianceModule.permitInvestment(msg.sender, giveQuantity, shareQuantity), ""Investment not permitted by compliance module"");

        requests.push(Request({
            participant: msg.sender,
            status: 0, // Active
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity,
            timestamp: block.timestamp,
            atUpdateId: pricefeedModule.getLastUpdateId()
        }));

        emit RequestUpdated(getLastRequestId());
    }

    function getLastRequestId() public view returns (uint256) {
        return requests.length - 1;
    }

    // Events
    event RequestUpdated(uint256 requestId);
}

interface IComplianceModule {
    function permitInvestment(address participant, uint256 giveQuantity, uint256 shareQuantity) external view returns (bool);
}

interface IPricefeedModule {
    function getLastUpdateId() external view returns (uint256);
}"
1160,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) external onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}",setPrices,"[{'function': 'owner', 'complexity': 0}, {'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9798183617952976,0.8492326635760689,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public sellPrice;
    uint256 public buyPrice;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }


    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}",42.25201201438904,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public sellPrice;
    uint256 public buyPrice;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        sellPrice = 1;
        buyPrice = 2;
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public onlyOwner {
        require(newSellPrice > 0, ""Sell price must be greater than zero"");
        require(newBuyPrice > 0, ""Buy price must be greater than zero"");
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}"
3416,Returns all the relevant information about a specific property .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PropertyInterface {
    function getProperty(uint256 _id) external view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    );
}

abstract contract PropertyWrapper is Ownable {
    using SafeMath for uint256;

    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    enum PropertyClass {
        NONE,
        BUILDING
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 y) internal pure returns (uint8 height) {
        // Placeholder for the actual computation logic
        return 0; // Replace with actual implementation if needed
    }

    function getProperty(uint256 _id) public view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];
        parent = uint32(property.parent);
        class = uint8(property.class);
        height = uint8(property.y);
        if (property.class == PropertyClass.BUILDING) {
            y = uint8(_computeHeight(property.x, property.z, property.y));
        } else {
            y = uint8(property.y);
        }
        x = uint8(property.x);
        z = uint8(property.z);
        dx = uint8(property.dx);
        dz = uint8(property.dz);
    }
}",getPropertyDetails,"[{'function': '_computeHeight', 'complexity': 0}, {'function': 'getPropertyDetails', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPropertyDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Property""}, ""name"": ""property"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""y"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""class""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PropertyClass""}, ""memberName"": ""BUILDING""}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""y""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_computeHeight""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""x""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""z""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""y""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""y""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""y""}}}]}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""parent""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""class""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""x""}, {""type"": ""Identifier"", ""name"": ""y""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""z""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""dx""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""dz""}, {""type"": ""Identifier"", ""name"": ""y""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",41.0,0.7673061636365528,0.264832884156943,"pragma solidity ^0.8.0;

contract PropertyRegistry {

    enum PropertyClass {
        BUILDING,
        LAND
    }

    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 y) internal pure returns (uint8) {
        // Replace with your actual height computation logic
        return y + 10;
    }


    function getPropertyDetails(uint256 _id) public view returns (uint32, uint8, uint8, uint8, uint8, uint8, uint8, uint8) {
        Property memory property = properties[_id];
        uint8 y;
        if (property.class == uint8(PropertyClass.BUILDING)) {
            y = _computeHeight(property.x, property.z, property.y);
        } else {
            y = property.y;
        }
        return (property.parent, property.class, property.x, y, property.z, property.dx, property.dz, y);
    }
}",43.18026208877564,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PropertyRegistry is Ownable {

    enum PropertyClass {
        BUILDING,
        LAND
    }

    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 y) internal pure returns (uint8) {
        // Replace with your actual height computation logic
        return y + 10;
    }

    function getPropertyDetails(uint256 _id) public view returns (uint32, uint8, uint8, uint8, uint8, uint8, uint8, uint8) {
        Property memory property = properties[_id];
        uint8 y;
        if (property.class == uint8(PropertyClass.BUILDING)) {
            y = _computeHeight(property.x, property.z, property.y);
        } else {
            y = property.y;
        }
        return (property.parent, property.class, property.x, y, property.z, property.dx, property.dz, y);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialPropertyId = 1;
        properties[initialPropertyId] = Property({
            parent: 0,
            class: uint8(PropertyClass.BUILDING),
            x: 1,
            y: 10, // Set to a fixed value instead of the zero default state
            z: 1,
            dx: 2,
            dz: 2
        });
    }
}"
4560,Get the current total number of market listings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256[] public forSalePixelconIndexes;

    function totalListings() public view returns (uint256) {
        return forSalePixelconIndexes.length;
    }
}",totalListings,"[{'function': 'totalListings', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalListings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""forSalePixelconIndexes""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract PixelconContract {
    uint256[] public forSalePixelconIndexes;

    function totalListings() public view returns (uint256) {
        return forSalePixelconIndexes.length;
    }
}",41.99076867103577,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PixelconContract is Ownable {
    uint256[] public forSalePixelconIndexes;

    constructor() Ownable(msg.sender) {
        forSalePixelconIndexes = [1, 2, 3]; // Fixed values to avoid zero or default state
    }

    function totalListings() public view returns (uint256) {
        return forSalePixelconIndexes.length;
    }
}"
2354,Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {
        // Your implementation here
    }
}",transferFromAndCall,"[{'function': 'transferFromAndCall', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFromAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""memberName"": ""code""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Recipient is not a contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""success""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TransferWithBytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",100.0,0.1684750604564338,0.1439801509317825,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event TransferWithBytes(address indexed _from, address indexed _to, uint256 _value, bytes _data);


    function transferFromAndCall(address _from, address _to, uint256 _value, bytes calldata _data) public returns (bool) {
        require(allowances[_from][msg.sender] >= _value, ""Insufficient allowance"");
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(address(_to).code.length > 0, ""Recipient is not a contract"");

        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(_from, _to, _value);

        (bool success, ) = _to.call(_data);
        if (success) {
            emit TransferWithBytes(_from, _to, _value, _data);
            return true;
        } else {
            return false;
        }
    }
}",43.50393915176392,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event TransferWithBytes(address indexed _from, address indexed _to, uint256 _value, bytes _data);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance to 1 for the owner
    }

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes calldata _data) public returns (bool) {
        require(allowances[_from][msg.sender] >= _value, ""Insufficient allowance"");
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(address(_to).code.length > 0, ""Recipient is not a contract"");

        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(_from, _to, _value);

        (bool success, ) = _to.call(_data);
        if (success) {
            emit TransferWithBytes(_from, _to, _value, _data);
            return true;
        } else {
            return false;
        }
    }
}"
3881,Check if specified holder trusts an address with recovery procedure .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TrustedWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) private trustedMap;

    function isTrusted(address _from, address _to) public view returns (bool) {
        return trustedMap[_from][_to];
    }
}",getHolderId,"[{'function': 'getHolderId', 'complexity': 0}, {'function': 'isTrusted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isTrusted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""holderId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getHolderId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""store""}, ""memberName"": ""holdersTrustStorage""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderId""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.6569204262796962,0.0267211680252081,"pragma solidity ^0.8.0;

contract TrustContract {

    struct Store {
        mapping(uint256 => mapping(address => bool)) holdersTrustStorage;
    }

    Store store;

    function getHolderId(address _holder) public pure returns (uint256) {
        //Implementation to get holder ID.  Replace with actual logic.
        return uint256(uint160(_holder));
    }


    function isTrusted(address _from, address _to) public view returns (bool) {
        uint256 holderId = getHolderId(_from);
        return store.holdersTrustStorage[holderId][_to];
    }
}",42.608062505722046,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TrustContract is Ownable {
    struct Store {
        mapping(uint256 => mapping(address => bool)) holdersTrustStorage;
    }

    Store store;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 fixedUint = 1;
        address fixedAddress = address(uint160(uint256(keccak256('a'))));
        bool fixedBool = true;
        string memory fixedString = 'initialized';
        bytes32 fixedBytes32 = keccak256(abi.encodePacked('init'));
    }

    function getHolderId(address _holder) public pure returns (uint256) {
        //Implementation to get holder ID.  Replace with actual logic.
        return uint256(uint160(_holder));
    }

    function isTrusted(address _from, address _to) public view returns (bool) {
        uint256 holderId = getHolderId(_from);
        return store.holdersTrustStorage[holderId][_to];
    }
}"
2976,Removes the necessary permissions for a user to destroy tokens from a blacklisted account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bytes4 constant DESTROY_BLACKLISTED_TOKENS_SIG = 0x7c5b3e18;

    mapping(address => bool) public blacklistDestroyers;

    event LogRemovedBlacklistDestroyer(address indexed who);

    modifier onlyValidator() {
        require(msg.sender == owner(), ""Only the validator can call this function"");
        _;
    }

    function isPermission(bytes4 sig) internal view returns (bool) {
        return sig == DESTROY_BLACKLISTED_TOKENS_SIG;
    }

    function removeUserPermission(address _who, bytes4 sig) internal {
        require(!blacklistDestroyers[_who], ""Address already has permission to destroy blacklisted tokens"");
        blacklistDestroyers[_who] = true;
    }

    function removeBlacklistDestroyer(address _who) public onlyValidator {
        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), ""Blacklist token destruction not supported by token"");
        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);
        emit LogRemovedBlacklistDestroyer(_who);
    }
}",removeBlacklistDestroyer,"[{'function': 'isPermission', 'complexity': 0}, {'function': 'removeBlacklistDestroyer', 'complexity': 1}, {'function': 'removeUserPermission', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeBlacklistDestroyer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isPermission""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DESTROY_BLACKLISTED_TOKENS_SIG""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Permission not supported""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""removeUserPermission""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_who""}, {""type"": ""Identifier"", ""name"": ""DESTROY_BLACKLISTED_TOKENS_SIG""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogRemovedBlacklistDestroyer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_who""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyValidator"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,0.7762565334808714,"pragma solidity ^0.8.0;

contract PermissionManager {

    bytes32 public constant DESTROY_BLACKLISTED_TOKENS_SIG = ""DESTROY_BLACKLISTED_TOKENS"";

    // ... other contract elements ...

    modifier onlyValidator() {
        // ... logic to check validator role ...
        _;
    }

    function isPermission(bytes32 permission) public view virtual returns (bool) {
        // ... logic to check if permission is supported ...
    }


    function removeBlacklistDestroyer(address _who) public onlyValidator {
        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), ""Permission not supported"");
        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);
        emit LogRemovedBlacklistDestroyer(_who);
    }

    function removeUserPermission(address _user, bytes32 _permission) internal virtual {
        // ... logic to remove user permission ...
    }

    event LogRemovedBlacklistDestroyer(address indexed _who);

    // ... rest of the contract ...
}",42.86737823486328,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PermissionManager is Ownable {
    bytes32 public constant DESTROY_BLACKLISTED_TOKENS_SIG = ""DESTROY_BLACKLISTED_TOKENS"";

    // ... other contract elements ...

    modifier onlyValidator() {
        // ... logic to check validator role ...
        _;
    }

    function isPermission(bytes32 permission) public view virtual returns (bool) {
        // ... logic to check if permission is supported ...
    }

    function removeBlacklistDestroyer(address _who) public onlyValidator {
        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), ""Permission not supported"");
        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);
        emit LogRemovedBlacklistDestroyer(_who);
    }

    function removeUserPermission(address _user, bytes32 _permission) internal virtual {
        // ... logic to remove user permission ...
    }

    event LogRemovedBlacklistDestroyer(address indexed _who);

    // ... rest of the contract ...
}"
6370,This function enables token transfers for everyone.Can only be enabled after the end of the ICO .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRelease is Ownable {
    using SafeMath for uint256;

    bool public released;
    event TokenReleased(bool indexed released);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Only the admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        // Assuming a standard Pausable contract from OpenZeppelin for pausing functionality
        // This should be implemented based on actual pause logic in your contract
        require(paused == false, ""Contract is paused"");
        _;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Tokens have already been released"");
        released = true;
        emit TokenReleased(released);
    }
}",releaseTokenForTransfer,"[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'releaseTokenForTransfer', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseTokenForTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""released""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Tokens already released""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""released""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenReleased""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""released""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,0.8422962522723169,"pragma solidity ^0.8.0;

contract MyContract {

    address public admin;
    bool public released;
    bool public paused;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    event TokenReleased(bool released);

    constructor() {
        admin = msg.sender;
    }

    function pause() public onlyAdmin {
        paused = true;
    }

    function unpause() public onlyAdmin {
        paused = false;
    }


    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Tokens already released"");
        released = true;
        emit TokenReleased(released);
    }
}",42.5443389415741,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public admin;
    bool public released;
    bool public paused;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    event TokenReleased(bool released);

    constructor() Ownable(msg.sender) {
        admin = msg.sender;
        paused = false; // Initialize paused to false instead of true
        released = false; // Initialize released to false instead of true
    }

    function pause() public onlyAdmin {
        paused = true;
    }

    function unpause() public onlyAdmin {
        paused = false;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Tokens already released"");
        released = true;
        emit TokenReleased(released);
    }
}"
3576,adds or removes addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhitelistModifier is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event ModifyWhitelist(address indexed investor, uint timestamp, address indexed caller, bool valid);

    function modifyWhitelist(address _investor, bool _valid) public onlyOwner {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }
}",modifyWhitelist,"[{'function': 'modifyWhitelist', 'complexity': 0}, {'function': 'grantRole', 'complexity': 0}, {'function': 'revokeRole', 'complexity': 0}, {'function': 'hasRole', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""modifyWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_investor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_valid"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""_investor""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_valid""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModifyWhitelist""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_investor""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_valid""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyWhitelist"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.970515648892947,0.9025139799587886,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(address => bool) public whitelist;
    bytes32 public constant WHITELIST_ROLE = keccak256(""WHITELIST_ROLE"");

    event ModifyWhitelist(address indexed investor, uint256 timestamp, address indexed sender, bool valid);

    modifier onlyWhitelist() {
        require(hasRole(WHITELIST_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    function modifyWhitelist(address _investor, bool _valid) public onlyWhitelist {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }

    //  Add functions for role management (grantRole, revokeRole, hasRole) here as needed.  Example below.  These would typically be in a separate AccessControl contract.
    function grantRole(bytes32 role, address account) public {
        //Implementation to grant role.  Replace with your actual implementation.
    }

    function revokeRole(bytes32 role, address account) public {
        //Implementation to revoke role. Replace with your actual implementation.
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        //Implementation to check role. Replace with your actual implementation.
    }
}",43.340567111968994,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => bool) public whitelist;
    bytes32 public constant WHITELIST_ROLE = keccak256(""WHITELIST_ROLE"");

    event ModifyWhitelist(address indexed investor, uint256 timestamp, address indexed sender, bool valid);

    modifier onlyWhitelist() {
        require(hasRole(WHITELIST_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        whitelist[msg.sender] = true; // Initialize with a fixed value
    }

    function modifyWhitelist(address _investor, bool _valid) public onlyWhitelist {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }

    //  Add functions for role management (grantRole, revokeRole, hasRole) here as needed.  Example below.  These would typically be in a separate AccessControl contract.
    function grantRole(bytes32 role, address account) public {
        //Implementation to grant role.  Replace with your actual implementation.
    }

    function revokeRole(bytes32 role, address account) public {
        //Implementation to revoke role. Replace with your actual implementation.
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        //Implementation to check role. Replace with your actual implementation.
    }
}"
1319,Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address spender, uint256 tokens) public returns (bool success) {
        requireTrade(msg.sender);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function requireTrade(address sender) internal view {
        // Implement trade requirement logic here if needed
    }
}",approve,"[{'function': 'approve', 'complexity': 0}, {'function': 'requireTrade', 'complexity': 2}, {'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""requireTrade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokens""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9908555619934816,0.928663927948396,"pragma solidity ^0.8.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract MyContract is IERC20 {
    mapping(address => mapping(address => uint256)) internal allowed;

    function requireTrade(address sender) internal view {
        // Add your trading requirement logic here.  This is a placeholder.
        require(true, ""Trade requirements not met"");
    }

    function approve(address spender, uint256 tokens) public returns (bool) {
        requireTrade(msg.sender);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
}",42.60727381706238,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is IERC20 {
    mapping(address => mapping(address => uint256)) internal allowed;

    function requireTrade(address sender) internal view {
        // Add your trading requirement logic here.  This is a placeholder.
        require(true, ""Trade requirements not met"");
    }

    function approve(address spender, uint256 tokens) public returns (bool) {
        requireTrade(msg.sender);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }
}"
4806,Returns the ether in escrow to the seller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EscrowInterface {
    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (Escrow memory, bytes32);
}

abstract contract EscrowWrapper is Ownable {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint256 sellerCanCancelAfter;
        uint128 totalGasFeesSpentByRelayer;
    }

    mapping(bytes32 => Escrow) public escrows;
    address public relayer;
    uint256 constant GAS_doSellerCancel = 20000;

    event CancelledBySeller(bytes32 indexed tradeHash);

    function transferMinusFees(address _seller, uint256 _amount, uint128 _gasFees, uint16 _fee) internal {
        // Implementation of the transfer minus fees logic
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

        if (!_escrow.exists) {
            return false;
        }

        if (_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {
            return false;
        }

        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);

        delete escrows[_tradeHash];

        emit CancelledBySeller(_tradeHash);

        transferMinusFees(_seller, _value, _gasFees, 0);

        return true;
    }
}",doSellerCancel,"[{'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'doSellerCancel', 'complexity': 3}]",7.0,{},81.0,0.8807304279885659,0.4677590469232772,"pragma solidity ^0.8.0;

contract Escrow {

    mapping(bytes32 => EscrowDetails) public escrows;

    struct EscrowDetails {
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint256 cancellationWindow;
    }

    event CancelledBySeller(bytes32 _tradeHash);

    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) internal pure returns (EscrowDetails memory, bytes32) {
        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
        return (EscrowDetails(_seller, _buyer, _value, _fee, block.timestamp + 100), tradeHash); //Example cancellation window of 100 seconds
    }


    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        (EscrowDetails memory escrow, bytes32 tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

        if (escrows[tradeHash].seller == address(0)) {
            return false;
        }

        if (block.timestamp < escrow.cancellationWindow) {
            return false;
        }

        uint256 gasFees = 100000 + _additionalGas; //Example gas fee calculation.  Replace with more robust calculation if needed.

        delete escrows[tradeHash];

        emit CancelledBySeller(tradeHash);

        (bool success, ) = payable(_seller).call{value: escrow.value - gasFees}("""");
        require(success, ""Transfer failed."");

        return true;
    }
}",44.10120058059693,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    mapping(bytes32 => EscrowDetails) public escrows;

    struct EscrowDetails {
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint256 cancellationWindow;
    }

    event CancelledBySeller(bytes32 _tradeHash);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) internal pure returns (EscrowDetails memory, bytes32) {
        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
        return (EscrowDetails(_seller, _buyer, _value, _fee, block.timestamp + 100), tradeHash); // Example cancellation window of 100 seconds
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        (EscrowDetails memory escrow, bytes32 tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

        if (escrows[tradeHash].seller == address(0)) {
            return false;
        }

        if (block.timestamp < escrow.cancellationWindow) {
            return false;
        }

        uint256 gasFees = 100000 + _additionalGas; // Example gas fee calculation. Replace with more robust calculation if needed.

        delete escrows[tradeHash];

        emit CancelledBySeller(tradeHash);

        (bool success, ) = payable(_seller).call{value: escrow.value - gasFees}("""");
        require(success, ""Transfer failed."");

        return true;
    }
}"
3857,Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum CampaignState { Init, PreSale, Sale, Closed }
    CampaignState public campaignState = CampaignState.Init;

    address public teamVaultAddr;

    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;

    event CampaignOpen(uint256 timestamp);

    modifier onlyController() {
        require(owner() == msg.sender, ""Only the controller can call this function"");
        _;
    }

    function startSale() public onlyController {
        require(campaignState > 2 && teamVaultAddr != address(0));
        campaignState = CampaignState.Sale;
        uint256 tNow = block.timestamp;
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;
        emit CampaignOpen(tNow);
    }
}",startSale,"[{'function': 'startSale', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""startSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Sale already started""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""teamVaultAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Team vault address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tNow"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tCampaignStart""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tBonusStageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tRegSaleStart""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""t_1st_StageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""t_2nd_StageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""t_3rd_StageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tCampaignEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignOpen""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tNow""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.9292620831071764,0.651930997921641,"pragma solidity ^0.8.0;

contract SaleCampaign {

    uint256 public campaignState;
    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;
    address public teamVaultAddr;

    event CampaignOpen(uint256 timestamp);

    function startSale() public {
        require(campaignState < 2, ""Sale already started"");
        require(teamVaultAddr != address(0), ""Team vault address not set"");

        campaignState = 2;
        uint256 tNow = block.timestamp;
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;

        emit CampaignOpen(tNow);
    }
}",43.17614507675171,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract SaleCampaign is Ownable {
    uint256 public campaignState;
    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;
    address public teamVaultAddr;

    event CampaignOpen(uint256 timestamp);

    constructor() Ownable(msg.sender) {
        campaignState = 1; // Set to 1 (never 0)
        tCampaignStart = block.timestamp;
        tBonusStageEnd = block.timestamp;
        tRegSaleStart = block.timestamp;
        t_1st_StageEnd = block.timestamp;
        t_2nd_StageEnd = block.timestamp;
        t_3rd_StageEnd = block.timestamp;
        tCampaignEnd = block.timestamp;
        teamVaultAddr = 0x1111111111111111111111111111111111111111; // Use fixed address value
    }

    function startSale() public {
        require(campaignState < 2, ""Sale already started"");
        require(teamVaultAddr != address(0), ""Team vault address not set"");

        campaignState = 2;
        uint256 tNow = block.timestamp;
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;

        emit CampaignOpen(tNow);
    }
}"
497,Add an associated Synth contract to the Synthetix system,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Synth {
    function currencyKey() external view returns (bytes4);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    Synth[] public availableSynths;
    mapping(bytes4 => Synth) public synths;

    event SynthAdded(bytes4 indexed currencyKey, Synth synth);

    function addSynth(Synth synth) external onlyOwner {
        bytes4 currencyKey = synth.currencyKey();
        require(synths[currencyKey] == Synth(0), ""Synth already exists"");
        availableSynths.push(synth);
        synths[currencyKey] = synth;
        emit SynthAdded(currencyKey, synth);
    }
}",addSynth,"[{'function': 'addSynth', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Synth""}, ""name"": ""synth"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""currencyKey"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""currencyKey""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""currencyKey""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synth""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Synth already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""availableSynths""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""synth""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""currencyKey""}}, ""right"": {""type"": ""Identifier"", ""name"": ""synth""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SynthAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currencyKey""}, {""type"": ""Identifier"", ""name"": ""synth""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""optionalProxy"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.9372189298882676,0.7828591539797807,"pragma solidity ^0.8.0;

// Assume necessary imports and interfaces for Synth and onlyOwner/optionalProxy modifiers are present.

contract SynthSystem {
    Synth[] public availableSynths;
    mapping(bytes32 => Synth) public synths;

    event SynthAdded(bytes32 currencyKey, Synth synth);

    modifier onlyOwner() {
        //Implementation of onlyOwner modifier
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    modifier optionalProxy() {
        //Implementation of optionalProxy modifier
        _;
    }


    function addSynth(Synth synth) public onlyOwner optionalProxy {
        bytes32 currencyKey = synth.currencyKey();
        require(synths[currencyKey] == Synth(address(0)), ""Synth already exists"");
        availableSynths.push(synth);
        synths[currencyKey] = synth;
        emit SynthAdded(currencyKey, synth);
    }

    // Placeholder for owner() and Synth interface.  Replace with actual implementation.
    address private owner;
    function owner() public view returns (address) { return owner; }
    interface Synth {
        function currencyKey() external view returns (bytes32);
    }
}",43.27500700950623,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract SynthSystem {
    Synth[] public availableSynths;
    mapping(bytes32 => Synth) public synths;

    event SynthAdded(bytes32 currencyKey, Synth synth);

    address private _owner;
    modifier onlyOwner() {
        require(_owner == msg.sender, ""Only owner can call this function"");
        _;
    }

    modifier optionalProxy() {
        _;
    }

    constructor(address initialOwner) {
        _owner = initialOwner;
    }

    function addSynth(Synth synth) public onlyOwner optionalProxy {
        bytes32 currencyKey = synth.currencyKey();
        require(synths[currencyKey] == Synth(address(0)), ""Synth already exists"");
        availableSynths.push(synth);
        synths[currencyKey] = synth;
        emit SynthAdded(currencyKey, synth);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    interface Synth {
        function currencyKey() external view returns (bytes32);
    }
}"
5313,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint8 public decimals;
    uint256 public sellPrice;
    uint256 public buyPrice;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint256 _totalSupply, uint8 _decimals) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        totalSupply = _totalSupply;
        decimals = _decimals;
    }

    function updatePrice() public {
        sellPrice = initialSellPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
    }
}",updatePrice,"[{'function': 'updatePrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""initialSellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""initialSupply""}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""decimals""}}], ""isArray"": False}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""initialBuyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""initialSupply""}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""decimals""}}], ""isArray"": False}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.6546062244676868,0.1851621763960534,"pragma solidity ^0.8.0;

contract PriceUpdater {
    uint256 public sellPrice;
    uint256 public buyPrice;
    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint8 public decimals;
    uint256 public totalSupply;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint8 _decimals, uint256 _totalSupply) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        decimals = _decimals;
        totalSupply = _totalSupply;
    }

    function updatePrice() public {
        sellPrice = (initialSellPrice * initialSupply * (10**decimals)) / totalSupply;
        buyPrice = (initialBuyPrice * initialSupply * (10**decimals)) / totalSupply;
    }
}",43.033613204956055,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceUpdater is Ownable {
    uint256 public sellPrice;
    uint256 public buyPrice;
    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint8 public decimals;
    uint256 public totalSupply;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint8 _decimals, uint256 _totalSupply) Ownable() {
        initialSellPrice = _initialSellPrice == 0 ? 1 : _initialSellPrice;
        initialBuyPrice = _initialBuyPrice == 0 ? 1 : _initialBuyPrice;
        initialSupply = _initialSupply == 0 ? 1 : _initialSupply;
        decimals = _decimals == 0 ? 1 : _decimals;
        totalSupply = _totalSupply == 0 ? 1 : _totalSupply;
    }

    function updatePrice() public {
        sellPrice = (initialSellPrice * initialSupply * (10**decimals)) / totalSupply;
        buyPrice = (initialBuyPrice * initialSupply * (10**decimals)) / totalSupply;
    }
}"
565,Removes a list of addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Whitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event WhitelistRemoved(address indexed user);

    function removeAddressesFromWhitelist(address[] memory _users) external onlyOwner {
        require(_users.length > 0, ""Cannot remove an empty list to whitelist!"");

        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}",removeAddressesFromWhitelist,"[{'function': 'removeAddressesFromWhitelist', 'complexity': 5}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeAddressesFromWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_users"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_users""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Cannot remove an empty list from whitelist!""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_users""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": True}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_users""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WhitelistRemoved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9868869818026226,0.909744729614348,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(address => bool) public whitelist;
    modifier onlyAdmin() {
        // Add admin role check here.  Replace with your actual admin check.
        require(msg.sender == address(0x123), ""Only admin can call this function"");
        _;
    }

    event WhitelistRemoved(address user);

    function removeAddressesFromWhitelist(address[] memory _users) external onlyAdmin {
        require(_users.length > 0, ""Cannot remove an empty list from whitelist!"");
        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}",42.84688711166382,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => bool) public whitelist;

    modifier onlyAdmin() {
        require(msg.sender == address(0x123), ""Only admin can call this function"");
        _;
    }

    event WhitelistRemoved(address user);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        whitelist[address(0x111)] = true;
        whitelist[address(0x222)] = true;
        whitelist[address(0x333)] = true;
    }

    function removeAddressesFromWhitelist(address[] memory _users) external onlyAdmin {
        require(_users.length > 0, ""Cannot remove an empty list from whitelist!"");
        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}"
3142,Get the token balance of ` tokenOwner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    mapping(address => uint256) public balances;

    constructor() {}

    function balanceOf(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }
}",balanceOf,"[{'function': 'balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9742393222647724,0.7659552353576201,"pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint) public balances;

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }
}",41.7698278427124,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    mapping(address => uint) public balances;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    mapping(address => uint256) public balanceOf;

 constructor() {
        balances[msg.sender] = 1000; // Initialize uint to a non-zero value
        balances[DEFAULT_ADDRESS] = 1; // Initialize address with a fixed value
        balances[DEFAULT_BOOL] = DEFAULT_BOOL; // Initialize bool with the default value
        balances[DEFAULT_BYTES32] = DEFAULT_BYTES32; // Initialize bytes32 with a fixed value
        balances[DEFAULT_STRING] = DEFAULT_STRING; // Initialize string with the default value
    }

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }
}
```

However, this contract still has an issue. The `balances` mapping is not initialized in the mapping(address => uint256) public balanceOf;

 constructor. We need to initialize it as well.

Here's the corrected code:

```solidity
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    mapping(address => uint) public balances;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    mapping(address => uint256) public balanceOf;

 constructor() {
        for (address account in balances.keys()) {
            balances[account] = 1; // Initialize uint to a non-zero value
        }
        balances[msg.sender] = 1000; // Initialize address with a fixed value
        balances[DEFAULT_ADDRESS] = 1; // Initialize address with a fixed value
        balances[DEFAULT_BOOL] = DEFAULT_BOOL; // Initialize bool with the default value
        balances[DEFAULT_BYTES32] = DEFAULT_BYTES32; // Initialize bytes32 with a fixed value
        balances[DEFAULT_STRING] = DEFAULT_STRING; // Initialize string with the default value
    }

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }
}
```

Note that I've also added `for (address account in balances.keys())` to initialize the `balances` mapping. This is because Solidity's mappings are not initialized by default, and we need to explicitly initialize them.

Also note that this contract does not inherit from any parent contracts like `Ownable`. If you want to add inheritance, you would need to use the `contract` keyword followed by the name of the parent contract, like this:

```solidity
pragma solidity ^0.8.0;

import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.6.0/contracts/ownership/Ownable.sol';
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    // ...
}
```

And then you would need to add the `mapping(address => uint256) public balanceOf;

 constructor` function with the `Ownable(msg.sender)` call, like this:

```solidity
pragma solidity ^0.8.0;

import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.6.0/contracts/ownership/Ownable.sol';
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint) public balances;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        for (address account in balances.keys()) {
            balances[account] = 1; // Initialize uint to a non-zero value
        }
        balances[msg.sender] = 1000; // Initialize address with a fixed value
        balances[DEFAULT_ADDRESS] = 1; // Initialize address with a fixed value
        balances[DEFAULT_BOOL] = DEFAULT_BOOL; // Initialize bool with the default value
        balances[DEFAULT_BYTES32] = DEFAULT_BYTES32; // Initialize bytes32 with a fixed value
        balances[DEFAULT_STRING] = DEFAULT_STRING; // Initialize string with the default value
    }

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }
}"
3096,This method can be used by the owner to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        MiniMeToken token = MiniMeToken(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}",pose,"[{'function': 'transfer', 'complexity': 0}, {'function': 'pose', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MiniMeToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.8669427067904595,0.5448524706320009,"pragma solidity ^0.8.0;

interface MiniMeToken {
    function balanceOf(address _owner) external view returns (uint256 balance);
    function transfer(address _to, uint256 _value) external returns (bool success);
}

contract MyContract {
    event ClaimedTokens(address indexed _token, address indexed owner, uint256 balance);

    function pose(address _token) public {
        if (_token == address(0)) {
            uint256 balance = address(this).balance;
            payable(msg.sender).transfer(balance);
            emit ClaimedTokens(address(0), msg.sender, balance);
        } else {
            MiniMeToken token = MiniMeToken(_token);
            uint256 balance = token.balanceOf(address(this));
            token.transfer(msg.sender, balance);
            emit ClaimedTokens(_token, msg.sender, balance);
        }
    }
}",42.74711632728577,"pragma solidity ^0.8.0;

interface MiniMeToken {
    function balanceOf(address _owner) external view returns (uint256 balance);
    function transfer(address _to, uint256 _value) external returns (bool success);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    event ClaimedTokens(address indexed _token, address indexed owner, uint256 balance);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function pose(address _token) public {
        if (_token == address(0)) {
            uint256 balance = address(this).balance;
            payable(msg.sender).transfer(balance);
            emit ClaimedTokens(address(0), msg.sender, balance);
        } else {
            MiniMeToken token = MiniMeToken(_token);
            uint256 balance = token.balanceOf(address(this));
            token.transfer(msg.sender, balance);
            emit ClaimedTokens(_token, msg.sender, balance);
        }
    }
}"
6593,returns the trader of the given orderID .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderTraderWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address trader;
        // other order details...
    }

    mapping(bytes32 => Order) public orders;

    function orderTrader(bytes32 _orderID) external view returns (address) {
        return orders[_orderID].trader;
    }
}",orderTrader,"[{'function': 'orderTrader', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""orderTrader"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_orderID""}}, ""memberName"": ""trader""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9767792686167108,0.8153551038173115,"pragma solidity ^0.8.0;

contract OrderBook {

    struct Order {
        address trader;
        // Add other order details as needed
    }

    mapping(bytes32 => Order) public orders;

    function orderTrader(bytes32 _orderID) public view returns (address) {
        return orders[_orderID].trader;
    }
}",41.89992380142212,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract OrderBook is Ownable {
    struct Order {
        address trader;
        // Add other order details as needed
    }

    mapping(bytes32 => Order) public orders;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function initializeOrders() public {
        bytes32 _orderID = ""init"";
        orders[_orderID] = Order(trader(0x1111111111111111111111111111111111111111));
        // Initialize other orders as needed
    }

    function orderTrader(bytes32 _orderID) public view returns (address) {
        return orders[_orderID].trader;
    }
}"
2524,Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    bool public transfersEnabled;
    address public controller;
    mapping(address => mapping(address => uint256)) public allowed;

    constructor(address _controller, bool _transfersEnabled) {
        require(_controller != address(0), ""Controller must be set"");
        controller = _controller;
        transfersEnabled = _transfersEnabled;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (msg.sender != controller) {
            require(transfersEnabled, ""Transfers are not enabled"");
            if (allowed[_from][msg.sender] < _amount) {
                return false;
            }
            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
        }
        require(_to != address(0), ""Invalid recipient address"");
        return IERC20(this).transferFrom(_from, _to, _amount);
    }
}",transferFrom,"[{'function': 'transferFrom', 'complexity': 4}, {'function': 'doTransfer', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': 'allowance', 'complexity': 0}, {'function': 'setTransfersEnabled', 'complexity': 1}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}, ""right"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}}, {""type"": ""stringLiteral"", ""value"": ""Transfers are disabled""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}]}, ""FalseBody"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.8292294759296901,0.4186348514926532,"pragma solidity ^0.8.0;

contract MyContract {
    address public controller;
    bool public transfersEnabled = true;
    mapping(address => mapping(address => uint256)) internal allowances;

    constructor(address _controller) {
        controller = _controller;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {
        require(msg.sender == controller || transfersEnabled, ""Transfers are disabled"");

        if (msg.sender != controller) {
            uint256 currentAllowance = allowances[_from][msg.sender];
            require(currentAllowance >= _amount, ""Insufficient allowance"");
            allowances[_from][msg.sender] -= _amount;
        }

        return doTransfer(_from, _to, _amount);
    }

    function doTransfer(address _from, address _to, uint256 _amount) internal returns (bool) {
        //Implementation of token transfer logic.  This is a placeholder.  Replace with actual transfer logic.
        return true;
    }


    function approve(address spender, uint256 amount) public {
        allowances[msg.sender][spender] = amount;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function setTransfersEnabled(bool _enabled) public {
        require(msg.sender == controller, ""Only the controller can change transfer status"");
        transfersEnabled = _enabled;
    }
}",43.65324187278748,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public controller;
    bool public transfersEnabled = true;
    mapping(address => mapping(address => uint256)) internal allowances;

    constructor() Ownable(msg.sender) {
        // Initialize variables to fixed, safe values
        controller = 0x1111111111111111111111111111111111111111; // Replace with actual address
        transfersEnabled = true;
        allowances[msg.sender][msg.sender] = 1; // Set allowance to 1 for the owner
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {
        require(msg.sender == controller || transfersEnabled, ""Transfers are disabled"");

        if (msg.sender != controller) {
            uint256 currentAllowance = allowances[_from][msg.sender];
            require(currentAllowance >= _amount, ""Insufficient allowance"");
            allowances[_from][msg.sender] -= _amount;
        }

        return doTransfer(_from, _to, _amount);
    }

    function doTransfer(address _from, address _to, uint256 _amount) internal returns (bool) {
        //Implementation of token transfer logic.  This is a placeholder.  Replace with actual transfer logic.
        return true;
    }

    function approve(address spender, uint256 amount) public {
        allowances[msg.sender][spender] = amount;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }

    function setTransfersEnabled(bool _enabled) public {
        require(msg.sender == controller, ""Only the controller can change transfer status"");
        transfersEnabled = _enabled;
    }
}"
4577,Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_who != address(0), ""Invalid address"");
        require(_value == 0 || allowed[msg.sender][_who] == 0, ""Allowance already granted"");
        allowed[msg.sender][_who] = _value;
        emit Approval(msg.sender, _who, _value);
        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_who""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_who""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""isArray"": False}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_who""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_who""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.9750655716378178,0.7703623896346377,"pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) internal allowed;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_who != address(0) && (_value == 0 || allowed[msg.sender][_who] == 0));
        allowed[msg.sender][_who] = _value;
        emit Approval(msg.sender, _who, _value);
        return true;
    }
}",42.78421092033386,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    mapping(address => mapping(address => uint256)) internal allowed;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        // Initialize state variables with fixed, safe values
        allowed[msg.sender][address(0)] = 1; // Set to 1 (never 0)
        allowed[address(0)][msg.sender] = 1; // Set to 1 (never 0)

        // Initialize bool variable
        bool initialized = true;

        // Initialize string variable
        string public tokenName = 'MyToken'; // Use placeholder value

        // Initialize bytes32 variable
        bytes32 public constant initBytes = bytes32('init'); // Set to fixed value

        // Initialize address variables with fixed values
        address public owner = 0x1111111111111111111111111111111111111111; // Use fixed address value
        address public admin = 0x2222222222222222222222222222222222222222; // Use fixed address value
    }

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_who != address(0) && (_value == 1 || allowed[msg.sender][_who] == 1));
        allowed[msg.sender][_who] = _value;
        emit Approval(msg.sender, _who, _value);
        return true;
    }
}"
6152,Whether price of asset has been updated less than VALIDITY seconds ago,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAssetInformation {
    function getTimestamp(address ofAsset) external view returns (uint256);
}

abstract contract AssetPriceChecker is Ownable {
    using SafeMath for uint256;

    struct Information {
        bool exists;
        uint256 timestamp;
    }

    mapping(address => Information) public information;
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds

    function hasRecentPrice(address ofAsset) public view pre_cond(information[ofAsset].exists) returns (bool isRecent) {
        require(information[ofAsset].exists, ""Asset information does not exist"");
        return now.sub(information[ofAsset].timestamp).div(1 seconds) <= VALIDITY;
    }
}",hasRecentPrice,"[{'function': 'setInformation', 'complexity': 0}, {'function': 'hasRecentPrice', 'complexity': 1}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""hasRecentPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""ofAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isRecent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""information""}, ""index"": {""type"": ""Identifier"", ""name"": ""ofAsset""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""No price information found for this asset.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeElapsed"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""information""}, ""index"": {""type"": ""Identifier"", ""name"": ""ofAsset""}}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isRecent""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""timeElapsed""}, ""right"": {""type"": ""Identifier"", ""name"": ""VALIDITY""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",15.0,0.7342933591507057,0.4181325355328026,"pragma solidity ^0.8.0;

contract PriceChecker {

    uint256 public constant VALIDITY = 3600; // 1 hour in seconds

    struct AssetInformation {
        uint256 timestamp;
        bool exists;
    }

    mapping(address => AssetInformation) public information;

    function setInformation(address ofAsset, uint256 timestamp) public {
        information[ofAsset] = AssetInformation(timestamp, true);
    }


    function hasRecentPrice(address ofAsset) public view returns (bool isRecent) {
        require(information[ofAsset].exists, ""No price information found for this asset."");
        uint256 timeElapsed = now - information[ofAsset].timestamp;
        isRecent = timeElapsed <= VALIDITY;
    }
}",42.5709593296051,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceChecker is Ownable {
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds

    struct AssetInformation {
        uint256 timestamp;
        bool exists;
    }

    mapping(address => AssetInformation) public information;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        VALIDITY = 3600;
    }

    function setInformation(address ofAsset, uint256 timestamp) public {
        information[ofAsset] = AssetInformation(timestamp, true);
    }

    function hasRecentPrice(address ofAsset) public view returns (bool isRecent) {
        require(information[ofAsset].exists, ""No price information found for this asset."");
        uint256 timeElapsed = block.timestamp - information[ofAsset].timestamp;
        isRecent = timeElapsed <= VALIDITY;
    }
}"
4397,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransfersControl is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled = false;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",setTransfersEnabled,"[{'function': 'setTransfersEnabled', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTransfersEnabled"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9345425053169976,0.842362674378975,"pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    bool public transfersEnabled;

    constructor() {
        owner = msg.sender;
        transfersEnabled = true;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setTransfersEnabled(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",42.04009413719177,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner;
    bool public transfersEnabled;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        transfersEnabled = true;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setTransfersEnabled(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}"
6310,Set address of migration target contract and enable migration process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MigrationAgentSetter {
    using SafeMath for uint256;

    address public migrationAgent;
    uint256 public totalMigrated;

    function setMigrationAgent(address _agent) external onlyOwner {
        require(migrationAgent == address(0x0) && totalMigrated == 0);
        migrationAgent = _agent;
    }
}",setMigrationAgent,"[{'function': 'setMigrationAgent', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMigrationAgent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_agent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""migrationAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Migration agent already set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""totalMigrated""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Tokens already migrated""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""migrationAgent""}, ""right"": {""type"": ""Identifier"", ""name"": ""_agent""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.9016799391389176,0.447551676470269,"pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    address public migrationAgent;
    uint256 public totalMigrated;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setMigrationAgent(address _agent) public onlyOwner {
        require(migrationAgent == address(0), ""Migration agent already set"");
        require(totalMigrated == 0, ""Tokens already migrated"");
        migrationAgent = _agent;
    }
}",42.31237745285034,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner;
    address public migrationAgent;
    uint256 public totalMigrated;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        migrationAgent = 0x1111111111111111111111111111111111111111; // fixed address
        totalMigrated = 1; // fixed uint256 value
    }

    function setMigrationAgent(address _agent) public onlyOwner {
        require(migrationAgent == address(0), ""Migration agent already set"");
        require(totalMigrated == 0, ""Tokens already migrated"");
        migrationAgent = _agent;
    }
}"
4553,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public blacklistedUsers;
    bool public paused = false;

    modifier userNotBlacklisted(address _user) {
        require(!blacklistedUsers[_user], ""User is blacklisted"");
        _;
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have permission"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused {
        _mint(_to, _amount);
    }
}",mint,"[{'function': '_mint', 'complexity': 0}, {'function': 'mint', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""requiresPermission"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""userNotBlacklisted"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,1.0,0.8009559340799308,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    // ... other contract code ...

    modifier requiresPermission() {
        // Add your permission logic here
        _;
    }

    modifier whenNotPaused() {
        // Add your pause logic here
        _;
    }

    modifier userNotBlacklisted(address _user) {
        // Add your blacklist logic here
        _;
    }


    function _mint(address _to, uint256 _amount) internal {
        // Add your internal mint logic here, including emitting Transfer event
    }

    function mint(address _to, uint256 _amount)
        public
        requiresPermission
        whenNotPaused
        userNotBlacklisted(_to)
    {
        _mint(_to, _amount);
    }

    // ... other contract code ...
}",43.21747636795044,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    // ... other contract code ...

    modifier requiresPermission() {
        // Add your permission logic here
        _;
    }

    modifier whenNotPaused() {
        // Add your pause logic here
        _;
    }

    modifier userNotBlacklisted(address _user) {
        // Add your blacklist logic here
        _;
    }

    function _mint(address _to, uint256 _amount) internal {
        // Add your internal mint logic here, including emitting Transfer event
    }

    function mint(address _to, uint256 _amount)
        public
        requiresPermission
        whenNotPaused
        userNotBlacklisted(_to)
    {
        _mint(_to, _amount);
    }

    // ... other contract code ...
}"
4912,Used only if there are some leftover funds ( because of topUpBalance ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
        wallet.transfer(address(this).balance);
    }
}",withdrawBalance,"[{'function': 'withdrawBalance', 'complexity': 0}, {'function': 'setStage', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""walletAddress""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""mustBeAtStage"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""Finalized""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9719643562074526,0.8578928092681435,"pragma solidity ^0.8.0;

contract MyContract {
    enum Stage {
        Pending,
        InProgress,
        Finalized
    }

    Stage public currentStage;
    address payable public walletAddress;

    modifier mustBeAtStage(Stage stage) {
        require(currentStage == stage, ""Must be at the Finalized stage"");
        _;
    }

    constructor(address payable _walletAddress) {
        walletAddress = _walletAddress;
        currentStage = Stage.Pending;
    }


    function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
        walletAddress.transfer(address(this).balance);
    }

    function setStage(Stage _stage) public {
        currentStage = _stage;
    }
}",42.61913537979126,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    enum Stage {
        Pending,
        InProgress,
        Finalized
    }

    Stage public currentStage;
    address payable public walletAddress;

    modifier mustBeAtStage(Stage stage) {
        require(currentStage == stage, ""Must be at the Finalized stage"");
        _;
    }

    constructor(address payable _walletAddress) Ownable() {
        currentStage = Stage.Pending;
        walletAddress = _walletAddress;
    }

    function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
        walletAddress.transfer(address(this).balance);
    }

    function setStage(Stage _stage) public {
        currentStage = _stage;
    }
}"
4727,This method MUST NEVER be called by smart contract code .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IGiftToken {
    function GiftsOfOwner(address _owner) external view returns (uint256[] memory);
}

abstract contract GiftWrapper is Ownable {
    using SafeMath for uint256;

    address public giftContractAddress;

    constructor(address _giftContractAddress) {
        giftContractAddress = _giftContractAddress;
    }

    function giftOwnerByIndex(uint256 _index) external view returns (uint256 GiftId) {
        IGiftToken giftToken = IGiftToken(giftContractAddress);
        uint256[] memory ownerGifts = giftToken.GiftsOfOwner(owner());
        require(_index < ownerGifts.length, ""Index out of bounds"");
        return ownerGifts[_index];
    }
}",giftOwnerByIndex,"[{'function': 'giftOwnerByIndex', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""giftOwnerByIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""GiftId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""GiftId""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""GiftsOfOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_index""}}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",25.0,0.6639647095137924,0.1605027840157845,"pragma solidity ^0.8.0;

contract GiftContract {

    mapping(address => uint256[]) public GiftsOfOwner;

    function giftOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 GiftId) {
        GiftId = GiftsOfOwner[_owner][_index];
    }
}",42.350340366363525,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract GiftContract {
    mapping(address => uint256[]) public GiftsOfOwner;
    address public owner;
    bool public initialized = true;
    bytes32 public initializedBytes;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        initializedBytes = bytes32('init');
    }

    function giftOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 GiftId) {
        require(initialized, ""Contract not initialized"");
        GiftId = GiftsOfOwner[_owner][_index];
    }
}"
5921,Hash ( keccak256 ) of the payload used by approvePreSigned,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovePreSignedHashingWrapper {
    using SafeMath for uint256;

    function approvePreSignedHashing(address _token, address _spender, uint256 _value, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(
            bytes4(0xf7ac9c2e),
            _token,
            _spender,
            _value,
            _fee,
            _nonce
        );
    }
}",approvePreSignedHashing,"[{'function': 'approvePreSignedHashing', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approvePreSignedHashing"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0xf7ac9c2e"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract PreSignedApproval {

    function approvePreSignedHashing(
        address _token,
        address _spender,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        return keccak256(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce);
    }
}",42.01479887962341,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract PreSignedApproval {
    address public constant TOKEN_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual token address
    address public constant SPENDER_ADDRESS = 0x2222222222222222222222222222222222222222; // Replace with actual spender address
    uint256 public constant VALUE = 1;
    uint256 public constant FEE = 1;
    uint256 public constant NONCE = 1;

    bytes32 public constant APPROVAL_HASH = keccak256(bytes4(0xf7ac9c2e));

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}
import ""openzeppelin/SafeMath.sol"";
contract PreSignedApproval {
    address public constant TOKEN_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual token address
    address public constant SPENDER_ADDRESS = 0x2222222222222222222222222222222222222222; // Replace with actual spender address
    uint256 public constant VALUE = 1;
    uint256 public constant FEE = 1;
    uint256 public constant NONCE = 1;

    bytes32 public constant APPROVAL_HASH = keccak256(bytes4(0xf7ac9c2e));

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables
        TOKEN_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual token address
        SPENDER_ADDRESS = 0x2222222222222222222222222222222222222222; // Replace with actual spender address
        VALUE = 1;
        FEE = 1;
        NONCE = 1;
    }

    function approvePreSignedHashing(
        address _token,
        address _spender,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        return keccak256(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce);
    }
}"
5070,Withdraw ether and delete the htlc swap .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MultisigWallet is Ownable {
    using SafeMath for uint256;

    struct Multisig {
        uint unlockTime;
        address[] owners;
        mapping(address => bool) ownerMap;
        uint deposit;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;

    function spendFromMultisig(bytes32 msigId, uint amount, address owner) internal {
        // Implementation of spending from multisig logic
    }

    function timeoutResolve(bytes32 msigId, uint amount) public onlyOwner {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time has not been reached"");
        spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);
    }
}",timeoutResolve,"[{'function': 'timeoutResolve', 'complexity': 2}, {'function': 'spendFromMultisig', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""timeoutResolve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""msigId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""deposit""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient deposit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""unlockTime""}}, {""type"": ""stringLiteral"", ""value"": ""Unlock time not reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""spendFromMultisig""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""msigId""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.8725435534995688,0.7602612181627897,"pragma solidity ^0.8.0;

contract MultisigWallet {
    struct Multisig {
        uint deposit;
        uint unlockTime;
        address owner;
        // Add other relevant fields as needed
    }

    mapping(bytes32 => Multisig) hashIdToMultisig;

    function timeoutResolve(bytes32 msigId, uint amount) public {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time not reached"");
        spendFromMultisig(msigId, amount);
    }

    function spendFromMultisig(bytes32 msigId, uint amount) internal {
        //Implementation to transfer funds and update state.  This is a placeholder.
        //Example:  payable(hashIdToMultisig[msigId].owner).transfer(amount);
        //Update hashIdToMultisig[msigId].deposit -= amount;
    }

}",43.102481842041016,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultisigWallet is Ownable {
    struct Multisig {
        uint deposit;
        uint unlockTime;
        address owner;
        // Add other relevant fields as needed
    }

    mapping(bytes32 => Multisig) hashIdToMultisig;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            address ownerAddress = address(uint160(i));
            hashIdToMultisig[bytes32(uint256(i))] = Multisig({
                deposit: 1, // Never 0
                unlockTime: block.timestamp + 1 days, // Example unlock time
                owner: ownerAddress
            });
        }
    }

    function timeoutResolve(bytes32 msigId, uint amount) public {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time not reached"");
        spendFromMultisig(msigId, amount);
    }

    function spendFromMultisig(bytes32 msigId, uint amount) internal {
        //Implementation to transfer funds and update state.  This is a placeholder.
        //Example:  payable(hashIdToMultisig[msigId].owner).transfer(amount);
        //Update hashIdToMultisig[msigId].deposit -= amount;
    }
}"
4823,Send tokens to multiple recipients on behalf of the address ` from ` The transaction will revert if any of the recipients is frozen .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    mapping(address => bool) public frozenAccounts;

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        require(!paused, ""Contract is already paused."");
        paused = false;
    }

    function freezeAccount(address account) external onlyOwner {
        frozenAccounts[account] = true;
    }

    function unfreezeAccount(address account) external onlyOwner {
        require(frozenAccounts[account], ""Account is not frozen."");
        delete frozenAccounts[account];
    }

    function operatorBatchSend(address _from, address[] memory _recipients, uint256[] memory _amounts, bytes memory _userData, bytes memory _operatorData) external whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
        require(_recipients.length == _amounts.length, ""The lengths of _recipients and _amounts should be the same."");
        require(isOperatorFor(msg.sender, _from), ""Only operators can call this function"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            doSend(msg.sender, _from, _recipients[i], _amounts[i].mul(_amounts[i]), _userData, _operatorData, true);
        }
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused."");
        _;
    }

    modifier whenAccountNotFrozen(address account) {
        require(!frozenAccounts[account], ""Account is frozen."");
        _;
    }
}",operatorBatchSend,"[{'function': 'operatorBatchSend', 'complexity': 0}]",4.0,{},72.0,0.8624401170138141,0.6263578398285321,"pragma solidity ^0.8.0;

// Assume necessary modifiers and doSend function are defined elsewhere
modifier whenNotPaused() {}
modifier whenAccountNotFrozen(address _account) {}

function operatorBatchSend(
    address _from,
    address[] memory _recipients,
    uint256[] memory _amounts,
    bytes memory _userData,
    bytes memory _operatorData
) public whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
    require(_recipients.length == _amounts.length, ""Recipients and amounts arrays must have the same length"");
    // Assume operator check is handled within the modifier or elsewhere
    for (uint256 i = 0; i < _recipients.length; i++) {
        doSend(msg.sender, _from, _recipients[i], _amounts[i], _userData, _operatorData, true);
    }
}

// Placeholder for doSend function.  Implementation details omitted.
function doSend(address _caller, address _sender, address _recipient, uint256 _amount, bytes memory _userData, bytes memory _operatorData, bool _isOperatorBatchSend) internal {}",43.1415753364563,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract has an abstract keyword removed
import ""openzeppelin/SafeMath.sol"";
contract OperatorBatchSend is Ownable {
    modifier whenNotPaused() {}
    modifier whenAccountNotFrozen(address _account) {}

    function operatorBatchSend(
        address _from,
        address[] memory _recipients,
        uint256[] memory _amounts,
        bytes memory _userData,
        bytes memory _operatorData
    ) public whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
        require(_recipients.length == _amounts.length, ""Recipients and amounts arrays must have the same length"");
        for (uint256 i = 0; i < _recipients.length; i++) {
            doSend(msg.sender, _from, _recipients[i], _amounts[i], _userData, _operatorData, true);
        }
    }

    function doSend(address _caller, address _sender, address _recipient, uint256 _amount, bytes memory _userData, bytes memory _operatorData, bool _isOperatorBatchSend) internal {}

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
4675,Used to launch the Module with the help of factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPolyToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract GeneralPermissionManager {
    constructor(address owner, address polyTokenAddress) {
        // Constructor implementation
    }
}

abstract contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    IPolyToken public polyToken;
    uint256 public setupCost;

    event GenerateModuleFromFactory(address indexed moduleAddress, string name, address factoryAddress, address sender, uint256 cost, uint256 timestamp);

    constructor(uint256 _setupCost, address _polyToken) {
        setupCost = _setupCost;
        polyToken = IPolyToken(_polyToken);
    }

    function deploy(bytes memory data) external returns (address) {
        if (setupCost > 0) {
            require(polyToken.transferFrom(msg.sender, owner(), setupCost), ""Failed transferFrom due to insufficient Allowance provided"");
        }
        address permissionManager = new GeneralPermissionManager{salt: bytes32(uint256(data))}(msg.sender, address(polyToken));
        emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, block.timestamp);
        return permissionManager;
    }
}",deploy,"[{'function': 'deploy', 'complexity': 2}, {'function': 'getName', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""deploy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""setupCost""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""polyToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""setupCost""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Failed transferFrom due to insufficent Allowance provided""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""GeneralPermissionManager""}, ""name"": ""permissionManager"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""GeneralPermissionManager""}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""polyToken""}], ""names"": []}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""GenerateModuleFromFactory""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""permissionManager""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getName""}, ""arguments"": [], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""setupCost""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""permissionManager""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",53.0,0.8712156815918857,0.6202057364712488,"pragma solidity ^0.8.0;

import ""./GeneralPermissionManager.sol""; // Assuming GeneralPermissionManager contract is in this file
import ""./IERC20.sol""; // Assuming IERC20 interface is defined

contract PermissionManagerFactory {

    event GenerateModuleFromFactory(address indexed permissionManager, string name, address indexed factory, address indexed deployer, uint256 setupCost, uint256 timestamp);

    IERC20 public polyToken;
    address public owner;
    uint256 public setupCost;

    constructor(address _polyToken, address _owner, uint256 _setupCost) {
        polyToken = IERC20(_polyToken);
        owner = _owner;
        setupCost = _setupCost;
    }

    function deploy(bytes calldata) external returns (address) {
        require(setupCost == 0 || polyToken.transferFrom(msg.sender, owner, setupCost), ""Failed transferFrom due to insufficent Allowance provided"");
        GeneralPermissionManager permissionManager = new GeneralPermissionManager(msg.sender, address(polyToken));
        emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, block.timestamp);
        return address(permissionManager);
    }

    function getName() public pure returns (string memory) {
        return ""GeneralPermissionManager"";
    }
}",43.4630982875824,"pragma solidity ^0.8.0;

import ""./GeneralPermissionManager.sol""; // Assuming GeneralPermissionManager contract is in this file
import ""./IERC20.sol""; // Assuming IERC20 interface is defined
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Importing Ownable from OpenZeppelin
import ""openzeppelin/SafeMath.sol"";
contract PermissionManagerFactory is Ownable {
    event GenerateModuleFromFactory(address indexed permissionManager, string name, address indexed factory, address indexed deployer, uint256 setupCost, uint256 timestamp);

    IERC20 public polyToken;
    uint256 public setupCost;

    constructor(address _polyToken, address _owner, uint256 _setupCost) Ownable(_owner) {
        polyToken = IERC20(_polyToken);
        setupCost = _setupCost;
    }

    function deploy(bytes calldata) external returns (address) {
        require(setupCost == 0 || polyToken.transferFrom(msg.sender, owner(), setupCost), ""Failed transferFrom due to insufficient Allowance provided"");
        GeneralPermissionManager permissionManager = new GeneralPermissionManager(msg.sender, address(polyToken));
        emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, block.timestamp);
        return address(permissionManager);
    }

    function getName() public pure returns (string memory) {
        return ""GeneralPermissionManager"";
    }
}"
772,This should be public rather than external .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    constructor(address _saleAuction, address _synthesizingAuction, address _geneSynthesis) {
        require(_saleAuction != address(0), ""Sale auction must be a valid address"");
        require(_synthesizingAuction != address(0), ""Synthesizing auction must be a valid address"");
        require(_geneSynthesis != address(0), ""Gene synthesis must be a valid address"");
        saleAuction = _saleAuction;
        synthesizingAuction = _synthesizingAuction;
        geneSynthesis = _geneSynthesis;
    }

    function unpause() public onlyOwner {
        require(saleAuction != address(0));
        require(synthesizingAuction != address(0));
        require(geneSynthesis != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}",unpause,"[{'function': 'unpause', 'complexity': 4}, {'function': 'setSaleAuction', 'complexity': 0}, {'function': 'setSynthesizingAuction', 'complexity': 0}, {'function': 'setGeneSynthesis', 'complexity': 0}, {'function': 'setNewContractAddress', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""saleAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Sale auction address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""synthesizingAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Synthesizing auction address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""geneSynthesis""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Gene synthesis address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""newContractAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New contract address already set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_unpause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.9402024741071432,0.5311637996367842,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";

contract MyContract is Pausable {
    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    function unpause() public {
        require(saleAuction != address(0), ""Sale auction address not set"");
        require(synthesizingAuction != address(0), ""Synthesizing auction address not set"");
        require(geneSynthesis != address(0), ""Gene synthesis address not set"");
        require(newContractAddress == address(0), ""New contract address already set"");
        _unpause();
    }

    function setSaleAuction(address _saleAuction) public {
        saleAuction = _saleAuction;
    }

    function setSynthesizingAuction(address _synthesizingAuction) public {
        synthesizingAuction = _synthesizingAuction;
    }

    function setGeneSynthesis(address _geneSynthesis) public {
        geneSynthesis = _geneSynthesis;
    }

    function setNewContractAddress(address _newContractAddress) public {
        newContractAddress = _newContractAddress;
    }
}",43.21116590499878,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Pausable, Ownable {
    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    constructor() Ownable(msg.sender) {
        saleAuction = address(0x111);
        synthesizingAuction = address(0x222);
        geneSynthesis = address(0x333);
        newContractAddress = address(0);
    }

    function unpause() public {
        require(saleAuction != address(0), ""Sale auction address not set"");
        require(synthesizingAuction != address(0), ""Synthesizing auction address not set"");
        require(geneSynthesis != address(0), ""Gene synthesis address not set"");
        require(newContractAddress == address(0), ""New contract address already set"");
        _unpause();
    }

    function setSaleAuction(address _saleAuction) public {
        saleAuction = _saleAuction;
    }

    function setSynthesizingAuction(address _synthesizingAuction) public {
        synthesizingAuction = _synthesizingAuction;
    }

    function setGeneSynthesis(address _geneSynthesis) public {
        geneSynthesis = _geneSynthesis;
    }

    function setNewContractAddress(address _newContractAddress) public {
        newContractAddress = _newContractAddress;
    }
}"
6429,Update the stored `` poaTokenMaster '' address to upgrade the PoaToken master contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

   function proxyChangeTokenMaster(address _newMaster) public returns (bool) {
    require(msg.sender == getContractAddress(""PoaManager""), ""Only the PoaManager contract can call this function"");
    require(_newMaster != address(0), ""Invalid new master address"");
    require(poaTokenMaster != _newMaster, ""New master address is the same as the current one"");
    require(isContract(_newMaster), ""New master address must be a contract"");

    address _oldMaster = poaTokenMaster;
    poaTokenMaster = _newMaster;
    emit ProxyUpgraded(_oldMaster, _newMaster);

    getContractAddress(""PoaLogger"").call(bytes4(keccak256(""logProxyUpgraded(address,address)"")), _oldMaster, _newMaster);

    return true;
}
}",updateMaster,"[{'function': 'logProxyUpgraded', 'complexity': 0}, {'function': 'updateMaster', 'complexity': 3}, {'function': '_isContract', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateMaster"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newMaster"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newMaster""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New master address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newMaster""}, ""right"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}}, {""type"": ""stringLiteral"", ""value"": ""New master address is the same as current master address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newMaster""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""New master address is not a valid contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_oldMaster"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newMaster""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ProxyUpgraded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_oldMaster""}, {""type"": ""Identifier"", ""name"": ""_newMaster""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""poaLogger""}, ""memberName"": ""logProxyUpgraded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_oldMaster""}, {""type"": ""Identifier"", ""name"": ""_newMaster""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyPoaManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.8242684650076665,0.4545464654307335,"pragma solidity ^0.8.0;

interface IPoaLogger {
    function logProxyUpgraded(address _oldMaster, address _newMaster) external;
}

contract PoaTokenProxy {
    address public poaTokenMaster;
    address public poaManager;
    IPoaLogger public poaLogger;

    event ProxyUpgraded(address indexed _oldMaster, address indexed _newMaster);

    constructor(address _poaManager, address _poaLogger) {
        poaManager = _poaManager;
        poaLogger = IPoaLogger(_poaLogger);
    }

    modifier onlyPoaManager() {
        require(msg.sender == poaManager, ""Caller is not PoaManager"");
        _;
    }

    function updateMaster(address _newMaster) external onlyPoaManager returns (bool) {
        require(_newMaster != address(0), ""New master address cannot be zero"");
        require(_newMaster != poaTokenMaster, ""New master address is the same as current master address"");
        require(_isContract(_newMaster), ""New master address is not a valid contract"");

        address _oldMaster = poaTokenMaster;
        poaTokenMaster = _newMaster;
        emit ProxyUpgraded(_oldMaster, _newMaster);
        poaLogger.logProxyUpgraded(_oldMaster, _newMaster);
        return true;
    }

    function _isContract(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }
}",43.60898208618164,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IPoaLogger {
    function logProxyUpgraded(address _oldMaster, address _newMaster) external;
}
import ""openzeppelin/SafeMath.sol"";
contract PoaTokenProxy is Ownable, IPoaLogger {
    address public poaTokenMaster;
    address public poaManager;
    IPoaLogger public poaLogger;

    event ProxyUpgraded(address indexed _oldMaster, address indexed _newMaster);

    constructor(address _poaManager, address _poaLogger) {
        require(_poaManager != address(0), ""Invalid Poa Manager Address"");
        require(_poaLogger != address(0), ""Invalid Poa Logger Address"");
        poaManager = _poaManager;
        poaLogger = IPoaLogger(_poaLogger);
    }

    modifier onlyPoaManager() {
        require(msg.sender == poaManager, ""Caller is not PoaManager"");
        _;
    }

    function updateMaster(address _newMaster) external onlyPoaManager returns (bool) {
        require(_newMaster != address(0), ""New master address cannot be zero"");
        require(_newMaster != poaTokenMaster, ""New master address is the same as current master address"");
        require(_isContract(_newMaster), ""New master address is not a valid contract"");

        address _oldMaster = poaTokenMaster;
        poaTokenMaster = _newMaster;
        emit ProxyUpgraded(_oldMaster, _newMaster);
        poaLogger.logProxyUpgraded(_oldMaster, _newMaster);
        return true;
    }

    function _isContract(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }
}"
4411,Trust an address to perform recovery procedure for the caller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function getHolderId(address holder) external view returns (uint);
    function isTrusted(address from, address to) external view returns (bool);
    function set(address store, bytes32 key, uint index, address value, bool trusted) external;
    function _emitErrorCode(uint errorCode) external pure returns (uint);
}

abstract contract TrustWrapper is Ownable {
    using SafeMath for uint;

    enum ErrorCodes {
        OK,
        CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF,
        CHRONOBANK_PLATFORM_ALREADY_TRUSTED
    }

    address public constant PLATFORM_ADDRESS = 0xYourPlatformContractAddress;
    ChronoBankPlatform platform = ChronoBankPlatform(PLATFORM_ADDRESS);

    function trust(address _to) public returns (uint) {
        uint fromId = _createHolderId(msg.sender);
        if (fromId == platform.getHolderId(_to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);
        }
        if (platform.isTrusted(msg.sender, _to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_ALREADY_TRUSTED);
        }
        platform.set(address(this), keccak256(abi.encodePacked(""holdersTrust"", fromId)), 0, _to, true);
        return ErrorCodes.OK;
    }

    function _createHolderId(address holder) internal view returns (uint) {
        // Implement your logic to create a unique ID for the holder
        return uint(keccak256(abi.encodePacked(holder)));
    }
}",trust,"[{'function': 'getHolderId', 'complexity': 0}, {'function': 'isTrusted', 'complexity': 0}, {'function': 'trust', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""trust"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""StatusCode""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getHolderId""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""fromId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIds""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""nextHolderId""}, ""isPrefix"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""fromId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getHolderId""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""toId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getHolderId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""toId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""nextHolderId""}, ""isPrefix"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""toId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getHolderId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""fromId""}, ""right"": {""type"": ""Identifier"", ""name"": ""toId""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""StatusCode""}, ""memberName"": ""SELF_TRUST_ERROR""}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isTrusted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fromId""}, {""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""StatusCode""}, ""memberName"": ""ALREADY_TRUSTED_ERROR""}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""trustStore""}, ""index"": {""type"": ""Identifier"", ""name"": ""fromId""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""StatusCode""}, ""memberName"": ""OK""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.7950438654855051,0.3147992484728528,"pragma solidity ^0.8.0;

contract TrustContract {

    mapping(uint256 => mapping(address => bool)) private trustStore;
    mapping(address => uint256) private holderIds;
    uint256 private nextHolderId = 1;

    enum StatusCode {
        OK,
        SELF_TRUST_ERROR,
        ALREADY_TRUSTED_ERROR
    }

    function getHolderId(address _address) public view returns (uint256) {
        return holderIds[_address];
    }

    function isTrusted(uint256 _fromId, address _to) public view returns (bool) {
        return trustStore[_fromId][_to];
    }


    function trust(address _to) public returns (StatusCode) {
        uint256 fromId = getHolderId(msg.sender);
        if (fromId == 0) {
            holderIds[msg.sender] = nextHolderId++;
            fromId = getHolderId(msg.sender);
        }
        uint256 toId = getHolderId(_to);
        if (toId == 0) {
            holderIds[_to] = nextHolderId++;
            toId = getHolderId(_to);
        }

        if (fromId == toId) {
            return StatusCode.SELF_TRUST_ERROR;
        }

        if (isTrusted(fromId, _to)) {
            return StatusCode.ALREADY_TRUSTED_ERROR;
        }

        trustStore[fromId][_to] = true;
        return StatusCode.OK;
    }
}",43.56288695335388,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TrustContract is Ownable {
    mapping(uint256 => mapping(address => bool)) private trustStore;
    mapping(address => uint256) private holderIds;
    uint256 private nextHolderId = 1;

    enum StatusCode {
        OK,
        SELF_TRUST_ERROR,
        ALREADY_TRUSTED_ERROR
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        nextHolderId = 1;
    }

    function getHolderId(address _address) public view returns (uint256) {
        return holderIds[_address];
    }

    function isTrusted(uint256 _fromId, address _to) public view returns (bool) {
        return trustStore[_fromId][_to];
    }

    function trust(address _to) public returns (StatusCode) {
        uint256 fromId = getHolderId(msg.sender);
        if (fromId == 0) {
            holderIds[msg.sender] = nextHolderId++;
            fromId = getHolderId(msg.sender);
        }
        uint256 toId = getHolderId(_to);
        if (toId == 0) {
            holderIds[_to] = nextHolderId++;
            toId = getHolderId(_to);
        }

        if (fromId == toId) {
            return StatusCode.SELF_TRUST_ERROR;
        }

        if (isTrusted(fromId, _to)) {
            return StatusCode.ALREADY_TRUSTED_ERROR;
        }

        trustStore[fromId][_to] = true;
        return StatusCode.OK;
    }
}"
2481,Destroy the vesting information associated with an account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    mapping(address => VestingSchedule) public vestingSchedules;
    mapping(address => uint256) public totalVestedAccountBalance;
    uint256 public totalVestedBalance;

    struct VestingSchedule {
        // Define the structure of a vesting schedule here
    }

    function purgeAccount(address account) external onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
}",purgeAccount,"[{'function': 'purgeAccount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""purgeAccount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingSchedules""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVestedBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalVestedBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""totalVestedAccountBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""totalVestedAccountBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyDuringSetup"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.987753596805324,0.8725129388059689,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract VestingSchedule {
    using SafeMath for uint256;

    // ... other contract variables ...

    mapping(address => VestingScheduleEntry) public vestingSchedules;
    uint256 public totalVestedBalance;
    mapping(address => uint256) public totalVestedAccountBalance;
    bool public setupPhase; //Example of a setup phase boolean

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    modifier onlyDuringSetup() {
        require(setupPhase, ""This function can only be called during setup"");
        _;
    }

    struct VestingScheduleEntry {
        // ... Vesting schedule details ...
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function purgeAccount(address account) public onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }

    // ... other contract functions ...
}",43.28889846801758,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract VestingSchedule is Ownable {
    using SafeMath for uint256;

    // ... other contract variables ...

    mapping(address => VestingScheduleEntry) public vestingSchedules;
    uint256 public totalVestedBalance;
    mapping(address => uint256) public totalVestedAccountBalance;
    bool public setupPhase; //Example of a setup phase boolean

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    modifier onlyDuringSetup() {
        require(setupPhase, ""This function can only be called during setup"");
        _;
    }

    struct VestingScheduleEntry {
        // ... Vesting schedule details ...
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalVestedBalance = 1;
        setupPhase = true;
    }

    function purgeAccount(address account) public onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }

    // ... other contract functions ...
}"
4726,` finalizeSale ( ) ` ends the TokenSale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function generateTokens(address, uint256) external returns (bool);
}

abstract contract VestedTokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public endTime;
    uint256 public totalIssued;
    uint256 public lockedTokens;
    uint256 public totalVested;
    uint256 public constant HARD_CAP = 100000 * 10**18; // Example hard cap, adjust as needed
    uint256 public constant MAX_TOKENS = 100000 * 10**18; // Example max tokens, adjust as needed
    bool public finalized;
    address public vaultAddress;
    TokenInterface public tokenContract;

    struct Vesting {
        uint256 amount;
        uint256 releaseTime;
    }

    mapping(address => Vesting) public vestedAllowances;

    function finalizeSale() public onlyOwner {
        require(block.timestamp > endTime || totalIssued >= HARD_CAP);
        require(!finalized, ""Sale has already been finalized"");

        vestedAllowances[vaultAddress] = Vesting(lockedTokens, block.timestamp + 3 years);

        uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalVested);
        require(tokenContract.generateTokens(vaultAddress, leftoverTokens), ""Token transfer failed for vault"");
        require(tokenContract.generateTokens(address(this), lockedTokens.add(totalVested)), ""Token transfer failed for contract"");

        finalized = true;
    }
}",finalizeSale,"[{'function': 'finalizeSale', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalIssued""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_TOKENS""}}}, {""type"": ""stringLiteral"", ""value"": ""Sale not yet ended or hard cap not reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""finalized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Sale already finalized""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""leftoverTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""MAX_TOKENS""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lockedTokens""}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalIssued""}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalIssuedEarlySale""}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalVested""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""vaultAddress""}, {""type"": ""Identifier"", ""name"": ""leftoverTokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lockedTokens""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalVested""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestedAllowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""vaultAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Vesting""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lockedTokens""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""365"", ""subdenomination"": ""days""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}], ""names"": []}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.9324567200349748,0.5722130034855012,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale {
    using SafeMath for uint256;

    IERC20 public token;
    address public vaultAddress;
    uint256 public MAX_TOKENS;
    uint256 public lockedTokens;
    uint256 public totalIssued;
    uint256 public totalIssuedEarlySale;
    uint256 public totalVested;
    uint256 public endTime;
    bool public finalized;

    struct Vesting {
        uint256 amount;
        uint256 startTime;
    }

    mapping(address => Vesting) public vestedAllowances;

    constructor(IERC20 _token, address _vaultAddress, uint256 _MAX_TOKENS, uint256 _endTime) {
        token = _token;
        vaultAddress = _vaultAddress;
        MAX_TOKENS = _MAX_TOKENS;
        endTime = _endTime;
    }

    function finalizeSale() public {
        require(block.timestamp >= endTime || totalIssued >= MAX_TOKENS, ""Sale not yet ended or hard cap not reached"");
        require(!finalized, ""Sale already finalized"");

        uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalIssuedEarlySale).sub(totalVested);
        token.transfer(vaultAddress, leftoverTokens);
        token.transfer(address(this), lockedTokens.add(totalVested));

        vestedAllowances[vaultAddress] = Vesting(lockedTokens, block.timestamp.add(365 days * 3));
        finalized = true;
    }
}",44.05569982528687,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address public vaultAddress;
    uint256 public MAX_TOKENS;
    uint256 public lockedTokens;
    uint256 public totalIssued;
    uint256 public totalIssuedEarlySale;
    uint256 public totalVested;
    uint256 public endTime;
    bool public finalized;

    struct Vesting {
        uint256 amount;
        uint256 startTime;
    }

    mapping(address => Vesting) public vestedAllowances;

    constructor(IERC20 _token, address _vaultAddress, uint256 _MAX_TOKENS, uint256 _endTime) Ownable(msg.sender) {
        token = _token;
        vaultAddress = _vaultAddress;
        MAX_TOKENS = _MAX_TOKENS;
        endTime = _endTime;
    }

    function finalizeSale() public {
        require(block.timestamp >= endTime || totalIssued >= MAX_TOKENS, ""Sale not yet ended or hard cap not reached"");
        require(!finalized, ""Sale already finalized"");

        uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalIssuedEarlySale).sub(totalVested);
        token.transfer(vaultAddress, leftoverTokens);
        token.transfer(address(this), lockedTokens.add(totalVested));

        vestedAllowances[vaultAddress] = Vesting(lockedTokens, block.timestamp.add(365 days * 3));
        finalized = true;
    }
}"
475,Release some of an affiliate 's tokens to a broker/trading wallet .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function transfer(address to, uint256 value) external returns (bool success);
}

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isAffiliate;
    }

    mapping(address => Holding) public heldTokens;
    address public tokenContract;

    event TokensReleased(address indexed beneficiary, uint256 amount);

    modifier onlyTransferAgent() {
        require(hasRole(TRANSFER_AGENT_ROLE, msg.sender), ""Caller is not a transfer agent"");
        _;
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyTransferAgent returns (bool) {
        require(tradingWallet != address(0), ""The destination wallet cannot be null."");
        require(!isExistingHolding(tradingWallet), ""The destination wallet must be a new fresh wallet."");
        Holding memory holding = heldTokens[who];
        require(holding.isAffiliate, ""Only affiliates can use this function; use release() for non-affiliates."");
        require(amount <= holding.quantity, ""The holding has less than the specified amount of tokens."");
        if (block.timestamp > holding.releaseDate) {
            bool res = ERC20Interface(tokenContract).transfer(tradingWallet, amount);
            if (res) {
                heldTokens[who] = Holding(holding.quantity.sub(amount), holding.releaseDate, holding.isAffiliate);
                emit TokensReleased(who, amount);
                return true;
            }
        }
        return false;
    }

    function isExistingHolding(address wallet) internal view returns (bool) {
        // Implement the logic to check if the wallet has an existing holding
        // This should be implemented based on your specific requirements and data storage
        return heldTokens[wallet].quantity > 0;
    }
}",partialRelease,"[{'function': 'partialRelease', 'complexity': 6}, {'function': 'setAffiliate', 'complexity': 0}, {'function': 'setReleaseDate', 'complexity': 0}, {'function': 'setHeldTokens', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""partialRelease"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tradingWallet"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""tradingWallet""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Trading wallet cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""heldTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""tradingWallet""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Trading wallet already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""affiliates""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, {""type"": ""stringLiteral"", ""value"": ""Address is not an affiliate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""heldTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""releaseDates""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}}, {""type"": ""stringLiteral"", ""value"": ""Release date not reached""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tradingWallet""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""heldTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensReleased""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.8092898077433699,0.3336191389457348,"pragma solidity ^0.8.0;

contract TokenRelease {

    mapping(address => uint256) public heldTokens;
    mapping(address => uint256) public releaseDates;
    mapping(address => bool) public affiliates;

    event TokensReleased(address indexed holder, uint256 amount);

    function partialRelease(address who, address tradingWallet, uint256 amount) public returns (bool) {
        require(tradingWallet != address(0), ""Trading wallet cannot be zero address"");
        require(heldTokens[tradingWallet] == 0, ""Trading wallet already exists"");
        require(affiliates[who], ""Address is not an affiliate"");
        require(heldTokens[who] >= amount, ""Insufficient token balance"");
        require(block.timestamp >= releaseDates[who], ""Release date not reached"");

        bool success = IERC20(tokenAddress).transfer(tradingWallet, amount);
        require(success, ""Transfer failed"");

        heldTokens[who] -= amount;
        emit TokensReleased(who, amount);
        return true;
    }

    address public tokenAddress;

    constructor(address _tokenAddress) {
        tokenAddress = _tokenAddress;
    }

    function setAffiliate(address _affiliate, bool _isAffiliate) public {
        affiliates[_affiliate] = _isAffiliate;
    }

    function setReleaseDate(address _holder, uint256 _releaseDate) public {
        releaseDates[_holder] = _releaseDate;
    }

    function setHeldTokens(address _holder, uint256 _amount) public {
        heldTokens[_holder] = _amount;
    }


    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }
}",43.86513662338257,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRelease is Ownable {
    mapping(address => uint256) public heldTokens;
    mapping(address => uint256) public releaseDates;
    mapping(address => bool) public affiliates;

    event TokensReleased(address indexed holder, uint256 amount);

    address public tokenAddress;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        tokenAddress = _tokenAddress;
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public returns (bool) {
        require(tradingWallet != address(0), ""Trading wallet cannot be zero address"");
        require(heldTokens[tradingWallet] == 0, ""Trading wallet already exists"");
        require(affiliates[who], ""Address is not an affiliate"");
        require(heldTokens[who] >= amount, ""Insufficient token balance"");
        require(block.timestamp >= releaseDates[who], ""Release date not reached"");

        bool success = IERC20(tokenAddress).transfer(tradingWallet, amount);
        require(success, ""Transfer failed"");

        heldTokens[who] -= amount;
        emit TokensReleased(who, amount);
        return true;
    }

    function setAffiliate(address _affiliate, bool _isAffiliate) public {
        affiliates[_affiliate] = _isAffiliate;
    }

    function setReleaseDate(address _holder, uint256 _releaseDate) public {
        releaseDates[_holder] = _releaseDate;
    }

    function setHeldTokens(address _holder, uint256 _amount) public {
        heldTokens[_holder] = _amount;
    }

    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }
}"
1443,the method caller will have to claim ownership of regulators since regulators are claimable,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Regulator {
    function addValidator(address validator) external;
    function transferOwnership(address newOwner) external;
}

interface RegulatorProxy {
    function initialize(address regulatorImplementation) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxy, uint256 index);

    function createRegulatorProxy(address regulatorImplementation) public onlyOwner {
        require(regulatorImplementation != address(0), ""Invalid implementation address"");

        address proxy = address(new RegulatorProxy(regulatorImplementation));
        Regulator newRegulator = Regulator(proxy);
        newRegulator.addValidator(msg.sender);
        addAllPermissions(newRegulator);
        RegulatorProxy(proxy).transferOwnership(msg.sender);
        regulators.push(proxy);
        emit CreatedRegulatorProxy(proxy, getCount() - 1);
    }

    function getCount() public view returns (uint256) {
        return regulators.length;
    }

    function addAllPermissions(Regulator regulator) internal virtual {
        // Implement any necessary permission logic here
    }
}",createRegulatorProxy,"[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'addAllPermissions', 'complexity': 0}, {'function': 'createRegulatorProxy', 'complexity': 0}, {'function': 'transferOwnership', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createRegulatorProxy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""regulatorImplementation"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""bytecode"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""RegulatorProxy""}], ""names"": []}, ""memberName"": ""creationCode""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""regulatorImplementation""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""proxy"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""proxy""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""create2"", ""arguments"": [{""type"": ""DecimalNumber"", ""value"": ""0""}, {""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""bytecode"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""32""}]}, {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""bytecode"", ""arguments"": []}]}]}}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Regulator""}, ""name"": ""newRegulator"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Regulator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxy""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newRegulator""}, ""memberName"": ""addValidator""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addAllPermissions""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newRegulator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RegulatorProxy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxy""}], ""names"": []}, ""memberName"": ""transferOwnership""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""regulators""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxy""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CreatedRegulatorProxy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxy""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""regulators""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.879606032699373,0.5644744814005768,"pragma solidity ^0.8.0;

interface Regulator {
    function addValidator(address validator) external;
    function transferOwnership(address newOwner) external;
}

contract MyContract {
    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxyAddress, uint256 index);

    function addAllPermissions(Regulator _reg) internal {
        // Add all necessary permissions here.  This is a placeholder.
    }


    function createRegulatorProxy(address regulatorImplementation) public {
        bytes memory bytecode = abi.encodePacked(type(RegulatorProxy).creationCode, abi.encode(regulatorImplementation));
        address proxy;
        assembly {
            proxy := create2(0, add(bytecode, 32), mload(bytecode))
        }
        Regulator newRegulator = Regulator(proxy);
        newRegulator.addValidator(msg.sender);
        addAllPermissions(newRegulator);
        RegulatorProxy(proxy).transferOwnership(msg.sender);
        regulators.push(proxy);
        emit CreatedRegulatorProxy(proxy, regulators.length - 1);
    }
}

contract RegulatorProxy {
    address public implementation;
    address public owner;

    constructor(address _implementation) {
        implementation = _implementation;
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public {
        require(msg.sender == owner, ""Only the owner can transfer ownership"");
        owner = newOwner;
    }

    fallback() external payable {
        address target = implementation;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize())
            let result := delegatecall(gas(), target, ptr, calldatasize(), 0, 0)
            let size := returndatasize()
            returndatacopy(ptr, 0, size)
            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}",44.60564804077149,"pragma solidity ^0.8.0;

interface Regulator {
    function addValidator(address validator) external;
    function transferOwnership(address newOwner) external;
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxyAddress, uint256 index);

    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function addAllPermissions(Regulator _reg) internal {
        // Add all necessary permissions here.  This is a placeholder.
    }

    function createRegulatorProxy(address regulatorImplementation) public onlyOwner {
        bytes memory bytecode = abi.encodePacked(type(RegulatorProxy).creationCode, abi.encode(regulatorImplementation));
        address proxy;
        assembly {
            proxy := create2(0, add(bytecode, 32), mload(bytecode))
        }
        Regulator newRegulator = Regulator(proxy);
        newRegulator.addValidator(msg.sender);
        addAllPermissions(newRegulator);
        RegulatorProxy(proxy).transferOwnership(owner());
        regulators.push(proxy);
        emit CreatedRegulatorProxy(proxy, regulators.length - 1);
    }
}
import ""openzeppelin/SafeMath.sol"";
contract RegulatorProxy {
    address public implementation;
    address public owner;

    constructor(address _implementation) {
        implementation = _implementation;
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public {
        require(msg.sender == owner, ""Only the owner can transfer ownership"");
        owner = newOwner;
    }

    fallback() external payable {
        address target = implementation;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize())
            let result := delegatecall(gas(), target, ptr, calldatasize(), 0, 0)
            let size := returndatasize()
            returndatacopy(ptr, 0, size)
            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}"
6667,Compute the new IssuanceData on the old balance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IssuanceData {
    function currentBalanceSum() external view returns (uint);
    function lastAverageBalance() external view returns (uint);
    function lastModified() external view returns (uint);
}

abstract contract IssuanceWrapper is Ownable {
    using SafeMath for uint;

    struct IssuanceDataStruct {
        uint currentBalanceSum;
        uint lastAverageBalance;
        uint lastModified;
    }

    function computeIssuanceData(uint preBalance, IssuanceData preIssuance) internal view returns (IssuanceData) {
        uint currentBalanceSum = preIssuance.currentBalanceSum();
        uint lastAverageBalance = preIssuance.lastAverageBalance();
        uint lastModified = preIssuance.lastModified();

        if (lastModified < feePeriodStartTime()) {
            if (lastModified < lastFeePeriodStartTime()) {
                lastAverageBalance = preBalance;
            } else {
                uint timeUpToRollover = feePeriodStartTime() - lastModified;
                uint lastFeePeriodDuration = feePeriodStartTime() - lastFeePeriodStartTime();
                uint lastBalanceSum = currentBalanceSum.add(preBalance.mul(timeUpToRollover));
                lastAverageBalance = lastBalanceSum / lastFeePeriodDuration;
            }
            currentBalanceSum = preBalance.mul(now - feePeriodStartTime());
        } else {
            currentBalanceSum = currentBalanceSum.add(preBalance.mul(now - lastModified));
        }

        return IssuanceData(currentBalanceSum, lastAverageBalance, now);
    }

    uint public feePeriodStartTime;
    uint public lastFeePeriodStartTime;

    constructor() {
        // Initialize fee period start times or other necessary state variables here.
    }
}",computeIssuanceData,"[{'function': 'safeAdd', 'complexity': 1}, {'function': 'safeMul', 'complexity': 2}, {'function': 'computeIssuanceData', 'complexity': 10}]",13.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeIssuanceData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""preBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IssuanceData""}, ""name"": ""preIssuance"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IssuanceData""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentBalanceSum"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""currentBalanceSum""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastAverageBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""lastAverageBalance""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastModifiedTimestamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""lastModifiedTimestamp""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastModifiedTimestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastModifiedTimestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastFeePeriodStartTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""preBalance""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeDiff"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastModifiedTimestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeAdd""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeMul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, {""type"": ""Identifier"", ""name"": ""timeDiff""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeMul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""preBalance""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastModifiedTimestamp""}}], ""isArray"": False}}}}]}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeAdd""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeMul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""preBalance""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastModifiedTimestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}}, ""TrueExpression"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""lastModifiedTimestamp""}}], ""isArray"": False}}], ""names"": []}], ""names"": []}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IssuanceData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, {""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.8519935454194154,0.2162310066249787,"pragma solidity ^0.8.0;

contract IssuanceCalculator {

    uint256 public feePeriodStartTime;
    uint256 public lastFeePeriodStartTime;

    struct IssuanceData {
        uint256 currentBalanceSum;
        uint256 lastAverageBalance;
        uint256 lastModifiedTimestamp;
    }

    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b >= a, ""Addition overflow"");
        return a + b;
    }

    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        require(a * b / a == b, ""Multiplication overflow"");
        return a * b;
    }


    function computeIssuanceData(uint256 preBalance, IssuanceData memory preIssuance) internal returns (IssuanceData memory) {
        uint256 currentBalanceSum = preIssuance.currentBalanceSum;
        uint256 lastAverageBalance = preIssuance.lastAverageBalance;
        uint256 lastModifiedTimestamp = preIssuance.lastModifiedTimestamp;

        if (lastModifiedTimestamp < feePeriodStartTime) {
            if (lastModifiedTimestamp < lastFeePeriodStartTime) {
                lastAverageBalance = preBalance;
            } else {
                uint256 timeDiff = feePeriodStartTime - lastModifiedTimestamp;
                lastAverageBalance = safeAdd(safeMul(lastAverageBalance, timeDiff), safeMul(preBalance, block.timestamp - feePeriodStartTime)) / (block.timestamp - lastModifiedTimestamp);
            }
        }

        currentBalanceSum = safeAdd(currentBalanceSum, safeMul(preBalance, block.timestamp - (lastModifiedTimestamp < feePeriodStartTime ? feePeriodStartTime : lastModifiedTimestamp)));

        return IssuanceData(currentBalanceSum, lastAverageBalance, block.timestamp);
    }
}",44.43427753448486,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract IssuanceCalculator is Ownable {
    uint256 public feePeriodStartTime = 1;
    uint256 public lastFeePeriodStartTime = 2;

    struct IssuanceData {
        uint256 currentBalanceSum;
        uint256 lastAverageBalance;
        uint256 lastModifiedTimestamp;
    }

    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a + b >= a, ""Addition overflow"");
        return a + b;
    }

    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        require(a * b / a == b, ""Multiplication overflow"");
        return a * b;
    }

    function computeIssuanceData(uint256 preBalance, IssuanceData memory preIssuance) internal returns (IssuanceData memory) {
        uint256 currentBalanceSum = preIssuance.currentBalanceSum;
        uint256 lastAverageBalance = preIssuance.lastAverageBalance;
        uint256 lastModifiedTimestamp = preIssuance.lastModifiedTimestamp;

        if (lastModifiedTimestamp < feePeriodStartTime) {
            if (lastModifiedTimestamp < lastFeePeriodStartTime) {
                lastAverageBalance = preBalance;
            } else {
                uint256 timeDiff = feePeriodStartTime - lastModifiedTimestamp;
                lastAverageBalance = safeAdd(safeMul(lastAverageBalance, timeDiff), safeMul(preBalance, block.timestamp - feePeriodStartTime)) / (block.timestamp - lastModifiedTimestamp);
            }
        }

        currentBalanceSum = safeAdd(currentBalanceSum, safeMul(preBalance, block.timestamp - (lastModifiedTimestamp < feePeriodStartTime ? feePeriodStartTime : lastModifiedTimestamp)));

        return IssuanceData(currentBalanceSum, lastAverageBalance, block.timestamp);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules provided
        feePeriodStartTime = 1;
        lastFeePeriodStartTime = 2;
    }
}"
1283,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) internal allowances;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approve failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",approveAndCall,"[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_extraData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApproveAndCallReceiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}, ""memberName"": ""receiveApproval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_extraData""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.5147336482995472,0.0368795284114753,"pragma solidity ^0.8.0;

interface ApproveAndCallReceiver {
    function receiveApproval(address from, uint256 amount, address token, bytes memory data) external;
}

contract MyToken {
    function approve(address spender, uint256 amount) public virtual returns (bool) {
        //Implementation for approve function.  This is a placeholder and needs to be implemented based on your token standard.
        return true;
    }

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount));

        ApproveAndCallReceiver(_spender).receiveApproval(
            msg.sender,
            _amount,
            address(this),
            _extraData
        );

        return true;
    }
}",42.70507407188416,"pragma solidity ^0.8.0;

interface ApproveAndCallReceiver {
    function receiveApproval(address from, uint256 amount, address token, bytes memory data) external;
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        balances[owner] = 1 ether; // Set to 1 ether instead of 0
        allowance[owner][address(this)] = uint256(-1); // Approval for self without limit
    }

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowance;

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        // Implementation for approve function.  This is a placeholder and needs to be implemented based on your token standard.
        require(amount > 0, ""Amount must be greater than zero"");
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount));

        ApproveAndCallReceiver(_spender).receiveApproval(
            msg.sender,
            _amount,
            address(this),
            _extraData
        );

        return true;
    }
}"
6724,Adds a pair of addresses to manual blockings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct ManualBlocking {
        uint256 expiryTime;
    }

    mapping(address => mapping(address => ManualBlocking)) public manualBlockings;

    event AddManualBlocking(address indexed from, address indexed to, uint256 expiryTime, address approver);

    function addManualBlocking(address _from, address _to, uint256 _expiryTime) public onlyOwner {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_expiryTime > block.timestamp, ""Invalid expiry time"");
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");
        manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}",addManualBlocking,"[{'function': 'addManualBlocking', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""addManualBlocking"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expiryTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""From address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""To address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expiryTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Expiry time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""manualBlockings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""expiryTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Blocking already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""manualBlockings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ManualBlocking""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_expiryTime""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AddManualBlocking""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_expiryTime""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9815534790422282,0.7433452038778275,"pragma solidity ^0.8.0;

contract ManualBlocking {

    struct ManualBlocking {
        uint256 expiryTime;
    }

    mapping(address => mapping(address => ManualBlocking)) public manualBlockings;

    event AddManualBlocking(address indexed _from, address indexed _to, uint256 expiryTime, address indexed _sender);

    function addManualBlocking(address _from, address _to, uint256 _expiryTime) public {
        require(_from != address(0), ""From address cannot be zero"");
        require(_to != address(0), ""To address cannot be zero"");
        require(_expiryTime > block.timestamp, ""Expiry time must be in the future"");
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");

        manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}",42.8769052028656,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ManualBlocking is Ownable {

    struct ManualBlocking {
        uint256 expiryTime;
    }

    mapping(address => mapping(address => ManualBlocking)) public manualBlockings;

    event AddManualBlocking(address indexed _from, address indexed _to, uint256 expiryTime, address indexed _sender);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function addManualBlocking(address _from, address _to, uint256 _expiryTime) public {
        require(_from != address(0), ""From address cannot be zero"");
        require(_to != address(0), ""To address cannot be zero"");
        require(_expiryTime > block.timestamp, ""Expiry time must be in the future"");
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");

        manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}"
2869,this function lets arbitrator withdraw DAI to the provided address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract DAIWrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public DAI;

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    constructor(address _daiAddress) {
        require(_daiAddress != address(0), ""Invalid DAI contract address"");
        DAI = IERC20(_daiAddress);
    }

    function withdrawDAI(address _receiver, uint256 _amount) public onlyOwner {
        require(_receiver != address(0), ""Invalid receiver address"");
        require(_amount > 0, ""Invalid amount"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance"");
        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}",withdrawDAI,"[{'function': 'withdrawDAI', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawDAI"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_receiver""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Receiver cannot be the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""DAI""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient DAI balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""DAI""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_receiver""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DAIWithdrawn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_receiver""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9739728970820428,0.7513362234731289,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 public DAI;

    constructor(address _daiAddress) {
        DAI = IERC20(_daiAddress);
    }

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    function withdrawDAI(address _receiver, uint256 _amount) public {
        require(_receiver != address(0), ""Receiver cannot be the zero address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient DAI balance"");

        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}",42.61698293685913,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public DAI;

    mapping(address => uint256) public balanceOf;

 constructor(address _daiAddress) Ownable(msg.sender) {
        DAI = IERC20(_daiAddress);
    }

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    function withdrawDAI(address _receiver, uint256 _amount) public {
        require(_receiver != address(0), ""Receiver cannot be the zero address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient DAI balance"");

        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}"
3748,Get the node at the end of a double linked list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address next;
        address previous;
    }

    mapping(uint256 => Node) public list;

    function end(List storage self) internal view returns (address) {
        return self.list[0].previous;
    }
}",end,"[{'function': 'end', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""end"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""List""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""NULL""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.8844113727473234,0.708587641194393,"pragma solidity ^0.8.0;

contract LinkedList {
    uint256 constant NULL = 0;

    struct List {
        address[] list;
    }

    function end(List storage self) public view returns (address) {
        return self.list[NULL];
    }
}",41.79635429382324,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LinkedList is Ownable {
    uint256 constant NULL = 0;

    struct List {
        address[] list;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        NULL = 1; // Set to 1 instead of 0
    }

    function end(List storage self) public view returns (address) {
        return self.list[NULL];
    }
}"
1053,Updates the board status according to the players score .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGame {
    function calculateBoardScore(uint boardId) external view returns (uint8 blackScore, uint8 whiteScore);
    function updateBoardStatus(uint boardId, BoardStatus status) external;
}

abstract contract GameWrapper is Ownable {
    using SafeMath for uint256;

    struct Board {
        bool exists;
        BoardStatus status;
    }

    mapping(uint => Board) public boards;

    IGame public gameContract;

    event BoardCreated(uint boardId, BoardStatus initialStatus);

    constructor(address _gameContractAddress) {
        gameContract = IGame(_gameContractAddress);
    }

    modifier boardWaitingToResolve(uint boardId) {
        require(boards[boardId].exists, ""Board does not exist"");
        require(boards[boardId].status == BoardStatus.Pending, ""Board status is not pending"");
        _;
    }

    function createBoard(uint boardId, BoardStatus initialStatus) external onlyOwner {
        require(!boards[boardId].exists, ""Board already exists"");
        boards[boardId] = Board({exists: true, status: initialStatus});
        emit BoardCreated(boardId, initialStatus);
    }

    function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {
        uint8 blackScore;
        uint8 whiteScore;
        (blackScore, whiteScore) = gameContract.calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;
        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }
        gameContract.updateBoardStatus(boardId, status);
    }
}",determineVictoryStatus,"[{'function': 'determineVictoryStatus', 'complexity': 2}, {'function': 'calculateBoardScore', 'complexity': 0}, {'function': 'updateBoardStatus', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""determineVictoryStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""boardId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""blackScore"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1131bfa80>}, {""type"": ""VariableDeclaration"", ""name"": ""whiteScore"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1131bf070>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateBoardScore""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""boardId""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""BoardStatus""}, ""name"": ""status"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""Draw""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blackScore""}, ""right"": {""type"": ""Identifier"", ""name"": ""whiteScore""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""BlackWin""}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""whiteScore""}, ""right"": {""type"": ""Identifier"", ""name"": ""blackScore""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""WhiteWin""}}}]}, ""FalseBody"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateBoardStatus""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""boardId""}, {""type"": ""Identifier"", ""name"": ""status""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8739152688537917,0.6410256524868173,"pragma solidity ^0.8.0;

enum BoardStatus { Draw, BlackWin, WhiteWin }

contract GameBoard {

    function determineVictoryStatus(uint256 boardId) public {
        (uint8 blackScore, uint8 whiteScore) = calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;

        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }

        updateBoardStatus(boardId, status);
    }

    function calculateBoardScore(uint256 boardId) internal view virtual returns (uint8, uint8) {
        //Implementation to calculate scores based on boardId
        return (0,0); // Placeholder return values.  Replace with actual score calculation.
    }

    function updateBoardStatus(uint256 boardId, BoardStatus status) internal virtual {
        //Implementation to update board status
    }
}",42.90708112716675,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

enum BoardStatus { Draw, BlackWin, WhiteWin }
import ""openzeppelin/SafeMath.sol"";
contract GameBoard is Ownable {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        blackScore = 1;
        whiteScore = 1;
        boardId = 1;
    }

    uint8 public blackScore;
    uint8 public whiteScore;
    uint256 public boardId;

    function determineVictoryStatus(uint256 boardId) public {
        (uint8 blackScore, uint8 whiteScore) = calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;

        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }

        updateBoardStatus(boardId, status);
    }

    function calculateBoardScore(uint256 boardId) internal view virtual returns (uint8, uint8) {
        //Implementation to calculate scores based on boardId
        return (0, 0); // Placeholder return values. Replace with actual score calculation.
    }

    function updateBoardStatus(uint256 boardId, BoardStatus status) internal virtual {
        //Implementation to update board status
    }
}"
963,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

abstract contract WrappedERC721 is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event OperatorApproval(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external onlyOwner {
        approvedOperators[_operator] = _approved;
        emit OperatorApproval(_msgSender(), _operator, _approved);
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return approvedOperators[_operator];
    }
}",isApprovedForAll,"[{'function': 'isApprovedForAll', 'complexity': 0}, {'function': 'isApprovedForAll', 'complexity': 0}, {'function': '_isApprovedForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isApprovedForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isApprovedForAll""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_operator""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.7512901810320052,0.0676129159968124,"pragma solidity ^0.8.0;

interface IERC1155 {
    function isApprovedForAll(address account, address operator) external view returns (bool);
}

contract MyContract is IERC1155 {

    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {
        return _isApprovedForAll(_owner, _operator);
    }

    function _isApprovedForAll(address _owner, address _operator) internal view returns (bool) {
        return _operatorApprovals[_owner][_operator];
    }

    //Other functions...
}",42.4421329498291,"pragma solidity ^0.8.0;

interface IERC1155 {
    function isApprovedForAll(address account, address operator) external view returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is IERC1155 {

    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _operatorApprovals[address(0x111)][address(0x222)] = true;
        _operatorApprovals[address(0x222)][address(0x333)] = true;
    }

    function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {
        return _isApprovedForAll(_owner, _operator);
    }

    function _isApprovedForAll(address _owner, address _operator) internal view returns (bool) {
        return _operatorApprovals[_owner][_operator];
    }

    //Other functions...
}"
3793,Create an invite using the signing model described in the contract description,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InviteCreator is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public pendingInvites;
    address public signingLogic;

    event InviteCreated(address indexed user, address indexed inviteAddress);

    modifier onlyUser() {
        require(msg.sender != owner(), ""Owner cannot create invites"");
        _;
    }

    function setSigningLogic(address _signingLogic) public onlyOwner {
        signingLogic = _signingLogic;
    }

    function createInvite(bytes memory _sig) public onlyUser {
        require(signingLogic != address(0), ""Signing logic not set"");
        address inviteAddress = signingLogic.call(abi.encodeWithSelector(this.recoverSigner.selector, keccak256(abi.encodePacked(msg.sender)), _sig));
        require(!pendingInvites[inviteAddress], ""Invite already created"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(msg.sender, inviteAddress);
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        return ECDSA.recover(hash, signature);
    }
}",createInvitation,"[{'function': 'createInvitation', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createInvitation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_sig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""inviteAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""signingLogic""}, ""memberName"": ""recoverSigner""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_sig""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingInvites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteAddress""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Invitation already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingInvites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InviteCreated""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""inviteAddress""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyUser"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8292370527162483,0.4801092983037735,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(address => bool) public pendingInvites;
    address public owner;
    // Assuming signingLogic is defined elsewhere and has a recoverSigner function
    address public signingLogic;

    modifier onlyUser() {
        // Add logic to check if msg.sender is a user
        require(true, ""Caller is not a user"");
        _;
    }

    event InviteCreated(address sender, address invitee);

    constructor(address _signingLogic) {
        owner = msg.sender;
        signingLogic = _signingLogic;
    }

    function createInvitation(bytes memory _sig) public onlyUser {
        address inviteAddress = signingLogic.recoverSigner(keccak256(abi.encodePacked(msg.sender)), _sig);
        require(!pendingInvites[inviteAddress], ""Invitation already exists"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(msg.sender, inviteAddress);
    }
}",42.75227808952332,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => bool) public pendingInvites;
    address public owner;
    // Assuming signingLogic is defined elsewhere and has a recoverSigner function
    address public signingLogic;

    modifier onlyUser() {
        require(msg.sender != address(0), ""Caller is not a user"");
        _;
    }

    event InviteCreated(address sender, address invitee);

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        signingLogic = address(0x1111111111111111111111111111111111111111); // Replace with actual value
        pendingInvites[msg.sender] = true; // Initialize pendingInvites for the owner
    }

    function createInvitation(bytes memory _sig) public onlyUser {
        address inviteAddress = signingLogic.recoverSigner(keccak256(abi.encodePacked(msg.sender)), _sig);
        require(!pendingInvites[inviteAddress], ""Invitation already exists"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(msg.sender, inviteAddress);
    }
}"
3662,Allow pre-approved user to take ownership of a token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToOwner;

    function takeOwnership(uint256 _tokenId) public override {
        address newOwner = msg.sender;
        address oldOwner = allStarIndexToOwner[_tokenId];
        require(_addressNotNull(newOwner), ""Address should not be null"");
        require(_approved(newOwner, _tokenId), ""Token is not approved for transfer"");
        _transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address addr) internal pure returns (bool) {
        return addr != address(0);
    }

    function _approved(address operator, uint256 tokenId) internal view returns (bool) {
        // Assuming there's a way to check if the operator is approved for the tokenId
        // This should be implemented based on your contract logic
        return true; // Placeholder implementation
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(to != address(0), ""Transfer to zero address"");
        allStarIndexToOwner[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}",takeOwnership,"[{'function': 'takeOwnership', 'complexity': 2}, {'function': '_addressNotNull', 'complexity': 0}, {'function': '_approved', 'complexity': 0}, {'function': '_transfer', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allStarIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addressNotNull""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwner""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""New owner address cannot be null""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwner""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""New owner is not approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldOwner""}, {""type"": ""Identifier"", ""name"": ""newOwner""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9944742965185864,0.7512979747296428,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(uint256 => address) public allStarIndexToOwner;

    function takeOwnership(uint256 _tokenId) public {
        address newOwner = msg.sender;
        address oldOwner = allStarIndexToOwner[_tokenId];

        require(_addressNotNull(newOwner), ""New owner address cannot be null"");
        require(_approved(newOwner, _tokenId), ""New owner is not approved"");

        _transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address _address) internal pure returns (bool) {
        return _address != address(0);
    }

    function _approved(address _to, uint256 _tokenId) internal view virtual returns (bool) {
        //  Implementation for approval check.  Replace with your actual logic.
        return true;
    }


    function _transfer(address _from, address _to, uint256 _tokenId) internal virtual {
        allStarIndexToOwner[_tokenId] = _to;
        // Emit events as needed.
    }
}",43.17012977600098,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(uint256 => address) public allStarIndexToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            allStarIndexToOwner[i] = address(uint160(i + 1));
        }
    }

    function takeOwnership(uint256 _tokenId) public {
        address newOwner = msg.sender;
        address oldOwner = allStarIndexToOwner[_tokenId];

        require(_addressNotNull(newOwner), ""New owner address cannot be null"");
        require(_approved(newOwner, _tokenId), ""New owner is not approved"");

        _transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address _address) internal pure returns (bool) {
        return _address != address(0);
    }

    function _approved(address _to, uint256 _tokenId) internal view virtual returns (bool) {
        //  Implementation for approval check.  Replace with your actual logic.
        return true;
    }

    function _transfer(address _from, address _to, uint256 _tokenId) internal virtual {
        allStarIndexToOwner[_tokenId] = _to;
        // Emit events as needed.
    }
}"
4592,Function use to change the lower and upper bound of the compatible version st,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyOwner {
        // Implementation of the function
    }
}",changeSTVersionBounds,"[{'function': 'changeSTVersionBounds', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeSTVersionBounds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_boundType"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""length"": None}, ""name"": ""_newVersion"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""versionBounds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_boundType""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newVersion""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.7558291078815033,0.6885159827947238,"pragma solidity ^0.8.0;

contract VersionBounds {

    mapping(string => uint8[]) public versionBounds;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyOwner {
        versionBounds[_boundType] = _newVersion;
    }
}",42.15028858184815,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for an Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract VersionBounds is Ownable {

    mapping(string => uint8[]) public versionBounds;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are already initialized by the parent contract
    }

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyOwner {
        versionBounds[_boundType] = _newVersion;
    }
}"
6054,Only the owner of a locked wallet can unlock the tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UnlockFunctionWrapper is Ownable {
    using SafeMath for uint256;

    struct Allocation {
        bool locked;
        uint256 value;
        uint256 end;
    }

    mapping(address => Allocation) public allocations;
    mapping(address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed account, address indexed sender, uint256 value);

    function unlock() external {
        require(allocations[msg.sender].locked, ""Allocation is not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Unlock time has not arrived yet"");
        balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);
        allocations[msg.sender].locked = false;
        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(msg.sender, address(this), allocations[msg.sender].value);
    }
}",unlock,"[{'function': 'unlock', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""unlock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""locked""}, {""type"": ""stringLiteral"", ""value"": ""Allocation not locked""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""end""}}, {""type"": ""stringLiteral"", ""value"": ""Lock period not expired""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""locked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Unlock""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.9227508933882907,0.592642664238888,"pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => uint256) public balanceOf;
    mapping(address => Allocation) public allocations;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed account, uint256 value);

    struct Allocation {
        uint256 value;
        uint256 end;
        bool locked;
    }

    function unlock() public {
        require(allocations[msg.sender].locked, ""Allocation not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Lock period not expired"");

        balanceOf[msg.sender] += allocations[msg.sender].value;
        allocations[msg.sender].locked = false;

        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(msg.sender, allocations[msg.sender].value);
    }
}",42.81014680862427,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => uint256) public balanceOf;
    mapping(address => Allocation) public allocations;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed account, uint256 value);

    struct Allocation {
        uint256 value;
        uint256 end;
        bool locked;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[address(0x111)] = 1;
        balanceOf[address(0x222)] = 1;
        balanceOf[address(0x333)] = 1;

        allocations[address(0x111)].value = 1;
        allocations[address(0x111)].end = block.timestamp + 1 weeks;
        allocations[address(0x111)].locked = true;

        allocations[address(0x222)].value = 1;
        allocations[address(0x222)].end = block.timestamp + 2 weeks;
        allocations[address(0x222)].locked = true;

        allocations[address(0x333)].value = 1;
        allocations[address(0x333)].end = block.timestamp + 3 weeks;
        allocations[address(0x333)].locked = true;
    }

    function unlock() public {
        require(allocations[msg.sender].locked, ""Allocation not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Lock period not expired"");

        balanceOf[msg.sender] += allocations[msg.sender].value;
        allocations[msg.sender].locked = false;

        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(msg.sender, allocations[msg.sender].value);
    }
}"
6003,Proxy function which allows sending of transactions in behalf of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransactionExecutor is Ownable {
    using SafeMath for uint256;

    event Execution(address indexed destination, uint256 value, bytes data);
    event ExecutionFailure(address indexed destination, uint256 value, bytes data);

    function executeTransaction(address destination, uint value, bytes memory data) public onlyOwner {
        if (destination.call{value: value}(data)) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}",executeTransaction,"[{'function': 'executeTransaction', 'complexity': 1}]",2.0,{},0.0,0.9309271136854586,0.7513310648997186,"pragma solidity ^0.8.0;

contract MyContract {

    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    event Execution(address destination, uint value, bytes data);
    event ExecutionFailure(address destination, uint value, bytes data);

    function executeTransaction(address destination, uint256 value, bytes memory data) public onlyOwner {
        (bool success, ) = destination.call{value: value}(data);
        if (success) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}",42.6405725479126,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {

    address private owner = msg.sender;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function."");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    event Execution(address destination, uint value, bytes data);
    event ExecutionFailure(address destination, uint value, bytes data);

    function executeTransaction(address destination, uint256 value, bytes memory data) public onlyOwner {
        (bool success, ) = destination.call{value: value}(data);
        if (success) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}"
1262,Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorSendWrapper is Ownable {
    using SafeMath for uint256;

    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) external {
        require(isOperatorFor(msg.sender, _from), ""Not authorized to send from this account"");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }
}",operatorSend,"[{'function': 'allowance', 'complexity': 0}, {'function': 'doSend', 'complexity': 0}, {'function': 'operatorSend', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""operatorSend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_userData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isOperatorFor""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Not an operator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doSend""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_userData""}, {""type"": ""Identifier"", ""name"": ""_operatorData""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9731168590298048,0.7327648071025458,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
}

contract MyContract {
    function isOperatorFor(address operator, address account) public view virtual returns (bool);
    function doSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData, bool isOperator) public virtual;

    function operatorSend(address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) public {
        require(isOperatorFor(msg.sender, _from), ""Not an operator"");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }
}",43.029927253723145,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    function isOperatorFor(address operator, address account) public view virtual returns (bool);
    function doSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData, bool isOperator) public virtual;

    function operatorSend(address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) public {
        require(isOperatorFor(msg.sender, _from), ""Not an operator"");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }
}"
4646,Returns the bond of a given darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeRegistryInterface {
    function darknodeBond(address darknodeID) external view returns (uint256);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address) public darknodeRegistries;

    constructor() {}

    function darknodeBond(address darknodeID, address darknodeRegistryAddress) external view returns (uint256) {
        require(darknodeRegistries[darknodeRegistryAddress] != address(0), ""Darknode registry not set"");
        DarknodeRegistryInterface darknodeRegistry = DarknodeRegistryInterface(darknodeRegistryAddress);
        return darknodeRegistry.darknodeBond(darknodeID);
    }
}",darknodeBond,"[{'function': 'darknodeBond', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""darknodeBond"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""darknodeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeRegistry""}, ""index"": {""type"": ""Identifier"", ""name"": ""darknodeID""}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",21.0,0.6137332775809696,0.0968519014702155,"pragma solidity ^0.8.0;

contract DarknodeBondContract {

    address public owner;
    mapping(address => uint256) public darknodeRegistry;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {
        return darknodeRegistry[darknodeID];
    }
}",41.95662021636963,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DarknodeBondContract is Ownable {
    mapping(address => uint256) public darknodeRegistry;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are already initialized in Ownable
    }

    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {
        return darknodeRegistry[darknodeID];
    }
}"
476,Transfer ` _value ` SAT tokens from sender 's account ` msg.sender ` to provided account address ` _to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address _to, uint256 _value) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    bool public funding_ended = false;
    address public founders;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(!funding_ended, ""Funding has ended"");
        require(msg.sender != founders, ""Founders cannot transfer tokens"");
        uint256 senderBalance = balances[msg.sender];
        require(senderBalance >= _value && _value > 0, ""Insufficient balance or invalid value"");

        balances[msg.sender] = safeSub(senderBalance, _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}",transfer,"[{'function': 'endFunding', 'complexity': 1}, {'function': 'transfer', 'complexity': 4}, {'function': 'mint', 'complexity': 1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fundingEnded""}, {""type"": ""stringLiteral"", ""value"": ""Funding has not ended""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""founder""}}, {""type"": ""stringLiteral"", ""value"": ""Founder cannot transfer tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.8375202724986046,0.3951884163088541,"pragma solidity ^0.8.0;

contract Token {
    address public founder;
    bool public fundingEnded;
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(address _founder) {
        founder = _founder;
    }

    function endFunding() public {
        require(msg.sender == founder, ""Only the founder can end funding"");
        fundingEnded = true;
    }

    function transfer(address _to, uint256 _value) public {
        require(fundingEnded, ""Funding has not ended"");
        require(msg.sender != founder, ""Founder cannot transfer tokens"");
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        require(_value > 0, ""Transfer value must be greater than zero"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
    }

    function mint(address _to, uint256 _amount) public {
        require(msg.sender == founder, ""Only founder can mint tokens"");
        balances[_to] += _amount;
    }
}",43.33455848693848,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    address public founder;
    bool public fundingEnded;
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        founder = msg.sender;
        fundingEnded = false; // Set to false instead of true for safety and consistency
    }

    function endFunding() public {
        require(msg.sender == founder, ""Only the founder can end funding"");
        fundingEnded = true;
    }

    function transfer(address _to, uint256 _value) public {
        require(fundingEnded, ""Funding has not ended"");
        require(msg.sender != founder, ""Founder cannot transfer tokens"");
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        require(_value > 0, ""Transfer value must be greater than zero"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
    }

    function mint(address _to, uint256 _amount) public {
        require(msg.sender == founder, ""Only founder can mint tokens"");
        balances[_to] += _amount;
    }
}"
2119,Returns the order amount for trader ` _trader ` at '_price ',"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function getAmount(uint _price, address _trader) public pure returns (uint) {
        return _price;
    }
}",calculateAmount,"[{'function': 'calculateAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_trader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""%"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_price""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint160""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_trader""}], ""names"": []}], ""names"": []}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1000"", ""subdenomination"": None}}}, {""type"": ""Identifier"", ""name"": ""amount""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",12.0,0.7226314747448813,0.2207424935539331,"pragma solidity ^0.8.0;

contract AmountCalculator {

    function calculateAmount(uint _price, address _trader) public view returns (uint) {
        // Replace this with your actual calculation logic
        uint amount = _price * uint(uint160(_trader)) % 1000; //Example calculation.  Replace with your actual logic.
        return amount;
    }
}",41.8351047039032,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract AmountCalculator {
    uint public price = 1;
    address public trader = 0x1111111111111111111111111111111111111111; // Replace with actual value
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function calculateAmount(uint _price, address _trader) public view returns (uint) {
        uint amount = _price * uint(uint160(_trader)) % 1000; //Example calculation. Replace with your actual logic.
        return amount;
    }
}"
3447,Set the Synth contract that the issuance controller uses to issue Synths .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    Synth public synth;

    event SynthUpdated(Synth indexed synth);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setSynth(Synth _synth) external onlyOwner {
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}",setSynth,"[{'function': 'setSynth', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_synth"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""synth""}, ""right"": {""type"": ""Identifier"", ""name"": ""_synth""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SynthUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_synth""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9589050881445292,0.709421400618421,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    address public synth;

    event SynthUpdated(address newSynth);

    function setSynth(address _synth) public onlyOwner {
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}",41.97979521751404,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public synth;
    bool public initialized = true;
    bytes32 public constant initBytes = bytes32('init');

    constructor() Ownable(0x1111111111111111111111111111111111111111 , 0x2222222222222222222222222222222222222222) {
        synth = 0x3333333333333333333333333333333333333333; // fixed, safe value
        initialized = true;
        initBytes = bytes32('init');
    }

    event SynthUpdated(address newSynth);

    function setSynth(address _synth) public onlyOwner {
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}"
2394,Migrate tokens to the new token contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MigrationAgent {
    function migrateFrom(address _from, uint256 _value) external;
}

event Migrate(address indexed from, address indexed agent, uint256 value);

abstract contract MigrableToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    uint256 public totalMigrated;
    address public migrationAgent;

    function migrate(uint256 _value) external {
        if (migrationAgent == address(0)) revert();
        if (_value == 0) revert();
        if (_value > balances[msg.sender]) revert();
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalMigrated = totalMigrated.add(_value);
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
        emit Migrate(msg.sender, migrationAgent, _value);
    }
}",_transfer,"[{'function': 'setMigrationAgent', 'complexity': 0}, {'function': 'migrate', 'complexity': 3}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}, {'function': 'allowance', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 0}, {'function': '_transfer', 'complexity': 3}, {'function': '_beforeTokenTransfer', 'complexity': -1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_beforeTokenTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""UncheckedStatement"", ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_afterTokenTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",46.0,0.7160267093804167,0.0549912943428117,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Token is IERC20 {
    address public migrationAgent;
    uint256 public totalMigrated;

    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;

    event Migrate(address indexed sender, address indexed migrationAgent, uint256 value);

    function setMigrationAgent(address _migrationAgent) public {
        migrationAgent = _migrationAgent;
    }

    function migrate(uint256 _value) public {
        require(migrationAgent != address(0), ""Migration agent not set"");
        require(_value > 0, ""Migration value must be greater than zero"");
        require(_balances[msg.sender] >= _value, ""Insufficient balance"");

        _balances[msg.sender] -= _value;
        _totalSupply -= _value;
        totalMigrated += _value;

        IERC20(migrationAgent).transferFrom(msg.sender, migrationAgent, _value);

        emit Migrate(msg.sender, migrationAgent, _value);
    }


    // ... other IERC20 functions ...

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        // Implement allowance function
        return 0;
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        // Implement approve function
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        // Implement transferFrom function
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        _afterTokenTransfer(sender, recipient, amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}

    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
}",45.85904002189636,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is IERC20, Ownable {
    address public migrationAgent;
    uint256 public totalMigrated;

    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;

    event Migrate(address indexed sender, address indexed migrationAgent, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        migrationAgent = 0x1111111111111111111111111111111111111111; // fixed address
        totalMigrated = 1; // fixed value
        _totalSupply = 1000000000000000000; // fixed value
    }

    function setMigrationAgent(address _migrationAgent) public {
        require(_migrationAgent != address(0), ""Migration agent cannot be zero"");
        migrationAgent = _migrationAgent;
    }

    function migrate(uint256 _value) public {
        require(migrationAgent != address(0), ""Migration agent not set"");
        require(_value > 0, ""Migration value must be greater than zero"");
        require(_balances[msg.sender] >= _value, ""Insufficient balance"");

        _balances[msg.sender] -= _value;
        _totalSupply -= _value;
        totalMigrated += _value;

        IERC20(migrationAgent).transferFrom(msg.sender, migrationAgent, _value);

        emit Migrate(msg.sender, migrationAgent, _value);
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        // Implement allowance function
        return 0;
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        // Implement approve function
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        // Implement transferFrom function
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        _afterTokenTransfer(sender, recipient, amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}

    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
}"
6317,This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContributionProxy is Ownable {
    using SafeMath for uint256;

    function proxy_contribution(address _toAddr) public payable {
        require(_toAddr != address(0));
        process_contribution(_toAddr);
    }

    function process_contribution(address _toAddr) internal {
        // Implementation of the contribution processing logic
    }
}",proxy_contribution,"[{'function': 'process_contribution', 'complexity': 0}, {'function': 'proxy_contribution', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxy_contribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_toAddr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_toAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Target address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""process_contribution""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_toAddr""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",1.0,0.9868129245452592,0.7424213297217366,"pragma solidity ^0.8.0;

contract MyContract {

    function process_contribution(address _toAddr) internal {
        //Implementation for processing contribution
    }


    function proxy_contribution(address _toAddr) public payable {
        require(_toAddr != address(0), ""Target address cannot be zero"");
        process_contribution(_toAddr);
    }
}",41.77892255783081,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function process_contribution(address _toAddr) internal {
        require(_toAddr != address(0), ""Target address cannot be zero"");
        // Implementation for processing contribution
    }

    function proxy_contribution(address _toAddr) public payable {
        process_contribution(_toAddr);
    }
}"
5800,` seal ( ) ` ends the Campaign by calling ` seal ( ) ` in the CampaignToken contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public tokenContract;
    uint256 public endFundingTime;

    constructor(address _tokenContract, uint256 _endFundingTime) {
        require(_endFundingTime > now, ""End funding time must be in the future"");
        tokenContract = _tokenContract;
        endFundingTime = _endFundingTime;
    }

    function seal() public {
        if (now < endFundingTime) throw;
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(tokenContract != address(0), ""Token contract must be set"");
        IToken(tokenContract).seal();
    }

    interface IToken {
        function seal() external;
    }
}",seal,"[{'function': 'seal', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""seal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endFundingTime""}}, {""type"": ""stringLiteral"", ""value"": ""Funding period has not ended""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContract""}], ""names"": []}, ""memberName"": ""seal""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.6927728476200408,0.2057148099275914,"pragma solidity ^0.8.0;

contract FundingContract {

    uint256 public endFundingTime;
    address public tokenContract;

    constructor(uint256 _endFundingTime, address _tokenContract) {
        endFundingTime = _endFundingTime;
        tokenContract = _tokenContract;
    }

    function seal() public {
        require(block.timestamp >= endFundingTime, ""Funding period has not ended"");
        IToken(tokenContract).seal();
    }
}

interface IToken {
    function seal() external;
}",42.12575149536133,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FundingContract is Ownable {
    uint256 public endFundingTime;
    address public tokenContract;

    constructor(uint256 _endFundingTime, address _tokenContract) Ownable(msg.sender) {
        endFundingTime = _endFundingTime;
        tokenContract = _tokenContract;
    }

    function seal() public {
        require(block.timestamp >= endFundingTime, ""Funding period has not ended"");
        IToken(tokenContract).seal();
    }
}

interface IToken {
    function seal() external;
}"
5101,Returns asset balance for a particular holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function balanceOf(address _owner, bytes32 smbl) external view returns (uint);
}

abstract contract BalanceWrapper {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;
    bytes32 public smbl;

    constructor(address platformAddress, bytes32 symbol) {
        chronoBankPlatform = ChronoBankPlatform(platformAddress);
        smbl = symbol;
    }

    function balanceOf(address _owner) public view returns (uint) {
        return chronoBankPlatform.balanceOf(_owner, smbl);
    }
}",balanceOf,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""chronoBankPlatform""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""smbl""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9840079121246632,0.8725129388059689,"pragma solidity ^0.8.0;

interface IChronoBankPlatform {
    function balanceOf(address _owner, string memory symbol) external view returns (uint256);
}

contract MyContract {
    IChronoBankPlatform public chronoBankPlatform;
    string public smbl;

    constructor(address _chronoBankPlatform, string memory _smbl) {
        chronoBankPlatform = IChronoBankPlatform(_chronoBankPlatform);
        smbl = _smbl;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        return chronoBankPlatform.balanceOf(_owner, smbl);
    }
}",42.29105138778687,"pragma solidity ^0.8.0;

interface IChronoBankPlatform {
    function balanceOf(address _owner, string memory symbol) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IChronoBankPlatform public chronoBankPlatform;
    string public smbl;

    mapping(address => uint256) public balanceOf;

 constructor(address _chronoBankPlatform, string memory _smbl) Ownable(msg.sender) {
        chronoBankPlatform = IChronoBankPlatform(_chronoBankPlatform);
        smbl = _smbl;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        return chronoBankPlatform.balanceOf(_owner, smbl);
    }
}"
752,"Called by ` settle ` , executes the settlement for a RenEx order or distributes the fees for a RenExAtomic swap .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRENexBalances {
    function transferBalanceWithFee(address, address, address, uint256, uint256, address) external;
}

abstract contract RenExWrapper is Ownable {
    using SafeMath for uint256;

    struct TokenPair {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    mapping(bytes32 => bytes32) public orderDetails;
    mapping(bytes32 => address) public orderSubmitter;
    IRENexBalances public renExBalancesContract;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = keccak256(""RENEX_ATOMIC_SETTLEMENT"");

    function execute(bytes32 _buyID, bytes32 _sellID, address _buyer, address _seller, TokenPair memory _tokens) public {
        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ? calculateAtomicFees(_buyID, _sellID, _tokens) : calculateSettlementDetails(_buyID, _sellID, _tokens);
        renExBalancesContract.transferBalanceWithFee(_buyer, _seller, settlementDetails.leftTokenAddress, settlementDetails.leftVolume, settlementDetails.leftTokenFee, orderSubmitter[_buyID]);
        renExBalancesContract.transferBalanceWithFee(_seller, _buyer, settlementDetails.rightTokenAddress, settlementDetails.rightVolume, settlementDetails.rightTokenFee, orderSubmitter[_sellID]);
    }

    function calculateAtomicFees(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of atomic fee calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }

    function calculateSettlementDetails(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of settlement details calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }
}",executeSettlement,"[{'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'calculateAtomicFees', 'complexity': 0}, {'function': 'calculateSettlementDetails', 'complexity': 0}, {'function': 'executeSettlement', 'complexity': 1}, {'function': 'getSettlementID', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""executeSettlement"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_buyID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_sellID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Tokens""}, ""name"": ""_tokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""buyOrderSubmitter"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sellOrderSubmitter"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""leftFee"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""rightFee"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getSettlementID""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyID""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""RENEX_ATOMIC_SETTLEMENT_ID""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""leftFee""}, {""type"": ""Identifier"", ""name"": ""rightFee""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAtomicFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyID""}, {""type"": ""Identifier"", ""name"": ""_sellID""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""leftFee""}, {""type"": ""Identifier"", ""name"": ""rightFee""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateSettlementDetails""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyID""}, {""type"": ""Identifier"", ""name"": ""_sellID""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""renExBalancesContract""}, ""memberName"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""memberName"": ""leftTokenVolume""}, {""type"": ""Identifier"", ""name"": ""leftFee""}, {""type"": ""Identifier"", ""name"": ""buyOrderSubmitter""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""renExBalancesContract""}, ""memberName"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""memberName"": ""rightTokenVolume""}, {""type"": ""Identifier"", ""name"": ""rightFee""}, {""type"": ""Identifier"", ""name"": ""sellOrderSubmitter""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.603969324871945,0.0192938380196449,"pragma solidity ^0.8.0;

interface IRenExBalancesContract {
    function transferBalanceWithFee(address from, address to, uint256 amount, uint256 fee, address feePayer) external;
}

contract SettlementExecutor {

    uint256 public constant RENEX_ATOMIC_SETTLEMENT_ID = 1; //Example ID

    IRenExBalancesContract public renExBalancesContract;

    constructor(address _renExBalancesContract) {
        renExBalancesContract = IRenExBalancesContract(_renExBalancesContract);
    }


    struct Tokens {
        uint256 leftTokenVolume;
        uint256 rightTokenVolume;
        // Add other relevant token details as needed
    }

    function calculateAtomicFees(uint256 _buyID, uint256 _sellID, address _buyer, address _seller, Tokens memory _tokens) internal pure returns (uint256 leftFee, uint256 rightFee) {
        //Implementation for atomic fee calculation
        return (10, 10); //Example fees
    }

    function calculateSettlementDetails(uint256 _buyID, uint256 _sellID, address _buyer, address _seller, Tokens memory _tokens) internal pure returns (uint256 leftFee, uint256 rightFee) {
        //Implementation for settlement fee calculation
        return (5, 5); //Example fees
    }


    function executeSettlement(uint256 _buyID, uint256 _sellID, address _buyer, address _seller, Tokens memory _tokens, address buyOrderSubmitter, address sellOrderSubmitter) external {
        uint256 leftFee;
        uint256 rightFee;

        if (getSettlementID(_buyID) == RENEX_ATOMIC_SETTLEMENT_ID) {
            (leftFee, rightFee) = calculateAtomicFees(_buyID, _sellID, _buyer, _seller, _tokens);
        } else {
            (leftFee, rightFee) = calculateSettlementDetails(_buyID, _sellID, _buyer, _seller, _tokens);
        }

        renExBalancesContract.transferBalanceWithFee(_buyer, _seller, _tokens.leftTokenVolume, leftFee, buyOrderSubmitter);
        renExBalancesContract.transferBalanceWithFee(_seller, _buyer, _tokens.rightTokenVolume, rightFee, sellOrderSubmitter);
    }

    function getSettlementID(uint256 _buyID) internal pure returns (uint256) {
        //Implementation to retrieve settlement ID for a given buy order ID.  Replace with actual logic.
        return 1; //Example return value
    }
}",45.038898229599,"pragma solidity ^0.8.0;

interface IRenExBalancesContract {
    function transferBalanceWithFee(address from, address to, uint256 amount, uint256 fee, address feePayer) external;
}
import ""openzeppelin/SafeMath.sol"";
contract SettlementExecutor is Ownable {

    uint256 public constant RENEX_ATOMIC_SETTLEMENT_ID = 1; //Example ID

    IRenExBalancesContract public renExBalancesContract;

    constructor(address _renExBalancesContract) Ownable(msg.sender) {
        renExBalancesContract = IRenExBalancesContract(_renExBalancesContract);
    }

    struct Tokens {
        uint256 leftTokenVolume;
        uint256 rightTokenVolume;
        // Add other relevant token details as needed
    }

    function calculateAtomicFees(uint256 _buyID, uint256 _sellID, address _buyer, address _seller, Tokens memory _tokens) internal pure returns (uint256 leftFee, uint256 rightFee) {
        //Implementation for atomic fee calculation
        return (10, 10); //Example fees
    }

    function calculateSettlementDetails(uint256 _buyID, uint256 _sellID, address _buyer, address _seller, Tokens memory _tokens) internal pure returns (uint256 leftFee, uint256 rightFee) {
        //Implementation for settlement fee calculation
        return (5, 5); //Example fees
    }

    function executeSettlement(uint256 _buyID, uint256 _sellID, address _buyer, address _seller, Tokens memory _tokens, address buyOrderSubmitter, address sellOrderSubmitter) external {
        uint256 leftFee;
        uint256 rightFee;

        if (getSettlementID(_buyID) == RENEX_ATOMIC_SETTLEMENT_ID) {
            (leftFee, rightFee) = calculateAtomicFees(_buyID, _sellID, _buyer, _seller, _tokens);
        } else {
            (leftFee, rightFee) = calculateSettlementDetails(_buyID, _sellID, _buyer, _seller, _tokens);
        }

        renExBalancesContract.transferBalanceWithFee(_buyer, _seller, _tokens.leftTokenVolume, leftFee, buyOrderSubmitter);
        renExBalancesContract.transferBalanceWithFee(_seller, _buyer, _tokens.rightTokenVolume, rightFee, sellOrderSubmitter);
    }

    function getSettlementID(uint256 _buyID) internal pure returns (uint256) {
        //Implementation to retrieve settlement ID for a given buy order ID.  Replace with actual logic.
        return 1; //Example return value
    }
}"
1142,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _amount) public override returns (bool) {
        require(_spender != address(0));
        require(_amount > 0);
        require(_amount <= balanceOf[msg.sender]);

        allowances[_spender][msg.sender] = _amount;

        emit Approval(msg.sender, _spender, _amount);

        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.8086072042978896,0.6206722039632836,"pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _amount) public returns (bool) {
        require(_spender != address(0), ""ERC20: approve to the zero address"");
        allowance[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }
}",42.44837427139282,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[owner()] = 1; // Set to 1 (never 0)
        allowance[address(0)][address(0)] = 0; // Default allowances are set to 0
    }

    function approve(address _spender, uint256 _amount) public returns (bool) {
        require(_spender != address(0), ""ERC20: approve to the zero address"");
        allowance[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }
}"
3633,` _value ` tokens will be sended to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITransfer {
    function transfer(bytes32 _to, uint256 _value) external returns (bool);
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event TransferHash(bytes32 indexed from, bytes32 indexed to, uint256 value);

    function transfer(bytes32 _to, uint256 _value) external onlyOwner returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit TransferHash(keccak256(abi.encodePacked(msg.sender)), _to, _value);
        return true;
    }
}",transfer,"[{'function': 'transfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""senderHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""senderHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""senderHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TransferHash""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""senderHash""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.7524165090747816,0.5494522584196055,"pragma solidity ^0.8.0;

contract Token {
    mapping(bytes32 => uint256) public balances;

    event TransferHash(bytes32 indexed from, bytes32 indexed to, uint256 value);

    function transfer(bytes32 _to, uint256 _value) public returns (bool) {
        bytes32 senderHash = keccak256(abi.encodePacked(msg.sender));
        require(balances[senderHash] >= _value, ""Insufficient balance"");
        balances[senderHash] -= _value;
        balances[_to] += _value;
        emit TransferHash(senderHash, _to, _value);
        return true;
    }
}",42.49542617797852,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(bytes32 => uint256) public balances;

    event TransferHash(bytes32 indexed from, bytes32 indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            balances[keccak256(abi.encodePacked(""address"", i))] = 1;
        }
    }

    function transfer(bytes32 _to, uint256 _value) public returns (bool) {
        bytes32 senderHash = keccak256(abi.encodePacked(msg.sender));
        require(balances[senderHash] >= _value, ""Insufficient balance"");
        balances[senderHash] -= _value;
        balances[_to] += _value;
        emit TransferHash(senderHash, _to, _value);
        return true;
    }
}"
4852,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function burn(uint256 _amount) public requiresPermission whenNotPaused {
        _burn(msg.sender, _amount);
    }
}",_burn,"[{'function': 'burn', 'complexity': 2}, {'function': '_burn', 'complexity': 0}, {'function': 'pause', 'complexity': 1}, {'function': 'unpause', 'complexity': 1}, {'function': 'grantPermission', 'complexity': 1}, {'function': 'revokePermission', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.5009748369022767,0.0359575735822536,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => bool) public hasPermission;

    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier requiresPermission() {
        require(hasPermission[msg.sender], ""No permission"");
        _;
    }

    function burn(uint256 _amount) public whenNotPaused requiresPermission {
        require(balanceOf[msg.sender] >= _amount, ""Insufficient balance"");
        _burn(msg.sender, _amount);
    }

    function _burn(address account, uint256 amount) internal {
        balanceOf[account] = balanceOf[account].sub(amount);
        totalSupply = totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function pause() public requiresPermission {
        paused = true;
    }

    function unpause() public requiresPermission {
        paused = false;
    }

    function grantPermission(address account) public requiresPermission {
        hasPermission[account] = true;
    }

    function revokePermission(address account) public requiresPermission {
        hasPermission[account] = false;
    }
}",43.7468695640564,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply = 1000000000000000000;
    mapping(address => uint256) public balanceOf;
    mapping(address => bool) public hasPermission;

    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier requiresPermission() {
        require(hasPermission[msg.sender], ""No permission"");
        _;
    }

    function burn(uint256 _amount) public whenNotPaused requiresPermission {
        require(balanceOf[msg.sender] >= _amount, ""Insufficient balance"");
        _burn(msg.sender, _amount);
    }

    function _burn(address account, uint256 amount) internal {
        balanceOf[account] = balanceOf[account].sub(amount);
        totalSupply = totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function pause() public requiresPermission {
        paused = true;
    }

    function unpause() public requiresPermission {
        paused = false;
    }

    function grantPermission(address account) public requiresPermission {
        hasPermission[account] = true;
    }

    function revokePermission(address account) public requiresPermission {
        hasPermission[account] = false;
    }

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        balanceOf[msg.sender] = 1000;
        totalSupply = 1000000000000000000;
        paused = false;
        hasPermission[msg.sender] = true;
    }
}"
2521,Returns the address currently assigned ownership of a given Warrior .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WarriorsWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    function ownerOf(uint208 _tokenId) external view returns (address owner) {
        require(_tokenId < warriors.length);
        owner = warriorToOwner[_tokenId];
    }
}",ownerOf,"[{'function': 'ownerOf', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""warriors""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""ERC721: owner query for nonexistent token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""warriorToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.9728370849291692,0.5319879176370615,"pragma solidity ^0.8.0;

contract MyContract {
    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        require(_tokenId < warriors.length, ""ERC721: owner query for nonexistent token"");
        owner = warriorToOwner[_tokenId];
    }
}",41.74627351760864,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            warriorToOwner[i] = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
        }
        warriors = [uint256(1), uint256(2), uint256(3)];
    }

    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        require(_tokenId < warriors.length, ""ERC721: owner query for nonexistent token"");
        owner = warriorToOwner[_tokenId];
    }
}"
402,Contract owner or Multisig can clawback ether after refund period is finished,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ClawbackEtherWrapper is Ownable {
    using SafeMath for uint256;

    bool public contractFailed;
    bool public contractRefundStarted;
    bool public contractRefundFinished;

    constructor() {}

    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
        require(contractFailed);
        require(contractRefundStarted);
        require(contractRefundFinished);
        require(value > 0);
        require(value <= address(this).balance);
        payable(msg.sender).transfer(value);
    }
}",emergencyClawbackEther,"[{'function': 'emergencyClawbackEther', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""emergencyClawbackEther"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractFailed""}, {""type"": ""stringLiteral"", ""value"": ""Contract must have failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractRefundStarted""}, {""type"": ""stringLiteral"", ""value"": ""Refund process must have started""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractRefundFinished""}, {""type"": ""stringLiteral"", ""value"": ""Refund process must have finished""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwnerOrMultisig"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.9582841098617804,0.4653668565122325,"pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    address public multisigWallet;
    bool public contractFailed;
    bool public contractRefundStarted;
    bool public contractRefundFinished;

    constructor(address _multisigWallet) {
        owner = msg.sender;
        multisigWallet = _multisigWallet;
    }

    modifier onlyOwnerOrMultisig() {
        require(msg.sender == owner || msg.sender == multisigWallet, ""Only owner or multisig can call this function"");
        _;
    }

    function emergencyClawbackEther(uint256 value) public onlyOwnerOrMultisig {
        require(contractFailed, ""Contract must have failed"");
        require(contractRefundStarted, ""Refund process must have started"");
        require(contractRefundFinished, ""Refund process must have finished"");
        require(value > 0, ""Value must be greater than zero"");
        require(address(this).balance >= value, ""Insufficient balance"");
        payable(msg.sender).transfer(value);
    }
}",43.02771353721619,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public multisigWallet;
    bool public contractFailed;
    bool public contractRefundStarted;
    bool public contractRefundFinished;

    constructor(address _multisigWallet) Ownable(msg.sender) {
        multisigWallet = _multisigWallet;
        contractFailed = false;
        contractRefundStarted = false;
        contractRefundFinished = false;
    }

    modifier onlyOwnerOrMultisig() {
        require(msg.sender == owner() || msg.sender == multisigWallet, ""Only owner or multisig can call this function"");
        _;
    }

    function emergencyClawbackEther(uint256 value) public onlyOwnerOrMultisig {
        require(contractFailed, ""Contract must have failed"");
        require(contractRefundStarted, ""Refund process must have started"");
        require(contractRefundFinished, ""Refund process must have finished"");
        require(value > 0, ""Value must be greater than zero"");
        require(address(this).balance >= value, ""Insufficient balance"");
        payable(msg.sender).transfer(value);
    }
}"
2323,By using this function you accept the terms of DXF,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Multisig {
    function send(uint256 amount) external returns (bool);
}

abstract contract DXFContract is Ownable {
    using SafeMath for uint256;

    uint public startingDateFunding;
    bool public dxfOpen = true;
    uint public maxNumberMembers = 1000;
    uint public totalTokens;
    uint public tokensCreationCap = 10000 ether;
    uint public remainingTokensVIPs;
    mapping(address => uint) public balances;
    address[] public members;
    mapping(address => uint) public indexMembers;
    mapping(address => bool) public vips;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function acceptTermsAndJoinDXF() payable external {
        require(now > startingDateFunding + 365 days, ""Too early"");
        require(dxfOpen, ""DXF is closed"");
        require(!vips[msg.sender], ""Already a VIP"");
        require(msg.value >= 10 ether, ""Minimum contribution is 10 ether"");
        require(msg.value <= (tokensCreationCap - totalTokens), ""Exceeds token creation cap"");
        require(msg.value <= 10000 ether - balances[msg.sender], ""Exceeds balance limit"");

        if (balances[msg.sender] == 0) {
            newMember(msg.sender);
            indexMembers[msg.sender] = members.length;
            members.push(Member(msg.sender, now, msg.value));
        } else {
            members[indexMembers[msg.sender]].initial_value += msg.value;
        }

        require(members.length <= maxNumberMembers, ""Max number of members reached"");
        require(multisigDXF != address(0), ""Invalid multisig contract"");

        Multisig multisig = Multisig(multisigDXF);
        require(multisig.send(msg.value), ""Transfer failed"");

        uint numTokens = msg.value;
        totalTokens += numTokens;
        require((tokensCreationCap - totalTokens) >= remainingTokensVIPs, ""Exceeds VIP tokens limit"");

        balances[msg.sender] += numTokens;
        Transfer(address(0), msg.sender, numTokens);
    }

    function newMember(address member) internal {
        // Implementation of newMember logic if needed
    }
}",joinDXF,"[{'function': 'joinDXF', 'complexity': 14}]",13.0,"{""type"": ""FunctionDefinition"", ""name"": ""joinDXF"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""startingDate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""31536000"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Funding period has ended""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isOpenForContributions""}, {""type"": ""stringLiteral"", ""value"": ""DXF is not open for contributions""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isVIP""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""VIP members cannot join through this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}}, {""type"": ""stringLiteral"", ""value"": ""Minimum contribution is 10 ether""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""totalTokensCreated""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensCreationCap""}}, {""type"": ""stringLiteral"", ""value"": ""Contribution exceeds remaining tokens creation cap""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""memberBalances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10000"", ""subdenomination"": ""ether""}}, {""type"": ""stringLiteral"", ""value"": ""Contribution exceeds individual balance limit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""members""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""maxMembers""}}, {""type"": ""stringLiteral"", ""value"": ""Member list has reached maximum capacity""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""multisigDXF""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Multisig DXF address is not set""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isNewMember"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""members""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isNewMember""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""isNewMember""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""members""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""memberBalances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""numTokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalTokensCreated""}, ""right"": {""type"": ""Identifier"", ""name"": ""numTokens""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""numTokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""multisigDXF""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",72.0,0.8511212770697228,0.354375505050049,"pragma solidity ^0.8.0;

contract DXF {
    uint256 public startingDate;
    uint256 public tokensCreationCap;
    uint256 public totalTokensCreated;
    uint256 public maxMembers;
    address payable public multisigDXF;
    bool public isOpenForContributions;
    address[] public members;
    mapping(address => uint256) public memberBalances;
    mapping(address => bool) public isVIP;


    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 _startingDate, uint256 _tokensCreationCap, uint256 _maxMembers, address payable _multisigDXF) {
        startingDate = _startingDate;
        tokensCreationCap = _tokensCreationCap;
        maxMembers = _maxMembers;
        multisigDXF = _multisigDXF;
        isOpenForContributions = true;
    }

    function joinDXF() public payable {
        require(block.timestamp < startingDate + 31536000, ""Funding period has ended"");
        require(isOpenForContributions, ""DXF is not open for contributions"");
        require(!isVIP[msg.sender], ""VIP members cannot join through this function"");
        require(msg.value >= 10 ether, ""Minimum contribution is 10 ether"");
        require(totalTokensCreated + msg.value <= tokensCreationCap, ""Contribution exceeds remaining tokens creation cap"");
        require(memberBalances[msg.sender] + msg.value <= 10000 ether, ""Contribution exceeds individual balance limit"");
        require(members.length < maxMembers, ""Member list has reached maximum capacity"");
        require(multisigDXF != address(0), ""Multisig DXF address is not set"");

        uint256 numTokens = msg.value;

        bool isNewMember = true;
        for (uint i = 0; i < members.length; i++) {
            if (members[i] == msg.sender) {
                isNewMember = false;
                break;
            }
        }

        if (isNewMember) {
            members.push(msg.sender);
        }

        memberBalances[msg.sender] += numTokens;
        totalTokensCreated += numTokens;
        emit Transfer(address(0), msg.sender, numTokens);
        payable(multisigDXF).transfer(msg.value);
    }
}",44.81221127510071,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DXF is Ownable {
    uint256 public startingDate;
    uint256 public tokensCreationCap;
    uint256 public totalTokensCreated;
    uint256 public maxMembers;
    address payable public multisigDXF;
    bool public isOpenForContributions;
    address[] public members;
    mapping(address => uint256) public memberBalances;
    mapping(address => bool) public isVIP;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 _startingDate, uint256 _tokensCreationCap, uint256 _maxMembers, address payable _multisigDXF) Ownable(msg.sender) {
        startingDate = _startingDate;
        tokensCreationCap = _tokensCreationCap;
        maxMembers = _maxMembers;
        multisigDXF = _multisigDXF;
        isOpenForContributions = true;
    }

    function joinDXF() public payable {
        require(block.timestamp < startingDate + 31536000, ""Funding period has ended"");
        require(isOpenForContributions, ""DXF is not open for contributions"");
        require(!isVIP[msg.sender], ""VIP members cannot join through this function"");
        require(msg.value >= 10 ether, ""Minimum contribution is 10 ether"");
        require(totalTokensCreated + msg.value <= tokensCreationCap, ""Contribution exceeds remaining tokens creation cap"");
        require(memberBalances[msg.sender] + msg.value <= 10000 ether, ""Contribution exceeds individual balance limit"");
        require(members.length < maxMembers, ""Member list has reached maximum capacity"");
        require(multisigDXF != address(0), ""Multisig DXF address is not set"");

        uint256 numTokens = msg.value;

        bool isNewMember = true;
        for (uint i = 0; i < members.length; i++) {
            if (members[i] == msg.sender) {
                isNewMember = false;
                break;
            }
        }

        if (isNewMember) {
            members.push(msg.sender);
        }

        memberBalances[msg.sender] += numTokens;
        totalTokensCreated += numTokens;
        emit Transfer(address(0), msg.sender, numTokens);
        payable(multisigDXF).transfer(msg.value);
    }
}"
36,Function used by the creator to set the contractor manager smart contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractorManagerSetter is Ownable {
    using SafeMath for uint256;

    event ContractorManagerSet(address indexed contractorManager);

    function setContractorManager(address _contractorManager) public onlyOwner {
        require(_contractorManager != address(0), ""Invalid contractor manager address"");
        emit ContractorManagerSet(_contractorManager);
    }
}",setContractorManager,"[{'function': 'setContractorManager', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setContractorManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractorManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contractorManager""}, ""right"": {""type"": ""Identifier"", ""name"": ""_contractorManager""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.6631109056361211,0.1665806979447398,"pragma solidity ^0.8.0;

contract ContractorManagement {

    address public owner;
    address public contractorManager;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function setContractorManager(address _contractorManager) public onlyOwner {
        contractorManager = _contractorManager;
    }
}",42.4995322227478,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ContractorManagement is Ownable {
    address public contractorManager;

    constructor(address _owner) Ownable(_owner) {
        owner = _owner;
    }

    function setContractorManager(address _contractorManager) public onlyOwner {
        contractorManager = _contractorManager;
    }
}"
1979,Get comprehensive information on an attribute type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAttributeType {
    struct AttributeType {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }
}

abstract contract AttributeTypeWrapper {
    using SafeMath for uint256;

    mapping(uint256 => IAttributeType.AttributeType) private _attributeTypes;

    function getAttributeTypeInformation(uint256 attributeTypeID) external view returns (string memory, bool, bool, address, uint256, uint256, uint256) {
        return (
            _attributeTypes[attributeTypeID].description,
            _attributeTypes[attributeTypeID].isRestricted,
            _attributeTypes[attributeTypeID].isOnlyPersonal,
            _attributeTypes[attributeTypeID].secondarySource,
            _attributeTypes[attributeTypeID].secondaryId,
            _attributeTypes[attributeTypeID].minimumRequiredStake,
            _attributeTypes[attributeTypeID].jurisdictionFee
        );
    }
}",getAttributeTypeDetails,"[{'function': 'getAttributeTypeDetails', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAttributeTypeDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""description"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isRestricted"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isOnlyPersonal"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""secondarySource"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""secondaryId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""minimumRequiredStake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""jurisdictionFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""AttributeType""}, ""name"": ""attributeType"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attributeType""}, ""memberName"": ""description""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attributeType""}, ""memberName"": ""isRestricted""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attributeType""}, ""memberName"": ""isOnlyPersonal""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attributeType""}, ""memberName"": ""secondarySource""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attributeType""}, ""memberName"": ""secondaryId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attributeType""}, ""memberName"": ""minimumRequiredStake""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attributeType""}, ""memberName"": ""jurisdictionFee""}], ""isArray"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",19.0,0.6730183332611755,0.2644198632638797,"pragma solidity ^0.8.0;

contract AttributeTypeRegistry {

    struct AttributeType {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }

    mapping(uint256 => AttributeType) public attributeTypes;

    function getAttributeTypeDetails(uint256 attributeTypeID) external view returns (string memory description, bool isRestricted, bool isOnlyPersonal, address secondarySource, uint256 secondaryId, uint256 minimumRequiredStake, uint256 jurisdictionFee) {
        AttributeType storage attributeType = attributeTypes[attributeTypeID];
        return (attributeType.description, attributeType.isRestricted, attributeType.isOnlyPersonal, attributeType.secondarySource, attributeType.secondaryId, attributeType.minimumRequiredStake, attributeType.jurisdictionFee);
    }
}",42.72968244552612,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttributeTypeRegistry is Ownable {

    struct AttributeType {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }

    mapping(uint256 => AttributeType) public attributeTypes;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint256 i = 1; ; ++i) {
            if (i > 3) break; // Limit to three addresses as per the requirement
            attributeTypes[i] = AttributeType({
                description: 'initialized',
                isRestricted: true,
                isOnlyPersonal: false,
                secondarySource: address(uint160(i)),
                secondaryId: i * 100,
                minimumRequiredStake: 1,
                jurisdictionFee: 1
            });
        }
    }

    function getAttributeTypeDetails(uint256 attributeTypeID) external view returns (string memory description, bool isRestricted, bool isOnlyPersonal, address secondarySource, uint256 secondaryId, uint256 minimumRequiredStake, uint256 jurisdictionFee) {
        AttributeType storage attributeType = attributeTypes[attributeTypeID];
        return (attributeType.description, attributeType.isRestricted, attributeType.isOnlyPersonal, attributeType.secondarySource, attributeType.secondaryId, attributeType.minimumRequiredStake, attributeType.jurisdictionFee);
    }
}"
2733,Set the stale period on the updated havven price,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public priceStalePeriod;

    function setPriceStalePeriod(uint time) external optionalProxy_onlyOwner {
        priceStalePeriod = time;
    }
}",setStalePeriod,"[{'function': 'setStalePeriod', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setStalePeriod"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""time"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""priceStalePeriod""}, ""right"": {""type"": ""Identifier"", ""name"": ""time""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""optionalProxy_onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9491962780426568,0.4525888007890558,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public priceStalePeriod;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    modifier optionalProxy_onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function setStalePeriod(uint256 time) public optionalProxy_onlyOwner {
        priceStalePeriod = time;
    }

    function owner() public view returns (address) {
        return owner;
    }
}",42.598931550979614,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public priceStalePeriod;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    modifier optionalProxy_onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        priceStalePeriod = 1;
    }

    function setStalePeriod(uint256 time) public optionalProxy_onlyOwner {
        priceStalePeriod = time;
    }
}"
1587,allows EtherToken to reclaim tokens wrongly sent to its address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/SafeMath.sol"";

interface IBasicToken {
    // Define the interface of the token contract here if needed
}

abstract contract Reclaimable is Ownable {
    using SafeMath for uint256;

    address public constant RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function reclaim(IBasicToken token) public onlyOwner {
        require(token != IBasicToken(RECLAIM_ETHER));
        Reclaimable.reclaim(token);
    }
}",reclaimToken,"[{'function': 'reclaim', 'complexity': 0}, {'function': 'reclaimToken', 'complexity': 1}, {'function': 'reclaim', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IBasicToken""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""RECLAIM_ETHER""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot reclaim Ether""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Reclaimable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""reclaim""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.8646730091606358,0.2825389300666805,"pragma solidity ^0.8.0;

interface IBasicToken {
    function reclaim() external;
}

contract MyContract {
    address constant RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function reclaimToken(IBasicToken token) public {
        require(address(token) != RECLAIM_ETHER, ""Cannot reclaim Ether"");
        Reclaimable(address(this)).reclaim(token);
    }
}

contract Reclaimable {
    function reclaim(IBasicToken token) public virtual {
        //Implementation to reclaim token
    }
}",42.11895561218262,"pragma solidity ^0.8.0;

interface IBasicToken {
    function reclaim() external;
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Reclaimable, Ownable {
    address constant RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function reclaimToken(IBasicToken token) public {
        require(address(token) != RECLAIM_ETHER, ""Cannot reclaim Ether"");
        Reclaimable(address(this)).reclaim(token);
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Reclaimable {
    function reclaim(IBasicToken token) public virtual {
        //Implementation to reclaim token
    }
}"
1004,"Used to reference a loan that is not yet created , and by that does not have an index","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentifierBuilder {
    using SafeMath for uint256;

    function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public view returns (bytes32) {
        return keccak256(abi.encodePacked(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}",generateLoanIdentifier,"[{'function': 'generateLoanIdentifier', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""generateLoanIdentifier"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Oracle""}, ""name"": ""oracle"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""borrower"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""creator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""currency"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""interestRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""interestRatePunitory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""duesIn"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""cancelableAt"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expirationRequest"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""metadata"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""oracle""}, {""type"": ""Identifier"", ""name"": ""borrower""}, {""type"": ""Identifier"", ""name"": ""creator""}, {""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""interestRate""}, {""type"": ""Identifier"", ""name"": ""interestRatePunitory""}, {""type"": ""Identifier"", ""name"": ""duesIn""}, {""type"": ""Identifier"", ""name"": ""cancelableAt""}, {""type"": ""Identifier"", ""name"": ""expirationRequest""}, {""type"": ""Identifier"", ""name"": ""metadata""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",2.0,0.9397251430487964,0.8791177691806069,"pragma solidity ^0.8.0;

interface Oracle {

}

contract LoanContract {

    function generateLoanIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}",42.62164258956909,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface Oracle {

}
import ""openzeppelin/SafeMath.sol"";
contract LoanContract is Ownable {
    uint256 private constant INITIAL_AMOUNT = 1;
    bytes32 private constant INITIAL_BYTES32 = bytes32('init');
    string private constant INITIALIZED_STRING = 'initialized';

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 amount = INITIAL_AMOUNT;
        bytes32 currency = INITIAL_BYTES32;
        string memory metadata = INITIALIZED_STRING;
    }

    function generateLoanIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}"
6826,Returns the block number for when the channel was closed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        uint closed;
    }

    Data private data;

    function closed() public view returns (uint) {
        return data.closed;
    }
}",closed,"[{'function': 'closed', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""closed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""closed""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9613764575822822,0.7825422900366437,"pragma solidity ^0.8.0;

contract MyContract {
    struct Data {
        bool closed;
    }

    Data public data;

    function closed() public view returns (bool) {
        return data.closed;
    }
}",41.64747619628906,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Data {
        bool closed;
    }

    Data public data;

    constructor() Ownable(msg.sender) {
        data.closed = true;
    }

    function closed() public view returns (bool) {
        return data.closed;
    }
}"
4437,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value > 0, ""Invalid value"");
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 0}, {'function': 'approve', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.7586281295836128,0.1693386210845264,"pragma solidity ^0.8.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract MyToken is IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = msg.sender;
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
        return true;
    }

    // ... other functions ...
}",42.54109072685242,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyToken is IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    constructor() {
        // Initialization of Ownable with the deployer's address
        Ownable(msg.sender);
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = msg.sender;
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
        return true;
    }

    // ... other functions ...
}"
2473,Finalize an upgrade process setting new asset implementation contract address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UpgradeHandler is Ownable {
    using SafeMath for uint256;

    uint256 public pendingVersion;
    uint256 public pendingVersionTimestamp;
    uint256 public constant UPGRADE_FREEZE_TIME = 7 days; // Example freeze time, adjust as needed
    uint256 public latestVersion;

    function commitUpgrade() public onlyOwner returns (bool) {
        if (pendingVersion == 0x0) {
            return false;
        }

        if (pendingVersionTimestamp.add(UPGRADE_FREEZE_TIME) > block.timestamp) {
            return false;
        }

        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;

        return true;
    }
}",commitUpgrade,"[{'function': 'commitUpgrade', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""commitUpgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""pendingVersion""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""pendingVersionTimestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""UPGRADE_FREEZE_TIME""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""latestVersion""}, ""right"": {""type"": ""Identifier"", ""name"": ""pendingVersion""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""pendingVersion""}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""pendingVersionTimestamp""}, ""isPrefix"": True}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.909618051278245,0.7057324174867924,"pragma solidity ^0.8.0;

contract UpgradeableContract {

    uint256 public UPGRADE_FREEZE_TIME = 2 days; // Example freeze time

    address public pendingVersion;
    uint256 public pendingVersionTimestamp;
    address public latestVersion;

    function commitUpgrade() public returns (bool) {
        if (pendingVersion == address(0)) {
            return false;
        }
        if (block.timestamp < pendingVersionTimestamp + UPGRADE_FREEZE_TIME) {
            return false;
        }
        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
}",42.96555924415589,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract UpgradeableContract is Ownable {
    uint256 public UPGRADE_FREEZE_TIME = 2 days; // Example freeze time

    address public pendingVersion;
    uint256 public pendingVersionTimestamp;
    address public latestVersion;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function commitUpgrade() public returns (bool) {
        if (pendingVersion == address(0)) {
            return false;
        }
        if (block.timestamp < pendingVersionTimestamp + UPGRADE_FREEZE_TIME) {
            return false;
        }
        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }

    // Initialize state variables
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        pendingVersion = address(0x1111111111111111111111111111111111111111); // Replace with actual address
        pendingVersionTimestamp = block.timestamp + 1; // Set to a fixed value
        latestVersion = msg.sender;
    }
}"
4258,Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 0}, {'function': 'allowance', 'complexity': 0}, {'function': 'approve', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9607667847978504,0.370144262965526,"pragma solidity ^0.8.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract MyToken is IERC20 {
    mapping(address => mapping(address => uint256)) internal _allowances;

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
}",42.90832567214966,"pragma solidity ^0.8.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is IERC20 {
    mapping(address => mapping(address => uint256)) internal _allowances;

    constructor() {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            if (i == 1) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                // Use fixed values as per the requirement
                _allowances[addr][addr] = 1;
            } else if (i == 2) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                // Use fixed values as per the requirement
                _allowances[addr][addr] = 2;
            } else if (i == 3) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                // Use fixed values as per the requirement
                _allowances[addr][addr] = 3;
            }
        }
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
}"
3893,should be called off chain with as much gas as needed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface KyberReserveInterface {
    // Define the interface of the KyberReserve here if needed
}

abstract contract KyberReserveWrapper is Ownable {
    using SafeMath for uint256;

    KyberReserveInterface[] public reserves;

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}",getReserves,"[{'function': 'getReserves', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getReserves"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""KyberReserveInterface""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""reserves""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

interface KyberReserveInterface {
    // Dummy interface, replace with actual interface if available
}

contract KyberNetwork {
    KyberReserveInterface[] public reserves;

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}",41.65934991836548,"pragma solidity ^0.8.0;

interface KyberReserveInterface {
    // Dummy interface, replace with actual interface if available
}
import ""openzeppelin/SafeMath.sol"";
contract KyberNetwork is Ownable {
    KyberReserveInterface[] public reserves;
    address public constant RESERVE_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual reserve address
    bool public constant INITIALIZED = true;

    constructor() Ownable(msg.sender) {
        reserves.push(RESERVE_ADDRESS);
    }

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}"
3338,Exposes that this contract thinks it is an AffiliateProgram,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AffiliateProgramWrapper is Ownable {
    using SafeMath for uint256;

    function isAffiliateProgram() public pure returns (bool) {
    return true;
}
}",isAffiliateProgramActive,"[{'function': 'isAffiliateProgramActive', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isAffiliateProgramActive"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",0.0,0.9706763592765264,0.855526185871245,"pragma solidity ^0.8.0;

contract AffiliateProgram {

    function isAffiliateProgramActive() public pure returns (bool) {
        return true;
    }
}",41.702889919281006,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract AffiliateProgram is Ownable {
    uint256 public constant VERSION = 1;
    address public constant ADMIN_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual admin address
    bool public constant IS_ACTIVE = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isAffiliateProgramActive() public pure returns (bool) {
        return IS_ACTIVE;
    }
}"
812,Allow users to buy tokens for ` newRate ` x eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public tokensPerEther;

    function setPrices(uint256 newRate) public onlyOwner {
        tokensPerEther = newRate;
    }
}",setPrices,"[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensPerEther""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRate""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public tokensPerEther;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setPrices(uint256 newRate) public onlyOwner {
        tokensPerEther = newRate;
    }
}",42.09391784667969,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public tokensPerEther = 1;
    address public owner = address(uint160(uint256(keccak256('a'))));

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setPrices(uint256 newRate) public onlyOwner {
        tokensPerEther = newRate;
    }
}"
714,Transfers ` amount ` from msg.sender to ` destination `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function balances(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address destination, uint256 amount) public tradable(msg.sender) returns (bool success) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);
        emit Transfer(msg.sender, destination, amount);
        return true;
    }
}",transfer,"[{'function': 'transfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""destination"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""destination""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""destination""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""destination""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""tradable"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.8197478924473504,0.5313152340923442,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier tradable() {
        // Add logic to check trading privileges here.  Example: require(isTrader[msg.sender], ""Not a trader"");
        _;
    }

    function transfer(address destination, uint256 amount) public tradable {
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);
        emit Transfer(msg.sender, destination, amount);
    }
}",42.53039503097534,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier tradable() {
        // Add logic to check trading privileges here.  Example: require(isTrader[msg.sender], ""Not a trader"");
        _;
    }

    constructor() Ownable(msg.sender) {
        balances[owner()] = 1; // Initialize the balance of the owner to 1
    }

    function transfer(address destination, uint256 amount) public tradable {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);
        emit Transfer(msg.sender, destination, amount);
    }
}"
6517,Set ` _token_address ` as the token address to be used in the auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RaidenToken {
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

abstract contract Auction is Ownable {
    using SafeMath for uint256;

    enum Stages { NotDeployed, AuctionDeployed, AuctionSetUp, AuctionEnded }
    Stages public stage;

    RaidenToken public token;
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;

    event Setup();

    modifier atStage(Stages expectedStage) {
        require(stage == expectedStage, ""Auction: Invalid stage"");
        _;
    }

    function setup(address _token_address) public onlyOwner atStage(Stages.AuctionDeployed) {
        require(_token_address != address(0), ""Token address must be valid"");
        token = RaidenToken(_token_address);
        num_tokens_auctioned = token.balanceOf(address(this));
        token_multiplier = 10 ** uint256(token.decimals());
        stage = Stages.AuctionSetUp;
        emit Setup();
    }
}",setup,"[{'function': 'setup', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""num_tokens_auctioned""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token_multiplier""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""decimals""}, ""arguments"": [], ""names"": []}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""AuctionSetUp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Setup""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8832303552796341,0.5933994576053513,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Auction {

    enum Stage {
        NotStarted,
        AuctionSetUp,
        Bidding,
        Ended
    }

    IERC20 public token;
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;
    Stage public stage;

    event Setup(address indexed tokenAddress);

    function setup(address _token_address) public {
        require(_token_address != address(0), ""Token address cannot be zero"");
        token = IERC20(_token_address);
        num_tokens_auctioned = token.balanceOf(address(this));
        token_multiplier = 10**token.decimals();
        stage = Stage.AuctionSetUp;
        emit Setup(_token_address);
    }
}",42.50658059120178,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    enum Stage {
        NotStarted,
        AuctionSetUp,
        Bidding,
        Ended
    }

    IERC20 public token;
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;
    Stage public stage;

    event Setup(address indexed tokenAddress);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        require(msg.sender != address(0), ""Contract address cannot be zero"");
        token = IERC20(""MyToken""); // Use a placeholder value for ERC20 mapping(address => uint256) public balanceOf;

 constructor
        num_tokens_auctioned = 1; // Set to a fixed, safe value
        token_multiplier = 10**18; // Set to a fixed, safe value
        stage = Stage.AuctionSetUp;
        emit Setup(address(this)); // Use the contract address instead of _tokenAddress
    }

    function setup(address _token_address) public {
        require(_token_address != address(0), ""Token address cannot be zero"");
        token = IERC20(_token_address);
        num_tokens_auctioned = token.balanceOf(address(this));
        token_multiplier = 10**token.decimals();
        stage = Stage.AuctionSetUp;
        emit Setup(_token_address);
    }
}"
2209,"match orders with admins involved , only admin","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Matcher {
    using SafeMath for uint256;

    address public admin;
    mapping(uint256 => address) public userId2Address;
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;

    constructor() {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    function matchByAdmin_TwH36(uint256[] memory inputs) external onlyAdmin {
        uint256 data = inputs[3];
        address user = userId2Address[data & USER_MASK];
        require(data >> 224 > userNonce[user]);
        (address token, bool isBuy) = decodeOrderTokenAndIsBuy(data);
        bytes32 orderHash = keccak256(this, inputs[0], inputs[1], inputs[2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
        require(verify(orderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[4]), bytes32(inputs[5])));
        uint256 tokenExecute = isBuy ? inputs[1] : inputs[0];
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        require(tokenExecute != 0);
        uint256 etherExecute = 0;
        isBuy = !isBuy;
        for (uint256 i = 6; i < inputs.length; i += 6) {
            require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));
            data = inputs[i + 3];
            user = userId2Address[data & USER_MASK];
            require(data >> 224 > userNonce[user]);
            bytes32 makerOrderHash = keccak256(this, inputs[i], inputs[i + 1], inputs[i + 2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
            require(verify(makerOrderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 4]), bytes32(inputs[i + 5])));
            (tokenExecute, etherExecute) = internalTrade(inputs[i], inputs[i + 1], inputs[i + 2], data, tokenExecute, etherExecute, isBuy, token, 0, makerOrderHash);
        }
        isBuy = !isBuy;
        tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        processTakerOrder(inputs[2], inputs[3], tokenExecute, etherExecute, isBuy, token, 0, orderHash);
    }
}",matchByAdmin_TwH36,"[{'function': 'matchByAdmin_TwH36', 'complexity': 3}, {'function': 'processTakerOrder', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""matchByAdmin_TwH36"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""inputs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint160""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""nonce"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""nonce""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userNonce""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}}, {""type"": ""stringLiteral"", ""value"": ""Nonce too low""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""orderHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""inputs""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountToExecute"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amountToExecute""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Zero amount to execute""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""processTakerOrder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""orderHash""}, {""type"": ""Identifier"", ""name"": ""amountToExecute""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",264.0,0.3394142298312125,0.0624653205969798,"pragma solidity ^0.8.0;

contract MyContract {
    // ... other contract code ...

    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;
    // ... other state variables ...

    function matchByAdmin_TwH36(uint256[] memory inputs) public {
        // 1. Extract data
        address user = address(uint160(inputs[0]));
        uint256 nonce = inputs[1];
        // ... extract other data ...

        // 2. Check nonce
        require(nonce > userNonce[user], ""Nonce too low"");

        // 3. Decode token and buy/sell
        // ... decoding logic ...

        // 4. Generate order hash
        bytes32 orderHash = keccak256(abi.encodePacked(inputs));

        // 5. Verify signature
        // ... verification logic using a verify function ...

        // 6. Calculate amount to execute
        uint256 amountToExecute = 0; // ... calculation logic ...

        // 7. Ensure non-zero amount
        require(amountToExecute > 0, ""Zero amount to execute"");

        // 8. Iterate and match
        for (uint256 i = 2; i < inputs.length; i++) {
            // ... extract maker order data ...
            // ... price comparison ...
            // ... update maker nonce ...
            // ... verify maker signature ...
            // ... generate maker order hash ...
            // ... internalTrade execution ...
        }

        // 9. Process taker order
        processTakerOrder(user, orderHash, amountToExecute);
    }

    function processTakerOrder(address user, bytes32 orderHash, uint256 amount) internal {
        userNonce[user]++;
        orderFills[orderHash] += amount;
        // ... other processing logic ...
    }

    // ... other contract functions, including internalTrade and verify ...
}",44.28047728538513,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint256 i = 0; i < 10; i++) {
            address addr = address(uint160(i + 1));
            userNonce[addr] = 1; // uint256: Set to 1 (never 0)
        }
        for (uint256 j = 0; j < 3; j++) {
            bytes32 hash = keccak256(abi.encodePacked(""init"", j));
            orderFills[hash] = 0; // uint256: Set to 1 (never 0)
        }
    }

    function matchByAdmin_TwH36(uint256[] memory inputs) public {
        address user = address(uint160(inputs[0]));
        uint256 nonce = inputs[1];
        require(nonce > userNonce[user], ""Nonce too low"");
        bytes32 orderHash = keccak256(abi.encodePacked(inputs));
        require(amountToExecute > 0, ""Zero amount to execute"");
        for (uint256 i = 2; i < inputs.length; i++) {
            // ... extract maker order data ...
            // ... price comparison ...
            // ... update maker nonce ...
            // ... verify maker signature ...
            // ... generate maker order hash ...
            // ... internalTrade execution ...
        }
        processTakerOrder(user, orderHash, amountToExecute);
    }

    function processTakerOrder(address user, bytes32 orderHash, uint256 amount) internal {
        userNonce[user]++;
        orderFills[orderHash] += amount;
        // ... other processing logic ...
    }
}"
5033,Returns the total number of Properties currently in existence .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PropertyRegistry is Ownable {
    using SafeMath for uint256;

    struct Property {
        // Define property structure here
    }

    Property[] public properties;

    function totalSupply() public view returns (uint) {
        return properties.length;
    }
}",totalSupply,"[{'function': 'totalSupply', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""properties""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.975889519565749,0.7825422900366437,"pragma solidity ^0.8.0;

contract PropertyRegistry {
    struct Property {
        // Define your property structure here
    }

    Property[] public properties;

    function totalSupply() public view returns (uint256) {
        return properties.length;
    }
}",41.84509992599487,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PropertyRegistry is Ownable {
    struct Property {
        // Define your property structure here
    }

    Property[] public properties;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        properties = [Property({ /* initialize each property */ })];
    }

    function totalSupply() public view returns (uint256) {
        return properties.length;
    }
}"
2439,Grant ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionManager {
    using SafeMath for uint256;

    struct Permission {
        address entity;
        bytes32 role;
        bytes32 paramsHash;
    }

    mapping(address => mapping(address => mapping(bytes32 => Permission))) private permissions;
    bytes32 public constant EMPTY_PARAM_HASH = keccak256("""");

    address public owner;

    modifier onlyPermissionManager(address _app, bytes32 _role) {
        require(permissions[msg.sender][_app][_role].entity != address(0), ""Only permission manager can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] memory _params) public onlyPermissionManager(_app, _role) {
        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal pure returns (bytes32) {
        require(_params.length > 0, ""Params array must not be empty"");
        return keccak256(abi.encodePacked(_params));
    }

    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {
        permissions[_entity][_app][_role] = Permission({
            entity: _entity,
            role: _role,
            paramsHash: _paramsHash
        });
    }
}",grantPermission,"[{'function': 'grantPermission', 'complexity': 0}, {'function': '_saveParams', 'complexity': 0}, {'function': '_setPermission', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantPermission"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_entity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_app"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_params"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""paramsHash"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_params""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paramsHash""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_saveParams""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_params""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paramsHash""}, ""right"": {""type"": ""Identifier"", ""name"": ""EMPTY_PARAM_HASH""}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setPermission""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_entity""}, {""type"": ""Identifier"", ""name"": ""_app""}, {""type"": ""Identifier"", ""name"": ""_role""}, {""type"": ""Identifier"", ""name"": ""paramsHash""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyPermissionManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.7276786413529516,0.2472165142116718,"pragma solidity ^0.8.0;

contract PermissionManager {

    bytes32 public constant EMPTY_PARAM_HASH = keccak256("""");

    modifier onlyPermissionManager() {
        // Add logic to check if the caller is a permission manager
        require(msg.sender == address(0x123), ""Not a permission manager"");
        _;
    }

    function grantPermission(
        address _entity,
        address _app,
        bytes32 _role,
        uint256[] memory _params
    ) public onlyPermissionManager {
        bytes32 paramsHash;
        if (_params.length > 0) {
            paramsHash = _saveParams(_params);
        } else {
            paramsHash = EMPTY_PARAM_HASH;
        }
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal returns (bytes32) {
        // Add logic to save parameters and return the hash
        return keccak256(abi.encodePacked(_params));
    }

    function _setPermission(
        address _entity,
        address _app,
        bytes32 _role,
        bytes32 _paramsHash
    ) internal {
        // Add logic to set the permission
    }
}",43.31174874305725,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PermissionManager is Ownable {
    bytes32 public constant EMPTY_PARAM_HASH = keccak256("""");

    modifier onlyPermissionManager() {
        require(msg.sender == address(0x123), ""Not a permission manager"");
        _;
    }

    function grantPermission(
        address _entity,
        address _app,
        bytes32 _role,
        uint256[] memory _params
    ) public onlyPermissionManager {
        bytes32 paramsHash;
        if (_params.length > 0) {
            paramsHash = _saveParams(_params);
        } else {
            paramsHash = EMPTY_PARAM_HASH;
        }
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal returns (bytes32) {
        return keccak256(abi.encodePacked(_params));
    }

    function _setPermission(
        address _entity,
        address _app,
        bytes32 _role,
        bytes32 _paramsHash
    ) internal {
        // Add logic to set the permission
    }
}"
6671,Offer ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy for day ` aday ` at a price ` ( aprice / 1.0e3 ) .toFixed ( 3 ) + ' ct/kWh ' ` above market price for a date given as day ` aday ` whilst asserting that the current date and time in nanoseconds since 1970 is ` atimestamp ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface BidInterface {
    struct Bid {
        address producer;
        uint32 day;
        uint32 price;
        uint64 energy;
        uint64 timestamp;
    }
}

abstract contract EnergyMarket is Ownable, BidInterface {
    using SafeMath for uint256;

    uint public kWh = 1000; // Example value for kWh
    Bid[] public bids;
    mapping(address => mapping(uint32 => uint)) public bidsIndex;

    event BidMade(address indexed producer, uint32 day, uint price, uint energy);
    event BidRevoked(address indexed producer, uint32 day, uint price, uint energy);

    modifier onlyRegisteredProducers() {
        require(isProducerRegistered(msg.sender), ""Only registered producers can call this function"");
        _;
    }

    function offer_energy(uint32 aday, uint32 aprice, uint64 aenergy, uint64 atimestamp) onlyRegisteredProducers external {
        require(aenergy >= kWh);
        uint idx = bidsIndex[msg.sender][aday];
        if ((bids.length > idx) && (bids[idx].producer == msg.sender) && (bids[idx].day == aday)) {
            require(atimestamp > bids[idx].timestamp);
            emit BidRevoked(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
        }
        idx = bids.length;
        bidsIndex[msg.sender][aday] = idx;
        bids.push(Bid({producer: msg.sender, day: aday, price: aprice, energy: aenergy, timestamp: atimestamp}));
        emit BidMade(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
    }

    function isProducerRegistered(address producer) internal view returns (bool) {
        // Implement your logic to check if the producer is registered
        return true; // Placeholder for actual implementation
    }
}",offerEnergy,"[{'function': 'offerEnergy', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""offerEnergy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aday"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aprice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aenergy"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""atimestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""aenergy""}, ""right"": {""type"": ""Identifier"", ""name"": ""minimumEnergy""}}, {""type"": ""stringLiteral"", ""value"": ""Energy amount must be greater than or equal to the minimum allowed.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bidsIndex""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""aday""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""atimestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""New timestamp must be later than the existing one.""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BidRevoked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""aday""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bidsIndex""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""aday""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Bid""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""aday""}, {""type"": ""Identifier"", ""name"": ""aprice""}, {""type"": ""Identifier"", ""name"": ""aenergy""}, {""type"": ""Identifier"", ""name"": ""atimestamp""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bidsIndex""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""aday""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""length""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BidMade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""aday""}, {""type"": ""Identifier"", ""name"": ""aprice""}, {""type"": ""Identifier"", ""name"": ""aenergy""}, {""type"": ""Identifier"", ""name"": ""atimestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.7771322500678349,0.2118269045077586,"pragma solidity ^0.8.0;

contract EnergyBidding {

    struct Bid {
        address producer;
        uint256 day;
        uint256 price;
        uint256 energy;
        uint256 timestamp;
    }

    uint256 public minimumEnergy = 1; // Minimum energy in kWh
    Bid[] public bids;
    mapping(address => mapping(uint256 => uint256)) public bidsIndex;

    event BidRevoked(address indexed producer, uint256 indexed day);
    event BidMade(address indexed producer, uint256 indexed day, uint256 price, uint256 energy, uint256 timestamp);

    function offerEnergy(uint256 aday, uint256 aprice, uint256 aenergy, uint256 atimestamp) public {
        require(aenergy >= minimumEnergy, ""Energy amount must be greater than or equal to the minimum allowed."");

        uint256 index = bidsIndex[msg.sender][aday];
        if (index > 0) {
            require(atimestamp > bids[index - 1].timestamp, ""New timestamp must be later than the existing one."");
            emit BidRevoked(msg.sender, aday);
            bids[index -1] = bids[bids.length -1];
            bids.pop();
            bidsIndex[msg.sender][aday] = 0;

        }

        bids.push(Bid(msg.sender, aday, aprice, aenergy, atimestamp));
        bidsIndex[msg.sender][aday] = bids.length;
        emit BidMade(msg.sender, aday, aprice, aenergy, atimestamp);
    }
}",44.12023162841797,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EnergyBidding is Ownable {
    struct Bid {
        address producer;
        uint256 day;
        uint256 price;
        uint256 energy;
        uint256 timestamp;
    }

    uint256 public minimumEnergy = 1; // Minimum energy in kWh
    Bid[] public bids;
    mapping(address => mapping(uint256 => uint256)) public bidsIndex;

    event BidRevoked(address indexed producer, uint256 indexed day);
    event BidMade(address indexed producer, uint256 indexed day, uint256 price, uint256 energy, uint256 timestamp);

    constructor() Ownable(msg.sender) {
        minimumEnergy = 1; // Initialize to safe non-corner-case value
        bidsIndex = mapping(address => mapping(uint256 => uint256))({}); // Initialize empty mapping
    }

    function offerEnergy(uint256 aday, uint256 aprice, uint256 aenergy, uint256 atimestamp) public {
        require(aenergy >= minimumEnergy, ""Energy amount must be greater than or equal to the minimum allowed."");

        uint256 index = bidsIndex[msg.sender][aday];
        if (index > 0) {
            require(atimestamp > bids[index - 1].timestamp, ""New timestamp must be later than the existing one."");
            emit BidRevoked(msg.sender, aday);
            bids[index - 1] = bids[bids.length - 1];
            bids.pop();
            bidsIndex[msg.sender][aday] = 0;
        }

        bids.push(Bid(msg.sender, aday, aprice, aenergy, atimestamp));
        bidsIndex[msg.sender][aday] = bids.length;
        emit BidMade(msg.sender, aday, aprice, aenergy, atimestamp);
    }
}"
4083,Calculates unpaid rewards of a given address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RewardCalculator {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] rewardsCumulative;
        mapping(address => uint) addressToPaidRewardIndex;
    }

    uint constant PIXEL_COUNT = 100; // Assuming PIXEL_COUNT is defined somewhere in your contract

    mapping(uint32 => FeeHistory) private feeHistories;

    function _getFeeHistory(uint32 _canvasId) internal view returns (FeeHistory storage) {
        return feeHistories[_canvasId];
    }

    function getPaintedPixelsCountByAddress(address _address, uint32 _canvasId) public view returns (uint);

    function calculateRewardToWithdraw(uint32 _canvasId, address _address) public view stateOwned(_canvasId) returns (uint reward, uint pixelsOwned) {
        FeeHistory storage _history = _getFeeHistory(_canvasId);
        uint _lastIndex = _history.rewardsCumulative.length - 1;
        uint _lastPaidIndex = _history.addressToPaidRewardIndex[_address];
        uint _pixelsOwned = getPaintedPixelsCountByAddress(_address, _canvasId);
        if (_lastIndex < 0) {
            return (0, _pixelsOwned);
        }
        uint _rewardsSum = _history.rewardsCumulative[_lastIndex];
        uint _lastWithdrawn = _history.rewardsCumulative[_lastPaidIndex];
        uint _toWithdraw = ((_rewardsSum - _lastWithdrawn) / PIXEL_COUNT) * _pixelsOwned;
        return (_toWithdraw, _pixelsOwned);
    }
}",calculateReward,"[{'function': 'calculateReward', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""pixelsOwned"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""FeeHistory""}, ""name"": ""history"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_history""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""history""}, ""memberName"": ""rewardsCumulative""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastCumulativeReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""history""}, ""memberName"": ""rewardsCumulative""}, ""index"": {""type"": ""Identifier"", ""name"": ""lastIndex""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastPaidIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_lastPaidIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastPaidReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""lastPaidIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""history""}, ""memberName"": ""rewardsCumulative""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""lastPaidIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""rewardPerPixel"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""lastCumulativeReward""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastPaidReward""}}], ""isArray"": False}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""history""}, ""memberName"": ""totalPixels""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""pixelsOwned""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""reward""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""rewardPerPixel""}, ""right"": {""type"": ""Identifier"", ""name"": ""pixelsOwned""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",34.0,0.7730682278973439,0.2904063270401227,"pragma solidity ^0.8.0;

contract MyContract {
    struct FeeHistory {
        uint[] rewardsCumulative;
        uint totalPixels;
    }

    mapping(uint => FeeHistory) internal _history;
    mapping(uint => mapping(address => uint)) internal _lastPaidIndex;
    mapping(uint => mapping(address => uint)) internal _pixelsOwned;


    function calculateReward(uint _canvasId, address _address) public view returns (uint reward, uint pixelsOwned) {
        FeeHistory storage history = _history[_canvasId];
        uint lastIndex = history.rewardsCumulative.length - 1;

        if (lastIndex < 0) {
            return (0, _pixelsOwned[_canvasId][_address]);
        }

        uint lastCumulativeReward = history.rewardsCumulative[lastIndex];
        uint lastPaidIndex = _lastPaidIndex[_canvasId][_address];
        uint lastPaidReward = lastPaidIndex > 0 ? history.rewardsCumulative[lastPaidIndex -1] : 0;

        uint rewardPerPixel = (lastCumulativeReward - lastPaidReward) / history.totalPixels;
        pixelsOwned = _pixelsOwned[_canvasId][_address];
        reward = rewardPerPixel * pixelsOwned;
    }
}",43.08956050872803,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct FeeHistory {
        uint[] rewardsCumulative;
        uint totalPixels;
    }

    mapping(uint => FeeHistory) internal _history;
    mapping(uint => mapping(address => uint)) internal _lastPaidIndex;
    mapping(uint => mapping(address => uint)) internal _pixelsOwned;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 0; i < 3; i++) {
            if (i == 0) {
                _history[i] = FeeHistory({rewardsCumulative: [1], totalPixels: 1});
            } else {
                _history[i] = FeeHistory({rewardsCumulative: new uint[](0), totalPixels: 0});
            }
        }
        for (uint i = 0; i < 3; i++) {
            for (uint j = 0; j < 3; j++) {
                _lastPaidIndex[i][address(uint160(uint256(keccak256(abi.encodePacked(j, i)))))] = 0;
                _pixelsOwned[i][address(uint160(uint256(keccak256(abi.encodePacked(j, i)))))] = 1;
            }
        }
    }

    function calculateReward(uint _canvasId, address _address) public view returns (uint reward, uint pixelsOwned) {
        FeeHistory storage history = _history[_canvasId];
        uint lastIndex = history.rewardsCumulative.length - 1;

        if (lastIndex < 0) {
            return (0, _pixelsOwned[_canvasId][_address]);
        }

        uint lastCumulativeReward = history.rewardsCumulative[lastIndex];
        uint lastPaidIndex = _lastPaidIndex[_canvasId][_address];
        uint lastPaidReward = lastPaidIndex > 0 ? history.rewardsCumulative[lastPaidIndex -1] : 0;

        uint rewardPerPixel = (lastCumulativeReward - lastPaidReward) / history.totalPixels;
        pixelsOwned = _pixelsOwned[_canvasId][_address];
        reward = rewardPerPixel * pixelsOwned;
    }
}"
6519,ERC20 transfer function overridden to disable transfers when paused,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    modifier notPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _value) public notPaused {
        super.transfer(_to, _value);
    }
}",transfer,"[{'function': 'transfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""notPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.8636102753886762,0.597713031281549,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/Context.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";


contract MyToken is Context, IERC20, Pausable {

    function transfer(address _to, uint256 _value) public virtual override notPaused returns (bool) {
        return super.transfer(_to, _value);
    }

    // ... other functions ...
}",42.32429838180542,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/Context.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Context, IERC20, Pausable, Ownable {
    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        _name = ""MyToken"";
        _symbol = ""TKN"";
        _totalSupply = 1 * 10 ** uint256(decimals());
        _balances[msg.sender] = _totalSupply;
    }

    function transfer(address _to, uint256 _value) public virtual override notPaused returns (bool) {
        return super.transfer(_to, _value);
    }

    // ... other functions ...
}"
5444,"Set a new campaign owner Based on the Campaign id , update the owner of the refered campaign .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CampaignManager is Ownable {
    using SafeMath for uint256;

    struct Campaign {
        address owner;
        // other campaign details...
    }

    mapping(bytes32 => Campaign) public campaigns;

    event CampaignUpdated(bytes32 indexed bidId, address newOwner);

    modifier onlyIfCampaignExists(bytes32 bidId) {
        require(campaigns[bidId].owner != address(0), ""Campaign does not exist"");
        _;
    }

    modifier onlyIfWhitelisted(address user) {
        // Assuming whitelist is managed elsewhere, implement as needed.
        require(isWhitelisted(user), ""User is not whitelisted"");
        _;
    }

    function setCampaignOwnerById(bytes32 bidId, address newOwner) public onlyIfCampaignExists(bidId) onlyIfWhitelisted(newOwner) {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }

    function isWhitelisted(address user) internal view returns (bool) {
        // Implement whitelist logic here.
        return true; // Placeholder for actual implementation.
    }
}",updateCampaignOwner,"[{'function': 'updateCampaignOwner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateCampaignOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}, ""memberName"": ""setOwner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwner""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""bidId""}, {""type"": ""Identifier"", ""name"": ""newOwner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyIfCampaignExists"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""bidId""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlyIfWhitelisted"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.9364902698248074,0.7001293151315053,"pragma solidity ^0.8.0;

contract CampaignManager {

    // Define Campaign struct and other necessary structs/mappings here...

    modifier onlyIfCampaignExists(bytes32 _bidId) {
        require(campaigns[_bidId].exists, ""Campaign does not exist"");
        _;
    }

    modifier onlyIfWhitelisted() {
        require(whitelisted[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    event CampaignUpdated(bytes32 indexed bidId, address indexed newOwner);

    function updateCampaignOwner(bytes32 bidId, address newOwner) public onlyIfCampaignExists(bidId) onlyIfWhitelisted {
        campaigns[bidId].setOwner(newOwner);
        emit CampaignUpdated(bidId, newOwner);
    }

    // ... rest of the contract ...
}",42.572481632232666,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CampaignManager {
    struct Campaign {
        bool exists;
        address owner;
    }

    mapping(bytes32 => Campaign) public campaigns;
    mapping(address => bool) public whitelisted;

    modifier onlyIfCampaignExists(bytes32 _bidId) {
        require(campaigns[_bidId].exists, ""Campaign does not exist"");
        _;
    }

    modifier onlyIfWhitelisted() {
        require(whitelisted[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    event CampaignUpdated(bytes32 indexed bidId, address indexed newOwner);

    constructor() {
        // Initialize all state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            campaigns[keccak256(abi.encodePacked(""campaign"", i))] = Campaign({exists: true, owner: address(uint160(i + 1e18))});
        }
        whitelisted[msg.sender] = true; // Assuming the deployer is initially whitelisted
    }

    function updateCampaignOwner(bytes32 bidId, address newOwner) public onlyIfCampaignExists(bidId) onlyIfWhitelisted {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }
}"
2581,Checks if the makeOrder price is reasonable and not manipulative,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TakePermitWrapper {
    using SafeMath for uint256;

    function isTakePermitted(uint orderPrice, uint referencePrice, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (bool) {
        return true;
    }
}",isTakeOrderPermitted,"[{'function': 'isTakeOrderPermitted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isTakeOrderPermitted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""orderPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""referencePrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sellAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""buyAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""sellQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""buyQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9812888790244896,0.9400357170187866,"pragma solidity ^0.8.0;

contract TakeOrderChecker {

    function isTakeOrderPermitted(uint orderPrice, uint referencePrice, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (bool) {
        return true;
    }
}",41.54938101768494,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TakeOrderChecker is Ownable {
    uint public constant MIN_PRICE = 1;
    address public immutable SELL_ASSET_ADDRESS = address(uint160(uint256(keccak256('sellAsset1'))));
    address public immutable BUY_ASSET_ADDRESS = address(uint160(uint256(keccak256('buyAsset1'))));

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already set in the constructor or have fixed values.
    }

    function isTakeOrderPermitted(uint orderPrice, uint referencePrice, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (bool) {
        require(orderPrice >= MIN_PRICE, ""Order price must be at least 1"");
        return true;
    }
}"
4669,Transfer a LAND owned by an Estate to a new owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LandRegistry is Ownable {
    using SafeMath for uint256;

    struct Estate {
        address owner;
        mapping(uint256 => address) lands;
    }

    mapping(uint256 => Estate) public estates;

    modifier canTransfer(uint256 estateId) {
        require(msg.sender == estates[estateId].owner, ""Not the owner"");
        _;
    }

    function _transferLand(uint256 estateId, uint256 landId, address destinatary) internal returns (bool) {
        require(destinatary != address(0), ""Invalid recipient"");
        estates[estateId].lands[landId] = destinatary;
        return true;
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) external canTransfer(estateId) {
        _transferLand(estateId, landId, destinatary);
    }
}",_transferLand,"[{'function': '_transferLand', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transferLand"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_estateId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_landId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_destinatary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""previousOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""estates""}, ""index"": {""type"": ""Identifier"", ""name"": ""_estateId""}}, ""memberName"": ""landOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_landId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""estates""}, ""index"": {""type"": ""Identifier"", ""name"": ""_estateId""}}, ""memberName"": ""landOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_landId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_destinatary""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LandTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_estateId""}, {""type"": ""Identifier"", ""name"": ""_landId""}, {""type"": ""Identifier"", ""name"": ""previousOwner""}, {""type"": ""Identifier"", ""name"": ""_destinatary""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.7457277005408096,0.1123062436780388,"pragma solidity ^0.8.0;

contract LandRegistry {

    // Define necessary structs and state variables here...  (Example below)
    struct Estate {
        mapping(uint256 => address) landOwners;
    }
    mapping(uint256 => Estate) estates;

    modifier canTransfer(uint256 _estateId) {
        // Add logic to check if the caller is authorized to transfer land in the given estate.
        require(msg.sender == estates[_estateId].landOwners[0], ""Unauthorized""); //Example: Only the original owner can transfer.  Replace with your actual logic.
        _;
    }

    event LandTransferred(uint256 estateId, uint256 landId, address previousOwner, address newOwner);

    function _transferLand(uint256 _estateId, uint256 _landId, address _destinatary) internal {
        address previousOwner = estates[_estateId].landOwners[_landId];
        estates[_estateId].landOwners[_landId] = _destinatary;
        emit LandTransferred(_estateId, _landId, previousOwner, _destinatary);
    }

    external function transferLand(uint256 estateId, uint256 landId, address destinatary) canTransfer(estateId) {
        _transferLand(estateId, landId, destinatary);
    }
}",43.38336944580078,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LandRegistry is Ownable {
    struct Estate {
        mapping(uint256 => address) landOwners;
    }
    mapping(uint256 => Estate) estates;

    modifier canTransfer(uint256 _estateId) {
        require(msg.sender == estates[_estateId].landOwners[0], ""Unauthorized"");
        _;
    }

    event LandTransferred(uint256 estateId, uint256 landId, address previousOwner, address newOwner);

    function _transferLand(uint256 _estateId, uint256 _landId, address _destinatary) internal {
        address previousOwner = estates[_estateId].landOwners[_landId];
        estates[_estateId].landOwners[_landId] = _destinatary;
        emit LandTransferred(_estateId, _landId, previousOwner, _destinatary);
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) public canTransfer(estateId) {
        _transferLand(estateId, landId, destinatary);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialEstateId = 1;
        estates[initialEstateId] = Estate({landOwners: new mapping(uint256 => address)(0x1111111111111111111111111111111111111111)});
    }
}"
689,Set both ethPreAmount and mtdPreAmount at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) external onlyOwner {
        require(mtdPreAmountInWei > 0);
        require(ethPreAmountInWei > 0);
        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices logic
    }
}",setPreAmounts,"[{'function': 'setPreAmounts', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreAmounts"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mtdPreAmountInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ethPreAmountInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mtdPreAmountInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""MTD pre-amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""ethPreAmountInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ETH pre-amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""mtdPreAmountInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""ethPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""ethPreAmountInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.9748363238260792,0.5761036007036797,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) public onlyOwner {
        require(mtdPreAmountInWei > 0, ""MTD pre-amount must be greater than zero"");
        require(ethPreAmountInWei > 0, ""ETH pre-amount must be greater than zero"");
        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;
        updatePrices();
    }

    function updatePrices() internal virtual {
        //Implementation for updating prices
    }

    function owner() public view returns (address) {
        return owner;
    }
}",42.89714694023132,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        mtdPreAmount = 1;
        ethPreAmount = 2;
    }

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) public onlyOwner {
        require(mtdPreAmountInWei > 0, ""MTD pre-amount must be greater than zero"");
        require(ethPreAmountInWei > 0, ""ETH pre-amount must be greater than zero"");
        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;
        updatePrices();
    }

    function updatePrices() internal virtual {
        //Implementation for updating prices
    }
}"
4185,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract Collectible is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public collectibleIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender;
    }
}",approve,"[{'function': '_owns', 'complexity': 0}, {'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owns""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller must own the collectible""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectibleIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9907758717182872,0.80846720196545,"pragma solidity ^0.8.0;

contract Collectible {

    mapping (uint256 => address) public collectibleIndexToOwner;
    mapping (uint256 => address) public collectibleIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return collectibleIndexToOwner[_tokenId] == _owner;
    }

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId), ""Caller must own the collectible"");
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }
}",42.48791265487671,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Collectible is Ownable {
    mapping (uint256 => address) public collectibleIndexToOwner;
    mapping (uint256 => address) public collectibleIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return collectibleIndexToOwner[_tokenId] == _owner;
    }

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId), ""Caller must own the collectible"");
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialTokenId = 1;
        collectibleIndexToOwner[initialTokenId] = msg.sender;
        collectibleIndexToApproved[initialTokenId] = address(0); // No approved address initially
    }
}"
6513,"Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface tokenltkrecipiente {
    function approve(address _spender, uint256 _value) external returns (bool success);
    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        tokenltkrecipiente spender = tokenltkrecipiente(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    function approve(address _spender, uint256 _value) internal returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Value must be greater than zero"");
        return tokenltkrecipiente(_spender).approve(_spender, _value);
    }
}",approveAndCall,"[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_extraData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApproveAndCallReceiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}, ""memberName"": ""receiveApproval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_extraData""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.9335970021405606,0.7548912239375398,"pragma solidity ^0.8.0;

interface ApproveAndCallReceiver {
    function receiveApproval(address from, uint256 value, address token, bytes memory extraData) external;
}

contract MyToken {
    function approve(address spender, uint256 value) public virtual returns (bool) {
        //Implementation for approve function.  This is a placeholder.
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _value));
        ApproveAndCallReceiver(_spender).receiveApproval(msg.sender, _value, address(this), _extraData);
        return true;
    }
}",42.57940745353699,"pragma solidity ^0.8.0;

interface ApproveAndCallReceiver {
    function receiveApproval(address from, uint256 value, address token, bytes memory extraData) external;
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        owner = msg.sender;
        balances[owner] = 1 ether; // Set to 1 ether as a placeholder for token balance
        allowed[owner][address(this)] = 1 ether; // Set approval limit
    }

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address spender, uint256 value) public virtual override returns (bool) {
        //Implementation for approve function.  This is a placeholder.
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _value));
        ApproveAndCallReceiver(_spender).receiveApproval(msg.sender, _value, address(this), _extraData);
        return true;
    }
}"
5584,Function that allows synth contract to delegate sending fee to the fee Pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISynth {
    function burn(address from, uint amount) external;
    function issue(address to, uint amount) external;
    function triggerTokenFallbackIfNeeded(address from, address to, uint amount) external;
}

interface IFeePool {
    function FEE_ADDRESS() external view returns (address);
    function amountReceivedFromExchange(uint amount) external pure returns (uint);
}

abstract contract ExchangeWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes4 => ISynth) public synths;
    IFeePool public feePool;
    address public proxy;

    constructor(address _feePool, address _proxy) {
        feePool = IFeePool(_feePool);
        proxy = _proxy;
    }

    function _internalExchange(
        address from,
        bytes4 sourceCurrencyKey,
        uint sourceAmount,
        bytes4 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal returns (bool) {
        require(destinationAddress != address(0), ""Zero destination"");
        require(destinationAddress != address(this), ""Synthetix is invalid destination"");
        require(destinationAddress != proxy, ""Proxy is invalid destination"");
        synths[sourceCurrencyKey].burn(from, sourceAmount);
        uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);
        uint amountReceived = destinationAmount;
        uint fee = 0;
        if (chargeFee) {
            amountReceived = feePool.amountReceivedFromExchange(destinationAmount);
            fee = destinationAmount.sub(amountReceived);
        }
        synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);
        if (fee > 0) {
            uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, ""XDR"");
            synths[""XDR""].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);
        }
        synths[destinationCurrencyKey].triggerTokenFallbackIfNeeded(from, destinationAddress, amountReceived);
        return true;
    }

    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey) internal view returns (uint) {
        // Implement the logic to calculate effective value based on currency keys and amounts
        // This is a placeholder for actual implementation details
        return sourceAmount;
    }
}",exchange,"[{'function': 'exchange', 'complexity': 0}, {'function': 'calculateExchangeAmount', 'complexity': 0}, {'function': 'calculateFee', 'complexity': 0}]",3.0,{},91.0,0.6998758904635254,0.2670734780443449,"pragma solidity ^0.8.0;

// Assume necessary contracts and interfaces are defined elsewhere, e.g., Synth, FeePool

function exchange(
    address from,
    bytes32 sourceCurrencyKey,
    uint256 sourceAmount,
    bytes32 destinationCurrencyKey,
    address destinationAddress,
    bool chargeFee
) internal {
    require(destinationAddress != address(0), ""Destination address cannot be zero"");

    Synth(sourceCurrencyKey).burn(from, sourceAmount);

    uint256 amountReceived = calculateExchangeAmount(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);

    if (chargeFee) {
        uint256 fee = calculateFee(amountReceived);
        amountReceived -= fee;
        FeePool().appendFee(fee); // Assuming FeePool contract has appendFee function
    }

    Synth(destinationCurrencyKey).issue(destinationAddress, amountReceived);
}


function calculateExchangeAmount(bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey) internal view returns (uint256) {
    //Implementation for exchange rate calculation.  Replace with actual logic.
    //This is a placeholder and needs to be replaced with the actual exchange rate calculation.
    return sourceAmount;
}

function calculateFee(uint256 amount) internal pure returns (uint256) {
    //Implementation for fee calculation. Replace with actual logic.
    //This is a placeholder and needs to be replaced with the actual fee calculation.  Example: 1% fee
    return amount / 100;
}",43.89086055755615,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Exchange is Ownable {
    function exchange(
        address from,
        bytes32 sourceCurrencyKey,
        uint256 sourceAmount,
        bytes32 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal {
        require(destinationAddress != address(0), ""Destination address cannot be zero"");

        Synth(sourceCurrencyKey).burn(from, sourceAmount);

        uint256 amountReceived = calculateExchangeAmount(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);

        if (chargeFee) {
            uint256 fee = calculateFee(amountReceived);
            amountReceived -= fee;
            FeePool().appendFee(fee); // Assuming FeePool contract has appendFee function
        }

        Synth(destinationCurrencyKey).issue(destinationAddress, amountReceived);
    }

    function calculateExchangeAmount(bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey) internal view returns (uint256) {
        //Implementation for exchange rate calculation.  Replace with actual logic.
        //This is a placeholder and needs to be replaced with the actual exchange rate calculation.
        return sourceAmount;
    }

    function calculateFee(uint256 amount) internal pure returns (uint256) {
        //Implementation for fee calculation. Replace with actual logic.
        //This is a placeholder and needs to be replaced with the actual fee calculation.  Example: 1% fee
        return amount / 100;
    }
}"
4746,"Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onApprove(address _owner, address _spender, uint256 _amount) public returns (bool) {
        if (isRegistered(_owner)) {
            return true;
        } else {
            return false;
        }
    }

    function isRegistered(address _owner) internal view returns (bool) {
        // Implement the logic to check if the owner is registered
        revert(""Not implemented"");
    }
}",isRegistered,"[{'function': 'isRegistered', 'complexity': 0}, {'function': 'onApprove', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRegistered"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.6472037623067892,0.1445241974173827,"pragma solidity ^0.8.0;

contract MyContract {

    function isRegistered(address _address) internal view returns (bool) {
        //Implementation for isRegistered function.  Replace this with your actual logic.
        return true; // Replace with your actual registration check
    }

    function onApprove(address _owner, address _spender, uint256 _amount) public view returns (bool) {
        return isRegistered(_owner);
    }
}",41.96818947792053,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isRegistered(address _address) internal view returns (bool) {
        //Implementation for isRegistered function.  Replace this with your actual logic.
        return true; // Replace with your actual registration check
    }

    function onApprove(address _owner, address _spender, uint256 _amount) public view returns (bool) {
        return isRegistered(_owner);
    }
}"
5679,Sets the new dividend percentage for buyouts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContract {
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public buyoutDividendPercentage;

    constructor(uint256 initialBuyoutDividendPercentage) {
        require(2000 <= initialBuyoutDividendPercentage && initialBuyoutDividendPercentage <= 12500);
        buyoutDividendPercentage = initialBuyoutDividendPercentage;
    }
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
    require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500);
    buyoutDividendPercentage = _buyoutDividendPercentage;
}
}",setBuyoutDividendPercentage,"[{'function': 'setBuyoutDividendPercentage', 'complexity': 2}, {'function': 'setCFO', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBuyoutDividendPercentage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_buyoutDividendPercentage"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""NumberLiteral"", ""number"": ""2000"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyoutDividendPercentage""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_buyoutDividendPercentage""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""12500"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Buyout dividend percentage must be between 2000 and 12500""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyoutDividendPercentage""}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyoutDividendPercentage""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCFO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.983564351755565,0.6428475211103191,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public buyoutDividendPercentage;
    address public cfo;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only CFO can call this function"");
        _;
    }

    constructor(address _cfo) {
        cfo = _cfo;
    }

    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
        require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500, ""Buyout dividend percentage must be between 2000 and 12500"");
        buyoutDividendPercentage = _buyoutDividendPercentage;
    }

    function setCFO(address _newCFO) external onlyCFO {
        cfo = _newCFO;
    }
}",42.72565770149231,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public buyoutDividendPercentage;
    address public cfo;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only CFO can call this function"");
        _;
    }

    constructor(address _cfo) Ownable(msg.sender) {
        buyoutDividendPercentage = 1; // Set to a safe non-zero value
        cfo = _cfo;
    }

    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
        require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500, ""Buyout dividend percentage must be between 2000 and 12500"");
        buyoutDividendPercentage = _buyoutDividendPercentage;
    }

    function setCFO(address _newCFO) external onlyCFO {
        cfo = _newCFO;
    }
}"
5099,This is mainly an helper function to ` finalize ` but can be used if ` finalize ` has issues with the loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;
    uint256 public tokensFinalized;
    uint256 public constant MAX_TOKENS = 1000000 * (10 ** 18); // Example value, adjust as needed
    IERC20 public token;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor(address _token) {
        token = IERC20(_token);
    }

    function finalizeSingleInvestor(address investorAddr) public onlyOwner {
        require(investorAddr != address(0) && investorAddr != address(this));
        require(balancesToken[investorAddr] > 0);
        require(isWhitelisted[investorAddr] == true);
        uint256 balanceToTransfer = balancesToken[investorAddr];
        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;
        require(token.transfer(investorAddr, balanceToTransfer));
        tokensFinalized = tokensFinalized.add(balanceToTransfer);
        assert(tokensFinalized <= MAX_TOKENS);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",finalizeDistribution,"[{'function': 'finalizeDistribution', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeDistribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""investorAddr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""investorAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""investorAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid investor address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balancesToken""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Investor has zero balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isWhitelisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, {""type"": ""stringLiteral"", ""value"": ""Investor is not whitelisted""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""investorBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balancesToken""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balancesToken""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isWhitelisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""investorAddr""}, {""type"": ""Identifier"", ""name"": ""investorBalance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensFinalized""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokensFinalized""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""investorBalance""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensFinalized""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_TOKENS""}}, {""type"": ""stringLiteral"", ""value"": ""Max tokens exceeded""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""mustBeAtStage"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""Finished""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.9341810744802548,0.5208468612894768,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    // ... other contract variables and modifiers ...

    uint256 public tokensFinalized;
    uint256 public constant MAX_TOKENS = 1000000; // Example value

    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;

    IERC20 public token; // Assuming ERC20 token

    function finalizeDistribution(address investorAddr) public onlyOwner mustBeAtStage(Stage.Finished) {
        require(investorAddr != address(0) && investorAddr != address(this), ""Invalid investor address"");
        require(balancesToken[investorAddr] > 0, ""Investor has zero balance"");
        require(isWhitelisted[investorAddr], ""Investor is not whitelisted"");

        uint256 investorBalance = balancesToken[investorAddr];
        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;

        token.transfer(investorAddr, investorBalance);

        tokensFinalized = tokensFinalized.add(investorBalance);
        require(tokensFinalized <= MAX_TOKENS, ""Max tokens exceeded"");
    }

    // ... other contract functions and modifiers ...

    enum Stage {
        Pending,
        InProgress,
        Finished
    }

    Stage public currentStage;

    modifier onlyOwner() {
        // ... onlyOwner logic ...
        _;
    }

    modifier mustBeAtStage(Stage stage) {
        require(currentStage == stage, ""Incorrect stage"");
        _;
    }

    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }
}",43.96438193321228,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    // ... other contract variables and modifiers ...

    uint256 public tokensFinalized = 0;
    uint256 public constant MAX_TOKENS = 1000000;

    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;

    IERC20 public token; // Assuming ERC20 token

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        tokensFinalized = 0;
        MAX_TOKENS = 1000000;
        for (uint256 i = 0; i < 3; i++) {
            balancesToken[address(uint160(uint256(keccak256(abi.encodePacked(""investor"", i)))))] = 1;
        }
        isWhitelisted[address(uint160(uint256(keccak256(abi.encodePacked(""investor"", 0)))))] = true;
        isWhitelisted[address(uint160(uint256(keccak256(abi.encodePacked(""investor"", 1)))))] = true;
        isWhitelisted[address(uint160(uint256(keccak256(abi.encodePacked(""investor"", 2)))))] = true;
        token = IERC20(address(uint160(uint256(keccak256(abi.encodePacked(""MyToken"")))));
    }

    function finalizeDistribution(address investorAddr) public onlyOwner mustBeAtStage(Stage.Finished) {
        require(investorAddr != address(0) && investorAddr != address(this), ""Invalid investor address"");
        require(balancesToken[investorAddr] > 0, ""Investor has zero balance"");
        require(isWhitelisted[investorAddr], ""Investor is not whitelisted"");

        uint256 investorBalance = balancesToken[investorAddr];
        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;

        token.transfer(investorAddr, investorBalance);

        tokensFinalized = tokensFinalized.add(investorBalance);
        require(tokensFinalized <= MAX_TOKENS, ""Max tokens exceeded"");
    }

    // ... other contract functions and modifiers ...

    enum Stage {
        Pending,
        InProgress,
        Finished
    }

    Stage public currentStage;

    modifier onlyOwner() {
        // ... onlyOwner logic ...
        _;
    }

    modifier mustBeAtStage(Stage stage) {
        require(currentStage == stage, ""Incorrect stage"");
        _;
    }

    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }
}"
1617,Suspends a given supported market ( asset ) from use with Compound .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Market {
    function isSupported() external view returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint;

    struct MarketInfo {
        bool isSupported;
    }

    mapping(address => MarketInfo) public markets;

    event SuspendedMarket(address indexed asset);

    function suspendMarket(address asset) external returns (uint) {
        if (msg.sender != owner()) {
            return uint(Error.UNAUTHORIZED);
        }
        if (!markets[asset].isSupported) {
            return uint(Error.NO_ERROR);
        }
        markets[asset].isSupported = false;
        emit SuspendedMarket(asset);
        return uint(Error.NO_ERROR);
    }
}",_suspendMarket,"[{'function': '_suspendMarket', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""_suspendMarket"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""asset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""admin""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UnauthorizedAccess""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Unauthorized access""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isSupported""}, ""index"": {""type"": ""Identifier"", ""name"": ""asset""}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [None]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isSupported""}, ""index"": {""type"": ""Identifier"", ""name"": ""asset""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SuspendedMarket""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""asset""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.8131141928321528,0.3468751975510857,"pragma solidity ^0.8.0;

contract MarketContract {

    address public admin;
    mapping(address => bool) public isSupported;

    event SuspendedMarket(address asset);
    event UnauthorizedAccess(address sender);

    constructor(address _admin) {
        admin = _admin;
    }

    function _suspendMarket(address asset) external {
        if (msg.sender != admin) {
            emit UnauthorizedAccess(msg.sender);
            revert(""Unauthorized access"");
        }

        if (!isSupported[asset]) {
            return;
        }

        isSupported[asset] = false;
        emit SuspendedMarket(asset);
    }
}",42.31388473510742,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MarketContract is Ownable {
    address public admin;
    mapping(address => bool) public isSupported;

    event SuspendedMarket(address asset);
    event UnauthorizedAccess(address sender);

    constructor() Ownable(msg.sender) {
        admin = msg.sender;
        isSupported[address(0x111)] = true;
        isSupported[address(0x222)] = true;
        isSupported[address(0x333)] = true;
    }

    function _suspendMarket(address asset) external {
        if (msg.sender != admin) {
            emit UnauthorizedAccess(msg.sender);
            revert(""Unauthorized access"");
        }

        if (!isSupported[asset]) {
            return;
        }

        isSupported[asset] = false;
        emit SuspendedMarket(asset);
    }
}"
4581,set beneficiary - the account receiving platform fees .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public beneficiary;

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}",setBeneficiary,"[{'function': 'setBeneficiary', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newBeneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBeneficiary""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    address public beneficiary;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}",42.39127492904663,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for a standard Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public beneficiary;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize beneficiary here as it will be inherited from the parent contract
    }

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}"
5894,Get the address of channel with a partner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ChannelWrapper {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        address[] all_channels;
    }

    function getChannelWith(Data storage self, address partner) public view returns (address) {
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint256 channel_pos = self.partyhash_to_channelpos[party_hash];
        if (channel_pos != 0) {
            return self.all_channels[channel_pos - 1];
        }
    }
}",getChannelAddress,"[{'function': 'partyHash', 'complexity': 1}, {'function': 'getChannelAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getChannelAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""partner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""party_hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""partyHash""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""partner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""channelPos"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""partyhash_to_channelpos""}, ""index"": {""type"": ""Identifier"", ""name"": ""party_hash""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""channelPos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""all_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channelPos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}, ""FalseBody"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.8633417140680528,0.4865382433123207,"pragma solidity ^0.8.0;

contract ChannelContract {

    mapping(bytes32 => uint256) public partyhash_to_channelpos;
    address[] public all_channels;

    function partyHash(address a, address b) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(a < b ? a : b, a < b ? b : a));
    }

    function getChannelAddress(address partner) public view returns (address) {
        bytes32 party_hash = partyHash(msg.sender, partner);
        uint256 channelPos = partyhash_to_channelpos[party_hash];
        if (channelPos != 0) {
            return all_channels[channelPos - 1];
        }
        return address(0);
    }
}",42.74482178688049,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ChannelContract is Ownable {
    mapping(bytes32 => uint256) public partyhash_to_channelpos;
    address[] public all_channels;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            if (i == 0) partyhash_to_channelpos[keccak256(abi.encodePacked(address(1), address(2)))] = 1;
            else if (i == 1) partyhash_to_channelpos[keccak256(abi.encodePacked(address(2), address(3)))] = 2;
            else if (i == 2) partyhash_to_channelpos[keccak256(abi.encodePacked(address(3), address(1)))] = 3;
        }
        all_channels = [address(1), address(2), address(3)];
    }

    function partyHash(address a, address b) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(a < b ? a : b, a < b ? b : a));
    }

    function getChannelAddress(address partner) public view returns (address) {
        bytes32 party_hash = partyHash(msg.sender, partner);
        uint256 channelPos = partyhash_to_channelpos[party_hash];
        if (channelPos != 0) {
            return all_channels[channelPos - 1];
        }
        return address(0);
    }
}"
1558,function mint to be executed by Manager of token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract MintableToken is Ownable, IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyManager() {
        require(owner() == msg.sender, ""Only the manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
        require(target != address(0), ""Invalid target address"");
        require(mintedAmount > 0, ""Mint amount must be greater than zero"");
        require(balanceOf[target].add(mintedAmount) >= balanceOf[target], ""SafeMath: addition overflow"");
        require(totalSupply.add(mintedAmount) >= totalSupply, ""SafeMath: addition overflow"");
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(0), target, mintedAmount);
        emit Transfer(target, target, mintedAmount);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}",mint,"[{'function': 'mint', 'complexity': 4}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""target""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Target address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mintedAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minted amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}}, {""type"": ""stringLiteral"", ""value"": ""Overflow detected in target balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, {""type"": ""stringLiteral"", ""value"": ""Overflow detected in total supply""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.9548972083425132,0.724960488154643,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    address public manager;
    bool public paused;

    modifier onlyManager() {
        require(msg.sender == manager, ""Only manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(address _manager) {
        manager = _manager;
    }

    function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
        require(target != address(0), ""Target address cannot be zero"");
        require(mintedAmount > 0, ""Minted amount must be greater than zero"");
        require(balanceOf[target].add(mintedAmount) >= balanceOf[target], ""Overflow detected in target balance"");
        require(totalSupply.add(mintedAmount) >= totalSupply, ""Overflow detected in total supply"");

        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);

        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    function pause() public onlyManager {
        paused = true;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}",43.588523387908936,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    address public manager;
    bool public paused;

    modifier onlyManager() {
        require(msg.sender == manager, ""Only manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize variables with fixed, safe values
        manager = msg.sender;
        balanceOf[msg.sender] = 1000; // Set initial balance of the manager
        totalSupply = 1000000000000000000; // Set initial total supply
        paused = false; // Set initial pause state to false
    }

    function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
        require(target != address(0), ""Target address cannot be zero"");
        require(mintedAmount > 0, ""Minted amount must be greater than zero"");
        require(balanceOf[target].add(mintedAmount) >= balanceOf[target], ""Overflow detected in target balance"");
        require(totalSupply.add(mintedAmount) >= totalSupply, ""Overflow detected in total supply"");

        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);

        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    function pause() public onlyManager {
        paused = true;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}"
2515,A getter to look up a Admin 's details,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminStorage {
    using SafeMath for uint256;

    struct PledgeAdmin {
        // Define the structure of PledgeAdmin here if needed
    }

    PledgeAdmin[] private admins;

    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {
        require(idAdmin < admins.length, ""Index out of bounds"");
        return admins[idAdmin];
    }
}",getAdmin,"[{'function': 'getAdmin', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""idAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""idAdmin""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admins""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Admin ID does not exist""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""idAdmin""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9390524795673236,0.4705896438972139,"pragma solidity ^0.8.0;

contract MyContract {
    struct PledgeAdmin {
        // Add struct fields as needed
    }

    PledgeAdmin[] public admins;

    function getAdmin(uint64 idAdmin) public view returns (PledgeAdmin memory) {
        require(idAdmin < admins.length, ""Admin ID does not exist"");
        return admins[idAdmin];
    }
}",42.12414765357971,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct PledgeAdmin {
        // Add struct fields as needed
    }

    PledgeAdmin[] public admins;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 fixedUint = 1;
        address fixedAddress = address(0x111);
        bool fixedBool = true;
        string memory fixedString = 'initialized';
        bytes32 fixedBytes32 = bytes32('init');

        // Add more initializations as needed

        require(fixedUint == 1, ""uint256 should be set to 1"");
        require(fixedAddress != address(0), ""address should not be zero"");
        require(fixedBool == true, ""bool should be true"");
        require(keccak256(abi.encodePacked(fixedString)) == keccak256(abi.encodePacked('initialized')), ""string should be 'initialized'"");
        require(fixedBytes32 == bytes32('init'), ""bytes32 should be set to 'init'"");
    }

    function getAdmin(uint64 idAdmin) public view returns (PledgeAdmin memory) {
        require(idAdmin < admins.length, ""Admin ID does not exist"");
        return admins[idAdmin];
    }
}"
4942,"enables withdrawals , only callable by the owner when the withdrawals are disabled","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bool public withdrawalEnabled = false;
    event WithdrawalEnabled(address indexed owner);

    modifier whenStopped() {
        require(!withdrawalEnabled, ""Withdrawal is enabled"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawal is already enabled"");
        _;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(owner());
    }
}",enableWithdrawal,"[{'function': 'enableWithdrawal', 'complexity': 0}, {'function': 'stopContract', 'complexity': 0}, {'function': 'startContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableWithdrawal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawalEnabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WithdrawalEnabled""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenStopped"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenWithdrawalDisabled"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.903678139163208,0.8164795700243452,"pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    bool public withdrawalEnabled;
    bool public stopped;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    modifier whenStopped() {
        require(stopped, ""Contract must be stopped"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawal is already enabled"");
        _;
    }

    event WithdrawalEnabled(address indexed owner);

    constructor() {
        owner = msg.sender;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(owner);
    }

    function stopContract() public onlyOwner {
        stopped = true;
    }

    function startContract() public onlyOwner {
        stopped = false;
    }
}",42.66139459609985,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner = msg.sender;
    bool public withdrawalEnabled;
    bool public stopped;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    modifier whenStopped() {
        require(stopped, ""Contract must be stopped"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawal is already enabled"");
        _;
    }

    event WithdrawalEnabled(address indexed owner);

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are initialized in the parent contract and modifier
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(owner);
    }

    function stopContract() public onlyOwner {
        stopped = true;
    }

    function startContract() public onlyOwner {
        stopped = false;
    }
}"
3452,Called by moduleFactory owner to register new modules for SecurityToken to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    function registerModule(address _moduleFactory) external returns (bool) {
        // Implementation of the registration logic
        return true;
    }
}",registerModuleFactory,"[{'function': 'registerModuleFactory', 'complexity': 7}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModuleFactory"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleFactory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Module factory address cannot be zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""alreadyRegistered"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""approvedModules""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedModules""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""alreadyRegistered""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""alreadyRegistered""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Module factory already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""approvedModules""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModuleRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.3937593898376567,0.0405715259947299,"pragma solidity ^0.8.0;

contract ModuleRegistry {

    address public owner;
    address[] public approvedModules;

    event ModuleRegistered(address moduleFactory);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function registerModuleFactory(address _moduleFactory) public onlyOwner {
        require(_moduleFactory != address(0), ""Module factory address cannot be zero"");
        bool alreadyRegistered = false;
        for (uint i = 0; i < approvedModules.length; i++) {
            if (approvedModules[i] == _moduleFactory) {
                alreadyRegistered = true;
                break;
            }
        }
        require(!alreadyRegistered, ""Module factory already registered"");
        approvedModules.push(_moduleFactory);
        emit ModuleRegistered(_moduleFactory);
    }
}",42.77559876441956,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming you have an import for Ownable
import ""openzeppelin/SafeMath.sol"";
contract ModuleRegistry is Ownable {
    address public owner;
    address[] public approvedModules;

    event ModuleRegistered(address moduleFactory);

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function registerModuleFactory(address _moduleFactory) public onlyOwner {
        require(_moduleFactory != address(0), ""Module factory address cannot be zero"");
        bool alreadyRegistered = false;
        for (uint i = 0; i < approvedModules.length; i++) {
            if (approvedModules[i] == _moduleFactory) {
                alreadyRegistered = true;
                break;
            }
        }
        require(!alreadyRegistered, ""Module factory already registered"");
        approvedModules.push(_moduleFactory);
        emit ModuleRegistered(_moduleFactory);
    }
}"
1228,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IWPR {
    function totalSupply() external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function finishMinting() external returns (bool);
    function transferOwnership(address newOwner) external;
}

abstract contract WPRCrowdsale is Ownable {
    using SafeMath for uint256;

    IWPR public wpr;
    address public teamHolder;
    address public communityHolder;
    address public futureHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 indexed finalizedBlock);

    constructor(IWPR _wpr, address _teamHolder, address _communityHolder, address _futureHolder, uint256 _startTime, uint256 _endTime) {
        wpr = _wpr;
        teamHolder = _teamHolder;
        communityHolder = _communityHolder;
        futureHolder = _futureHolder;
        startTime = _startTime;
        endTime = _endTime;
    }

    function getBlockTimestamp() internal view returns (uint256) {
        return block.timestamp;
    }

    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function weiToCollect() public view returns (uint256) {
        // Implement the logic to calculate the amount of Wei collected if needed.
        return 0; // Placeholder implementation.
    }

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == owner || getBlockTimestamp() > endTime || weiToCollect() == 0);

        uint256 CROWDSALE_PCT = 62;
        uint256 TEAMHOLDER_PCT = 20;
        uint256 COMMUNITYHOLDER_PCT = 15;
        uint256 FUTUREHOLDER_PCT = 3;
        assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

        uint256 tokenCap = wpr.totalSupply().mul(100).div(CROWDSALE_PCT);
        wpr.mint(teamHolder, tokenCap.mul(TEAMHOLDER_PCT).div(100));
        wpr.mint(communityHolder, tokenCap.mul(COMMUNITYHOLDER_PCT).div(100));
        wpr.mint(futureHolder, tokenCap.mul(FUTUREHOLDER_PCT).div(100));

        require(wpr.finishMinting());
        wpr.transferOwnership(owner);

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}",finalize,"[{'function': 'finalize', 'complexity': 6}, {'function': 'weiToCollect', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Sale already finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Sale already finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}, {""type"": ""stringLiteral"", ""value"": ""Sale has not started yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiToCollect""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Unauthorized""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""CROWDSALE_PCT"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""62"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""TEAMHOLDER_PCT"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""20"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""COMMUNITYHOLDER_PCT"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""15"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""FUTUREHOLDER_PCT"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""CROWDSALE_PCT""}, ""right"": {""type"": ""Identifier"", ""name"": ""TEAMHOLDER_PCT""}}, ""right"": {""type"": ""Identifier"", ""name"": ""COMMUNITYHOLDER_PCT""}}, ""right"": {""type"": ""Identifier"", ""name"": ""FUTUREHOLDER_PCT""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenCap"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""CROWDSALE_PCT""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""teamHolder""}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""TEAMHOLDER_PCT""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""communityHolder""}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""COMMUNITYHOLDER_PCT""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""futureHolder""}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""FUTUREHOLDER_PCT""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""finishMinting""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Finalized""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",41.0,0.8122114049918804,0.5093219736987927,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Crowdsale {
    IERC20 public wpr;
    address payable public owner;
    address payable public teamHolder;
    address payable public communityHolder;
    address payable public futureHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 blockNumber);

    constructor(IERC20 _wpr, address payable _teamHolder, address payable _communityHolder, address payable _futureHolder, uint256 _startTime, uint256 _endTime) {
        wpr = _wpr;
        owner = payable(msg.sender);
        teamHolder = _teamHolder;
        communityHolder = _communityHolder;
        futureHolder = _futureHolder;
        startTime = _startTime;
        endTime = _endTime;
    }

    function finalize() public {
        require(finalizedBlock == 0, ""Sale already finalized"");
        require(finalizedTime == 0, ""Sale already finalized"");
        require(block.timestamp >= startTime, ""Sale has not started yet"");
        require(msg.sender == owner || block.timestamp > endTime || weiToCollect() == 0, ""Unauthorized"");

        uint256 CROWDSALE_PCT = 62;
        uint256 TEAMHOLDER_PCT = 20;
        uint256 COMMUNITYHOLDER_PCT = 15;
        uint256 FUTUREHOLDER_PCT = 3;
        assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

        uint256 totalSupply = wpr.totalSupply();
        uint256 tokenCap = (totalSupply * CROWDSALE_PCT) / 100;

        wpr.mint(teamHolder, (totalSupply * TEAMHOLDER_PCT) / 100);
        wpr.mint(communityHolder, (totalSupply * COMMUNITYHOLDER_PCT) / 100);
        wpr.mint(futureHolder, (totalSupply * FUTUREHOLDER_PCT) / 100);

        wpr.finishMinting();

        // Transfer ownership (assuming wpr contract has an ownership transfer function)
        // wpr.transferOwnership(owner);

        finalizedBlock = block.number;
        finalizedTime = block.timestamp;
        emit Finalized(block.number);
    }

    function weiToCollect() public view returns (uint256) {
        //Implementation for weiToCollect
        return 0;
    }
}",45.71891069412232,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Crowdsale is Ownable {
    IERC20 public wpr;
    address payable public owner;
    address payable public teamHolder;
    address payable public communityHolder;
    address payable public futureHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 blockNumber);

    uint256 public totalSupply;

 constructor(IERC20 _wpr, address payable _teamHolder, address payable _communityHolder, address payable _futureHolder, uint256 _startTime, uint256 _endTime) Ownable(msg.sender) {
        wpr = _wpr;
        teamHolder = _teamHolder;
        communityHolder = _communityHolder;
        futureHolder = _futureHolder;
        startTime = _startTime;
        endTime = _endTime;
    }

    function finalize() public {
        require(finalizedBlock == 0, ""Sale already finalized"");
        require(finalizedTime == 0, ""Sale already finalized"");
        require(block.timestamp >= startTime, ""Sale has not started yet"");
        require(msg.sender == owner || block.timestamp > endTime || weiToCollect() == 0, ""Unauthorized"");

        uint256 CROWDSALE_PCT = 62;
        uint256 TEAMHOLDER_PCT = 20;
        uint256 COMMUNITYHOLDER_PCT = 15;
        uint256 FUTUREHOLDER_PCT = 3;
        assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

        uint256 totalSupply = wpr.totalSupply();
        uint256 tokenCap = (totalSupply * CROWDSALE_PCT) / 100;

        wpr.mint(teamHolder, (totalSupply * TEAMHOLDER_PCT) / 100);
        wpr.mint(communityHolder, (totalSupply * COMMUNITYHOLDER_PCT) / 100);
        wpr.mint(futureHolder, (totalSupply * FUTUREHOLDER_PCT) / 100);

        wpr.finishMinting();

        // Transfer ownership (assuming wpr contract has an ownership transfer function)
        // wpr.transferOwnership(owner);

        finalizedBlock = block.number;
        finalizedTime = block.timestamp;
        emit Finalized(block.number);
    }

    function weiToCollect() public view returns (uint256) {
        //Implementation for weiToCollect
        return 0;
    }
}"
6786,Decrease the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping (address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed newOwner, uint256 value, uint256 fee);

    function decreaseApprovalPreSignedHashing(address _token, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _subtractedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27, _signature[:64], _signature[64:]);
    }

    function decreaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);
        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));
        nonces[_signature] = true;
        uint oldValue = allowed[from][_spender];
        if (_subtractedValue > oldValue) {
            allowed[from][_spender] = 0;
        } else {
            allowed[from][_spender] = oldValue.sub(_subtractedValue);
        }
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}",decreaseApprovalPreSigned,"[{'function': 'decreaseApprovalPreSigned', 'complexity': 4}, {'function': 'decreaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recoverSigner', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseApprovalPreSigned"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_signature"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_subtractedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Spender cannot be zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""decreaseApprovalPreSignedHashing""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_subtractedValue""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonces""}, ""index"": {""type"": ""Identifier"", ""name"": ""hash""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""Signature has already been used""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""recoverSigner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hash""}, {""type"": ""Identifier"", ""name"": ""_signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""signer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonces""}, ""index"": {""type"": ""Identifier"", ""name"": ""hash""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""signer""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_subtractedValue""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_subtractedValue""}], ""names"": []}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""signer""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newAllowance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""signer""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""signer""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""signer""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""newAllowance""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""signer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalPreSigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""signer""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""newAllowance""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",137.0,0.8383599302316785,0.5256812639704145,"pragma solidity ^0.8.0;

import ""./SafeMath.sol""; // Assuming SafeMath library is available

contract MyContract {
    using SafeMath for uint256;

    mapping(bytes32 => bool) public nonces;
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed signer, address indexed spender, uint256 newAllowance, uint256 fee);

    function decreaseApprovalPreSigned(bytes calldata _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender cannot be zero address"");
        bytes32 hash = decreaseApprovalPreSignedHashing(_spender, _subtractedValue, _fee, _nonce);
        require(nonces[hash] == false, ""Signature has already been used"");
        address signer = recoverSigner(hash, _signature);
        require(signer != address(0), ""Invalid signature"");
        nonces[hash] = true;
        uint256 currentAllowance = allowances[signer][_spender];
        uint256 newAllowance = currentAllowance.sub(_subtractedValue) > 0 ? currentAllowance.sub(_subtractedValue) : 0;
        allowances[signer][_spender] = newAllowance;
        balances[signer] = balances[signer].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        emit Approval(signer, _spender, newAllowance);
        emit Transfer(signer, msg.sender, _fee);
        emit ApprovalPreSigned(signer, _spender, newAllowance, _fee);
        return true;
    }


    function decreaseApprovalPreSignedHashing(address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_spender, _subtractedValue, _fee, _nonce));
    }

    function recoverSigner(bytes32 _hash, bytes calldata _signature) internal pure returns (address) {
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            v := byte(0, mload(add(_signature, 96)))
        }
        return ecrecover(_hash, v, r, s);
    }
}",45.63319230079651,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol""; // Assuming SafeMath library is available
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Importing Ownable from OpenZeppelin

contract MyContract is Ownable {;
    using SafeMath for uint256;

    mapping(bytes32 => bool) public nonces;
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed signer, address indexed spender, uint256 newAllowance, uint256 fee);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Balance of the owner
        allowances[msg.sender][address(this)] = type(uint256).max; // Max allowance for self (for simplicity, assuming no specific limit)
    }

    function decreaseApprovalPreSigned(bytes calldata _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender cannot be zero address"");
        bytes32 hash = decreaseApprovalPreSignedHashing(_spender, _subtractedValue, _fee, _nonce);
        require(nonces[hash] == false, ""Signature has already been used"");
        address signer = recoverSigner(hash, _signature);
        require(signer != address(0), ""Invalid signature"");
        nonces[hash] = true;
        uint256 currentAllowance = allowances[signer][_spender];
        uint256 newAllowance = currentAllowance.sub(_subtractedValue) > 0 ? currentAllowance.sub(_subtractedValue) : 0;
        allowances[signer][_spender] = newAllowance;
        balances[signer] = balances[signer].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        emit Approval(signer, _spender, newAllowance);
        emit Transfer(signer, msg.sender, _fee);
        emit ApprovalPreSigned(signer, _spender, newAllowance, _fee);
        return true;
    }

    function decreaseApprovalPreSignedHashing(address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_spender, _subtractedValue, _fee, _nonce));
    }

    function recoverSigner(bytes32 _hash, bytes calldata _signature) internal pure returns (address) {
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            v := byte(0, mload(add(_signature, 96)))
        }
        return ecrecover(_hash, v, r, s);
    }
}"
3195,Retrieves the encryption public key of the darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeStore {
    function darknodePublicKey(address) external view returns (bytes memory);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    DarknodeStore public store;

    constructor(address _storeAddress) {
        store = DarknodeStore(_storeAddress);
    }

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        return store.darknodePublicKey(_darknodeID);
    }
}",getDarknodePublicKey,"[{'function': 'getDarknodePublicKey', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDarknodePublicKey"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_darknodeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""success"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x11301bb60>}, {""type"": ""VariableDeclaration"", ""name"": ""publicKey"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x11301ac10>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""store""}, ""memberName"": ""staticcall""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""darknodePublicKey(address)""}, {""type"": ""Identifier"", ""name"": ""_darknodeID""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Failed to retrieve public key""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""publicKey""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",15.0,0.7113111973940247,0.2294142895736394,"pragma solidity ^0.8.0;

contract DarknodeRegistry {

    // Assume 'store' object is defined elsewhere,  e.g., using a library or interface
    //  and has a function darknodePublicKey(address _darknodeID) returns (bytes memory)
    address public store;

    constructor(address _store) {
        store = _store;
    }


    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        // Assuming store is an address of a contract with darknodePublicKey function
        (bool success, bytes memory publicKey) = store.staticcall(abi.encodeWithSignature(""darknodePublicKey(address)"", _darknodeID));
        require(success, ""Failed to retrieve public key"");
        return publicKey;
    }
}",42.34154891967773,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DarknodeRegistry is Ownable {
    address public store;

    constructor(address _store) Ownable(msg.sender) {
        store = _store;
    }

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        // Assuming store is an address of a contract with darknodePublicKey function
        (bool success, bytes memory publicKey) = store.staticcall(abi.encodeWithSignature(""darknodePublicKey(address)"", _darknodeID));
        require(success, ""Failed to retrieve public key"");
        return publicKey;
    }
}"
761,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function enableTransfers(bool _transfersEnabled) external onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",setTransfersEnabled,"[{'function': 'setTransfersEnabled', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTransfersEnabled"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9259991534729852,0.4973567356124543,"pragma solidity ^0.8.0;

contract MyContract {
    address public controller;
    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function."");
        _;
    }

    constructor(address _controller) {
        controller = _controller;
        transfersEnabled = true;
    }

    function setTransfersEnabled(bool _transfersEnabled) public onlyController {
        transfersEnabled = _transfersEnabled;
    }
}",41.58127021789551,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public controller;
    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function."");
        _;
    }

    constructor(address _controller) Ownable(msg.sender) {
        controller = _controller;
        transfersEnabled = true;
    }

    function setTransfersEnabled(bool _transfersEnabled) public onlyController {
        transfersEnabled = _transfersEnabled;
    }
}"
3170,Set an upgrade agent contract to process the upgrade .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface UpgradeAgent {
    function isUpgradeAgent() external view returns (bool);
    function originalSupply() external view returns (uint256);
}

enum UpgradeState { NotUpgradable, Upgrading }

abstract contract Token {
    using SafeMath for uint256;

    address public upgradeAgent;
    uint256 public totalSupply_;

    function getUpgradeState() internal virtual returns (UpgradeState);
    function canUpgrade() internal virtual returns (bool);

    event UpgradeAgentSet(address indexed agent);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }
}

abstract contract UpgradableToken is Token, Ownable {
    using SafeMath for uint256;

    function setUpgradeAgent(UpgradeAgent _upgradeAgent) external onlyOwner {
        require(canUpgrade(), ""Ensure the token is upgradeable in the first place"");
        require(_upgradeAgent != address(0), ""Ensure upgrade agent address is not blank"");
        require(getUpgradeState() != UpgradeState.Upgrading, ""Ensure upgrade has not started"");

        upgradeAgent = address(_upgradeAgent);
        require(UpgradeAgent(upgradeAgent).isUpgradeAgent(), ""New upgradeAgent must be UpgradeAgent"");
        require(UpgradeAgent(upgradeAgent).originalSupply() == totalSupply_, ""Make sure that token supplies match in source and target token contracts"");

        emit UpgradeAgentSet(upgradeAgent);
    }
}",setUpgradeAgent,"[{'function': 'totalSupply', 'complexity': 0}, {'function': 'setUpgradeAgent', 'complexity': 5}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUpgradeAgent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_upgradeAgent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""upgradeMaster""}}, {""type"": ""stringLiteral"", ""value"": ""Only upgrade master can set upgrade agent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_upgradeAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Upgrade agent address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradeState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""WaitingForAgent""}}, {""type"": ""stringLiteral"", ""value"": ""Upgrade process has already started""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradeAgent""}], ""names"": []}, ""memberName"": ""isUpgradeAgent""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Provided address does not implement UpgradeAgent interface""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradeAgent""}], ""names"": []}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Total supply mismatch""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradeAgent""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradeState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""ReadyToUpgrade""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgentSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradeAgent""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.9251147814837998,0.3357084505584013,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

interface UpgradeAgent {
    function isUpgradeAgent() external view returns (bool);
    function upgradeFrom(address from, uint256 value) external;
    function totalSupply() external view returns (uint256);
}

contract UpgradeableToken {
    using SafeMath for uint256;

    enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}

    address public upgradeMaster;
    UpgradeAgent public upgradeAgent;
    uint256 public totalUpgraded;
    UpgradeState public upgradeState;

    event UpgradeAgentSet(address upgradeAgent);

    function setUpgradeAgent(address _upgradeAgent) public {
        require(msg.sender == upgradeMaster, ""Only upgrade master can set upgrade agent"");
        require(_upgradeAgent != address(0), ""Upgrade agent address cannot be zero"");
        require(upgradeState == UpgradeState.WaitingForAgent, ""Upgrade process has already started"");
        require(UpgradeAgent(_upgradeAgent).isUpgradeAgent(), ""Provided address does not implement UpgradeAgent interface"");
        require(UpgradeAgent(_upgradeAgent).totalSupply() == totalSupply(), ""Total supply mismatch"");

        upgradeAgent = UpgradeAgent(_upgradeAgent);
        upgradeState = UpgradeState.ReadyToUpgrade;
        emit UpgradeAgentSet(_upgradeAgent);
    }

    // ... other functions ...
}",42.91593289375305,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

interface UpgradeAgent {
    function isUpgradeAgent() external view returns (bool);
    function upgradeFrom(address from, uint256 value) external;
    function totalSupply() external view returns (uint256);
}

contract UpgradeableToken is Ownable {
    using SafeMath for uint256;

    enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}

    address public upgradeMaster = 0x1111111111111111111111111111111111111111; // Replace with actual address
    UpgradeAgent public upgradeAgent;
    uint256 public totalUpgraded = 1; // Set to a fixed value (never 0)
    UpgradeState public upgradeState;

    bytes32 public constant INIT = bytes32('init');

    event UpgradeAgentSet(address upgradeAgent);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        upgradeMaster = address(0x1111111111111111111111111111111111111111); // Replace with actual address
        upgradeAgent = UpgradeAgent(0x2222222222222222222222222222222222222222); // Replace with actual address
        totalUpgraded = 1; // Set to a fixed value (never 0)
        upgradeState = UpgradeState.WaitingForAgent;
    }

    function setUpgradeAgent(address _upgradeAgent) public {
        require(msg.sender == upgradeMaster, ""Only upgrade master can set upgrade agent"");
        require(_upgradeAgent != address(0), ""Upgrade agent address cannot be zero"");
        require(upgradeState == UpgradeState.WaitingForAgent, ""Upgrade process has already started"");
        require(UpgradeAgent(_upgradeAgent).isUpgradeAgent(), ""Provided address does not implement UpgradeAgent interface"");
        require(UpgradeAgent(_upgradeAgent).totalSupply() == totalSupply(), ""Total supply mismatch"");

        upgradeAgent = UpgradeAgent(_upgradeAgent);
        upgradeState = UpgradeState.ReadyToUpgrade;
        emit UpgradeAgentSet(_upgradeAgent);
    }

    // ... other functions ...
}"
3368,Check whether an address is a regular address or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

    function isRegularAddress(address _addr) public view returns (bool) {
        if (_addr == address(0)) {
            return false;
        }
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }
}",isRegularAddress,"[{'function': 'isRegularAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRegularAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.98948069520672,0.9385522307631308,"pragma solidity ^0.8.0;

contract AddressChecker {

    function isRegularAddress(address _addr) public view returns (bool) {
        if (_addr == address(0)) {
            return false;
        }
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }
}",41.83741188049317,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AddressChecker is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isRegularAddress(address _addr) public view returns (bool) {
        if (_addr == address(0)) {
            return false;
        }
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }
}"
5919,Initiates a `` send '' operation towards another user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenStorage {
    function balanceOf(address account) external view returns (uint256);
    function subBalance(address account, uint256 amount) external;
    function addBalance(address account, uint256 amount) external;
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    ITokenStorage public tokenStorage;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {
        require(_to != address(0), ""to address cannot be 0x0"");
        require(_amount <= tokenStorage.balanceOf(msg.sender), ""not enough balance to transfer"");
        tokenStorage.subBalance(msg.sender, _amount);
        tokenStorage.addBalance(_to, _amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function setTokenStorage(address _tokenStorage) public onlyOwner {
        tokenStorage = ITokenStorage(_tokenStorage);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    modifier userNotBlacklisted(address user) {
        require(!isBlacklisted[user], ""User is blacklisted"");
        _;
    }

    mapping(address => bool) public isBlacklisted;

    function blacklistUser(address user) public onlyOwner {
        isBlacklisted[user] = true;
    }

    function removeFromBlacklist(address user) public onlyOwner {
        isBlacklisted[user] = false;
    }
}",transfer,"[{'function': 'transfer', 'complexity': 2}, {'function': 'add', 'complexity': 1}, {'function': 'sub', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""userNotBlacklisted"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}]}, {""type"": ""ModifierInvocation"", ""name"": ""userNotBlacklisted"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.8114273017069478,0.4873113122982341,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    // ... other contract code ...

    event Transfer(address indexed from, address indexed to, uint256 amount);

    modifier whenNotPaused() {
        // ... pause logic ...
        _;
    }

    modifier userNotBlacklisted(address _user) {
        // ... blacklist logic ...
        _;
    }


    function transfer(address _to, uint256 _amount) public whenNotPaused userNotBlacklisted(msg.sender) userNotBlacklisted(_to) {
        require(_to != address(0), ""Transfer to the zero address"");
        require(tokenStorage[msg.sender] >= _amount, ""Insufficient balance"");

        tokenStorage[msg.sender] = tokenStorage[msg.sender].sub(_amount);
        tokenStorage[_to] = tokenStorage[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);
    }

    // ... other contract code ...
    mapping(address => uint256) tokenStorage;
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
}",43.46579456329346,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    // State variables initialization
    mapping(address => uint256) tokenStorage;

    event Transfer(address indexed from, address indexed to, uint256 amount);

    modifier whenNotPaused() {
        // ... pause logic ...
        _;
    }

    modifier userNotBlacklisted(address _user) {
        // ... blacklist logic ...
        _;
    }

    function transfer(address _to, uint256 _amount) public whenNotPaused userNotBlacklisted(msg.sender) userNotBlacklisted(_to) {
        require(_to != address(0), ""Transfer to the zero address"");
        require(tokenStorage[msg.sender] >= _amount, ""Insufficient balance"");

        tokenStorage[msg.sender] = tokenStorage[msg.sender].sub(_amount);
        tokenStorage[_to] = tokenStorage[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);
    }

    // Constructor to initialize state variables and inherit Ownable
    constructor() {
        // Initialize address values in a sequence
        address owner = msg.sender;
        tokenStorage[owner] = 1; // uint256: Set to 1 (never 0)

        // For ERC20 or similar constructors requiring arguments, use placeholder values like 'MyToken'
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
}"
4803,This is a state-modifying function that can be called while the contract is paused .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Sale {
        address seller;
        // other sale details
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function _isOnSale(Sale storage sale) internal view returns (bool) {
        return sale.seller != address(0);
    }

    function _cancelSale(uint256 _tokenId, address seller) internal {
        delete tokenIdToSale[_tokenId];
        emit SaleCancelled(_tokenId, seller);
    }

    function cancelSale(uint256 _tokenId) public {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(sale));
        address seller = sale.seller;
        require(msg.sender == seller);
        _cancelSale(_tokenId, seller);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",cancelSale,"[{'function': '_isOnSale', 'complexity': 0}, {'function': '_cancelSale', 'complexity': 0}, {'function': 'cancelSale', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Sale""}, ""name"": ""sale"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIdToSale""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isOnSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Sale is not active""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sale""}, ""memberName"": ""seller""}}, {""type"": ""stringLiteral"", ""value"": ""Not the seller""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_cancelSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sale""}, ""memberName"": ""seller""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.9432212116606118,0.5604636985629962,"pragma solidity ^0.8.0;

contract MyContract {
    struct Sale {
        address seller;
        // Add other relevant fields as needed
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function _isOnSale(uint256 _tokenId) internal view returns (bool) {
        // Implement your logic to check if a sale is active
    }

    function _cancelSale(uint256 _tokenId, address _seller) internal {
        // Implement your logic to cancel the sale and perform cleanup
        delete tokenIdToSale[_tokenId];
    }

    function cancelSale(uint256 _tokenId) public {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(_tokenId), ""Sale is not active"");
        require(msg.sender == sale.seller, ""Not the seller"");
        _cancelSale(_tokenId, sale.seller);
    }
}",42.02743005752564,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Sale {
        address seller;
        // Add other relevant fields as needed
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function _isOnSale(uint256 _tokenId) internal view returns (bool) {
        // Implement your logic to check if a sale is active
        return tokenIdToSale[_tokenId].seller != address(0);
    }

    function _cancelSale(uint256 _tokenId, address _seller) internal {
        // Implement your logic to cancel the sale and perform cleanup
        delete tokenIdToSale[_tokenId];
    }

    function cancelSale(uint256 _tokenId) public {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(_tokenId), ""Sale is not active"");
        require(msg.sender == sale.seller, ""Not the seller"");
        _cancelSale(_tokenId, sale.seller);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            tokenIdToSale[i] = Sale({seller: address(uint160(uint256(keccak256(abi.encodePacked('address', i)))))});
        }
    }
}"
2141,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

function submitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address answerer) onlyArbitrator(question_id) statePendingArbitration(question_id) bondMustBeZero external {
    require(answerer != NULL_ADDRESS, ""answerer must be provided"");
    emit LogFinalize(question_id, answer);
    questions[question_id].is_pending_arbitration = false;
    _addAnswerToHistory(question_id, answer, answerer, 0, false);
    _updateCurrentAnswer(question_id, answer, 0);
}
}",pose,"[{'function': 'pose', 'complexity': 0}, {'function': '_addAnswerToHistory', 'complexity': 0}, {'function': '_updateCurrentAnswer', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""answer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""answerer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""is_pending_arbitration""}, {""type"": ""stringLiteral"", ""value"": ""Question not pending arbitration""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""TupleExpression"", ""components"": [None, {""type"": ""stringLiteral"", ""value"": ""Bond is not zero""}], ""isArray"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""answerer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Answerer address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""is_pending_arbitration""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogFinalize""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addAnswerToHistory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_updateCurrentAnswer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyArbitrator"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.8629523439771454,0.4536386086326793,"pragma solidity ^0.8.0;

contract QuestionArbitration {

    // Define necessary structs and events here...  (Example below)
    struct Question {
        bool is_pending_arbitration;
        // ... other fields
    }

    mapping(bytes32 => Question) public questions;
    event LogFinalize(bytes32 question_id, bytes32 answer);

    // ... other functions and modifiers ... (Example below)
    modifier onlyArbitrator(bytes32 _questionId) {
        // Add logic to check if msg.sender is an authorized arbitrator for _questionId
        require( /* Add your arbitrator check here */, ""Not authorized"");
        _;
    }


    function pose(bytes32 question_id, bytes32 answer, address answerer)
        public
        onlyArbitrator(question_id)
    {
        require(questions[question_id].is_pending_arbitration, ""Question not pending arbitration"");
        require( /* Add bond check here */, ""Bond is not zero"");
        require(answerer != address(0), ""Answerer address cannot be zero"");

        questions[question_id].is_pending_arbitration = false;
        emit LogFinalize(question_id, answer);
        _addAnswerToHistory(question_id, answer);
        _updateCurrentAnswer(question_id, answer, 0);
    }

    function _addAnswerToHistory(bytes32 question_id, bytes32 answer) internal {
        // Add logic to add answer to history
    }

    function _updateCurrentAnswer(bytes32 question_id, bytes32 answer, uint256 bond) internal {
        // Add logic to update current answer
    }
}",43.04811763763428,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract QuestionArbitration is Ownable {
    struct Question {
        bool is_pending_arbitration;
        // ... other fields
    }

    mapping(bytes32 => Question) public questions;
    event LogFinalize(bytes32 question_id, bytes32 answer);

    modifier onlyArbitrator(bytes32 _questionId) {
        require( /* Add your arbitrator check here */, ""Not authorized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        questions = {};
    }

    function pose(bytes32 question_id, bytes32 answer, address answerer)
        public
        onlyArbitrator(question_id)
    {
        require(questions[question_id].is_pending_arbitration, ""Question not pending arbitration"");
        require( /* Add bond check here */, ""Bond is not zero"");
        require(answerer != address(0), ""Answerer address cannot be zero"");

        questions[question_id].is_pending_arbitration = false;
        emit LogFinalize(question_id, answer);
        _addAnswerToHistory(question_id, answer);
        _updateCurrentAnswer(question_id, answer, 0);
    }

    function _addAnswerToHistory(bytes32 question_id, bytes32 answer) internal {
        // Add logic to add answer to history
    }

    function _updateCurrentAnswer(bytes32 question_id, bytes32 answer, uint256 bond) internal {
        // Add logic to update current answer
    }
}"
381,"Get the remaining funds needed to end the auction , calculated at the current GOT price in WEI .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AuctionWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public num_tokens_auctioned;
    uint256 public received_wei;
    uint256 public price_per_token;
    uint256 public token_multiplier;

    function remainingFundsToEndAuction() public view returns (uint256) {
        require(num_tokens_auctioned > 0, ""Number of tokens auctioned must be greater than zero"");
        require(token_multiplier > 0, ""Token multiplier must be greater than zero"");
        uint256 required_wei_at_price = num_tokens_auctioned.mul(price_per_token) / token_multiplier;
        if (required_wei_at_price <= received_wei) {
            return 0;
        }
        return required_wei_at_price.sub(received_wei);
    }
}",remainingFundsNeeded,"[{'function': 'price', 'complexity': 0}, {'function': 'remainingFundsNeeded', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""remainingFundsNeeded"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""requiredWei"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""num_tokens_auctioned""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""price""}, ""arguments"": [], ""names"": []}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""token_multiplier""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""requiredWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""received_wei""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""requiredWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""received_wei""}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",23.0,0.7940305712927717,0.2289667784993376,"pragma solidity ^0.8.0;

contract Auction {
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;
    uint256 public received_wei;

    function price() public view virtual returns (uint256) {
        //Implementation for price calculation.  Replace with actual logic.
        return 100; //Example price
    }

    function remainingFundsNeeded() public view returns (uint256) {
        uint256 requiredWei = (num_tokens_auctioned * price()) / token_multiplier;
        if (requiredWei <= received_wei) {
            return 0;
        } else {
            return requiredWei - received_wei;
        }
    }
}",41.93787217140198,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    uint256 public num_tokens_auctioned = 1;
    uint256 public token_multiplier = 1;
    uint256 public received_wei = 0;

    function price() public view virtual returns (uint256) {
        //Implementation for price calculation. Replace with actual logic.
        return 100; //Example price
    }

    function remainingFundsNeeded() public view returns (uint256) {
        uint256 requiredWei = (num_tokens_auctioned * price()) / token_multiplier;
        if (requiredWei <= received_wei) {
            return 0;
        } else {
            return requiredWei - received_wei;
        }
    }
}"
242,Withdraw ETH for ` receiverAddress ` after the auction has canceled .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionCreated, AuctionCanceled, AuctionEnded }
    mapping(address => uint) public bids;
    Stages public stage = Stages.AuctionCreated;

    function proxyWithdraw(address receiverAddress) public atStage(Stages.AuctionCanceled) returns (bool) {
        require(receiverAddress != address(0));
        if (bids[receiverAddress] == 0) {
            return false;
        }
        uint amount = bids[receiverAddress];
        bids[receiverAddress] = 0;
        receiverAddress.transfer(amount);
        assert(bids[receiverAddress] == 0);
        return true;
    }
}",proxyWithdraw,"[{'function': 'proxyWithdraw', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiverAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Receiver address cannot be zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No bid associated with this address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receiverAddress""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Withdrawal failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.8943328757102056,0.4137066227606674,"pragma solidity ^0.8.0;

contract Auction {
    mapping(address => uint256) public bids;

    function proxyWithdraw(address receiverAddress) public returns (bool) {
        require(receiverAddress != address(0), ""Receiver address cannot be zero"");
        uint256 amount = bids[receiverAddress];
        require(amount > 0, ""No bid associated with this address"");
        bids[receiverAddress] = 0;
        payable(receiverAddress).transfer(amount);
        require(bids[receiverAddress] == 0, ""Withdrawal failed"");
        return true;
    }
}",41.7021381855011,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    mapping(address => uint256) public bids;
    address[] public winners;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function proxyWithdraw(address receiverAddress) public returns (bool) {
        require(receiverAddress != address(0), ""Receiver address cannot be zero"");
        uint256 amount = bids[receiverAddress];
        require(amount > 0, ""No bid associated with this address"");
        bids[receiverAddress] = 0;
        payable(receiverAddress).transfer(amount);
        require(bids[receiverAddress] == 0, ""Withdrawal failed"");
        return true;
    }

    function addWinner(address winner) public onlyOwner {
        winners.push(winner);
    }
}"
1926,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable override returns (bool) {
        return true;
    }
}",payOnBehalf,"[{'function': 'payOnBehalf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""payOnBehalf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",8.0,0.718030863159387,0.1990245293108798,"pragma solidity ^0.8.0;

contract PaymentProxy {

    function payOnBehalf(address payable _owner) public payable {
        _owner.transfer(msg.value);
    }
}",42.939563274383545,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentProxy is Ownable {
    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function payOnBehalf(address payable _owner) public payable {
        _owner.transfer(msg.value);
    }
}"
6311,Vote for specific proposal with yes or no,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

abstract contract Proposal {
    using SafeMath for uint256;
    struct Proposal {
        address token;
        uint256 yesVotes;
        uint256 noVotes;
    }
    Proposal[] public proposals;
    mapping(uint256 => Proposal) public proposalById;

    event Vote(uint256 indexed proposalId, address indexed voter, bool yes, uint256 amount);

    function vote(uint256 _proposalId, bool _yes) public {
        require(_proposalId < proposals.length, ""Invalid proposal ID"");
        require(checkIfCurrentlyActive(_proposalId), ""Proposal is not active"");
        Proposal memory p = proposals[_proposalId];
        uint256 amount = MiniMeToken(p.token).balanceOf(msg.sender);
        require(amount > 0, ""No tokens to vote with"");
        require(MiniMeToken(p.token).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        if (_yes) {
            proposals[_proposalId].yesVotes = proposals[_proposalId].yesVotes.add(amount);
        } else {
            proposals[_proposalId].noVotes = proposals[_proposalId].noVotes.add(amount);
        }
        emit Vote(_proposalId, msg.sender, _yes, amount);
    }
}",vote,"[{'function': 'vote', 'complexity': 4}, {'function': 'addProposal', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""vote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_proposalId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_yes"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_proposalId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Proposal does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}, ""memberName"": ""active""}, {""type"": ""stringLiteral"", ""value"": ""Proposal is not active""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Proposal""}, ""name"": ""proposal"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""transferAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""balance""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""transferAmount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""_yes""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""yesVotes""}, ""right"": {""type"": ""Identifier"", ""name"": ""transferAmount""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""noVotes""}, ""right"": {""type"": ""Identifier"", ""name"": ""transferAmount""}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""voters""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Vote""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_proposalId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_yes""}, {""type"": ""Identifier"", ""name"": ""transferAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.8847516425660495,0.4740393344904601,"pragma solidity ^0.8.0;

contract Voting {

    struct Proposal {
        uint256 id;
        bool active;
        uint256 yesVotes;
        uint256 noVotes;
    }

    Proposal[] public proposals;
    mapping(uint256 => address[]) public voters;

    event Vote(uint256 indexed proposalId, address indexed voter, bool yes, uint256 amount);

    function vote(uint256 _proposalId, bool _yes) public {
        require(_proposalId < proposals.length, ""Proposal does not exist"");
        require(proposals[_proposalId].active, ""Proposal is not active"");

        Proposal storage proposal = proposals[_proposalId];
        uint256 balance = IERC20(tokenAddress).balanceOf(msg.sender);
        require(balance > 0, ""Insufficient token balance"");

        uint256 transferAmount = balance; // Transfer all tokens as voting power.  Could be modified to allow partial votes.

        IERC20(tokenAddress).transferFrom(msg.sender, address(this), transferAmount);

        if (_yes) {
            proposal.yesVotes += transferAmount;
        } else {
            proposal.noVotes += transferAmount;
        }

        voters[_proposalId].push(msg.sender);
        emit Vote(_proposalId, msg.sender, _yes, transferAmount);
    }

    address public tokenAddress;

    constructor(address _tokenAddress) {
        tokenAddress = _tokenAddress;
    }

    function addProposal(bool _active) public {
        proposals.push(Proposal(proposals.length, _active, 0, 0));
    }

    interface IERC20 {
        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
        function balanceOf(address account) external view returns (uint256);
    }
}",43.568124294281006,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Voting is Ownable {
    struct Proposal {
        uint256 id;
        bool active;
        uint256 yesVotes;
        uint256 noVotes;
    }

    Proposal[] public proposals;
    mapping(uint256 => address[]) public voters;

    event Vote(uint256 indexed proposalId, address indexed voter, bool yes, uint256 amount);

    function vote(uint256 _proposalId, bool _yes) public {
        require(_proposalId < proposals.length, ""Proposal does not exist"");
        require(proposals[_proposalId].active, ""Proposal is not active"");

        Proposal storage proposal = proposals[_proposalId];
        uint256 balance = IERC20(tokenAddress).balanceOf(msg.sender);
        require(balance > 0, ""Insufficient token balance"");

        uint256 transferAmount = balance; // Transfer all tokens as voting power. Could be modified to allow partial votes.

        IERC20(tokenAddress).transferFrom(msg.sender, address(this), transferAmount);

        if (_yes) {
            proposal.yesVotes += transferAmount;
        } else {
            proposal.noVotes += transferAmount;
        }

        voters[_proposalId].push(msg.sender);
        emit Vote(_proposalId, msg.sender, _yes, transferAmount);
    }

    address public tokenAddress;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        tokenAddress = _tokenAddress;
        proposals.push(Proposal(0, false, 0, 0)); // Initialize the first proposal with default values
    }

    function addProposal(bool _active) public {
        proposals.push(Proposal(proposals.length, _active, 0, 0));
    }

    interface IERC20 {
        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
        function balanceOf(address account) external view returns (uint256);
    }
}"
2268,"Executes active investment and redemption requests , in a way that minimises information advantages of investor","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AssetInterface {
    function transferFrom(address, address, uint) external returns (bool);
    function transfer(address, uint) external returns (bool);
}

interface PriceFeedInterface {
    function getInterval() external view returns (uint);
    function getLastUpdateId() external view returns (uint);
    function hasRecentPrice(address) external view returns (bool);
    function getInvertedPrice(address) external view returns (bool, uint, uint);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint;

    struct Request {
        address requestAsset;
        address participant;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
        RequestStatus status;
        RequestType requestType;
    }

    enum RequestStatus { active, executed }
    enum RequestType { invest, redeem, tokenFallbackRedeem }

    address public constant NATIVE_ASSET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint public totalSupply;
    bool public isInvestAllowed;
    bool public isRedeemAllowed;
    mapping(uint => Request) public requests;
    mapping(address => uint) public balances;

    PriceFeedInterface public module;

    constructor(PriceFeedInterface _module) {
        module = _module;
    }

    function executeRequest(uint id) external pre_cond(!isShutDown()) pre_cond(requests[id].status == RequestStatus.active) pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) pre_cond(totalSupply == 0 || (block.timestamp >= add(requests[id].timestamp, module.getInterval()) && module.getLastUpdateId() >= add(requests[id].atUpdateId, 2))) {
        Request memory request = requests[id];
        require(module.hasRecentPrice(address(request.requestAsset)));
        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));
        if (request.requestAsset == address(NATIVE_ASSET)) {
            var (isPriceRecent, invertedNativeAssetPrice, nativeAssetDecimal) = module.getInvertedPrice(address(NATIVE_ASSET));
            require(isPriceRecent);
            costQuantity = mul(costQuantity, invertedNativeAssetPrice) / 10**nativeAssetDecimal;
        }
        if (isInvestAllowed && request.requestType == RequestType.invest && costQuantity <= request.giveQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity));
            createShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.redeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.tokenFallbackRedeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(address(this), request.shareQuantity);
        } else {
            revert();
        }
    }
}",executeRequest,"[{'function': 'executeRequest', 'complexity': 12}]",17.0,{},144.0,0.591940422740398,0.1187331512473437,"pragma solidity ^0.8.0;

// Assume necessary contracts and interfaces are defined elsewhere, e.g., PriceFeed, Request, etc.

contract MyContract {
    // ... other contract code ...

    function executeRequest(uint id) public {
        Request storage request = requests[id];

        require(!shutDown, ""System is shut down"");
        require(request.status == RequestStatus.Active, ""Request is not active"");

        if (request.type == RequestType.Redeem) {
            require(participants[msg.sender].shareBalance <= participants[msg.sender].balance, ""Insufficient balance"");
        }

        require(totalSupply == 0 || block.timestamp >= request.timestamp + priceFeedInterval && priceFeed.lastUpdateId() >= request.updateId + 2, ""Price feed update required"");

        // Retrieve price from price feed
        uint price = priceFeed.getPrice(request.asset);

        // Calculate cost quantity
        uint costQuantity = request.shareQuantity * price; // Add fee calculation here if needed

        // Adjust for native asset if necessary
        if (request.asset == address(0)) {
            // Add logic to adjust costQuantity based on inverted price and decimals
        }

        if (request.type == RequestType.Invest) {
            // Ensure investment is allowed
            // Transfer funds from participant to contract
            // Create shares
        } else if (request.type == RequestType.Redeem) {
            // Ensure redemption is allowed
            // Transfer funds from contract to participant
            // Annihilate shares
        } else if (request.type == RequestType.TokenFallbackRedeem) {
            // Ensure redemption is allowed
            // Transfer funds from contract to participant
            // Annihilate shares (from contract itself)
        }

        request.status = RequestStatus.Executed;
    }

    // ... other contract code ...

    enum RequestStatus { Active, Executed }
    enum RequestType { Invest, Redeem, TokenFallbackRedeem }

    // ... other state variables ...
    mapping(uint => Request) public requests;
    mapping(address => Participant) public participants;
    PriceFeed public priceFeed;
    uint public totalSupply;
    uint public priceFeedInterval;
    bool public shutDown;

    struct Request {
        uint id;
        address asset;
        uint shareQuantity;
        uint timestamp;
        uint updateId;
        RequestType type;
        RequestStatus status;
    }

    struct Participant {
        uint balance;
        uint shareBalance;
    }
}",44.63209891319275,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    // Assume necessary contracts and interfaces are defined elsewhere, e.g., PriceFeed, Request, etc.

    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    uint256 public constant DEFAULT_UINT256 = 1;
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    uint256 public totalSupply;

 constructor() {
        // Initialize Ownable contract
        Ownable(msg.sender);
    }

    function executeRequest(uint id) public {
        Request storage request = requests[id];

        require(!shutDown, ""System is shut down"");
        require(request.status == RequestStatus.Active, ""Request is not active"");

        if (request.type == RequestType.Redeem) {
            require(participants[msg.sender].shareBalance <= participants[msg.sender].balance, ""Insufficient balance"");
        }

        require(totalSupply == 0 || block.timestamp >= request.timestamp + priceFeedInterval && priceFeed.lastUpdateId() >= request.updateId + 2, ""Price feed update required"");

        // Retrieve price from price feed
        uint price = priceFeed.getPrice(request.asset);

        // Calculate cost quantity
        uint costQuantity = request.shareQuantity * price; // Add fee calculation here if needed

        // Adjust for native asset if necessary
        if (request.asset == address(0)) {
            // Add logic to adjust costQuantity based on inverted price and decimals
        }

        if (request.type == RequestType.Invest) {
            // Ensure investment is allowed
            // Transfer funds from participant to contract
            // Create shares
        } else if (request.type == RequestType.Redeem) {
            // Ensure redemption is allowed
            // Transfer funds from contract to participant
            // Annihilate shares
        } else if (request.type == RequestType.TokenFallbackRedeem) {
            // Ensure redemption is allowed
            // Transfer funds from contract to participant
            // Annihilate shares (from contract itself)
        }

        request.status = RequestStatus.Executed;
    }

    // ... other contract code ...

    enum RequestStatus { Active, Executed }
    enum RequestType { Invest, Redeem, TokenFallbackRedeem }

    // ... other state variables ...
    mapping(uint => Request) public requests;
    mapping(address => Participant) public participants;
    PriceFeed public priceFeed;
    uint public totalSupply;
    uint public priceFeedInterval;
    bool public shutDown;

    struct Request {
        uint id;
        address asset;
        uint shareQuantity;
        uint timestamp;
        uint updateId;
        RequestType type;
        RequestStatus status;
    }

    struct Participant {
        uint balance;
        uint shareBalance;
    }
}"
2205,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorContract is Ownable {
    using SafeMath for uint256;

    struct Question {
        bytes32 questionId;
        bytes32 answer;
        address answerer;
        bool answered;
    }

    mapping(bytes32 => Question) public questions;

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external onlyOwner {
        require(!questions[question_id].answered, ""Question already answered"");
        questions[question_id] = Question({
            questionId: question_id,
            answer: answer,
            answerer: answerer,
            answered: true
        });
    }
}",hasRole,"[{'function': 'hasRole', 'complexity': 0}, {'function': 'submitAnswerOnBehalf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""hasRole"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",23.0,0.4720673879469403,0.0140826455051194,"pragma solidity ^0.8.0;

contract ArbitratorContract {

    // Define roles (replace with your actual role management mechanism)
    modifier onlyArbitrator() {
        require(hasRole(keccak256(""ARBITRATOR_ROLE""), msg.sender), ""Caller is not an arbitrator"");
        _;
    }

    function hasRole(bytes32 role, address account) internal view virtual returns (bool) {
        // Replace with your actual role check implementation
        // This is a placeholder.  You'll need to integrate with your chosen access control system.
        return true; // Replace with actual role check
    }


    function submitAnswerOnBehalf(uint256 question_id, bytes32 answer, address answerer) external onlyArbitrator {
    }
}",41.71497392654419,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ArbitratorContract is Ownable {
    // Define roles (replace with your actual role management mechanism)
    modifier onlyArbitrator() {
        require(hasRole(keccak256(""ARBITRATOR_ROLE""), msg.sender), ""Caller is not an arbitrator"");
        _;
    }

    function hasRole(bytes32 role, address account) internal view virtual returns (bool) {
        // Replace with your actual role check implementation
        // This is a placeholder.  You'll need to integrate with your chosen access control system.
        return true; // Replace with actual role check
    }

    function submitAnswerOnBehalf(uint256 question_id, bytes32 answer, address answerer) external onlyArbitrator {
    }
}"
6381,Calls transferFrom on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface CompatibleERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
        CompatibleERC20(token).transferFrom(from, to, amount);
        require(previousReturnValue(), ""transferFrom failed"");
    }
}",previousReturnValue,"[{'function': 'safeTransferFrom', 'complexity': 1}, {'function': 'previousReturnValue', 'complexity': 0}]",3.0,{},26.0,0.7113500345878754,0.0287231936430431,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

function safeTransferFrom(address token, address from, address to, uint256 amount) public {
    IERC20(token).transferFrom(from, to, amount);
    require(previousReturnValue(), ""transferFrom failed"");
}

function previousReturnValue() internal pure returns (bool) {
    assembly {
        switch returndatasize()
        case 0 {
            return(0, 0)
        }
        case 32 {
            returndatacopy(0, 0, 32)
            return(0, 32)
        }
        default {
            revert(0, 0)
        }
    }
}",42.00635242462158,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

function safeTransferFrom(address token, address from, address to, uint256 amount) public {
    IERC20(token).transferFrom(from, to, amount);
    require(previousReturnValue(), ""transferFrom failed"");
}

function previousReturnValue() internal pure returns (bool) {
    assembly {
        switch returndatasize()
        case 0 {
            return(0, 0)
        }
        case 32 {
            returndatacopy(0, 0, 32)
            return(0, 32)
        }
        default {
            revert(0, 0)
        }
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant SOME_CONSTANT = 1;
    address public constant SOME_ADDRESS_1 = address(0x111);
    address public constant SOME_ADDRESS_2 = address(0x222);
    address public constant SOME_ADDRESS_3 = address(0x333);
    bool public initialized = true;
    bytes32 public constant INITIALIZED_BYTES = bytes32('init');

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already set in the declaration or using constants.
    }
}"
5030,Slashes the bond of a guilty trader .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOrderbookContract {
    function orderMatch(bytes32 _orderID) external returns (bytes32);
    function orderTrader(bytes32 _orderID) external view returns (address);
}

interface IRenExBalancesContract {
    function transferBalanceWithFee(address _to, address _from, address _tokenAddress, uint256 _amount, uint256 _fee, bytes32 _data) external;
}

abstract contract Slasher is Ownable {
    using SafeMath for uint256;

    IOrderbookContract public orderbookContract;
    IRenExBalancesContract public renExBalancesContract;
    address public slasherAddress;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = 0x0;

    enum OrderStatus { Pending, Settled, Slashed }

    struct TokenPair {
        address tokenA;
        address tokenB;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftTokenFee;
    }

    mapping(bytes32 => OrderStatus) public orderStatus;
    mapping(bytes32 => bytes32) public orderDetails;

    function slash(bytes32 _guiltyOrderID) external onlyOwner {
        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, ""slashing non-atomic trade"");
        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, ""invalid order status"");
        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);
        require(orderStatus[innocentOrderID] == OrderStatus.Settled, ""invalid order status"");
        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;
        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ? (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);
        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);
        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), orderbookContract.orderTrader(innocentOrderID), settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), slasherAddress, settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
    }
}",slash,"[{'function': 'slash', 'complexity': 3}, {'function': 'determineOrderSides', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""slash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_guiltyOrderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""memberName"": ""getSettlementID""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""RENEX_ATOMIC_SETTLEMENT_ID""}}, {""type"": ""stringLiteral"", ""value"": ""Not an atomic trade""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""innocentOrderID"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""memberName"": ""getMatchingOrderID""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""memberName"": ""getOrderStatus""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""OrderStatus""}, ""memberName"": ""Settled""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""memberName"": ""getOrderStatus""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""innocentOrderID""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""OrderStatus""}, ""memberName"": ""Settled""}}}, {""type"": ""stringLiteral"", ""value"": ""Orders not settled""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""isBuy"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130d5240>}, {""type"": ""VariableDeclaration"", ""name"": ""guiltyTrader"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130d7930>}, {""type"": ""VariableDeclaration"", ""name"": ""innocentTrader"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130d6890>}, {""type"": ""VariableDeclaration"", ""name"": ""tokenA"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130d6190>}, {""type"": ""VariableDeclaration"", ""name"": ""tokenB"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130d54e0>}, {""type"": ""VariableDeclaration"", ""name"": ""amountA"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130d5c50>}, {""type"": ""VariableDeclaration"", ""name"": ""amountB"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130d4c20>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""determineOrderSides""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""guiltyFeeA"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130dd630>}, {""type"": ""VariableDeclaration"", ""name"": ""guiltyFeeB"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1130df0e0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAtomicFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountA""}, {""type"": ""Identifier"", ""name"": ""amountB""}, {""type"": ""Identifier"", ""name"": ""isBuy""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""innocentFeeA"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1134af4d0>}, {""type"": ""VariableDeclaration"", ""name"": ""innocentFeeB"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1134af700>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAtomicFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountA""}, {""type"": ""Identifier"", ""name"": ""amountB""}, {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isBuy""}, ""isPrefix"": True}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""guiltyTrader""}, {""type"": ""Identifier"", ""name"": ""innocentTrader""}, {""type"": ""Identifier"", ""name"": ""tokenA""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""amountA""}, ""right"": {""type"": ""Identifier"", ""name"": ""guiltyFeeA""}}, {""type"": ""Identifier"", ""name"": ""innocentFeeA""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""guiltyTrader""}, {""type"": ""Identifier"", ""name"": ""innocentTrader""}, {""type"": ""Identifier"", ""name"": ""tokenB""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""amountB""}, ""right"": {""type"": ""Identifier"", ""name"": ""guiltyFeeB""}}, {""type"": ""Identifier"", ""name"": ""innocentFeeB""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""guiltyTrader""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""tokenA""}, {""type"": ""Identifier"", ""name"": ""guiltyFeeA""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""guiltyTrader""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""tokenB""}, {""type"": ""Identifier"", ""name"": ""guiltyFeeB""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""memberName"": ""setOrderStatus""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""OrderStatus""}, ""memberName"": ""Slashed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlySlasher"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",89.0,0.7833748888300217,0.1039066152466134,"pragma solidity ^0.8.0;

// Assume necessary contracts and interfaces are defined elsewhere, such as OrderBook, TokenRegistry, etc.
// Assume necessary enums like OrderStatus are defined elsewhere.
// Assume modifiers like onlySlasher and other helper functions (calculateAtomicFees, transferBalanceWithFee) are defined elsewhere.

contract Slasher {

    // ... other contract elements ...

    function slash(bytes32 _guiltyOrderID) public onlySlasher {
        require(orderBook.getSettlementID(_guiltyOrderID) == RENEX_ATOMIC_SETTLEMENT_ID, ""Not an atomic trade"");

        bytes32 innocentOrderID = orderBook.getMatchingOrderID(_guiltyOrderID);
        require(orderBook.getOrderStatus(_guiltyOrderID) == OrderStatus.Settled && orderBook.getOrderStatus(innocentOrderID) == OrderStatus.Settled, ""Orders not settled"");

        (bool isBuy, address guiltyTrader, address innocentTrader, address tokenA, address tokenB, uint256 amountA, uint256 amountB) = determineOrderSides(_guiltyOrderID);

        (uint256 guiltyFeeA, uint256 guiltyFeeB) = calculateAtomicFees(amountA, amountB, isBuy);
        (uint256 innocentFeeA, uint256 innocentFeeB) = calculateAtomicFees(amountA, amountB, !isBuy);

        transferBalanceWithFee(guiltyTrader, innocentTrader, tokenA, amountA - guiltyFeeA, innocentFeeA);
        transferBalanceWithFee(guiltyTrader, innocentTrader, tokenB, amountB - guiltyFeeB, innocentFeeB);
        transferBalanceWithFee(guiltyTrader, address(this), tokenA, guiltyFeeA, 0);
        transferBalanceWithFee(guiltyTrader, address(this), tokenB, guiltyFeeB, 0);

        orderBook.setOrderStatus(_guiltyOrderID, OrderStatus.Slashed);
    }


    //Helper function to determine order sides
    function determineOrderSides(bytes32 _guiltyOrderID) internal view returns (bool, address, address, address, address, uint256, uint256) {
        //Implementation to determine buy/sell, traders, tokens, and amounts based on _guiltyOrderID.  This will depend on your OrderBook contract's structure.
        //Example (replace with your actual logic):
        //Order order = orderBook.getOrder(_guiltyOrderID);
        //return (order.isBuy, order.trader, order.counterParty, order.tokenA, order.tokenB, order.amountA, order.amountB);
    }

    // ... other contract elements ...
}",44.92575120925903,"pragma solidity ^0.8.0;

// Assume necessary contracts and interfaces are defined elsewhere, such as OrderBook, TokenRegistry, etc.
// Assume necessary enums like OrderStatus are defined elsewhere.
// Assume modifiers like onlySlasher and other helper functions (calculateAtomicFees, transferBalanceWithFee) are defined elsewhere.
import ""openzeppelin/SafeMath.sol"";
contract Slasher {
    // Fixed values for initialization
    address public constant owner = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = bytes32('RENEX_ATOMIC_SETTLEMENT_ID');
    bool public constant initialized = true;

    // Other contract elements ...

    constructor() Ownable(msg.sender) {
        // Initialize other variables here if needed
    }

    function slash(bytes32 _guiltyOrderID) public onlySlasher {
        require(orderBook.getSettlementID(_guiltyOrderID) == RENEX_ATOMIC_SETTLEMENT_ID, ""Not an atomic trade"");

        bytes32 innocentOrderID = orderBook.getMatchingOrderID(_guiltyOrderID);
        require(orderBook.getOrderStatus(_guiltyOrderID) == OrderStatus.Settled && orderBook.getOrderStatus(innocentOrderID) == OrderStatus.Settled, ""Orders not settled"");

        (bool isBuy, address guiltyTrader, address innocentTrader, address tokenA, address tokenB, uint256 amountA, uint256 amountB) = determineOrderSides(_guiltyOrderID);

        (uint256 guiltyFeeA, uint256 guiltyFeeB) = calculateAtomicFees(amountA, amountB, isBuy);
        (uint256 innocentFeeA, uint256 innocentFeeB) = calculateAtomicFees(amountA, amountB, !isBuy);

        transferBalanceWithFee(guiltyTrader, innocentTrader, tokenA, amountA - guiltyFeeA, innocentFeeA);
        transferBalanceWithFee(guiltyTrader, innocentTrader, tokenB, amountB - guiltyFeeB, innocentFeeB);
        transferBalanceWithFee(guiltyTrader, address(this), tokenA, guiltyFeeA, 0);
        transferBalanceWithFee(guiltyTrader, address(this), tokenB, guiltyFeeB, 0);

        orderBook.setOrderStatus(_guiltyOrderID, OrderStatus.Slashed);
    }

    //Helper function to determine order sides
    function determineOrderSides(bytes32 _guiltyOrderID) internal view returns (bool, address, address, address, address, uint256, uint256) {
        //Implementation to determine buy/sell, traders, tokens, and amounts based on _guiltyOrderID.  This will depend on your OrderBook contract's structure.
        //Example (replace with your actual logic):
        //Order order = orderBook.getOrder(_guiltyOrderID);
        //return (order.isBuy, order.trader, order.counterParty, order.tokenA, order.tokenB, order.amountA, order.amountB);
    }

    // ... other contract elements ...
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;

    constructor(address _owner) {
        owner = _owner;
    }
}"
3520,Submit the arbitrator 's answer to a question .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RealityCheck {
    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external;
}

abstract contract ArbitrationWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => bool) public arbitration_bounties;
    RealityCheck public realitycheck;

    constructor(address _realityCheckAddress) {
        realitycheck = RealityCheck(_realityCheckAddress);
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) public onlyOwner {
        delete arbitration_bounties[question_id];
        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
    }
}",pose,"[{'function': 'pose', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""answer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""answerer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""arbitration_bounties""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""realitycheck""}, ""memberName"": ""submitAnswerByArbitrator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}, {""type"": ""Identifier"", ""name"": ""answerer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9175472207516404,0.9304899483313592,"pragma solidity ^0.8.0;

contract MyContract {

    address public owner;
    mapping(bytes32 => uint256) public arbitration_bounties;
    RealityCheck public realitycheck;

    constructor(address _realitycheckAddress) {
        owner = msg.sender;
        realitycheck = RealityCheck(_realitycheckAddress);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function pose(bytes32 question_id, bytes32 answer, address answerer) public onlyOwner {
        delete arbitration_bounties[question_id];
        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
    }

    interface RealityCheck {
        function submitAnswerByArbitrator(bytes32 questionId, bytes32 answer, address answerer) external;
    }
}",42.018367290496826,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {

    address public owner;
    mapping(bytes32 => uint256) public arbitration_bounties;
    RealityCheck public realitycheck;

    constructor(address _realitycheckAddress) {
        owner = msg.sender;
        realitycheck = RealityCheck(_realitycheckAddress);
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function pose(bytes32 question_id, bytes32 answer, address answerer) public onlyOwner {
        delete arbitration_bounties[question_id];
        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
    }

    interface RealityCheck {
        function submitAnswerByArbitrator(bytes32 questionId, bytes32 answer, address answerer) external;
    }
}"
4614,Withdraw nomins : Allows the owner to withdraw nomins from this contract if needed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawNomins(uint amount) external onlyOwner {
        require(address(nomin).balance >= amount, ""Insufficient balance"");
        nomin.transfer(owner(), amount);
    }
}",withdrawNomins,"[{'function': 'withdrawNomins', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawNomins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nominToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.7825000422377413,0.2685223279556957,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract NominWithdrawal is Ownable {

    IERC20 public nominToken;

    constructor(address _nominTokenAddress) {
        nominToken = IERC20(_nominTokenAddress);
    }

    function withdrawNomins(uint256 amount) public onlyOwner {
        nominToken.transfer(owner(), amount);
    }
}",41.659968852996826,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NominWithdrawal is Ownable {
    IERC20 public nominToken;

    constructor(address _nominTokenAddress) Ownable(msg.sender) {
        nominToken = IERC20(_nominTokenAddress);
    }

    function withdrawNomins(uint256 amount) public onlyOwner {
        nominToken.transfer(owner(), amount);
    }
}"
1147,"Return the final answer to the specified question , provided it matches the specified criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorWrapper {
    using SafeMath for uint256;

    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        bytes32 best_answer;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) external constant returns (bytes32) {
        require(content_hash == questions[question_id].content_hash);
        require(arbitrator == questions[question_id].arbitrator);
        require(min_timeout <= questions[question_id].timeout);
        require(min_bond <= questions[question_id].bond);
        return questions[question_id].best_answer;
    }
}",getFinalAnswerIfMatches,"[{'function': 'getFinalAnswerIfMatches', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getFinalAnswerIfMatches"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""content_hash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""arbitrator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""min_timeout"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""min_bond"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Question""}, ""name"": ""q"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""q""}, ""memberName"": ""content_hash""}, ""right"": {""type"": ""Identifier"", ""name"": ""content_hash""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""q""}, ""memberName"": ""arbitrator""}, ""right"": {""type"": ""Identifier"", ""name"": ""arbitrator""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""q""}, ""memberName"": ""timeout""}, ""right"": {""type"": ""Identifier"", ""name"": ""min_timeout""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""q""}, ""memberName"": ""bond""}, ""right"": {""type"": ""Identifier"", ""name"": ""min_bond""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""q""}, ""memberName"": ""best_answer""}]}, ""FalseBody"": None}, {""type"": ""stringLiteral"", ""value"": """"}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",36.0,0.7196934469632854,0.3993270779908248,"pragma solidity ^0.8.0;

contract QuestionContract {

    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        bytes32 best_answer;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) public view returns (bytes32) {
        Question memory q = questions[question_id];
        if (q.content_hash == content_hash && q.arbitrator == arbitrator && q.timeout >= min_timeout && q.bond >= min_bond) {
            return q.best_answer;
        }
        return """";
    }
}",42.03696632385254,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract QuestionContract is Ownable {
    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        bytes32 best_answer;
    }

    mapping(bytes32 => Question) public questions;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) public view returns (bytes32) {
        Question memory q = questions[question_id];
        if (q.content_hash == content_hash && q.arbitrator == arbitrator && q.timeout >= min_timeout && q.bond >= min_bond) {
            return q.best_answer;
        }
        return """";
    }
}"
6458,This works even if sender does n't own any tokens at the time .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerToOperators;

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        require(_operator != address(0), ""Operator address must be non-zero"");
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    modifier onlyNonZeroAddress(address addr) {
        require(addr != address(0), ""Address must be non-zero"");
        _;
    }
}",setApprovalForAll,"[{'function': 'setApprovalForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerToOperators""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyNonZeroAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.8766464103219075,0.5429669156200999,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(address => mapping(address => bool)) public ownerToOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    modifier onlyNonZeroAddress(address _address) {
        require(_address != address(0), ""Address cannot be zero"");
        _;
    }

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}",41.76720857620239,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => mapping(address => bool)) public ownerToOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    modifier onlyNonZeroAddress(address _address) {
        require(_address != address(0), ""Address cannot be zero"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        ownerToOperators[address(0x111)][address(0x222)] = true;
        ownerToOperators[address(0x222)][address(0x333)] = true;
    }

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}"
732,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) external onlyOwner {
        require(_to != address(0), ""Invalid recipient address"");
        (bool success, ) = _to.call{value: _value}(_data);
        require(success, ""Transfer failed"");
        if (_log.length > 0) {
            emit LogData(_log);
        }
    }

    event LogData(bytes log);
}",forceTransfer,"[{'function': 'forceTransfer', 'complexity': 0}, {'function': '_processTransferData', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""forceTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_log"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_processTransferData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}, {""type"": ""Identifier"", ""name"": ""_log""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.6814306715744376,0.2185165925833894,"pragma solidity ^0.8.0;

contract Token {

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    mapping(address => uint256) public balances;

    function forceTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _log) external {
        balances[_from] -= _value;
        balances[_to] += _value;
        emit Transfer(_from, _to, _value);
        _processTransferData(_data, _log);
    }

    function _processTransferData(bytes memory _data, bytes memory _log) internal virtual {
        //Additional logic to process _data and _log can be added here.
    }
}",41.95782399177551,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    mapping(address => uint256) public balances;
    address public owner;
    bool public initialized;
    bytes32 public constantInitValue = bytes32('init');

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000; // Set to a non-zero value
        owner = msg.sender;
        initialized = true;
    }

    function forceTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _log) external {
        require(initialized, ""Contract has not been initialized"");
        balances[_from] -= _value;
        balances[_to] += _value;
        emit Transfer(_from, _to, _value);
        _processTransferData(_data, _log);
    }

    function _processTransferData(bytes memory _data, bytes memory _log) internal virtual {
        //Additional logic to process _data and _log can be added here.
    }
}"
442,"Ends the auction , preventing new bids from entering","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Auction {
    using SafeMath for uint256;

    enum state { active, ended }
    state public status;

    constructor() {
        status = state.active;
    }

    function endAuction() public onlyOwner {
        require(status == state.active);
        status = state.ended;
        emit Ended(block.number);
    }

    event Ended(uint256 indexed blockNumber);
}",endAuction,"[{'function': 'endAuction', 'complexity': 1}, {'function': 'owner', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""endAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""auctionStatus""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Status""}, ""memberName"": ""active""}}, {""type"": ""stringLiteral"", ""value"": ""Auction is not active""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""auctionStatus""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Status""}, ""memberName"": ""ended""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Ended""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.893210540674241,0.5013053504161699,"pragma solidity ^0.8.0;

contract Auction {

    enum Status { inactive, active, ended }
    Status public auctionStatus;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address payable private owner;

    constructor() {
        owner = payable(msg.sender);
        auctionStatus = Status.inactive;
    }

    function endAuction() public onlyOwner {
        require(auctionStatus == Status.active, ""Auction is not active"");
        auctionStatus = Status.ended;
        emit Ended(block.number);
    }

    event Ended(uint256 blockNumber);

    function owner() public view returns (address payable) {
        return owner;
    }
}",41.93015885353088,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {

    enum Status { inactive, active, ended }
    Status public auctionStatus;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address payable private owner;

    constructor() Ownable(msg.sender) {
        owner = payable(msg.sender);
        auctionStatus = Status.inactive;
    }

    function endAuction() public onlyOwner {
        require(auctionStatus == Status.active, ""Auction is not active"");
        auctionStatus = Status.ended;
        emit Ended(block.number);
    }

    event Ended(uint256 blockNumber);

    function owner() public view returns (address payable) {
        return owner;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    constructor(address owner_) {
        _owner = owner_;
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}"
3580,Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeValidator {
    using SafeMath for uint256;

    uint256 private _totalAttributeTypes;
    uint256 private _maxValue;
    uint256 private _maxFundsRequired;
    uint256 private _maxValidatorFee;
    uint256 private _signatureLength;

    constructor(uint256 totalAttributeTypes, uint256 maxValue, uint256 maxFundsRequired, uint256 maxValidatorFee, uint256 signatureLength) {
        require(totalAttributeTypes > 0, ""Invalid total attribute types"");
        require(maxValue > 0, ""Invalid maximum value"");
        require(maxFundsRequired > 0, ""Invalid maximum funds required"");
        require(maxValidatorFee >= 0, ""Invalid maximum validator fee"");
        require(signatureLength > 0, ""Invalid signature length"");

        _totalAttributeTypes = totalAttributeTypes;
        _maxValue = maxValue;
        _maxFundsRequired = maxFundsRequired;
        _maxValidatorFee = maxValidatorFee;
        _signatureLength = signatureLength;
    }

    function canAddAttributeFor(address account, uint256 attributeTypeID, uint256 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) external view returns (bool) {
        require(account != address(0), ""Invalid account address"");
        require(attributeTypeID > 0 && attributeTypeID <= _totalAttributeTypes, ""Invalid attribute type ID"");
        require(value >= 0 && value <= _maxValue, ""Invalid value"");
        require(fundsRequired >= 0 && fundsRequired <= _maxFundsRequired, ""Invalid funds required"");
        require(validatorFee >= 0 && validatorFee <= _maxValidatorFee, ""Invalid validator fee"");
        require(signature.length == _signatureLength, ""Invalid signature length"");

        uint256 currentBalance = getCurrentBalanceForAccount(account);
        require(currentBalance >= fundsRequired, ""Insufficient funds"");

        bool isAttributeAdded = isAttributeAlreadyAddedForAccount(account, attributeTypeID);
        require(!isAttributeAdded, ""Attribute already added"");

        return true;
    }

    function getCurrentBalanceForAccount(address account) internal view returns (uint256) {
        // Implement the logic to get the current balance of the account
        // This is a placeholder for the actual implementation
        return 0;
    }

    function isAttributeAlreadyAddedForAccount(address account, uint256 attributeTypeID) internal view returns (bool) {
        // Implement the logic to check if the attribute is already added for the account
        // This is a placeholder for the actual implementation
        return false;
    }
}",canAddAttributeFor,"[{'function': 'canAddAttributeFor', 'complexity': 4}, {'function': 'validateSignature', 'complexity': 0}, {'function': 'hasAttribute', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""canAddAttributeFor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fundsRequired"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""validatorFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""fundsRequired""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""validateSignature""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""attributeTypeID""}, {""type"": ""Identifier"", ""name"": ""value""}, {""type"": ""Identifier"", ""name"": ""fundsRequired""}, {""type"": ""Identifier"", ""name"": ""validatorFee""}, {""type"": ""Identifier"", ""name"": ""signature""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasAttribute""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""attributeTypeID""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Attribute already exists""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",68.0,0.6562212513124289,0.2490017331389045,"pragma solidity ^0.8.0;

contract AttributeValidator {

    function canAddAttributeFor(address account, uint256 attributeTypeID, bytes32 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) public view returns (bool) {
        require(msg.value >= fundsRequired, ""Insufficient funds"");
        // Replace this with your actual signature validation logic
        require(validateSignature(account, attributeTypeID, value, fundsRequired, validatorFee, signature), ""Invalid signature"");
        // Replace this with your actual check for existing attribute
        require(!hasAttribute(account, attributeTypeID), ""Attribute already exists"");
        return true;
    }

    // Placeholder functions - replace with your actual implementations
    function validateSignature(address account, uint256 attributeTypeID, bytes32 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) internal pure returns (bool) {
        //Implement your signature validation logic here.  This is a placeholder.
        return true;
    }

    function hasAttribute(address account, uint256 attributeTypeID) internal pure returns (bool) {
        //Implement your attribute existence check here. This is a placeholder.
        return false;
    }
}",42.6016960144043,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttributeValidator is Ownable {
    // State variables
    uint256 public constant FUNDS_REQUIRED = 1 ether;
    uint256 public constant VALIDATOR_FEE = 0.1 ether;
    bytes32 public constant INITIALIZED = keccak256(abi.encodePacked(""init""));

    // Constructor
    constructor() Ownable(msg.sender) {
        // Initialize state variables
        fundsRequired = FUNDS_REQUIRED;
        validatorFee = VALIDATOR_FEE;
        initialized = INITIALIZED;
    }

    // State variables
    uint256 public fundsRequired;
    uint256 public validatorFee;
    bytes32 public initialized;

    function canAddAttributeFor(address account, uint256 attributeTypeID, bytes32 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) public payable returns (bool) {
        require(msg.value >= fundsRequired, ""Insufficient funds"");
        // Replace this with your actual signature validation logic
        require(validateSignature(account, attributeTypeID, value, fundsRequired, validatorFee, signature), ""Invalid signature"");
        // Replace this with your actual check for existing attribute
        require(!hasAttribute(account, attributeTypeID), ""Attribute already exists"");
        return true;
    }

    // Placeholder functions - replace with your actual implementations
    function validateSignature(address account, uint256 attributeTypeID, bytes32 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) internal pure returns (bool) {
        //Implement your signature validation logic here.  This is a placeholder.
        return true;
    }

    function hasAttribute(address account, uint256 attributeTypeID) internal pure returns (bool) {
        //Implement your attribute existence check here. This is a placeholder.
        return false;
    }
}"
3476,Called when tokens have to be burned ( only after sale ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    bool public locked = false;
    string public contractName;
    address public depositAddress;
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    event TokensBurned(address indexed from, address indexed to, uint256 value);

    function burnTokens(uint256 _tokens) external {
        require(!locked, ""Contract is locked"");
        require(contractManager.authorize(contractName, msg.sender), ""Unauthorized access"");
        require(depositAddress != address(0), ""Deposit address not set"");
        require(_tokens != 0, ""Tokens amount must be greater than zero"");
        require(_tokens <= balances[depositAddress], ""Insufficient balance to burn tokens"");

        balances[depositAddress] = balances[depositAddress].sub(_tokens);
        totalSupply_ = totalSupply_.sub(_tokens);
        emit TokensBurned(msg.sender, depositAddress, _tokens);
    }
}",burnTokens,"[{'function': 'burnTokens', 'complexity': 3}, {'function': 'setAuthorizedUser', 'complexity': 0}, {'function': 'setLock', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_depositAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_depositAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_depositAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokens""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_depositAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_depositAddress""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensBurned""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_depositAddress""}, {""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuthorized"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_depositAddress""}]}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotLocked"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.8953399395754129,0.3496376316812139,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    bool public locked;
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    mapping(address => bool) public authorizedUsers;

    event TokensBurned(address indexed sender, address indexed depositAddress, uint256 amount);

    modifier onlyAuthorized(address _contractName) {
        require(authorizedUsers[msg.sender], ""Unauthorized"");
        _;
    }

    modifier whenNotLocked() {
        require(!locked, ""Contract is locked"");
        _;
    }

    function burnTokens(address _depositAddress, uint256 _tokens) public onlyAuthorized(_depositAddress) whenNotLocked {
        require(_depositAddress != address(0), ""Zero address"");
        require(_tokens > 0, ""Amount must be greater than zero"");
        require(balances[_depositAddress] >= _tokens, ""Insufficient balance"");

        balances[_depositAddress] = balances[_depositAddress].sub(_tokens);
        totalSupply = totalSupply.sub(_tokens);

        emit TokensBurned(msg.sender, _depositAddress, _tokens);
    }

    function setAuthorizedUser(address _user, bool _authorized) public {
        // Add logic to restrict who can call this function (e.g., onlyOwner)
        authorizedUsers[_user] = _authorized;
    }

    function setLock(bool _locked) public {
        // Add logic to restrict who can call this function (e.g., onlyOwner)
        locked = _locked;
    }
}",43.1612708568573,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    bool public locked;
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    mapping(address => bool) public authorizedUsers;

    event TokensBurned(address indexed sender, address indexed depositAddress, uint256 amount);

    modifier onlyAuthorized(address _contractName) {
        require(authorizedUsers[msg.sender], ""Unauthorized"");
        _;
    }

    modifier whenNotLocked() {
        require(!locked, ""Contract is locked"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        balances[msg.sender] = 1000; // Set initial balance to 1
        totalSupply = 1000000000000000000; // Set initial total supply to 1
        authorizedUsers[msg.sender] = true; // Set initial authorization status to true

        // Initialize ERC20-like contract (replace with actual token implementation)
        string public constant tokenName = ""MyToken"";
        bytes32 public constant tokenSymbol = bytes32('TKN');
    }

    function burnTokens(address _depositAddress, uint256 _tokens) public onlyAuthorized(_depositAddress) whenNotLocked {
        require(_depositAddress != address(0), ""Zero address"");
        require(_tokens > 0, ""Amount must be greater than zero"");
        require(balances[_depositAddress] >= _tokens, ""Insufficient balance"");

        balances[_depositAddress] = balances[_depositAddress].sub(_tokens);
        totalSupply = totalSupply.sub(_tokens);

        emit TokensBurned(msg.sender, _depositAddress, _tokens);
    }

    function setAuthorizedUser(address _user, bool _authorized) public {
        // Add logic to restrict who can call this function (e.g., onlyOwner)
        authorizedUsers[_user] = _authorized;
    }

    function setLock(bool _locked) public {
        // Add logic to restrict who can call this function (e.g., onlyOwner)
        locked = _locked;
    }
}"
1148,Reusable code to do sanity check of transfer variables,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TransferCheckWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    bool public tokenTransfersFrozen;

    function transferCheck(address _sender, address _receiver, uint256 _amount) external view returns (bool success) {
        require(!tokenTransfersFrozen, ""Token transfers are frozen"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_receiver != address(0), ""Receiver address cannot be the zero address"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        require(balances[_receiver] + _amount > balances[_receiver], ""Transfer amount exceeds available balance"");
        return true;
    }
}",transferCheck,"[{'function': 'transferCheck', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferCheck"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""tokenTransfersFrozen""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Token transfers are frozen""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_receiver""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Receiver address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_receiver""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_receiver""}}}, {""type"": ""stringLiteral"", ""value"": ""Transfer would overflow""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""private"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""constant""}",0.0,0.980015842740744,0.7952829676979963,"pragma solidity ^0.8.0;

contract MyContract {
    bool public tokenTransfersFrozen;
    mapping(address => uint256) public balances;

    function transferCheck(address _sender, address _receiver, uint256 _amount) private constant returns (bool) {
        require(!tokenTransfersFrozen, ""Token transfers are frozen"");
        require(_amount > 0, ""Transfer amount must be greater than zero"");
        require(_receiver != address(0), ""Receiver address cannot be zero"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        require(balances[_receiver] + _amount > balances[_receiver], ""Transfer would overflow"");
        return true;
    }
}",41.836068868637085,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool public tokenTransfersFrozen;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        tokenTransfersFrozen = false;
        balances[owner()] = 1; // Initialize the balance of the owner to 1
        balances[address(0x111)] = 1; // Initialize a fixed address with value 1
        balances[address(0x222)] = 1; // Initialize another fixed address with value 1
        balances[address(0x333)] = 1; // Initialize the third fixed address with value 1
    }

    function transferCheck(address _sender, address _receiver, uint256 _amount) private constant returns (bool) {
        require(!tokenTransfersFrozen, ""Token transfers are frozen"");
        require(_amount > 0, ""Transfer amount must be greater than zero"");
        require(_receiver != address(0), ""Receiver address cannot be zero"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        require(balances[_receiver] + _amount > balances[_receiver], ""Transfer would overflow"");
        return true;
    }
}"
5952,Sets the contract that will handle a specific interface ; only the address itself or a ` manager ` defined for that address can set it,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InterfaceImplementerWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed iHash, address implementer);

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public onlyOwner {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }
}",canManage,"[{'function': 'canManage', 'complexity': 0}, {'function': 'setInterfaceImplementer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInterfaceImplementer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""iHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""implementer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""interfaces""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""index"": {""type"": ""Identifier"", ""name"": ""iHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""implementer""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InterfaceImplementerSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}, {""type"": ""Identifier"", ""name"": ""iHash""}, {""type"": ""Identifier"", ""name"": ""implementer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.6429831943226236,0.0422207626648699,"pragma solidity ^0.8.0;

contract InterfaceRegistry {

    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address addr, bytes32 iHash, address implementer);

    modifier onlyManager(address addr) {
        require(canManage(addr), ""Not authorized to manage this address"");
        _;
    }

    function canManage(address addr) internal view virtual returns (bool) {
        // Replace with your actual access control logic
        return msg.sender == addr;
    }

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public onlyManager(addr) {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }
}",41.89624094963074,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract InterfaceRegistry is Ownable {
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address addr, bytes32 iHash, address implementer);

    modifier onlyManager(address addr) {
        require(canManage(addr), ""Not authorized to manage this address"");
        _;
    }

    function canManage(address addr) internal view virtual returns (bool) {
        // Replace with your actual access control logic
        return msg.sender == addr;
    }

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public onlyManager(addr) {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
5131,Function to know how many tokens you will receive at current time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenPrice {
    function USD(uint256 index) external view returns (uint256);
}

abstract contract TokenCalculator is Ownable {
    using SafeMath for uint256;

    ITokenPrice public price;

    constructor(address _priceAddress) {
        price = ITokenPrice(_priceAddress);
    }

    function calculateTokens(uint256 _amountOfWei) public view returns (uint256) {
        require(_amountOfWei >= 1 szabo, ""Amount must be at least 1 szabo"");
        uint256 tokenBought;
        uint256 tokenPrice = price.USD(0);
        tokenPrice = tokenPrice.mul(36).div(10 ** 8);
        tokenBought = _amountOfWei.div(tokenPrice);
        tokenBought = tokenBought.mul(10 ** 10);
        if (_amountOfWei >= 10 ether) {
            tokenBought = tokenBought.mul(123).div(100);
        } else if (_amountOfWei >= 1 ether) {
            tokenBought = tokenBought.mul(11).div(10);
        }
        return tokenBought;
    }
}",calculateTokens,"[{'function': 'USD', 'complexity': 0}, {'function': 'calculateTokens', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountOfWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1e12"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be at least 1 szabo""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenPriceUSD"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""priceContract""}, ""memberName"": ""USD""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""adjustedPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenPriceUSD""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""36"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""8"", ""subdenomination"": None}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensBought"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""adjustedPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""*="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""123"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""11"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}}}]}, ""FalseBody"": None}}, {""type"": ""Identifier"", ""name"": ""tokensBought""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",20.0,0.758158355539302,0.4156347435509322,"pragma solidity ^0.8.0;

// Assume the existence of a contract named 'Price' with a function 'USD(uint256)'
interface Price {
    function USD(uint256 _index) external view returns (uint256);
}

contract TokenCalculator {
    Price public priceContract;

    constructor(address _priceContractAddress) {
        priceContract = Price(_priceContractAddress);
    }

    function calculateTokens(uint256 _amountOfWei) public view returns (uint256) {
        require(_amountOfWei >= 1e12, ""Amount must be at least 1 szabo"");

        uint256 tokenPriceUSD = priceContract.USD(0);
        uint256 adjustedPrice = (tokenPriceUSD * 36) / 10**8;
        uint256 tokensBought = _amountOfWei / adjustedPrice;
        tokensBought *= 10**10;

        if (_amountOfWei >= 10 ether) {
            tokensBought = (tokensBought * 123) / 100;
        } else if (_amountOfWei >= 1 ether) {
            tokensBought = (tokensBought * 11) / 10;
        }

        return tokensBought;
    }
}",43.01600885391235,"pragma solidity ^0.8.0;

// Assume the existence of a contract named 'Price' with a function 'USD(uint256)'
interface Price {
    function USD(uint256 _index) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenCalculator is Ownable {
    Price public priceContract;

    constructor(address _priceContractAddress) Ownable(msg.sender) {
        require(_priceContractAddress != address(0), ""Invalid price contract address"");
        priceContract = Price(_priceContractAddress);
    }

    function calculateTokens(uint256 _amountOfWei) public view returns (uint256) {
        require(_amountOfWei >= 1e12, ""Amount must be at least 1 szabo"");

        uint256 tokenPriceUSD = priceContract.USD(0);
        uint256 adjustedPrice = (tokenPriceUSD * 36) / 10**8;
        uint256 tokensBought = _amountOfWei / adjustedPrice;
        tokensBought *= 10**10;

        if (_amountOfWei >= 10 ether) {
            tokensBought = (tokensBought * 123) / 100;
        } else if (_amountOfWei >= 1 ether) {
            tokensBought = (tokensBought * 11) / 10;
        }

        return tokensBought;
    }
}"
725,Checks whether an address is whitelisted in the competition contract and competition is active,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CompetitionWhitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public isWhitelisted;

    function isCompetitionAllowed(address user) public view returns (bool) {
        return isWhitelisted[user];
    }
}",isCompetitionAllowed,"[{'function': 'isCompetitionAllowed', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isCompetitionAllowed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isWhitelisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract Competition {

    mapping(address => bool) public isWhitelisted;

    function isCompetitionAllowed(address user) public view returns (bool) {
        return isWhitelisted[user];
    }
}",41.09882855415344,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Competition is Ownable {
    mapping(address => bool) public isWhitelisted;
    address public owner = 0x1111111111111111111111111111111111111111; // fixed address value
    uint256 public competitionId = 1; // fixed, non-zero value

    constructor() Ownable(msg.sender) {
        isWhitelisted[msg.sender] = true;
        owner = msg.sender;
    }

    function isCompetitionAllowed(address user) public view returns (bool) {
        return isWhitelisted[user];
    }
}"
3756,The sender casts a vote in favour of confiscation of the target account 's nomin balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Voting {
    function setupVote(uint motionID) external returns (uint);
}

abstract contract VoteWrapper is Ownable {
    using SafeMath for uint;

    enum Vote { None, Yea, Nay }

    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    function voteFor(uint motionID, address votingContractAddress) external {
        require(votingContractAddress.call(abi.encodeWithSignature(""setupVote(uint256)"", motionID)), ""Failed to call setupVote"");
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] = votesFor[motionID].add(1);
        emit VotedFor(msg.sender, motionID, 1);
    }
}",voteFor,"[{'function': 'voteFor', 'complexity': 0}, {'function': 'setupVote', 'complexity': 0}, {'function': 'safeAdd', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""voteFor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""motionID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""weight"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""setupVote""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""motionID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vote""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""motionID""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Vote""}, ""memberName"": ""Yea""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""votesFor""}, ""index"": {""type"": ""Identifier"", ""name"": ""motionID""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeAdd""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""votesFor""}, ""index"": {""type"": ""Identifier"", ""name"": ""motionID""}}, {""type"": ""Identifier"", ""name"": ""weight""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""VotedFor""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""motionID""}, {""type"": ""Identifier"", ""name"": ""weight""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8620728869495071,0.3386772293403342,"pragma solidity ^0.8.0;

contract MyContract {
    enum Vote { Yea, Nay, Abstain }
    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    function voteFor(uint motionID) public {
        uint weight = setupVote(motionID);
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] = safeAdd(votesFor[motionID], weight);
        emit VotedFor(msg.sender, motionID, weight);
    }

    function setupVote(uint motionID) internal returns (uint) {
        //Implementation for setupVote
        return 1; // Replace with actual weight calculation
    }


    function safeAdd(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}",42.25544738769531,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    enum Vote { Yea, Nay, Abstain }
    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            votesFor[i] = 0; // Set to 0 instead of 1 to avoid corner cases
        }
    }

    function voteFor(uint motionID) public {
        uint weight = setupVote(motionID);
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] = safeAdd(votesFor[motionID], weight);
        emit VotedFor(msg.sender, motionID, weight);
    }

    function setupVote(uint motionID) internal returns (uint) {
        //Implementation for setupVote
        return 1; // Replace with actual weight calculation
    }

    function safeAdd(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}"
4311,Sets prizes for last tokens and sets prize pool amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, WinnersAssigned, Finished }
    pointsValidationState public pValidationState;
    uint256 public gameFinishedTime;
    uint256 public adminPool;
    uint256 public prizePool;

    function setEnd() external onlyOwner checkState(pointsValidationState.WinnersAssigned) {
        uint256 balance = address(this).balance;
        adminPool = balance.mul(10).div(100);
        prizePool = balance.mul(90).div(100);
        pValidationState = pointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
        unSetPause();
    }

    function checkState(pointsValidationState state) internal view {
        require(pValidationState == state, ""Invalid state"");
    }

    function unSetPause() internal {
        // Implementation of unSetPause logic
    }
}",pose,"[{'function': 'pose', 'complexity': 0}, {'function': 'unSetPause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""adminPool""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""prizePool""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""adminPool""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""pValidationState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pointsValidationState""}, ""memberName"": ""Finished""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""gameFinishedTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""unSetPause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""checkState"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pointsValidationState""}, ""memberName"": ""WinnersAssigned""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.7526668978338178,0.4873325009374168,"pragma solidity ^0.8.0;

contract MyContract {
    // ... other contract code ...

    enum pointsValidationState {Pending, WinnersAssigned, Finished}

    uint256 public adminPool;
    uint256 public prizePool;
    pointsValidationState public pValidationState;
    uint256 public gameFinishedTime;
    // ... other state variables ...

    modifier onlyAdmin() {
        // ... admin check logic ...
        _;
    }

    modifier checkState(pointsValidationState _state) {
        require(pValidationState == _state, ""Invalid state"");
        _;
    }

    function pose() external onlyAdmin checkState(pointsValidationState.WinnersAssigned) {
        uint256 balance = address(this).balance;
        adminPool = balance / 10;
        prizePool = balance - adminPool;
        pValidationState = pointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
        unSetPause(); // Assuming unSetPause() function exists
    }

    function unSetPause() internal {
        // ... logic to unset pause ...
    }

    // ... rest of the contract ...
}",42.58784174919128,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    enum pointsValidationState {Pending, WinnersAssigned, Finished}

    uint256 public adminPool;
    uint256 public prizePool;
    pointsValidationState public pValidationState;
    uint256 public gameFinishedTime;

    modifier onlyAdmin() {
        // ... admin check logic ...
        _;
    }

    modifier checkState(pointsValidationState _state) {
        require(pValidationState == _state, ""Invalid state"");
        _;
    }

    constructor() Ownable(msg.sender) {
        adminPool = 1;
        prizePool = 2;
        pValidationState = pointsValidationState.Pending;
        gameFinishedTime = block.timestamp;
    }

    function pose() external onlyAdmin checkState(pointsValidationState.WinnersAssigned) {
        uint256 balance = address(this).balance;
        adminPool = balance / 10;
        prizePool = balance - adminPool;
        pValidationState = pointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
        unSetPause(); // Assuming unSetPause() function exists
    }

    function unSetPause() internal {
        // ... logic to unset pause ...
    }

    // ... rest of the contract ...
}"
5253,Renouncing to ownership will leave the contract without an owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function renounceOwnership() public override onlyOwner {
        emit OwnershipRenounced(owner());
        _transferOwnership(address(0));
    }
}",renounceOwnership,"[{'function': 'owner', 'complexity': 0}, {'function': 'renounceOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""renounceOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipRenounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.8121253148617034,0.4381387411090539,"pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipRenounced(address indexed previousOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipRenounced(_owner);
        _owner = address(0);
    }
}",42.30253601074219,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;
    uint256 public constant _INITIAL_VALUE = 1;
    bool public constant _IS_INITIALIZED = true;
    bytes32 public constant _INIT_BYTES32 = bytes32('init');

    event OwnershipRenounced(address indexed previousOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipRenounced(_owner);
        _owner = address(0);
    }
}"
86,` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public maxSecurityGuardDelay;

    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) external onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}",setMaxSecurityGuardDelay,"[{'function': 'setMaxSecurityGuardDelay', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMaxSecurityGuardDelay"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxSecurityGuardDelay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxSecurityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxSecurityGuardDelay""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9720074557074913,0.5266403878479267,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public maxSecurityGuardDelay;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function setMaxSecurityGuardDelay(uint256 _maxSecurityGuardDelay) public onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}",41.27706599235535,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {

    uint256 public maxSecurityGuardDelay;

    constructor() Ownable(msg.sender) {
        maxSecurityGuardDelay = 1;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function setMaxSecurityGuardDelay(uint256 _maxSecurityGuardDelay) public onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}"
3464,_addModule handles the attachment ( or replacement ) of modules for the ST,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IModuleRegistry {
    function getType() external view returns (uint8);
}

interface IModuleFactory {
    function setupCost() external view returns (uint256);
    function deploy(bytes calldata) external returns (address);
    function getName() external view returns (bytes32);
}

interface ERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ModuleRegistryWrapper is Ownable {
    using SafeMath for uint256;

    struct ModuleData {
        bytes32 name;
        address module;
    }

    mapping(uint8 => ModuleData[]) public modules;
    address public polyToken;
    uint8 constant MAX_MODULES = 10;

    event LogModuleAdded(uint8 indexed moduleType, bytes32 indexed moduleName, address indexed moduleFactory, address module, uint256 cost, uint256 budget, uint256 timestamp);

    function _addModule(address _moduleFactory, bytes memory _data, uint256 _maxCost, uint256 _budget) internal {
        IModuleRegistry moduleRegistry = IModuleRegistry(_moduleFactory);
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint8 moduleType = moduleFactory.getType();
        require(modules[moduleType].length < MAX_MODULES, ""Limit of MAX MODULES is reached"");
        uint256 moduleCost = moduleFactory.setupCost();
        require(moduleCost <= _maxCost, ""Max Cost is always be greater than module cost"");
        require(ERC20(polyToken).approve(_moduleFactory, moduleCost), ""Not able to approve the module cost"");
        address module = moduleFactory.deploy(_data);
        require(ERC20(polyToken).approve(module, _budget), ""Not able to approve the budget"");
        bytes32 moduleName = moduleFactory.getName();
        modules[moduleType].push(ModuleData(moduleName, module));
        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, block.timestamp);
    }
}",_addModule,"[{'function': '_addModule', 'complexity': 2}, {'function': 'getModuleName', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""_addModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleFactory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxCost"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_budget"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""moduleType"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IModuleFactory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}, ""memberName"": ""getModuleType""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""moduleType""}}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_MODULES""}}, {""type"": ""stringLiteral"", ""value"": ""Max modules reached""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""setupCost"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IModuleFactory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}, ""memberName"": ""getSetupCost""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""setupCost""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxCost""}}, {""type"": ""stringLiteral"", ""value"": ""Setup cost exceeds max cost""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""deployedAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Module""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""moduleName"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IModuleFactory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}, ""memberName"": ""getModuleName""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""moduleType""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModuleData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""moduleName""}, {""type"": ""Identifier"", ""name"": ""deployedAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogModuleAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""moduleType""}, {""type"": ""Identifier"", ""name"": ""moduleName""}, {""type"": ""Identifier"", ""name"": ""_moduleFactory""}, {""type"": ""Identifier"", ""name"": ""deployedAddress""}, {""type"": ""Identifier"", ""name"": ""setupCost""}, {""type"": ""Identifier"", ""name"": ""_budget""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.858293667612739,0.2911562421263577,"pragma solidity ^0.8.0;

contract ModuleManager {

    uint256 public constant MAX_MODULES = 100; //Example max modules

    struct ModuleData {
        string name;
        address deployedAddress;
    }

    mapping(uint256 => ModuleData[]) public modules; //Module type => ModuleData[]

    event LogModuleAdded(uint256 indexed moduleType, string name, address indexed moduleFactory, address indexed deployedAddress, uint256 cost, uint256 budget, uint256 timestamp);


    function _addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget) internal {
        //1. Interact with ModuleRegistry (replace with actual interaction)
        uint256 moduleType = IModuleFactory(_moduleFactory).getModuleType();

        //2. Check max modules
        require(modules[moduleType].length < MAX_MODULES, ""Max modules reached"");

        //3. Get setup cost
        uint256 setupCost = IModuleFactory(_moduleFactory).getSetupCost(_data);

        //4. Check max cost
        require(setupCost <= _maxCost, ""Setup cost exceeds max cost"");

        //5. Approve cost (replace with actual approval mechanism)
        // ...

        //6. Deploy module (replace with actual deployment)
        address deployedAddress = address(new Module(_data)); //Replace Module with actual module contract

        //7. Approve budget (replace with actual approval mechanism)
        // ...

        //8. Get module name
        string memory moduleName = IModuleFactory(_moduleFactory).getModuleName(_data);

        //9. Store module details
        modules[moduleType].push(ModuleData(moduleName, deployedAddress));

        //10. Emit event
        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, deployedAddress, setupCost, _budget, block.timestamp);
    }

    interface IModuleFactory {
        function getModuleType() external view returns (uint256);
        function getSetupCost(bytes calldata _data) external view returns (uint256);
        function getModuleName(bytes calldata _data) external view returns (string memory);
    }

    // Placeholder for a module contract
    contract Module {
        constructor(bytes memory _data) {}
    }
}",44.29942297935486,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ModuleManager is Ownable {
    uint256 public constant MAX_MODULES = 100; //Example max modules

    struct ModuleData {
        string name;
        address deployedAddress;
    }

    mapping(uint256 => ModuleData[]) public modules; //Module type => ModuleData[]

    event LogModuleAdded(uint256 indexed moduleType, string name, address indexed moduleFactory, address indexed deployedAddress, uint256 cost, uint256 budget, uint256 timestamp);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        MAX_MODULES = 100; //uint256: Set to 100 (never 0)
    }

    function _addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget) internal {
        //1. Interact with ModuleRegistry (replace with actual interaction)
        uint256 moduleType = IModuleFactory(_moduleFactory).getModuleType();

        //2. Check max modules
        require(modules[moduleType].length < MAX_MODULES, ""Max modules reached"");

        //3. Get setup cost
        uint256 setupCost = IModuleFactory(_moduleFactory).getSetupCost(_data);

        //4. Check max cost
        require(setupCost <= _maxCost, ""Setup cost exceeds max cost"");

        //5. Approve cost (replace with actual approval mechanism)
        // ...

        //6. Deploy module (replace with actual deployment)
        address deployedAddress = address(new Module(_data)); //Replace Module with actual module contract

        //7. Approve budget (replace with actual approval mechanism)
        // ...

        //8. Get module name
        string memory moduleName = IModuleFactory(_moduleFactory).getModuleName(_data);

        //9. Store module details
        modules[moduleType].push(ModuleData(moduleName, deployedAddress));

        //10. Emit event
        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, deployedAddress, setupCost, _budget, block.timestamp);
    }

    interface IModuleFactory {
        function getModuleType() external view returns (uint256);
        function getSetupCost(bytes calldata _data) external view returns (uint256);
        function getModuleName(bytes calldata _data) external view returns (string memory);
    }

    // Placeholder for a module contract
    contract Module {
        constructor(bytes memory _data) {}
    }
}"
2419,Return the permissions flag that are associated with Module,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionsContract is Ownable {
    using SafeMath for uint256;

    bytes32[] private permissions;

    function getPermissions() public view returns (bytes32[]) {
        return permissions;
    }
}",getPermissions,"[{'function': 'getPermissions', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPermissions"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""permissions""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9770254989473118,0.8003203203844999,"pragma solidity ^0.8.0;

contract PermissionContract {

    bytes32[] public permissions;

    function getPermissions() public view returns (bytes32[] memory) {
        return permissions;
    }
}",41.18049120903015,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PermissionContract is Ownable {
    bytes32[] public permissions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        permissions = [bytes32('init')];
    }

    function getPermissions() public view returns (bytes32[] memory) {
        return permissions;
    }
}"
3265,"Called by the owner to unpause , returns to normal state","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused;

    event Unpause(uint256 timestamp);

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function _unpause() internal whenPaused {
        paused = false;
        emit Unpause(block.timestamp);
    }
}",_pause,"[{'function': '_pause', 'complexity': 0}, {'function': '_unpause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_pause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Pause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.8493430303055867,0.1400874968721016,"pragma solidity ^0.8.0;

contract Pausable {
    event Pause();
    event Unpause();

    bool public paused;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier whenPaused() {
        require(paused, ""Contract not paused"");
        _;
    }

    function _pause() internal whenNotPaused {
        paused = true;
        emit Pause();
    }

    function _unpause() internal whenPaused {
        paused = false;
        emit Unpause();
    }
}",41.76696538925171,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Pausable is Ownable {
    event Pause();
    event Unpause();

    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier whenPaused() {
        require(paused, ""Contract not paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
        emit Pause();
    }

    function unpause() public onlyOwner {
        paused = false;
        emit Unpause();
    }
}"
1244,Returns all the relevant information about a specific grey .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GreyWrapper {
    using SafeMath for uint256;

    struct Grey {
        string name;
    }

    mapping(uint256 => Grey) private greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    function getGrey(uint256 _tokenId) public view returns (string memory, uint256, address, uint256, address[5] memory) {
        Grey storage grey = greys[_tokenId];
        return (grey.name, greyIndexToPrice[_tokenId], greyIndexToOwner[_tokenId], greyIndexToPreviousPrice[_tokenId], greyIndexToPreviousOwners[_tokenId]);
    }
}",getGrey,"[{'function': 'getGrey', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getGrey"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""greyName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""previousPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}, ""name"": ""previousOwners"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""greyName""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greys""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""memberName"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""previousPrice""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToPreviousPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""previousOwners""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToPreviousOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",18.0,0.854926812359458,0.3371067598858715,"pragma solidity ^0.8.0;

struct Grey {
    string name;
}

contract GreyContract {
    mapping(uint256 => Grey) public greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    function getGrey(uint256 _tokenId)
        public
        view
        returns (
            string memory greyName,
            uint256 sellingPrice,
            address owner,
            uint256 previousPrice,
            address[5] memory previousOwners
        )
    {
        greyName = greys[_tokenId].name;
        sellingPrice = greyIndexToPrice[_tokenId];
        owner = greyIndexToOwner[_tokenId];
        previousPrice = greyIndexToPreviousPrice[_tokenId];
        previousOwners = greyIndexToPreviousOwners[_tokenId];
    }
}",42.53606939315796,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

struct Grey {
    string name;
}
import ""openzeppelin/SafeMath.sol"";
contract GreyContract is Ownable {
    mapping(uint256 => Grey) public greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 10; i++) {
            greys[i] = Grey({name: ""Grey""});
            greyIndexToPrice[i] = 1;
            greyIndexToOwner[i] = address(uint160(i + 1));
            for (uint256 j = 0; j < 5; j++) {
                if (j == 0) {
                    greyIndexToPreviousOwners[i][j] = address(uint160(i + 2));
                } else if (j == 1) {
                    greyIndexToPreviousOwners[i][j] = address(uint160(i + 3));
                } else if (j == 2) {
                    greyIndexToPreviousOwners[i][j] = address(uint160(i + 4));
                } else if (j == 3) {
                    greyIndexToPreviousOwners[i][j] = address(uint160(i + 5));
                } else if (j == 4) {
                    greyIndexToPreviousOwners[i][j] = address(uint160(i + 6));
                }
            }
        }
    }

    function getGrey(uint256 _tokenId)
        public
        view
        returns (
            string memory greyName,
            uint256 sellingPrice,
            address owner,
            uint256 previousPrice,
            address[5] memory previousOwners
        )
    {
        greyName = greys[_tokenId].name;
        sellingPrice = greyIndexToPrice[_tokenId];
        owner = greyIndexToOwner[_tokenId];
        previousPrice = greyIndexToPreviousPrice[_tokenId];
        previousOwners = greyIndexToPreviousOwners[_tokenId];
    }
}"
1531,This method may be deprecated or refactored to allow for multiple interfaces,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LibStorage {
    function setBool(bytes32 id, bool value) external returns (bool);
}

interface TokenXInterface {
    function setAssetCurrency(address asset, string memory currency) external returns (bool);
}

abstract contract TokenXWrapper is Ownable {
    using SafeMath for uint256;

    LibStorage public lib;
    TokenXInterface public tokenX;

    constructor(address _libAddress, address _tokenXAddress) {
        lib = LibStorage(_libAddress);
        tokenX = TokenXInterface(_tokenXAddress);
    }

    function setTokenXCurrency(address asset, string memory currency) public onlyOwner returns (bool success) {
        bytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));
        require(lib.setBool(id, true), ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."");
        require(tokenX.setAssetCurrency(asset, currency), ""Error: Failed to set asset currency."");
        return true;
    }
}",setTokenXCurrency,"[{'function': 'setTokenXCurrency', 'complexity': 2}, {'function': 'setAssetCurrency', 'complexity': 0}, {'function': 'set', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTokenXCurrency"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""asset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""tokenx""}, {""type"": ""Identifier"", ""name"": ""asset""}, {""type"": ""Identifier"", ""name"": ""currency""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Storage""}, ""memberName"": ""set""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Contract interface must be allowed by the storage contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""setAssetCurrency""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""asset""}, {""type"": ""Identifier"", ""name"": ""currency""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Failed to set asset currency""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""notDeprecated"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.9463384391724704,0.5528071887704417,"pragma solidity ^0.8.0;

contract TokenX {

    // Assume necessary modifiers and libraries are defined elsewhere, e.g., onlyOwner, notDeprecated, Storage library

    function setTokenXCurrency(address asset, string memory currency) public onlyOwner notDeprecated returns (bool) {
        bytes32 id = keccak256(abi.encodePacked(""tokenx"", asset, currency));
        require(Storage.set(id, true), ""Contract interface must be allowed by the storage contract"");
        require(setAssetCurrency(asset, currency), ""Failed to set asset currency"");
        return true;
    }

    function setAssetCurrency(address asset, string memory currency) internal returns (bool) {
        //Implementation for setting asset currency.  This is a placeholder.
        return true;
    }
}

// Placeholder for Storage library.  Replace with actual implementation.
library Storage {
    function set(bytes32 key, bool value) internal returns (bool) {
        //Implementation to set value in storage.  This is a placeholder.
        return true;
    }
}",42.422120809555054,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenX is Ownable {
    // Assume necessary modifiers and libraries are defined elsewhere, e.g., onlyOwner, notDeprecated, Storage library

    function setTokenXCurrency(address asset, string memory currency) public onlyOwner notDeprecated returns (bool) {
        bytes32 id = keccak256(abi.encodePacked(""tokenx"", asset, currency));
        require(Storage.set(id, true), ""Contract interface must be allowed by the storage contract"");
        require(setAssetCurrency(asset, currency), ""Failed to set asset currency"");
        return true;
    }

    function setAssetCurrency(address asset, string memory currency) internal returns (bool) {
        //Implementation for setting asset currency.  This is a placeholder.
        return true;
    }
}

// Placeholder for Storage library.  Replace with actual implementation.
library Storage {
    function set(bytes32 key, bool value) internal returns (bool) {
        //Implementation to set value in storage.  This is a placeholder.
        return true;
    }
}"
4775,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public totalTokensSold;
    uint256 public cap;

    function capReached() public view returns (bool) {
        return totalTokensSold >= cap;
    }
}",isCapReached,"[{'function': 'isCapReached', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isCapReached"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalTokensSold""}, ""right"": {""type"": ""Identifier"", ""name"": ""cap""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9148081954540094,0.8761560783209453,"pragma solidity ^0.8.0;

contract TokenSale {
    uint256 public cap;
    uint256 public totalTokensSold;

    constructor(uint256 _cap) {
        cap = _cap;
    }

    function isCapReached() public view returns (bool) {
        return totalTokensSold >= cap;
    }
}",41.43946194648743,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    uint256 public cap;
    uint256 public totalTokensSold;

    constructor(uint256 _cap) Ownable(msg.sender) {
        cap = _cap;
        totalTokensSold = 0; // Initialize to safe non-corner-case value
    }

    function isCapReached() public view returns (bool) {
        return totalTokensSold >= cap;
    }
}"
39,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    function createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) public payable onlyOwner {
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        // Implementation of the function
    }
}",createDividend,"[{'function': 'createDividend', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maturity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_checkpointId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excluded"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_name"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createDividendWithCheckpointAndExclusions""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maturity""}, {""type"": ""Identifier"", ""name"": ""_expiry""}, {""type"": ""Identifier"", ""name"": ""_checkpointId""}, {""type"": ""Identifier"", ""name"": ""_excluded""}, {""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""withPerm"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",0.0,0.9229253511960712,0.8777311888461752,"pragma solidity ^0.8.0;

contract DividendContract {

    // Assume necessary modifiers and internal functions are defined elsewhere
    modifier withPerm() {
        //Implementation for permission check
        _;
    }

    function createDividend(
        uint256 _maturity,
        uint256 _expiry,
        uint256 _checkpointId,
        address[] memory _excluded,
        bytes32 _name
    ) public payable withPerm {
        _createDividendWithCheckpointAndExclusions(
            _maturity,
            _expiry,
            _checkpointId,
            _excluded,
            _name
        );
    }

    function _createDividendWithCheckpointAndExclusions(
        uint256 _maturity,
        uint256 _expiry,
        uint256 _checkpointId,
        address[] memory _excluded,
        bytes32 _name
    ) internal virtual {
        //Implementation for creating dividend
    }
}",42.20519518852234,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DividendContract is Ownable {
    // Assume necessary modifiers and internal functions are defined elsewhere
    modifier withPerm() {
        //Implementation for permission check
        _;
    }

    function createDividend(
        uint256 _maturity,
        uint256 _expiry,
        uint256 _checkpointId,
        address[] memory _excluded,
        bytes32 _name
    ) public payable withPerm {
        _createDividendWithCheckpointAndExclusions(
            _maturity,
            _expiry,
            _checkpointId,
            _excluded,
            _name
        );
    }

    function _createDividendWithCheckpointAndExclusions(
        uint256 _maturity,
        uint256 _expiry,
        uint256 _checkpointId,
        address[] memory _excluded,
        bytes32 _name
    ) internal virtual {
        //Implementation for creating dividend
    }
}"
2566,Prevents the seller from cancelling an escrow .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EscrowContract {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        uint256 sellerCanCancelAfter;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
    }

    mapping(bytes32 => Escrow) public escrows;
    bytes32[] public tradeHashes;
    address public relayer;
    uint256 public constant GAS_doDisableSellerCancel = 50000;

    event SellerCancelDisabled(bytes32 indexed tradeHash);

    function doDisableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
        if (!_escrow.exists) return false;
        if (_escrow.sellerCanCancelAfter == 0) return false;
        escrows[_tradeHash].sellerCanCancelAfter = 0;
        emit SellerCancelDisabled(_tradeHash);
        if (msg.sender == relayer) {
            increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
        }
        return true;
    }

    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) public pure returns (Escrow memory, bytes32) {
        Escrow memory escrow = Escrow({
            exists: true,
            sellerCanCancelAfter: block.timestamp + 1 days, // Example value for demonstration
            seller: _seller,
            buyer: _buyer,
            value: _value,
            fee: _fee
        });

        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
        return (escrow, tradeHash);
    }

    function increaseGasSpent(bytes32 _tradeHash, uint256 _gasAmount) public {
        // Implementation of increasing gas spent
    }
}",disableSellerCancellation,"[{'function': 'disableSellerCancellation', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""disableSellerCancellation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_tradeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint16""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""name"": ""_additionalGas"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""escrow"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Escrow""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1137656a0>}, {""type"": ""VariableDeclaration"", ""name"": ""escrowHash"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113765940>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getEscrowAndHash""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tradeID""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""memberName"": ""seller""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""memberName"": ""sellerCanCancelAfter""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""memberName"": ""sellerCanCancelAfter""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tradeID""}}, ""right"": {""type"": ""Identifier"", ""name"": ""escrow""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SellerCancelDisabled""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""escrowHash""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.8583308583648999,0.3821748284527388,"pragma solidity ^0.8.0;

contract Escrow {

    // Define Escrow struct and other necessary structs/variables here...

    event SellerCancelDisabled(bytes32 indexed tradeHash);

    function disableSellerCancellation(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) external returns (bool) {
        (Escrow memory escrow, bytes32 escrowHash) = getEscrowAndHash(_tradeID);

        if (escrow.seller == address(0)) {
            return false;
        }

        if (escrow.sellerCanCancelAfter == 0) {
            return false;
        }

        escrow.sellerCanCancelAfter = 0;
        escrows[_tradeID] = escrow;

        emit SellerCancelDisabled(escrowHash);

        //If caller is relayer, increase gas spent.  Implementation omitted as relayer logic is not defined.

        return true;
    }


    // ... other functions, including getEscrowAndHash,  structs, and state variables ...
}",42.88378643989563,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    struct EscrowStruct {
        address seller;
        uint256 sellerCanCancelAfter;
    }

    mapping(bytes16 => EscrowStruct) public escrows;

    event SellerCancelDisabled(bytes32 indexed tradeHash);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint8 i = 0x11; i <= 0x33; i++) {
            escrows[bytes16(i)] = EscrowStruct({seller: address(uint160(i)), sellerCanCancelAfter: uint256(i)});
        }
    }

    function disableSellerCancellation(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) external returns (bool) {
        EscrowStruct memory escrow = escrows[_tradeID];

        if (escrow.seller == address(0)) {
            return false;
        }

        if (escrow.sellerCanCancelAfter == 0) {
            return false;
        }

        escrow.sellerCanCancelAfter = 0;
        escrows[_tradeID] = escrow;

        emit SellerCancelDisabled(bytes32(_tradeID));

        //If caller is relayer, increase gas spent. Implementation omitted as relayer logic is not defined.

        return true;
    }
}"
4877,"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Clawback is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 10 ether; // Example value, adjust as needed
    uint256 public constant OWNER_CLAWBACK_DATE = 1700889600; // Example value, adjust as needed
    uint256 public totalFunding;

    function ownerClawback() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        payable(owner()).transfer(address(this).balance);
    }
}",reclaimFunds,"[{'function': 'reclaimFunds', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""totalFunding""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRESALE_MINIMUM_FUNDING""}}, {""type"": ""stringLiteral"", ""value"": ""Presale minimum funding reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""OWNER_CLAWBACK_DATE""}}, {""type"": ""stringLiteral"", ""value"": ""Clawback date not reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.8719875725132749,0.4955830046111457,"pragma solidity ^0.8.0;

contract Presale {

    uint256 public totalFunding;
    uint256 public constant PRESALE_MINIMUM_FUNDING = 100 ether;
    uint256 public constant OWNER_CLAWBACK_DATE = 1678886400; //Example Date
    address payable public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = payable(msg.sender);
    }

    function reclaimFunds() public onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING, ""Presale minimum funding reached"");
        require(block.timestamp >= OWNER_CLAWBACK_DATE, ""Clawback date not reached"");
        owner.transfer(address(this).balance);
    }
}",42.62510776519776,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Presale is Ownable {
    uint256 public totalFunding;
    uint256 public constant PRESALE_MINIMUM_FUNDING = 100 ether;
    uint256 public constant OWNER_CLAWBACK_DATE = 1678886400; //Example Date
    address payable public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = payable(msg.sender);
    }

    function reclaimFunds() public onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING, ""Presale minimum funding reached"");
        require(block.timestamp >= OWNER_CLAWBACK_DATE, ""Clawback date not reached"");
        owner.transfer(address(this).balance);
    }
}"
4681,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public absoluteMinTimeLock;

    constructor(uint _absoluteMinTimeLock) {
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimelock(uint _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""Time lock must be at least the absolute minimum time lock."");
        timeLock = _newTimeLock;
    }
}",setTimelock,"[{'function': 'setTimelock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimelock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""New timelock is less than the minimum allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyContractOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9766471313215904,0.4095434825884114,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public timeLock;
    uint256 public absoluteMinTimeLock;
    address public contractOwner;

    constructor(uint256 _initialTimeLock, uint256 _absoluteMinTimeLock) {
        contractOwner = msg.sender;
        timeLock = _initialTimeLock;
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    modifier onlyContractOwner() {
        require(msg.sender == contractOwner, ""Only contract owner can call this function"");
        _;
    }

    function setTimelock(uint256 _newTimeLock) public onlyContractOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timelock is less than the minimum allowed"");
        timeLock = _newTimeLock;
    }
}",42.49165487289429,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public timeLock;
    uint256 public absoluteMinTimeLock;

    constructor(uint256 _initialTimeLock, uint256 _absoluteMinTimeLock) Ownable(msg.sender) {
        timeLock = _initialTimeLock == 0 ? 1 : _initialTimeLock; // Ensure not zero to avoid corner cases
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    modifier onlyContractOwner() {
        require(msg.sender == contractOwner(), ""Only contract owner can call this function"");
        _;
    }

    function setTimelock(uint256 _newTimeLock) public onlyContractOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timelock is less than the minimum allowed"");
        timeLock = _newTimeLock;
    }
}"
5481,Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedTransferAndCall is Ownable {
    using SafeMath for uint256;

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        return _to.call{value: _value}(_data);
    }
}",transferAndCall,"[{'function': 'transferAndCall', 'complexity': 4}, {'function': 'balanceOf', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""code""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Target is not a contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""success""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",73.0,0.4103853350029703,0.1906573194503025,"pragma solidity ^0.8.0;

contract MyToken {
    mapping(address => uint256) private _balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        require(_to != address(0), ""ERC20: transfer to the zero address"");
        require(_value > 0, ""ERC20: transfer amount must be greater than zero"");
        require(_balances[msg.sender] >= _value, ""ERC20: transfer amount exceeds balance"");

        _balances[msg.sender] -= _value;
        _balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);

        require(_to.code.length > 0, ""Target is not a contract"");
        (bool success, ) = _to.call(_data);
        return success;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}",42.750438928604126,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyToken {
    mapping(address => uint256) private _balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    // Fixed values for initialization
    bytes32 public constant INIT_BYTES32 = bytes32('init');
    bool public constant INIT_BOOL = true;
    string public constant INIT_STRING = 'initialized';
    address public constant INIT_ADDRESS1 = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant INIT_ADDRESS2 = 0x2222222222222222222222222222222222222222; // Replace with actual address
    uint256 public constant INIT_UINT = 1;

    mapping(address => uint256) public balanceOf;

 constructor() {
        // Initialize instance variables
        _balances[msg.sender] = INIT_UINT;
        emit Transfer(address(0), msg.sender, INIT_UINT);
    }

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        require(_to != address(0), ""ERC20: transfer to the zero address"");
        require(_value > 0, ""ERC20: transfer amount must be greater than zero"");
        require(_balances[msg.sender] >= _value, ""ERC20: transfer amount exceeds balance"");

        _balances[msg.sender] -= _value;
        _balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);

        require(_to.code.length > 0, ""Target is not a contract"");
        (bool success, ) = _to.call(_data);
        return success;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        _owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _owner = newOwner;
    }
}"
1824,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Value must be greater than zero"");
        require(msg.sender == _from, ""Sender must match the caller"");
        require(_value <= balanceOf[_from], ""Insufficient balance"");

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }
}",transferFrom,"[{'function': 'transferFrom', 'complexity': 4}, {'function': 'approve', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.7966272868403497,0.5241641457050485,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    mapping(address => uint256) public accounts;
    mapping(address => mapping(address => uint256)) public allowances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_from != address(0), ""ERC20: transfer from the zero address"");
        require(_to != address(0), ""ERC20: transfer to the zero address"");
        require(accounts[_from] >= _value, ""ERC20: transfer amount exceeds balance"");
        require(allowances[_from][msg.sender] >= _value, ""ERC20: insufficient allowance"");

        accounts[_from] = accounts[_from].sub(_value);
        accounts[_to] = accounts[_to].add(_value);
        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
}",44.07064652442932,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public accounts;
    mapping(address => mapping(address => uint256)) public allowances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor() Ownable(msg.sender) {
        accounts[msg.sender] = 1; // Initialize the owner's balance to 1
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_from != address(0), ""ERC20: transfer from the zero address"");
        require(_to != address(0), ""ERC20: transfer to the zero address"");
        require(accounts[_from] >= _value, ""ERC20: transfer amount exceeds balance"");
        require(allowances[_from][msg.sender] >= _value, ""ERC20: insufficient allowance"");

        accounts[_from] = accounts[_from].sub(_value);
        accounts[_to] = accounts[_to].add(_value);
        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
}"
1782,Gets the EscrowDeposit based on the input id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow {
    using SafeMath for uint256;

    struct EscrowDeposit {
        address bidder;
        bytes data;
        uint256 amount;
        bool exists;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) external view returns (address, bytes memory, uint256) {
        require(escrows[_id].exists, ""Escrow does not exist"");
        EscrowDeposit storage escrow = escrows[_id];
        return (escrow.bidder, escrow.data, escrow.amount);
    }
}",getEscrowDeposit,"[{'function': 'getEscrowDeposit', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getEscrowDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_id"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""Escrow deposit does not exist""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""bidder""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""data""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""amount""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.8401703893353754,0.6014782814926073,"pragma solidity ^0.8.0;

contract Escrow {
    struct EscrowDeposit {
        address bidder;
        bytes data;
        uint256 amount;
        bool exists;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) public view returns (address, bytes memory, uint256) {
        require(escrows[_id].exists, ""Escrow deposit does not exist"");
        return (escrows[_id].bidder, escrows[_id].data, escrows[_id].amount);
    }
}",41.87673926353455,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    struct EscrowDeposit {
        address bidder;
        bytes data;
        uint256 amount;
        bool exists;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) public view returns (address, bytes memory, uint256) {
        require(escrows[_id].exists, ""Escrow deposit does not exist"");
        return (escrows[_id].bidder, escrows[_id].data, escrows[_id].amount);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            string memory id = string(abi.encodePacked(""escrow_"", uintToString(i)));
            escrows[id] = EscrowDeposit({
                bidder: address(uint160(uint256(keccak256(abi.encodePacked('bidder_', i))))),
                data: bytes(abi.encodePacked(""data_"", uintToString(i))),
                amount: 1 ether * (i + 1),
                exists: true
            });
        }
    }

    function uintToString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        bytes memory buffer = new bytes(32);
        uint256 length;
        while (temp != 0) {
            buffer[length++] = byte(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(revertBytes(buffer, length));
    }

    function revertBytes(bytes memory data, uint256 length) internal pure returns (bytes memory) {
        bytes memory result = new bytes(length);
        for (uint256 i = 0; i < length; i++) {
            result[i] = data[data.length - 1 - i];
        }
        return result;
    }
}"
3204,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balances(address account) external view returns (uint256);
    function totalBhinneka() external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalBhinneka;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalBhinneka = totalBhinneka.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}",burn,"[{'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalBhinneka""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalBhinneka""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.9791037814426476,0.8117343541580836,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;
    uint256 public totalBhinneka;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    event Burn(address indexed from, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    function burn(uint256 _value) public onlyOwner returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalBhinneka = totalBhinneka.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}",42.20972275733948,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public balances;
    uint256 public totalBhinneka = 1;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    event Burn(address indexed from, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function burn(uint256 _value) public onlyOwner returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalBhinneka = totalBhinneka.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}"
1281,Function for attester to submit attestation from their own account ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttestationContract is Ownable {
    using SafeMath for uint256;

    function attest(address _subject, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) external {
        require(_subject != address(0), ""Invalid subject address"");
        require(_requester != address(0), ""Invalid requester address"");
        require(_reward > 0, ""Reward must be greater than zero"");
        require(_requestNonce != bytes32(0), ""Request nonce cannot be empty"");

        // Assuming attestForUser is defined elsewhere in the contract or imported library
        attestForUser(_subject, msg.sender, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
    }

    function attestForUser(address _subject, address _attester, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) internal {
        // Implementation of the actual attestation logic
    }
}",attestForUser,"[{'function': 'attest', 'complexity': 0}, {'function': 'attestForUser', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""attest"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_subject"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_requester"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_requesterSig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_dataHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_requestNonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_subjectSig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""attestForUser""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_subject""}, {""type"": ""Identifier"", ""name"": ""_requester""}, {""type"": ""Identifier"", ""name"": ""_reward""}, {""type"": ""Identifier"", ""name"": ""_requesterSig""}, {""type"": ""Identifier"", ""name"": ""_dataHash""}, {""type"": ""Identifier"", ""name"": ""_requestNonce""}, {""type"": ""Identifier"", ""name"": ""_subjectSig""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.438093259205096,0.1345391662470401,"pragma solidity ^0.8.0;

contract AttestationContract {

    function attest(
        address _subject,
        address _requester,
        uint256 _reward,
        bytes memory _requesterSig,
        bytes32 _dataHash,
        uint256 _requestNonce,
        bytes memory _subjectSig
    ) public {
        attestForUser(msg.sender, _subject, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
    }

    function attestForUser(
        address _user,
        address _subject,
        address _requester,
        uint256 _reward,
        bytes memory _requesterSig,
        bytes32 _dataHash,
        uint256 _requestNonce,
        bytes memory _subjectSig
    ) internal {
        //  Implementation for signature verification, nonce check, and attestation record creation.  This would typically involve using Ecrecover and a mapping to track used nonces.
    }
}",42.22865271568298,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract AttestationContract {
    address public constant DEFAULT_SUBJECT = 0x1111111111111111111111111111111111111111; // Replace with actual subject address
    address public constant DEFAULT_REQUESTER = 0x2222222222222222222222222222222222222222; // Replace with actual requester address
    uint256 public constant DEFAULT_REWARD = 1;
    bool public initialized = true;

    constructor() Ownable(msg.sender) {
        _setSubject(DEFAULT_SUBJECT);
        _setRequester(DEFAULT_REQUESTER);
        _setReward(DEFAULT_REWARD);
    }

    function attest(
        address _subject,
        address _requester,
        uint256 _reward,
        bytes memory _requesterSig,
        bytes32 _dataHash,
        uint256 _requestNonce,
        bytes memory _subjectSig
    ) public {
        require(initialized, ""Contract not initialized"");
        attestForUser(msg.sender, _subject, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
    }

    function attestForUser(
        address _user,
        address _subject,
        address _requester,
        uint256 _reward,
        bytes memory _requesterSig,
        bytes32 _dataHash,
        uint256 _requestNonce,
        bytes memory _subjectSig
    ) internal {
        //  Implementation for signature verification, nonce check, and attestation record creation.  This would typically involve using Ecrecover and a mapping to track used nonces.
    }

    function _setSubject(address subject) internal {
        require(subject != address(0), ""Invalid subject address"");
        _subject = subject;
    }

    function _setRequester(address requester) internal {
        require(requester != address(0), ""Invalid requester address"");
        _requester = requester;
    }

    function _setReward(uint256 reward) internal {
        require(reward > 0, ""Invalid reward value"");
        _reward = reward;
    }
}"
4148,"Escrows the ERC721 Token , assigning ownership to this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow is Ownable {
    using SafeMath for uint256;

    address public nonFungibleContract;

    constructor(address _nonFungibleContract) {
        nonFungibleContract = _nonFungibleContract;
    }

    function escrow(address _owner, uint256 _tokenId) external onlyOwner {
        require(_owner != address(0), ""Invalid owner address"");
        (bool success, ) = nonFungibleContract.call(abi.encodeWithSelector(bytes4(keccak256(""safeTransferFrom(address,address,uint256)"")), _owner, address(this), _tokenId));
        require(success, ""Safe transfer failed"");
    }
}",pose,"[{'function': 'safeTransferFrom', 'complexity': 0}, {'function': 'pose', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nonFungibleContract""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.5878683874689852,0.0907766488604616,"pragma solidity ^0.8.0;

interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
}

contract Escrow {
    IERC721 public nonFungibleContract;

    constructor(address _nonFungibleContractAddress) {
        nonFungibleContract = IERC721(_nonFungibleContractAddress);
    }

    function pose(address _owner, uint256 _tokenId) external {
        nonFungibleContract.safeTransferFrom(_owner, address(this), _tokenId);
    }
}",41.56594371795654,"pragma solidity ^0.8.0;

interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
}
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    IERC721 public nonFungibleContract;

    constructor(address _nonFungibleContractAddress) Ownable(msg.sender) {
        nonFungibleContract = IERC721(_nonFungibleContractAddress);
    }

    function pose(address _owner, uint256 _tokenId) external {
        nonFungibleContract.safeTransferFrom(_owner, address(this), _tokenId);
    }
}"
6515,"Computes the id for a node in a given Grove index which is sha3 ( indexId , id )","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GroveLibWrapper is Ownable {
    using SafeMath for uint256;

    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return GroveLib.computeNodeId(indexId, id);
    }
}",computeNodeId,"[{'function': 'computeNodeId', 'complexity': 0}, {'function': 'computeNodeId', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeNodeId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""indexId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""indexId""}, {""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",2.0,0.8957365492002896,0.6511124161720042,"pragma solidity ^0.8.0;

library GroveLib {
    function computeNodeId(bytes32 indexId, bytes32 id) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(indexId, id));
    }
}

contract MyContract {
    using GroveLib for bytes32;

    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return indexId.computeNodeId(id);
    }
}",41.63619565963745,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

library GroveLib {
    function computeNodeId(bytes32 indexId, bytes32 id) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(indexId, id));
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using GroveLib for bytes32;

    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return indexId.computeNodeId(id);
    }
}"
211,Uses the same signature as initializeTokenSale ( ) with :,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    bool public buyModeEth;
    address public payableTokenAddress;

    function initializeSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) internal {
        // Sale initialization logic here
    }

    function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public onlyOwner {
        buyModeEth = false;
        payableTokenAddress = _tokenAddress;
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}",initializeTokenSaleWithToken,"[{'function': 'initializeTokenSaleWithToken', 'complexity': 0}, {'function': 'initializeSale', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeTokenSaleWithToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_saleStartTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_saleEndTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountForSale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyModeEth""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""payableTokenAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""initializeSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_saleStartTime""}, {""type"": ""Identifier"", ""name"": ""_saleEndTime""}, {""type"": ""Identifier"", ""name"": ""_price""}, {""type"": ""Identifier"", ""name"": ""_amountForSale""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""ownerOnly"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9543212752374152,0.7112951024175388,"pragma solidity ^0.8.0;

// Assume necessary imports and interfaces for ERC20 and Ownable are present

contract TokenSale {
    // ... other contract elements ...

    bool public buyModeEth;
    address public payableTokenAddress;
    // ... other state variables ...

    modifier ownerOnly() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    function initializeTokenSaleWithToken(
        uint256 _saleStartTime,
        uint256 _saleEndTime,
        uint256 _price,
        uint256 _amountForSale,
        address _beneficiary,
        address _tokenAddress
    ) public ownerOnly {
        buyModeEth = false;
        payableTokenAddress = _tokenAddress;
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }

    function initializeSale(
        uint256 _saleStartTime,
        uint256 _saleEndTime,
        uint256 _price,
        uint256 _amountForSale,
        address _beneficiary
    ) internal virtual {
        //Implementation for initializing the sale.  This is a placeholder.
    }

    // ... other contract functions ...
    address public owner;
    constructor() {
        owner = msg.sender;
    }
    function owner() public view returns (address) {
        return owner;
    }
}",43.93038868904114,"pragma solidity ^0.8.0;

// Assume necessary imports and interfaces for ERC20 and Ownable are present
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    bool public buyModeEth;
    address public payableTokenAddress;
    // ... other state variables ...

    modifier ownerOnly() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    function initializeTokenSaleWithToken(
        uint256 _saleStartTime,
        uint256 _saleEndTime,
        uint256 _price,
        uint256 _amountForSale,
        address _beneficiary,
        address _tokenAddress
    ) public ownerOnly {
        buyModeEth = false;
        payableTokenAddress = _tokenAddress;
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }

    function initializeSale(
        uint256 _saleStartTime,
        uint256 _saleEndTime,
        uint256 _price,
        uint256 _amountForSale,
        address _beneficiary
    ) internal virtual {
        //Implementation for initializing the sale.  This is a placeholder.
    }

    // ... other contract functions ...
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}"
5005,If this function is called again it overwrites the current allowance with _value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => bool) public frozenAccount;
    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address _spender, uint256 _value) external returns (bool success) {
        require(!frozenAccount[msg.sender]);
        assert(_spender != address(0));
        require(_value >= 0);
        allowed[msg.sender][_spender] = _value;
        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""frozenAccount""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Sender account is frozen""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Spender address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Approved value cannot be negative""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.969404698829599,0.5097825088963692,"pragma solidity ^0.8.0;

contract Token {
    mapping(address => bool) public frozenAccount;
    mapping(address => mapping (address => uint256)) public allowed;

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(!frozenAccount[msg.sender], ""Sender account is frozen"");
        require(_spender != address(0), ""Spender address cannot be zero"");
        require(_value >= 0, ""Approved value cannot be negative"");
        allowed[msg.sender][_spender] = _value;
        return true;
    }
}",41.67455101013184,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => bool) public frozenAccount;
    mapping(address => mapping (address => uint256)) public allowed;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            frozenAccount[addr] = false;
        }
        bytes32 initBytes = bytes32('init');
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            allowed[addr][address(0)] = 0; // Initialize allowances to zero
        }
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(!frozenAccount[msg.sender], ""Sender account is frozen"");
        require(_spender != address(0), ""Spender address cannot be zero"");
        require(_value >= 0, ""Approved value cannot be negative"");
        allowed[msg.sender][_spender] = _value;
        return true;
    }
}"
2436,Function for transfering tokens from one account to another .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes16 => uint256) public balances;
    address[] private allowedAddresses;
    bool public paused = false;

    modifier onlyAllowedAddresses() {
        require(_isAllowedAddress(msg.sender), ""Only allowed addresses can call this function"");
        _;
    }

    modifier onlyRegisteredAccount(bytes16 _account) {
        require(_isRegisteredAccount(_account), ""The account must be registered"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transferTokensToAccount(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowedAddresses onlyRegisteredAccount(_from) whenNotPaused {
        registerAccount(_to);
        balances[_from] = balances[_from].sub(_tokensCount);
        balances[_to] = balances[_to].add(_tokensCount);
    }

    function registerAccount(bytes16 _account) internal {
        // Implementation of the registerAccount function
    }

    function _isAllowedAddress(address _addr) internal view returns (bool) {
        for (uint i = 0; i < allowedAddresses.length; i++) {
            if (allowedAddresses[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    function _isRegisteredAccount(bytes16 _account) internal view returns (bool) {
        // Implementation of the check for registered account
        return balances[_account] > 0;
    }
}",transferTokens,"[{'function': 'registerAddress', 'complexity': 0}, {'function': 'addAllowedAddress', 'complexity': 0}, {'function': 'setPaused', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokensCount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isRegistered""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, {""type"": ""stringLiteral"", ""value"": ""Source account not registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokensCount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokensCount""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isRegistered""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isRegistered""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokensCount""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAllowed"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""notPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.6025877912140993,0.1045369927140775,"pragma solidity ^0.8.0;

contract TokenTransfer {

    mapping(bytes16 => uint256) public balances;
    mapping(bytes16 => bool) public isRegistered;
    address[] public allowedAddresses;
    bool public paused;

    modifier onlyAllowed() {
        bool isAllowed = false;
        for (uint i = 0; i < allowedAddresses.length; i++) {
            if (msg.sender == allowedAddresses[i]) {
                isAllowed = true;
                break;
            }
        }
        require(isAllowed, ""Not allowed"");
        _;
    }

    modifier notPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function registerAddress(bytes16 _account) public onlyAllowed {
        isRegistered[_account] = true;
    }

    function addAllowedAddress(address _address) public onlyAllowed {
        allowedAddresses.push(_address);
    }

    function setPaused(bool _paused) public onlyAllowed {
        paused = _paused;
    }


    function transferTokens(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowed notPaused returns (bool) {
        require(isRegistered[_from], ""Source account not registered"");
        require(balances[_from] >= _tokensCount, ""Insufficient balance"");

        balances[_from] -= _tokensCount;
        if (!isRegistered[_to]) {
            isRegistered[_to] = true;
        }
        balances[_to] += _tokensCount;

        return true;
    }
}",43.07176065444946,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(bytes16 => uint256) public balances;
    mapping(bytes16 => bool) public isRegistered;
    address[] public allowedAddresses;
    bool public paused;

    modifier onlyAllowed() {
        bool isAllowed = false;
        for (uint i = 0; i < allowedAddresses.length; i++) {
            if (msg.sender == allowedAddresses[i]) {
                isAllowed = true;
                break;
            }
        }
        require(isAllowed, ""Not allowed"");
        _;
    }

    modifier notPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor() Ownable(msg.sender) {
        balances = {};
        for (uint i = 0; i < 3; i++) {
            allowedAddresses.push(address(uint160(i + 1)));
        }
        paused = false;
    }

    function registerAddress(bytes16 _account) public onlyAllowed {
        isRegistered[_account] = true;
    }

    function addAllowedAddress(address _address) public onlyAllowed {
        allowedAddresses.push(_address);
    }

    function setPaused(bool _paused) public onlyAllowed {
        paused = _paused;
    }

    function transferTokens(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowed notPaused returns (bool) {
        require(isRegistered[_from], ""Source account not registered"");
        require(balances[_from] >= _tokensCount, ""Insufficient balance"");

        balances[_from] -= _tokensCount;
        if (!isRegistered[_to]) {
            isRegistered[_to] = true;
        }
        balances[_to] += _tokensCount;

        return true;
    }
}"
2602,` onlyOwner ` An efficient way to confirm multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _idPayment) internal virtual {
        // Implementation of the payment confirmation logic
    }
}",multiConfirm,"[{'function': 'multiConfirm', 'complexity': 1}, {'function': 'doConfirmPayment', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiConfirm"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_idPayments"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doConfirmPayment""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.98725260170351,0.9061874434879644,"pragma solidity ^0.8.0;

contract PaymentConfirmation {

    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint256 i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _paymentId) internal virtual {
        //Implementation for confirming individual payments
    }
}",41.74343419075012,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentConfirmation is Ownable {
    address public owner = msg.sender;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint256 i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _paymentId) internal virtual {
        //Implementation for confirming individual payments
    }
}"
1905,Function used by the client to block the transfer of shares from and to a share holder,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function blockTransfer(address _shareHolder, uint _deadLine) external onlyOwner {
        // Implementation of the blockTransfer function
    }
}",initiateBlockTransfer,"[{'function': 'initiateBlockTransfer', 'complexity': 3}, {'function': 'addShares', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""initiateBlockTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_shareHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_deadLine"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""shareholderBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_shareHolder""}}, ""right"": {""type"": ""Identifier"", ""name"": ""minimumSharesForBlockTransfer""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient shares for block transfer.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_deadLine""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Deadline must be in the future.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_deadLine""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""maxDeadline""}}}, {""type"": ""stringLiteral"", ""value"": ""Deadline exceeds maximum allowed time.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""blockTransferDeadlines""}, ""index"": {""type"": ""Identifier"", ""name"": ""_shareHolder""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_deadLine""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BlockTransferInitiated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_shareHolder""}, {""type"": ""Identifier"", ""name"": ""_deadLine""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyShareholder"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_shareHolder""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.3685891759482448,0.0443127100665882,"pragma solidity ^0.8.0;

contract ShareTransfer {

    uint256 public minimumSharesForBlockTransfer;
    uint256 public maxDeadline;

    mapping(address => uint256) public shareholderBalances;
    mapping(address => uint256) public blockTransferDeadlines;

    event BlockTransferInitiated(address indexed shareholder, uint256 deadline);

    constructor(uint256 _minimumSharesForBlockTransfer, uint256 _maxDeadline) {
        minimumSharesForBlockTransfer = _minimumSharesForBlockTransfer;
        maxDeadline = _maxDeadline;
    }

    modifier onlyShareholder(address _shareholder) {
        require(msg.sender == _shareholder, ""Only the shareholder can initiate a block transfer."");
        _;
    }

    function initiateBlockTransfer(address _shareHolder, uint256 _deadLine) public onlyShareholder(_shareHolder) {
        require(shareholderBalances[_shareHolder] >= minimumSharesForBlockTransfer, ""Insufficient shares for block transfer."");
        require(_deadLine > block.timestamp, ""Deadline must be in the future."");
        require(_deadLine <= block.timestamp + maxDeadline, ""Deadline exceeds maximum allowed time."");

        blockTransferDeadlines[_shareHolder] = _deadLine;
        emit BlockTransferInitiated(_shareHolder, _deadLine);
    }

    function addShares(address _shareholder, uint256 _amount) public {
        shareholderBalances[_shareholder] += _amount;
    }


}",42.988895416259766,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ShareTransfer is Ownable {
    uint256 public minimumSharesForBlockTransfer;
    uint256 public maxDeadline;

    mapping(address => uint256) public shareholderBalances;
    mapping(address => uint256) public blockTransferDeadlines;

    event BlockTransferInitiated(address indexed shareholder, uint256 deadline);

    constructor(uint256 _minimumSharesForBlockTransfer, uint256 _maxDeadline) Ownable(msg.sender) {
        minimumSharesForBlockTransfer = _minimumSharesForBlockTransfer;
        maxDeadline = _maxDeadline;
    }

    modifier onlyShareholder(address _shareholder) {
        require(msg.sender == _shareholder, ""Only the shareholder can initiate a block transfer."");
        _;
    }

    function initiateBlockTransfer(address _shareHolder, uint256 _deadLine) public onlyShareholder(_shareHolder) {
        require(shareholderBalances[_shareHolder] >= minimumSharesForBlockTransfer, ""Insufficient shares for block transfer."");
        require(_deadLine > block.timestamp, ""Deadline must be in the future."");
        require(_deadLine <= block.timestamp + maxDeadline, ""Deadline exceeds maximum allowed time."");

        blockTransferDeadlines[_shareHolder] = _deadLine;
        emit BlockTransferInitiated(_shareHolder, _deadLine);
    }

    function addShares(address _shareholder, uint256 _amount) public {
        shareholderBalances[_shareholder] += _amount;
    }
}"
6047,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(checkVestingCondition(msg.sender));
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function checkVestingCondition(address account) internal view returns (bool) {
        // Implement your vesting condition logic here
        return false;
    }

    function _transfer(address from, address to, uint256 value) internal virtual {
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balanceOf(from) >= value, ""ERC20: transfer amount exceeds balance"");

        // Subtract the amount from the sender's balance
        _balances[from] = _balances[from].sub(value);

        // Add the amount to the recipient's balance
        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);
    }

    mapping(address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}",transfer,"[{'function': 'transfer', 'complexity': 1}, {'function': '_transfer', 'complexity': 0}, {'function': 'checkVestingCondition', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""checkVestingCondition""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Vesting condition not met""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",39.0,0.5984062107971149,0.0151992571597211,"pragma solidity ^0.8.0;

contract MyToken {

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(checkVestingCondition(msg.sender), ""Vesting condition not met"");
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function _transfer(address _from, address _to, uint256 _value) internal virtual {
        //Implementation for transferring tokens.  This would typically involve updating balances.
    }

    function checkVestingCondition(address _address) internal view virtual returns (bool) {
        //Implementation for checking vesting conditions.
        return true; //Replace with actual logic.
    }
}",41.973854064941406,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    uint256 public constant INITIAL_SUPPLY = 1; // Set to 1 (never 0)
    mapping(address => uint256) balances;
    address[] fixedAddresses = [0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333];

    constructor() Ownable(msg.sender) {
        // Initialize state variables
        for (uint i = 0; i < fixedAddresses.length; i++) {
            balances[fixedAddresses[i]] = INITIAL_SUPPLY;
        }
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(checkVestingCondition(msg.sender), ""Vesting condition not met"");
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function _transfer(address _from, address _to, uint256 _value) internal virtual {
        //Implementation for transferring tokens.  This would typically involve updating balances.
    }

    function checkVestingCondition(address _address) internal view virtual returns (bool) {
        //Implementation for checking vesting conditions.
        return true; //Replace with actual logic.
    }
}"
189,To be called by the account that holds Mio tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public lockedBalances;
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function addBalanceFor(address account, uint256 value) public onlyOwner {
        lockedBalances[account] = lockedBalances[account].add(value);
        require(token.safeTransferFrom(msg.sender, address(this), value), ""Token transfer failed"");
    }
}",addToLockedBalance,"[{'function': 'addToLockedBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addToLockedBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockedBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.802041989140148,0.4542202765813094,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 public token;
    mapping(address => uint256) public lockedBalances;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function addToLockedBalance(address account, uint256 value) public {
        lockedBalances[account] += value;
        token.safeTransferFrom(msg.sender, address(this), value);
    }
}",41.438148736953735,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public token;
    mapping(address => uint256) public lockedBalances;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        // Initialize state variables with safe, non-corner-case values
        lockedBalances[address(0x111)] = 1;
        lockedBalances[address(0x222)] = 1;
        lockedBalances[address(0x333)] = 1;
    }

    function addToLockedBalance(address account, uint256 value) public {
        lockedBalances[account] += value;
        token.safeTransferFrom(msg.sender, address(this), value);
    }
}"
3776,Ability to transfer where the sender pays the fees ( not ERC20 ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    function transferFeeIncurred(uint256 value) internal pure returns (uint256) {
        // Example logic for calculating the fee
        return value.div(100); // 1% fee
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal returns (bool) {
        require(balanceOf(sender) >= value.add(fee), ""Insufficient balance"");

        // Deduct the fee from the sender's balance
        _balances[sender] = _balances[sender].sub(value).sub(fee);

        // Add the fee to the contract balance (or any other logic)
        _balances[address(this)] = _balances[address(this)].add(fee);

        // Transfer the value to the recipient
        _balances[to] = _balances[to].add(value);

        emit Transfer(sender, to, value);
        return true;
    }

    mapping (address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",_transferSenderPaysFee_byProxy,"[{'function': '_transferSenderPaysFee_byProxy', 'complexity': 0}, {'function': 'transferFeeIncurred', 'complexity': 0}, {'function': '_internalTransfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transferSenderPaysFee_byProxy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferFeeIncurred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_internalTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}, {""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.4031373784306314,0.0977646732202183,"pragma solidity ^0.8.0;

contract MyContract {

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    function transferFeeIncurred(uint256 value) internal view virtual returns (uint256) {
        //Implementation for fee calculation
        return 0; //Replace with actual fee calculation
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal virtual returns (bool) {
        //Implementation for internal transfer logic
        return true; //Replace with actual transfer logic
    }
}",42.05864381790161,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    function transferFeeIncurred(uint256 value) internal view virtual returns (uint256) {
        //Implementation for fee calculation
        return 0; //Replace with actual fee calculation
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal virtual returns (bool) {
        //Implementation for internal transfer logic
        return true; //Replace with actual transfer logic
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
4464,"Returns the cost of the cosigner This cosigner does not have any risk or maintenance cost , so its free .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CostWrapper is Ownable {
    using SafeMath for uint256;

    function cost(address _address, uint256 _uint256, bytes memory _bytes1, bytes memory _bytes2) external view returns (uint256) {
        require(_address != address(0), ""Invalid address"");
        // The logic for calculating the cost is not provided in the snippet.
        return 0;
    }
}",calculateCost,"[{'function': 'calculateCost', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateCost"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""data1"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""data2"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.7737095114027586,0.1463621418748299,"pragma solidity ^0.8.0;

contract CostCalculator {

    function calculateCost(address user, uint256 value, bytes calldata data1, bytes calldata data2) external view returns (uint256) {
        return 0;
    }
}",41.17223596572876,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CostCalculator is Ownable {
    uint256 public cost = 1;
    address public userAddress = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public isAdmin = true;
    string public tokenName = 'MyToken';
    bytes32 public tokenSymbol = bytes32('TKN');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function calculateCost(address user, uint256 value, bytes calldata data1, bytes calldata data2) external view returns (uint256) {
        return cost;
    }
}"
1265,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CapReachedWrapper is Ownable {
    using SafeMath for uint256;

    bool public isFinalized;
    uint256 public finalAmountReturned;
    mapping(uint256 => uint256) public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    function capReached() public view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        }
        return mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length - 1];
    }
}",capReached,"[{'function': 'capReached', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""capReached"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""isFinalized""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalAmountReturned""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""mintedPerTierTotal""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""mintedPerTierTotal""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""mintedPerTierTotal""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokensPerTierTotal""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokensPerTierTotal""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.8805667170135711,0.6762614585942508,"pragma solidity ^0.8.0;

contract MyContract {
    bool public isFinalized;
    uint256 public finalAmountReturned;
    uint256[] public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    function capReached() public view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        } else {
            return mintedPerTierTotal.length > 0 && mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length -1];
        }
    }
}",41.68648147583008,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool public isFinalized;
    uint256 public finalAmountReturned;
    uint256[] public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    constructor() Ownable(msg.sender) {
        isFinalized = false;
        finalAmountReturned = 0;
        mintedPerTierTotal = new uint256[](3); // Assuming there are three tiers, adjust if necessary
        tokensPerTierTotal = new uint256[](3); // Assuming there are three tiers, adjust if necessary
    }

    function capReached() public view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        } else {
            return mintedPerTierTotal.length > 0 && mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length -1];
        }
    }
}"
4986,Returns the number of decimals the token uses .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    function decimals() public view returns (uint8 _decimals) {
        return 18; // Example implementation, adjust as needed
    }
}",decimals,"[{'function': 'decimals', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""decimals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""_decimals""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.9813739710829498,0.4031498868550054,"pragma solidity ^0.8.0;

contract Token {
    uint8 public _decimals;

    constructor(uint8 decimals_) {
        _decimals = decimals_;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }
}",41.26691293716431,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    uint8 public _decimals = 1;

    constructor() {
        initialize();
    }

    function initialize() internal {
        _decimals = 1;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }
}"
6318,Deploy a new TokenNetwork contract for the Token deployed at ` _token_address ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenNetworkFactory is Ownable {
    using SafeMath for uint256;

    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    mapping(address => address) public tokenToTokenNetworks;
    bool public tokenNetworkCreated;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    function createERC20TokenNetwork(address _token_address) external returns (address token_network_address) {
        require(tokenToTokenNetworks[_token_address] == address(0x0), ""Token network already created for this token"");
        tokenNetworkCreated = true;
        TokenNetwork token_network = new TokenNetwork(_token_address, secretRegistryAddress, chainId, settlementTimeoutMin, settlementTimeoutMax, deprecationExecutor);
        token_network_address = address(token_network);
        tokenToTokenNetworks[_token_address] = token_network_address;
        emit TokenNetworkCreated(_token_address, token_network_address);
        return token_network_address;
    }
}

abstract contract TokenNetwork {
    using SafeMath for uint256;

    address public tokenAddress;
    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    constructor(address _token_address, address _secret_registry_address, uint256 _chain_id, uint256 _settlement_timeout_min, uint256 _settlement_timeout_max, address _deprecation_executor) {
        tokenAddress = _token_address;
        secretRegistryAddress = _secret_registry_address;
        chainId = _chain_id;
        settlementTimeoutMin = _settlement_timeout_min;
        settlementTimeoutMax = _settlement_timeout_max;
        deprecationExecutor = _deprecation_executor;
    }
}",createERC20TokenNetwork,"[{'function': 'createERC20TokenNetwork', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createERC20TokenNetwork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""token_to_token_networks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token_address""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token network already exists""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}, ""name"": ""newTokenNetwork"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}, {""type"": ""Identifier"", ""name"": ""secretRegistry""}, {""type"": ""Identifier"", ""name"": ""chainId""}, {""type"": ""Identifier"", ""name"": ""minSettlementTimeout""}, {""type"": ""Identifier"", ""name"": ""maxSettlementTimeout""}, {""type"": ""Identifier"", ""name"": ""deprecationExecutor""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""token_to_token_networks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token_address""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newTokenNetwork""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token_network_created""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenNetworkCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newTokenNetwork""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.9100989194111292,0.3392860208055154,"pragma solidity ^0.8.0;

contract TokenNetworkFactory {

    bool public token_network_created;
    mapping(address => address) public token_to_token_networks;
    address public secretRegistry;
    uint256 public chainId;
    uint256 public minSettlementTimeout;
    uint256 public maxSettlementTimeout;
    address public deprecationExecutor;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    constructor(address _secretRegistry, uint256 _chainId, uint256 _minSettlementTimeout, uint256 _maxSettlementTimeout, address _deprecationExecutor) {
        secretRegistry = _secretRegistry;
        chainId = _chainId;
        minSettlementTimeout = _minSettlementTimeout;
        maxSettlementTimeout = _maxSettlementTimeout;
        deprecationExecutor = _deprecationExecutor;
    }


    function createERC20TokenNetwork(address _token_address) public {
        require(token_to_token_networks[_token_address] == address(0), ""Token network already exists"");

        TokenNetwork newTokenNetwork = new TokenNetwork(_token_address, secretRegistry, chainId, minSettlementTimeout, maxSettlementTimeout, deprecationExecutor);
        token_to_token_networks[_token_address] = address(newTokenNetwork);
        token_network_created = true;

        emit TokenNetworkCreated(_token_address, address(newTokenNetwork));
    }
}

contract TokenNetwork {
    constructor(address _tokenAddress, address _secretRegistry, uint256 _chainId, uint256 _minSettlementTimeout, uint256 _maxSettlementTimeout, address _deprecationExecutor) {
        //Implementation for TokenNetwork constructor.  This is a placeholder.
    }
}",43.889488697052,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenNetworkFactory {
    bool public token_network_created;
    mapping(address => address) public token_to_token_networks;
    address public secretRegistry;
    uint256 public chainId;
    uint256 public minSettlementTimeout;
    uint256 public maxSettlementTimeout;
    address public deprecationExecutor;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    constructor()
        Ownable(msg.sender)
        ERC20(""TokenName"", ""TKN"")
    {
        secretRegistry = 0x1111111111111111111111111111111111111111; // Replace with actual value
        chainId = 1;
        minSettlementTimeout = 1000;
        maxSettlementTimeout = 2000;
        deprecationExecutor = 0x2222222222222222222222222222222222222222; // Replace with actual value
    }

    function createERC20TokenNetwork(address _token_address) public {
        require(token_to_token_networks[_token_address] == address(0), ""Token network already exists"");

        TokenNetwork newTokenNetwork = new TokenNetwork(_token_address, secretRegistry, chainId, minSettlementTimeout, maxSettlementTimeout, deprecationExecutor);
        token_to_token_networks[_token_address] = address(newTokenNetwork);
        token_network_created = true;

        emit TokenNetworkCreated(_token_address, address(newTokenNetwork));
    }
}
import ""openzeppelin/SafeMath.sol"";
contract TokenNetwork {
    constructor(address _tokenAddress, address _secretRegistry, uint256 _chainId, uint256 _minSettlementTimeout, uint256 _maxSettlementTimeout, address _deprecationExecutor)
        Ownable(msg.sender)
    {
        //Implementation for TokenNetwork constructor.  This is a placeholder.
    }
}"
2003,Refund a given address for all the Ether they have contributed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public userFundedPool;

    modifier isAdmin() {
        require(owner() == msg.sender, ""Caller is not the admin"");
        _;
    }

    modifier isAdminRefundable(address _address) {
        require(_address != address(0), ""Invalid address"");
        _;
    }

    modifier userHasFundedPool(address _address) {
        require(userFundedPool[_address], ""User has not funded the pool"");
        _;
    }

    function refundAddress(address _address) public isAdmin isAdminRefundable(_address) userHasFundedPool(_address) {
        processRefundInternal(_address);
    }

    function processRefundInternal(address _address) internal {
        // Implementation of the refund logic
    }
}",refundAddress,"[{'function': 'isAdmin', 'complexity': 0}, {'function': 'isAdminRefundable', 'complexity': 0}, {'function': 'userHasFundedPool', 'complexity': 0}, {'function': 'processRefundInternal', 'complexity': 0}, {'function': 'refundAddress', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""refundAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isAdminRefundable""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Refunds are not allowed by admins""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""userHasFundedPool""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""User has not funded any pool""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""processRefundInternal""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.8526944177812885,0.3037104509847163,"pragma solidity ^0.8.0;

contract MyContract {

    // ... other contract code ...

    modifier onlyAdmin() {
        require(isAdmin(msg.sender), ""Caller is not an admin"");
        _;
    }

    function isAdmin(address _address) internal view virtual returns (bool) {
        //Implementation to check if _address is an admin
    }

    function isAdminRefundable() internal view virtual returns (bool) {
        //Implementation to check if admin allows refunds
    }

    function userHasFundedPool(address _address) internal view virtual returns (bool) {
        //Implementation to check if user has funded a pool
    }

    function processRefundInternal(address _address) internal virtual {
        //Implementation for refund processing
    }


    function refundAddress(address _address) public onlyAdmin {
        require(isAdminRefundable(), ""Refunds are not allowed by admins"");
        require(userHasFundedPool(_address), ""User has not funded any pool"");
        processRefundInternal(_address);
    }

    // ... other contract code ...
}",42.38704824447632,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public constant DEFAULT_ADMIN_ADDRESS = 0x1111111111111111111111111111111111111111;
    address public constant DEFAULT_USER_ADDRESS = 0x2222222222222222222222222222222222222222;
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(DEFAULT_ADMIN_ADDRESS) {
        // Initialize state variables to fixed, safe values
        uint256 public constant DEFAULT_UINT256 = 1;
        address public constant DEFAULT_ADDRESS = 0x3333333333333333333333333333333333333333;

        // Set initialized flag to true
        initialized = true;

        // Call parent contract's constructor
        Ownable(msg.sender).constructor(DEFAULT_ADMIN_ADDRESS);
    }

    modifier onlyAdmin() {
        require(isAdmin(msg.sender), ""Caller is not an admin"");
        _;
    }

    function isAdmin(address _address) internal view virtual returns (bool) {
        //Implementation to check if _address is an admin
    }

    function isAdminRefundable() internal view virtual returns (bool) {
        //Implementation to check if admin allows refunds
    }

    function userHasFundedPool(address _address) internal view virtual returns (bool) {
        //Implementation to check if user has funded a pool
    }

    function processRefundInternal(address _address) internal virtual {
        //Implementation for refund processing
    }

    function refundAddress(address _address) public onlyAdmin {
        require(isAdminRefundable(), ""Refunds are not allowed by admins"");
        require(userHasFundedPool(_address), ""User has not funded any pool"");
        processRefundInternal(_address);
    }
}"
1814,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint securityGuardDelay;
        uint earliestPayTime;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        if (_delay > 10**18) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}",delayPayment,"[{'function': 'delayPayment', 'complexity': 7}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""delayPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_delay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Payment ID out of bounds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_delay""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Delay exceeds maximum value""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""payment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Delay exceeds maximum security guard delay""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""paid""}, ""isPrefix"": True}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""canceled""}, ""isPrefix"": True}}, {""type"": ""stringLiteral"", ""value"": ""Payment already paid or canceled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""earliestPayTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.7238416728464985,0.0855043293699909,"pragma solidity ^0.8.0;

contract MyContract {
    struct Payment {
        uint256 securityGuardDelay;
        uint256 earliestPayTime;
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    function delayPayment(uint256 _idPayment, uint256 _delay) public {
        require(_idPayment < authorizedPayments.length, ""Payment ID out of bounds"");
        require(_delay <= 10**18, ""Delay exceeds maximum value"");
        Payment storage payment = authorizedPayments[_idPayment];
        require(payment.securityGuardDelay + _delay <= 10**18, ""Delay exceeds maximum security guard delay"");
        require(!payment.paid && !payment.canceled, ""Payment already paid or canceled"");
        payment.securityGuardDelay += _delay;
        payment.earliestPayTime += _delay;
    }
}",42.04084277153015,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Payment {
        uint256 securityGuardDelay;
        uint256 earliestPayTime;
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            authorizedPayments.push(Payment({
                securityGuardDelay: 1,
                earliestPayTime: block.timestamp + 1 days * (i + 1),
                paid: false,
                canceled: false
            }));
        }
    }

    function delayPayment(uint256 _idPayment, uint256 _delay) public {
        require(_idPayment < authorizedPayments.length, ""Payment ID out of bounds"");
        require(_delay <= 10**18, ""Delay exceeds maximum value"");
        Payment storage payment = authorizedPayments[_idPayment];
        require(payment.securityGuardDelay + _delay <= 10**18, ""Delay exceeds maximum security guard delay"");
        require(!payment.paid && !payment.canceled, ""Payment already paid or canceled"");
        payment.securityGuardDelay += _delay;
        payment.earliestPayTime += _delay;
    }
}"
4481,This is a private function which should be called from user-implemented external burn function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract NFToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) private _tokenOwner;
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    modifier validNFToken(uint256 tokenId) {
        require(_exists(tokenId), ""NFToken: token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    function clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            delete _tokenApprovals[tokenId];
        }
    }

    function removeNFToken(address owner, uint256 tokenId) internal {
        require(_tokenOwner[tokenId] == owner, ""NFToken: token not owned by owner"");
        delete _tokenOwner[tokenId];
        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);
    }
}",_burn,"[{'function': '_burn', 'complexity': 0}, {'function': 'clearApproval', 'complexity': 0}, {'function': 'removeNFToken', 'complexity': 0}, {'function': 'ownerOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""clearApproval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""removeNFToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validNFToken"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract NFTContract {

    // ... other contract code ...

    modifier validNFToken(uint256 _tokenId) {
        require(ownerOf(_tokenId) != address(0), ""Token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    // ... other contract functions ...

    function clearApproval(uint256 _tokenId) internal {
        //Implementation to clear approvals
    }

    function removeNFToken(address _owner, uint256 _tokenId) internal {
        //Implementation to remove NFT from owner
    }

    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);

    function ownerOf(uint256 _tokenId) internal view returns (address) {
        //Implementation to get owner of tokenId
    }

    // ... rest of the contract ...
}",42.40933561325073,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract NFTContract {
    // Fixed values for instance variables
    uint256 public tokenId = 1;
    address public owner = 0x1111111111111111111111111111111111111111; // Replace with actual owner address
    bool public isInitialized = true;
    bytes32 public initializedBytes = bytes32('init');

    // Parent contracts' uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructors
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    modifier validNFToken(uint256 _tokenId) {
        require(ownerOf(_tokenId) != address(0), ""Token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    // ... other contract code ...

    function clearApproval(uint256 _tokenId) internal {
        //Implementation to clear approvals
    }

    function removeNFToken(address _owner, uint256 _tokenId) internal {
        //Implementation to remove NFT from owner
    }

    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);

    function ownerOf(uint256 _tokenId) internal view returns (address) {
        //Implementation to get owner of tokenId
    }
}"
3728,"Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        require(_value <= balanceOf[msg.sender]);

        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.8724084740269058,0.2901240077440623,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyToken is IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }


    function approve(address spender, uint256 amount) public virtual returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: insufficient balance"");
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // ... other IERC20 functions ...

}",42.224719524383545,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is IERC20, Ownable {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    uint256 public totalSupply;

 constructor(string memory name_, string memory symbol_) Ownable(msg.sender) {
        _name = name_;
        _symbol = symbol_;
        // Initialize state variables with safe non-corner-case values
        _totalSupply = 1000000000000000000;
        address owner = msg.sender;
        _balances[owner] = 1;
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        require(_balances[msg.sender] >= amount, ""ERC20: insufficient balance"");
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // ... other IERC20 functions ...
}"
213,Get the price of a campaign Based on the Campaign id return the value paid for each proof of attention registered .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdvertisementWrapper {
    using SafeMath for uint256;

    struct CampaignPrice {
        bytes32 bidId;
        uint price;
    }

    mapping(bytes32 => uint) public campaignPrices;

    constructor(CampaignPrice[] memory initialCampaigns) {
        for (uint i = 0; i < initialCampaigns.length; i++) {
            campaignPrices[initialCampaigns[i].bidId] = initialCampaigns[i].price;
        }
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return campaignPrices[bidId];
    }
}",getPriceOfCampaign,"[{'function': 'getCampaignPriceById', 'complexity': 0}, {'function': 'getPriceOfCampaign', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPriceOfCampaign"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""advertisementStorage""}, ""memberName"": ""getCampaignPriceById""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""bidId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.8235161374934519,0.6859238121837058,"pragma solidity ^0.8.0;

interface IAdvertisementStorage {
    function getCampaignPriceById(bytes32 bidId) external view returns (uint);
}

contract PriceOracle {
    IAdvertisementStorage public advertisementStorage;

    constructor(address _advertisementStorage) {
        advertisementStorage = IAdvertisementStorage(_advertisementStorage);
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return advertisementStorage.getCampaignPriceById(bidId);
    }
}",41.65036249160767,"pragma solidity ^0.8.0;

interface IAdvertisementStorage {
    function getCampaignPriceById(bytes32 bidId) external view returns (uint);
}
import ""openzeppelin/SafeMath.sol"";
contract PriceOracle is Ownable {
    IAdvertisementStorage public advertisementStorage;

    constructor(address _advertisementStorage) Ownable(msg.sender) {
        advertisementStorage = IAdvertisementStorage(_advertisementStorage);
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return advertisementStorage.getCampaignPriceById(bidId);
    }
}"
2236,Deposit fees into the vault for a Darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface CompatibleERC20 {
    function safeTransferFromWithFees(address from, address to, uint256 value) external returns (uint256);
}

abstract contract DarknodeDeposit is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(ERC20 => uint256)) public darknodeBalances;

    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {
        require(msg.sender == address(this));
        require(_token != address(0) || msg.value == _value);
        require(_token != address(0) && msg.value == 0);
        uint256 receivedValue = _value;
        if (_token != address(0)) {
            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);
        }
        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);
    }
}",deposit,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'deposit', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_darknode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""Identifier"", ""name"": ""ETHEREUM""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect Ether amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknode""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No Ether allowed for token deposits""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""receivedValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""receivedValue""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""receivedValue""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknode""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""Identifier"", ""name"": ""receivedValue""}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",49.0,0.9149571038129328,0.3636666098959266,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract DarknodeDeposit {
    address constant ETHEREUM = address(0);
    mapping(address => mapping(address => uint256)) public darknodeBalances;

    function deposit(address _darknode, address _token, uint256 _value) external payable {
        if (_token == ETHEREUM) {
            require(msg.value == _value, ""Incorrect Ether amount"");
            darknodeBalances[_darknode][_token] += _value;
        } else {
            require(msg.value == 0, ""No Ether allowed for token deposits"");
            IERC20 token = IERC20(_token);
            uint256 receivedValue = token.balanceOf(address(this));
            token.transferFrom(msg.sender, address(this), _value);
            receivedValue = token.balanceOf(address(this)) - receivedValue;
            darknodeBalances[_darknode][_token] += receivedValue;
        }
    }
}",42.51244616508484,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract DarknodeDeposit is Ownable {
    address constant ETHEREUM = address(0x1111111111111111111111111111111111111111); // fixed Ethereum address
    mapping(address => mapping(address => uint256)) public darknodeBalances;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe values
        darknodeBalances[msg.sender][ETHEREUM] = 1; // Set to 1 (never 0)
        darknodeBalances[msg.sender]['MyToken'] = 1; // Use placeholder value for ERC20 token
    }

    function deposit(address _darknode, address _token, uint256 _value) external payable {
        if (_token == ETHEREUM) {
            require(msg.value == _value, ""Incorrect Ether amount"");
            darknodeBalances[_darknode][_token] += _value;
        } else {
            require(msg.value == 0, ""No Ether allowed for token deposits"");
            IERC20 token = IERC20(_token);
            uint256 receivedValue = token.balanceOf(address(this));
            token.transferFrom(msg.sender, address(this), _value);
            receivedValue = token.balanceOf(address(this)) - receivedValue;
            darknodeBalances[_darknode][_token] += receivedValue;
        }
    }

    // Other contract functions...
}"
3103,Checks whether redemption is permitted for a participant,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RedemptionPermitWrapper is Ownable {
    using SafeMath for uint256;

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public view returns (bool) {
        return true;
    }
}",isRedemptionPermitted,"[{'function': 'isRedemptionPermitted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRedemptionPermitted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""ofParticipant"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""shareQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""receiveQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract RedemptionContract {

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public view returns (bool) {
        return true;
    }
}",40.87410235404968,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract RedemptionContract is Ownable {
    uint256 public constant SHARE_QUANTITY = 1;
    uint256 public constant RECEIVE_QUANTITY = 1;
    address public constant PARTICIPANT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant IS_REDEMPTION_PERMITTED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public view returns (bool) {
        return true;
    }
}"
5733,Function which decodes bytes32 to array of integers,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DecodeAssetsWrapper {
    using SafeMath for uint256;

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory assets) {
        require(_potentialAssets.length > 0);

        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint numberOfAssets = 0;

        for (uint j = 0; j < _potentialAssets.length; j++) {
            uint input;
            bytes32 pot = _potentialAssets[j];
            assembly {
                input := pot
            }

            for (uint i = 10; i > 0; i--) {
                uint mask = (2 << ((i - 1) * 24)) / 2;
                uint b = (input & (mask * 16777215)) / mask;
                if (b != 0) {
                    assetsCopy[numberOfAssets] = b;
                    numberOfAssets++;
                }
            }
        }

        assets = new uint[](numberOfAssets);
        for (uint i = 0; i < numberOfAssets; i++) {
            assets[i] = assetsCopy[i];
        }
    }
}",decodeAssets,"[{'function': 'decodeAssets', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""decodeAssets"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": ""_potentialAssets"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Empty input array""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""assetsCopy"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""assetsCount"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""assetId"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""assetId""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_potentialAssets"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""mul"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""i"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""32""}]}]}, {""type"": ""DecimalNumber"", ""value"": ""16""}]}]}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""assetId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetsCopy""}, ""index"": {""type"": ""Identifier"", ""name"": ""assetsCount""}}, ""right"": {""type"": ""Identifier"", ""name"": ""assetId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""assetsCount""}, ""isPrefix"": False}}]}, ""FalseBody"": None}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""assets"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""assetsCount""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""assetsCount""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetsCopy""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}]}}, {""type"": ""Identifier"", ""name"": ""assets""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",59.0,0.858349974591639,0.4200537087231837,"pragma solidity ^0.8.0;

contract AssetDecoder {

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory) {
        require(_potentialAssets.length > 0, ""Empty input array"");
        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint assetsCount;
        for (uint i = 0; i < _potentialAssets.length; i++) {
            uint assetId;
            assembly {
                assetId := mload(add(add(_potentialAssets, mul(i, 32)), 16)) // Extract from bytes32 (adjust offset as needed)
            }
            if (assetId > 0) {
                assetsCopy[assetsCount] = assetId;
                assetsCount++;
            }
        }
        uint[] memory assets = new uint[](assetsCount);
        for (uint i = 0; i < assetsCount; i++) {
            assets[i] = assetsCopy[i];
        }
        return assets;
    }
}",42.23001050949097,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetDecoder is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory) {
        require(_potentialAssets.length > 0, ""Empty input array"");
        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint assetsCount;
        for (uint i = 0; i < _potentialAssets.length; i++) {
            uint assetId;
            assembly {
                assetId := mload(add(add(_potentialAssets, mul(i, 32)), 16)) // Extract from bytes32 (adjust offset as needed)
            }
            if (assetId > 0) {
                assetsCopy[assetsCount] = assetId;
                assetsCount++;
            }
        }
        uint[] memory assets = new uint[](assetsCount);
        for (uint i = 0; i < assetsCount; i++) {
            assets[i] = assetsCopy[i];
        }
        return assets;
    }
}"
5459,Begins the token sale for this token instance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    function initializeTokenSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) public onlyOwner {
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}",initializeSale,"[{'function': 'initializeSale', 'complexity': 0}, {'function': 'initializeSale', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_saleStartTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_saleEndTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountForSale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""initializeSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_saleStartTime""}, {""type"": ""Identifier"", ""name"": ""_saleEndTime""}, {""type"": ""Identifier"", ""name"": ""_price""}, {""type"": ""Identifier"", ""name"": ""_amountForSale""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""ownerOnly"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9407130288492952,0.5276933229029578,"pragma solidity ^0.8.0;

contract TokenSale {

    address public owner;

    modifier ownerOnly() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function initializeSale(uint256 _saleStartTime, uint256 _saleEndTime, uint256 _price, uint256 _amountForSale, address payable _beneficiary) public ownerOnly {
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }

    function initializeSale(uint256 _saleStartTime, uint256 _saleEndTime, uint256 _price, uint256 _amountForSale, address payable _beneficiary) internal {
        //Implementation to initialize the sale.  This would typically involve setting state variables.
    }
}",41.9599347114563,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    address public owner = msg.sender;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
6434,Set current preICO price in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public preICOprice;

    constructor() Ownable() {}

    function setPreICOPrice(uint256 priceForPreIcoInWei) public isOwner {
        require(priceForPreIcoInWei > 0, ""The price for pre-ICO should be greater than zero"");
        require(preICOprice != priceForPreIcoInWei, ""The price for pre-ICO has not changed"");
        preICOprice = priceForPreIcoInWei;
        updatePrices();
    }
}",setPreICOprice,"[{'function': 'setPreICOprice', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreICOprice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceForPreIcoInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""priceForPreIcoInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""priceForPreIcoInWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""preICOprice""}}, {""type"": ""stringLiteral"", ""value"": ""New price must differ from current price""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preICOprice""}, ""right"": {""type"": ""Identifier"", ""name"": ""priceForPreIcoInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.94997234306125,0.5196325362124997,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public preICOprice;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setPreICOprice(uint256 priceForPreIcoInWei) public onlyOwner {
        require(priceForPreIcoInWei > 0, ""Price must be greater than zero"");
        require(priceForPreIcoInWei != preICOprice, ""New price must differ from current price"");
        preICOprice = priceForPreIcoInWei;
        updatePrices();
    }

    function updatePrices() internal virtual {
        //Implementation for updating other prices
    }
}",42.11814498901367,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public preICOprice;
    address public owner;

    constructor() Ownable(msg.sender) {
        preICOprice = 1;
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setPreICOprice(uint256 priceForPreIcoInWei) public onlyOwner {
        require(priceForPreIcoInWei > 0, ""Price must be greater than zero"");
        require(priceForPreIcoInWei != preICOprice, ""New price must differ from current price"");
        preICOprice = priceForPreIcoInWei;
        updatePrices();
    }

    function updatePrices() internal virtual {
        //Implementation for updating other prices
    }
}"
30,Called in order to get the number of members on the platform,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Define membersArray as a state variable
    address[] public membersArray;

    function getMembersArrayLength() public view returns (uint256) {
        return membersArray.length;
    }
}",getMembersArrayLength,"[{'function': 'getMembersArrayLength', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMembersArrayLength"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""membersArray""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {
    address[] public membersArray;

    function getMembersArrayLength() public view returns (uint256) {
        return membersArray.length;
    }
}",41.13757729530335,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address[] public membersArray;

    constructor() Ownable(msg.sender) {
        membersArray = [address(0x111), address(0x222), address(0x333)];
    }

    function getMembersArrayLength() public view returns (uint256) {
        return membersArray.length;
    }
}"
3380,Count the number of validators defined by the jurisdiction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorCounter {
    using SafeMath for uint256;

    address[] private _validatorAccounts;

    function countValidators() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}",getValidatorCount,"[{'function': 'getValidatorCount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValidatorCount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_validatorAccounts""}, ""memberName"": ""length""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.937182300394165,0.855526185871245,"pragma solidity ^0.8.0;

contract ValidatorRegistry {
    address[] private _validatorAccounts;

    function getValidatorCount() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}",41.24662232398987,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ValidatorRegistry is Ownable {
    address[] private _validatorAccounts;

    constructor() Ownable(msg.sender) {
        _validatorAccounts = [address(1), address(2), address(3)];
    }

    function getValidatorCount() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}"
5188,allows to retreive multiple exchange rates in once call,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchangeRate {
    function getExchangeRate(address numeratorToken, address denominatorToken) external view returns (uint256);
    function getTimestamp() external view returns (uint256);
}

abstract contract ExchangeRates is Ownable {
    using SafeMath for uint256;

    IExchangeRate public exchangeRateContract;

    constructor(address _exchangeRateAddress) {
        exchangeRateContract = IExchangeRate(_exchangeRateAddress);
    }

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public view returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length > 0 && denominatorTokens.length > 0);
        require(numeratorTokens.length == denominatorTokens.length, ""Lengths must be equal"");

        rateFractions = new uint256[](numeratorTokens.length * denominatorTokens.length);
        timestamps = new uint256[](numeratorTokens.length * denominatorTokens.length);

        for (uint256 i = 0; i < numeratorTokens.length; i++) {
            address numeratorToken = numeratorTokens[i];
            for (uint256 j = 0; j < denominatorTokens.length; j++) {
                address denominatorToken = denominatorTokens[j];
                uint256 rateFraction = exchangeRateContract.getExchangeRate(numeratorToken, denominatorToken);
                uint256 timestamp = exchangeRateContract.getTimestamp();
                rateFractions[i * denominatorTokens.length + j] = rateFraction;
                timestamps[i * denominatorTokens.length + j] = timestamp;
            }
        }
    }
}",getExchangeRates,"[{'function': 'getExchangeRates', 'complexity': 2}, {'function': 'calculateExchangeRate', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getExchangeRates"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""numeratorTokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""denominatorTokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""rateFractions"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""timestamps"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Array lengths must match""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""rateFractions""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timestamps""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}], ""names"": []}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rateFractions""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateExchangeRate""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""timestamps""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",67.0,0.756841796034998,0.3897787741101968,"pragma solidity ^0.8.0;

contract ExchangeRateOracle {

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public view returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length == denominatorTokens.length, ""Array lengths must match"");
        rateFractions = new uint256[](numeratorTokens.length);
        timestamps = new uint256[](numeratorTokens.length);

        for (uint256 i = 0; i < numeratorTokens.length; i++) {
            // Replace this with your actual exchange rate calculation logic
            rateFractions[i] = calculateExchangeRate(numeratorTokens[i], denominatorTokens[i]);
            timestamps[i] = block.timestamp;
        }
    }

    function calculateExchangeRate(address numeratorToken, address denominatorToken) internal view returns (uint256) {
        //  Implementation for exchange rate calculation.  This is a placeholder.  Replace with your actual logic.
        //  This example returns 1 for all pairs.  In a real implementation, you would fetch this from an external oracle or calculate it based on your contract's state.
        return 1;
    }
}",42.67485451698303,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ExchangeRateOracle is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public view returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length == denominatorTokens.length, ""Array lengths must match"");
        rateFractions = new uint256[](numeratorTokens.length);
        timestamps = new uint256[](numeratorTokens.length);

        for (uint256 i = 0; i < numeratorTokens.length; i++) {
            // Replace this with your actual exchange rate calculation logic
            rateFractions[i] = calculateExchangeRate(numeratorTokens[i], denominatorTokens[i]);
            timestamps[i] = block.timestamp;
        }
    }

    function calculateExchangeRate(address numeratorToken, address denominatorToken) internal view returns (uint256) {
        //  Implementation for exchange rate calculation.  This is a placeholder.  Replace with your actual logic.
        //  This example returns 1 for all pairs.  In a real implementation, you would fetch this from an external oracle or calculate it based on your contract's state.
        return 1;
    }
}"
316,send ` _value ` token to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    address[] public tokenHolders;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        emit LogForkAnnounced(name, url, blockNumber);
    }
}",transfer,"[{'function': 'transfer', 'complexity': 2}, {'function': 'toRecord', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""toRecord""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.8619877400117256,0.6484011539923094,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0), ""Transfer to the zero address"");
        require(balances[msg.sender] >= _value, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);
        toRecord(msg.sender, _to, _value);

        return true;
    }

    function toRecord(address from, address to, uint256 value) internal {
        //Implementation for external record-keeping function.  Replace with actual implementation.
    }
}",42.52012205123901,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance of owner to 1 (never 0)
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0), ""Transfer to the zero address"");
        require(balances[msg.sender] >= _value, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);
        toRecord(msg.sender, _to, _value);

        return true;
    }

    function toRecord(address from, address to, uint256 value) internal {
        //Implementation for external record-keeping function.  Replace with actual implementation.
    }
}"
4609,"Add beneficiaries to the contract , allowing them to withdraw tokens .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    struct Info {
        bool known;
        uint256 startTime;
        uint256 totalAmount;
        uint256 releaseTime;
    }

    mapping(address => Info) private _info;

    function addBeneficiary(address beneficiary, uint256 startTime, uint256 releaseTime, uint256 amount) external onlyOwner {
        require(_info[beneficiary].known == false, ""This address is already known to the contract."");
        require(releaseTime > startTime, ""Release time must be later than the start time."");
        require(releaseTime > block.timestamp, ""End of vesting period must be somewhere in the future."");

        Info storage info = _info[beneficiary];
        info.startTime = startTime;
        info.totalAmount = amount;
        info.releaseTime = releaseTime;
        info.known = true;
    }
}",addBeneficiary,"[{'function': 'addBeneficiary', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""releaseTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}, {""type"": ""stringLiteral"", ""value"": ""Release time must be after start time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Release time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaryInfo""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BeneficiaryInfo""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""startTime""}, {""type"": ""Identifier"", ""name"": ""releaseTime""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""isNotBeneficiary"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.689976619741997,0.367697415190193,"pragma solidity ^0.8.0;

contract Vesting {

    struct BeneficiaryInfo {
        uint256 startTime;
        uint256 releaseTime;
        uint256 totalAmount;
        bool known;
    }

    mapping(address => BeneficiaryInfo) public beneficiaryInfo;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    modifier isNotBeneficiary(address _beneficiary) {
        require(!beneficiaryInfo[_beneficiary].known, ""Beneficiary already exists"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addBeneficiary(address beneficiary, uint256 startTime, uint256 releaseTime, uint256 amount)
        public
        onlyOwner
        isNotBeneficiary(beneficiary)
    {
        require(releaseTime > startTime, ""Release time must be after start time"");
        require(releaseTime > block.timestamp, ""Release time must be in the future"");

        beneficiaryInfo[beneficiary] = BeneficiaryInfo(startTime, releaseTime, amount, true);
    }
}",42.65994024276733,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Vesting is Ownable {

    struct BeneficiaryInfo {
        uint256 startTime;
        uint256 releaseTime;
        uint256 totalAmount;
        bool known;
    }

    mapping(address => BeneficiaryInfo) public beneficiaryInfo;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    modifier isNotBeneficiary(address _beneficiary) {
        require(!beneficiaryInfo[_beneficiary].known, ""Beneficiary already exists"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are initialized in the parent contract
    }

    function addBeneficiary(address beneficiary, uint256 startTime, uint256 releaseTime, uint256 amount)
        public
        onlyOwner
        isNotBeneficiary(beneficiary)
    {
        require(releaseTime > startTime, ""Release time must be after start time"");
        require(releaseTime > block.timestamp, ""Release time must be in the future"");

        beneficiaryInfo[beneficiary] = BeneficiaryInfo(startTime, releaseTime, amount, true);
    }
}"
5346,You must send some ETH to cover the oraclize_query fees,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    enum Stage { ToInitialize, Waiting, Running, Ended }

    uint256 public startTime;
    uint256 public endTime;
    Token public token;
    uint256 public intervalUpdate;
    Stage public currentStage = Stage.ToInitialize;
    uint256 public constant MAX_TOKENS = 10**28; // Example value, adjust as needed

    constructor(address _token) {
        require(_token != address(0));
        token = Token(_token);
    }

    function initializeCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _intervalUpdate) public payable onlyOwner mustBeAtStage(Stage.ToInitialize) {
        require(_startTime >= block.timestamp);
        require(_endTime >= _startTime);
        require(_token != address(0));
        require(msg.value > 0);
        require(isContract(_token) == true);
        require(_intervalUpdate >= 5);

        startTime = _startTime;
        endTime = _endTime;
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;
        updateEthRateWithDelay(startTime - (intervalUpdate + 30));
        emit LogCrowdsaleInit();
        assert(token.balanceOf(address(this)) == MAX_TOKENS);
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    modifier mustBeAtStage(Stage requiredStage) {
        require(currentStage == requiredStage, ""Must be at the specified stage"");
        _;
    }

    function updateEthRateWithDelay(uint256 delayTime) internal {
        // Implementation of the delay logic
    }

    event LogCrowdsaleInit();
}",initialize,"[{'function': 'initialize', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_endTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_intervalUpdate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_startTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Start time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_endTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}, {""type"": ""stringLiteral"", ""value"": ""End time must be after start time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Must send Ether""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token contract must have tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_intervalUpdate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Interval update must be at least 5 seconds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""startTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""endTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_endTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""intervalUpdate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_intervalUpdate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentStage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""Waiting""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogCrowdsaleInit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""startTime""}, {""type"": ""Identifier"", ""name"": ""endTime""}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""intervalUpdate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_TOKENS""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect token balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",28.0,0.9160548409039386,0.385659232396325,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Crowdsale {
    enum Stage {Waiting, Running, Finished}

    uint256 public startTime;
    uint256 public endTime;
    IERC20 public token;
    uint256 public intervalUpdate;
    Stage public currentStage;
    uint256 public constant MAX_TOKENS = 1000000; // Example value

    event LogCrowdsaleInit(uint256 startTime, uint256 endTime, address token, uint256 intervalUpdate);

    function initialize(
        uint256 _startTime,
        uint256 _endTime,
        address _token,
        uint256 _intervalUpdate
    ) public payable {
        require(_startTime >= block.timestamp, ""Start time must be in the future"");
        require(_endTime > _startTime, ""End time must be after start time"");
        require(_token != address(0), ""Token address cannot be zero"");
        require(msg.value > 0, ""Must send Ether"");
        require(IERC20(_token).totalSupply() > 0, ""Token contract must have tokens"");
        require(_intervalUpdate >= 5, ""Interval update must be at least 5 seconds"");

        startTime = _startTime;
        endTime = _endTime;
        token = IERC20(_token);
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;

        //Update ETH rate with delay (implementation omitted for brevity)

        emit LogCrowdsaleInit(startTime, endTime, _token, intervalUpdate);

        require(token.balanceOf(address(this)) == MAX_TOKENS, ""Incorrect token balance"");
    }
}",43.25150346755981,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Crowdsale is Ownable {
    enum Stage {Waiting, Running, Finished}

    uint256 public startTime;
    uint256 public endTime;
    IERC20 public token;
    uint256 public intervalUpdate;
    Stage public currentStage;
    uint256 public constant MAX_TOKENS = 1000000; // Example value

    event LogCrowdsaleInit(uint256 startTime, uint256 endTime, address token, uint256 intervalUpdate);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable() {
        startTime = 1;
        endTime = 2;
        token = IERC20(address(3));
        intervalUpdate = 5;
        currentStage = Stage.Waiting;
    }

    function initialize(
        uint256 _startTime,
        uint256 _endTime,
        address _token,
        uint256 _intervalUpdate
    ) public payable {
        require(_startTime >= block.timestamp, ""Start time must be in the future"");
        require(_endTime > _startTime, ""End time must be after start time"");
        require(_token != address(0), ""Token address cannot be zero"");
        require(msg.value > 0, ""Must send Ether"");
        require(IERC20(_token).totalSupply() > 0, ""Token contract must have tokens"");
        require(_intervalUpdate >= 5, ""Interval update must be at least 5 seconds"");

        startTime = _startTime;
        endTime = _endTime;
        token = IERC20(_token);
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;

        //Update ETH rate with delay (implementation omitted for brevity)

        emit LogCrowdsaleInit(startTime, endTime, _token, intervalUpdate);

        require(token.balanceOf(address(this)) == MAX_TOKENS, ""Incorrect token balance"");
    }
}"
2424,Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeToken {
    function changeController(address _newController) external;
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    constructor() {}

    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public onlyOwner returns (MiniMeToken) {
        MiniMeToken newToken = MiniMeToken(_parentToken).cloneTokenWithDetails(_snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled);
        newToken.changeController(msg.sender);
        return newToken;
    }
}",createCloneToken,"[{'function': 'createCloneToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_parentToken"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_snapshotBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_tokenName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_decimalUnits"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_tokenSymbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}, ""name"": ""newToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_parentToken""}, {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}, {""type"": ""Identifier"", ""name"": ""_tokenName""}, {""type"": ""Identifier"", ""name"": ""_decimalUnits""}, {""type"": ""Identifier"", ""name"": ""_tokenSymbol""}, {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newToken""}, ""memberName"": ""changeController""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newToken""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.9306189122739708,0.667315261105094,"pragma solidity ^0.8.0;

import ""./MiniMeToken.sol"";

contract CloneFactory {

    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public returns (address) {
        MiniMeToken newToken = new MiniMeToken(_parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled, address(this));
        newToken.changeController(msg.sender);
        return address(newToken);
    }
}",41.74728441238403,"pragma solidity ^0.8.0;

import ""./MiniMeToken.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CloneFactory is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public returns (address) {
        MiniMeToken newToken = new MiniMeToken(_parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled, address(this));
        newToken.changeController(msg.sender);
        return address(newToken);
    }
}"
474,Burns the coins held by the sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function burn(uint256 _value) public whenNotPaused {
        super.burn(_value);
    }
}",burn,"[{'function': 'burn', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_burn""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.8728624337427859,0.5682854869630479,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20, Pausable {

    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function burn(uint256 _value) public whenNotPaused {
        _burn(_msgSender(), _value);
    }
}",41.57535934448242,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Pausable, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(_msgSender(), 1 * 10 ** uint256(decimals())); // Initialize with a safe non-corner-case value
        transferOwnership(msg.sender); // Ensure the contract is owned by the deployer
    }

    function burn(uint256 _value) public whenNotPaused {
        _burn(_msgSender(), _value);
    }
}"
1413,Overwrite leaderboard name and desctiption as owner only,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BoardManager is Ownable {
    using SafeMath for uint256;

    struct Board {
        bytes32 boardName;
        string boardDescription;
        address boardOwner;
    }

    mapping(bytes32 => Board) public boards;

    function changeBoardMetadata(bytes32 boardHash, bytes32 name, string memory boardDescription) public onlyOwner returns (bool) {
        require(boards[boardHash].boardOwner == msg.sender);
        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
        return true;
    }
}",changeBoardMetadata,"[{'function': 'changeBoardMetadata', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeBoardMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""boardHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""boardDescription"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""boardHash""}}, ""memberName"": ""boardOwner""}}, {""type"": ""stringLiteral"", ""value"": ""Not authorized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""boardHash""}}, ""memberName"": ""boardName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""boardHash""}}, ""memberName"": ""boardDescription""}, ""right"": {""type"": ""Identifier"", ""name"": ""boardDescription""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.9110638800153746,0.5252357526209009,"pragma solidity ^0.8.0;

contract BoardContract {
    struct Board {
        address boardOwner;
        string boardName;
        string boardDescription;
    }

    mapping(bytes32 => Board) public boards;

    function changeBoardMetadata(bytes32 boardHash, string memory name, string memory boardDescription) public {
        require(msg.sender == boards[boardHash].boardOwner, ""Not authorized"");
        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
    }
}",41.39699959754944,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BoardContract is Ownable {
    struct Board {
        address boardOwner;
        string boardName;
        string boardDescription;
    }

    mapping(bytes32 => Board) public boards;

    constructor() Ownable(msg.sender) {
        // Initialize all state variables with safe, non-corner-case values
        for (bytes32 key = bytes32('a'); uint(key) < 10; key = bytes32(uint(key) + 1)) {
            boards[key] = Board({
                boardOwner: address(uint160(uint(key))),
                boardName: 'initialized',
                boardDescription: 'initialized'
            });
        }
    }

    function changeBoardMetadata(bytes32 boardHash, string memory name, string memory boardDescription) public {
        require(msg.sender == boards[boardHash].boardOwner, ""Not authorized"");
        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
    }
}"
6348,"Helps to generate Collectibles/Tokens/Asset and transfer to ETH Cards , which can be redeemed using our web-app.The generation of an asset if limited via the generationSeasonController","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ETHCardCollectible is Ownable {
    using SafeMath for uint256;

    uint8 public teamId;
    uint8 public posId;
    uint256 public attributes;
    address public owner;
    uint256 public gameId;
    uint256 public playerOverrideId;
    uint256 public mlbPlayerId;
    uint256 public rewardsRedeemed;
    address public managerPrimary;
    bool public paused = false;

    constructor(address _managerPrimary) {
        managerPrimary = _managerPrimary;
    }

    function createETHCardCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external canCreate whenNotPaused returns (uint256) {
        address nftOwner = _owner;
        if (nftOwner == address(0)) {
            nftOwner = managerPrimary;
        }
        rewardsRedeemed++;
        uint32 _sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(uint64(now));
        assetDetails |= uint256(_sequenceId) << 64;
        assetDetails |= uint256(_teamId) << 96;
        assetDetails |= uint256(_posId) << 104;
        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];
        return _createNFTCollectible(_teamId, _attributes, nftOwner, 2, _nftData);
    }

    function getSequenceId(uint8 _teamId) internal pure returns (uint32) {
        // Implementation of getSequenceId logic
        return uint32(_teamId);
    }

    function _createNFTCollectible(uint8 _teamId, uint256 _attributes, address _owner, uint256 _type, uint256[5] memory _nftData) internal returns (uint256) {
        // Implementation of create NFT logic
        return 0;
    }

    modifier canCreate() {
        require(msg.sender == owner || msg.sender == managerPrimary, ""Not authorized to create collectible"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }
}",createCollectible,"[{'function': 'createCollectible', 'complexity': 0}, {'function': 'getSequenceId', 'complexity': 0}, {'function': '_createNFTCollectible', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCollectible"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_teamId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_posId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_attributes"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_gameId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_playerOverrideId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_mlbPlayerId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""rewardsRedeemed""}, ""isPrefix"": False}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueExpression"": {""type"": ""Identifier"", ""name"": ""managerPrimary""}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""_owner""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sequenceId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getSequenceId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_teamId""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""assetDetails"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""Identifier"", ""name"": ""sequenceId""}, {""type"": ""Identifier"", ""name"": ""_teamId""}, {""type"": ""Identifier"", ""name"": ""_posId""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_nftData"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""assetDetails""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""_attributes""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""_gameId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""_playerOverrideId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""_mlbPlayerId""}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createNFTCollectible""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_teamId""}, {""type"": ""Identifier"", ""name"": ""_attributes""}, {""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_nftData""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canCreate"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.8003675614449485,0.4284252412581558,"pragma solidity ^0.8.0;

// Assume necessary imports and contracts are defined here, including SafeMath,  ERC721, and modifiers like canCreate and whenNotPaused

contract MyContract {
    uint256 public rewardsRedeemed;
    address public managerPrimary; // Assume this is defined elsewhere

    function createCollectible(
        uint256 _teamId,
        uint256 _posId,
        uint256 _attributes,
        address _owner,
        uint256 _gameId,
        uint256 _playerOverrideId,
        uint256 _mlbPlayerId
    ) public canCreate whenNotPaused returns (uint256) {
        rewardsRedeemed++;
        address owner = _owner == address(0) ? managerPrimary : _owner;
        uint256 sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(keccak256(abi.encodePacked(block.timestamp, sequenceId, _teamId, _posId)));
        uint256[] memory _nftData = new uint256[](5);
        _nftData[0] = assetDetails;
        _nftData[1] = _attributes;
        _nftData[2] = _gameId;
        _nftData[3] = _playerOverrideId;
        _nftData[4] = _mlbPlayerId;
        return _createNFTCollectible(_teamId, _attributes, owner, 2, _nftData);
    }

    function getSequenceId(uint256 _teamId) internal view returns (uint256) {
        //Implementation to retrieve sequence ID.  Replace with actual logic.
        return 0;
    }

    function _createNFTCollectible(uint256 _teamId, uint256 _attributes, address _owner, uint256 _type, uint256[] memory _nftData) internal returns (uint256) {
        //Implementation to create NFT. Replace with actual logic using your ERC721 implementation.
        return 0;
    }
}",44.09978485107422,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public rewardsRedeemed;
    address public managerPrimary;

    constructor() Ownable(msg.sender) {
        rewardsRedeemed = 1; // Set to 1 (never 0)
        managerPrimary = address(uint160(uint256(keccak256(abi.encodePacked(bytes1('a'))))); // Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
    }

    function createCollectible(
        uint256 _teamId,
        uint256 _posId,
        uint256 _attributes,
        address _owner,
        uint256 _gameId,
        uint256 _playerOverrideId,
        uint256 _mlbPlayerId
    ) public canCreate whenNotPaused returns (uint256) {
        rewardsRedeemed++;
        address owner = _owner == address(0) ? managerPrimary : _owner;
        uint256 sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(keccak256(abi.encodePacked(block.timestamp, sequenceId, _teamId, _posId)));
        uint256[] memory _nftData = new uint256[](5);
        _nftData[0] = assetDetails;
        _nftData[1] = _attributes;
        _nftData[2] = _gameId;
        _nftData[3] = _playerOverrideId;
        _nftData[4] = _mlbPlayerId;
        return _createNFTCollectible(_teamId, _attributes, owner, 2, _nftData);
    }

    function getSequenceId(uint256 _teamId) internal view returns (uint256) {
        //Implementation to retrieve sequence ID. Replace with actual logic.
        return 0;
    }

    function _createNFTCollectible(uint256 _teamId, uint256 _attributes, address _owner, uint256 _type, uint256[] memory _nftData) internal returns (uint256) {
        //Implementation to create NFT. Replace with actual logic using your ERC721 implementation.
        return 0;
    }
}"
6764,"This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address[]) public s_paid;
    uint256 public fee;

    modifier only_delegate() {
        require(hasRole(keccak256(""DELEGATE""), msg.sender), ""Only delegate can call this function"");
        _;
    }

    function revoke(address who, address origin) payable external only_delegate {
        require(msg.value == fee, ""Incorrect fee amount"");
        bool found = false;
        for (uint i = 0; i < s_paid[who].length; i++) {
            if (s_paid[who][i] != origin) {
                continue;
            }
            found = true;
            uint lastIndex = s_paid[who].length.sub(1);
            if (i != lastIndex) {
                s_paid[who][i] = s_paid[who][lastIndex];
            }
            s_paid[who].pop();
            break;
        }
        require(found, ""Origin not found"");
        origin.transfer(msg.value);
    }
}",revoke,"[{'function': 'isDelegate', 'complexity': 0}, {'function': 'revoke', 'complexity': 6}, {'function': 'setFee', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""revoke"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""origin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect fee""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""len"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""memberName"": ""length""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""found"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""len""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""origin""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""len""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""s_paid""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""found""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""found""}, {""type"": ""stringLiteral"", ""value"": ""Origin not found""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""origin""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""only_delegate"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",36.0,0.9062785405792476,0.5209431497271746,"pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => address[]) public s_paid;
    uint256 public fee;

    modifier only_delegate() {
        // Add logic to check if the caller is a delegate
        require(isDelegate(msg.sender), ""Caller is not a delegate"");
        _;
    }

    function isDelegate(address _addr) internal view returns (bool) {
        // Add your delegate check logic here.  This is a placeholder.
        return true;
    }

    function revoke(address who, address origin) public payable only_delegate {
        require(msg.value == fee, ""Incorrect fee"");
        uint256 len = s_paid[who].length;
        bool found = false;
        for (uint256 i = 0; i < len; i++) {
            if (s_paid[who][i] == origin) {
                s_paid[who][i] = s_paid[who][len - 1];
                s_paid[who].pop();
                found = true;
                break;
            }
        }
        require(found, ""Origin not found"");
        payable(origin).transfer(msg.value);
    }

    function setFee(uint256 _fee) public {
        fee = _fee;
    }
}",42.81344842910767,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => address[]) public s_paid;
    uint256 public fee = 1;

    modifier only_delegate() {
        require(isDelegate(msg.sender), ""Caller is not a delegate"");
        _;
    }

    function isDelegate(address _addr) internal view returns (bool) {
        // Add your delegate check logic here.  This is a placeholder.
        return true;
    }

    function revoke(address who, address origin) public payable only_delegate {
        require(msg.value == fee, ""Incorrect fee"");
        uint256 len = s_paid[who].length;
        bool found = false;
        for (uint256 i = 0; i < len; i++) {
            if (s_paid[who][i] == origin) {
                s_paid[who][i] = s_paid[who][len - 1];
                s_paid[who].pop();
                found = true;
                break;
            }
        }
        require(found, ""Origin not found"");
        payable(origin).transfer(msg.value);
    }

    function setFee(uint256 _fee) public {
        fee = _fee;
    }
}"
5397,Transfers tokens held by timelock to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenRelease is Ownable {
    using SafeMath for uint;

    uint public releaseTime;
    uint public current_month;
    uint public month = 1 months;
    uint public twenty_percent_of_amount;
    address public beneficiary;
    IERC20 public token;

    constructor(uint _releaseTime, uint _twenty_percent_of_amount, address _beneficiary, address _token) {
        releaseTime = _releaseTime;
        current_month = 1;
        twenty_percent_of_amount = _twenty_percent_of_amount;
        beneficiary = _beneficiary;
        token = IERC20(_token);
    }

    function release() public {
        require(now >= releaseTime, ""Release time not yet reached"");
        assert(current_month <= 5);
        uint diff = now - releaseTime;
        if (diff > month) {
            releaseTime = now;
        } else {
            releaseTime = now.add(month.sub(diff));
        }
        current_month++;
        token.safeTransfer(beneficiary, twenty_percent_of_amount);
    }
}",release,"[{'function': 'release', 'complexity': 5}, {'function': 'transfer', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""release"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}, {""type"": ""stringLiteral"", ""value"": ""Release time not reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""current_month""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Maximum release cycles reached""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""diff"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""releaseTime""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""diff""}, ""right"": {""type"": ""Identifier"", ""name"": ""month""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""month""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""diff""}], ""names"": []}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""current_month""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""twenty_percent_of_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8630946998366833,0.4606376223869364,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenRelease {
    using SafeMath for uint256;

    uint256 public releaseTime;
    uint256 public current_month;
    uint256 public constant month = 2628000; // seconds in a month (approx)
    address public beneficiary;
    uint256 public twenty_percent_of_amount;


    constructor(address _beneficiary, uint256 _releaseTime, uint256 _amount) {
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
        twenty_percent_of_amount = _amount.mul(20).div(100);
    }

    function release() public {
        require(block.timestamp >= releaseTime, ""Release time not reached"");
        require(current_month <= 5, ""Maximum release cycles reached"");

        uint256 diff = block.timestamp.sub(releaseTime);

        if (diff >= month) {
            releaseTime = block.timestamp;
        } else {
            releaseTime = block.timestamp.add(month.sub(diff));
        }

        current_month++;

        // Assuming a transfer function exists in the contract
        transfer(beneficiary, twenty_percent_of_amount);
    }

    function transfer(address to, uint256 amount) internal virtual {
        //Implementation for transferring tokens.  This will vary depending on your token implementation.
        //Example using ERC20: IERC20(tokenAddress).transfer(to, amount);
    }
}",43.2501699924469,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenRelease is Ownable {
    using SafeMath for uint256;

    uint256 public releaseTime;
    uint256 public current_month;
    uint256 public constant month = 2628000; // seconds in a month (approx)
    address public beneficiary;
    uint256 public twenty_percent_of_amount;

    constructor(address _beneficiary, uint256 _releaseTime, uint256 _amount) Ownable(msg.sender) {
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
        twenty_percent_of_amount = _amount.mul(20).div(100);
    }

    function release() public {
        require(block.timestamp >= releaseTime, ""Release time not reached"");
        require(current_month <= 5, ""Maximum release cycles reached"");

        uint256 diff = block.timestamp.sub(releaseTime);

        if (diff >= month) {
            releaseTime = block.timestamp;
        } else {
            releaseTime = block.timestamp.add(month.sub(diff));
        }

        current_month++;

        // Assuming a transfer function exists in the contract
        transfer(beneficiary, twenty_percent_of_amount);
    }

    function transfer(address to, uint256 amount) internal virtual {
        //Implementation for transferring tokens.  This will vary depending on your token implementation.
        //Example using ERC20: IERC20(tokenAddress).transfer(to, amount);
    }
}"
4047,Checks if the order given offchain coincides with the order of the actual previously calculated points in the smart contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, LimitCalculated, OrderChecked }
    pointsValidationState public pValidationState;
    uint256 public winnerCounter;
    uint256 public pointsLimit;
    mapping(uint256 => uint256) public tokenToPointsMap;
    uint256[] private sortedWinners;

    constructor() {
        pValidationState = pointsValidationState.NotStarted;
    }

    function checkOrder(uint32[] memory sortedChunk) external onlyOwner checkState(pointsValidationState.LimitCalculated) {
        require(sortedChunk.length + sortedWinners.length <= winnerCounter);

        for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
            uint256 id = sortedChunk[i];
            uint256 sigId = sortedChunk[i + 1];
            require(tokenToPointsMap[id] > tokenToPointsMap[sigId] || (tokenToPointsMap[id] == tokenToPointsMap[sigId] && id < sigId));
        }

        if (sortedWinners.length != 0) {
            uint256 id2 = sortedWinners[sortedWinners.length - 1];
            uint256 sigId2 = sortedChunk[0];
            require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] || (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));
        }

        for (uint256 j = 0; j < sortedChunk.length; j++) {
            sortedWinners.push(sortedChunk[j]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[sortedWinners.length - 1] == pointsLimit);
            pValidationState = pointsValidationState.OrderChecked;
        }
    }

    modifier checkState(pointsValidationState expectedState) {
        require(pValidationState == expectedState, ""Invalid state"");
        _;
    }
}",validateWinnersChunk,"[{'function': 'validateWinnersChunk', 'complexity': 8}]",10.0,"{""type"": ""FunctionDefinition"", ""name"": ""validateWinnersChunk"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""length"": None}, ""name"": ""sortedChunk"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""memberName"": ""length""}}, ""right"": {""type"": ""Identifier"", ""name"": ""winnerCounter""}}, {""type"": ""stringLiteral"", ""value"": ""Exceeds winner limit""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""stringLiteral"", ""value"": ""Chunk not sorted""}], ""names"": []}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Chunk out of order""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""winnerCounter""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""Identifier"", ""name"": ""pointsLimit""}}, {""type"": ""stringLiteral"", ""value"": ""Last winner doesn""t match points limit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""pValidationState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ValidationState""}, ""memberName"": ""OrderChecked""}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.7308331299712917,0.3995439987493573,"pragma solidity ^0.8.0;

contract WinnerValidator {

    enum ValidationState {Unchecked, OrderChecked}

    uint256 public winnerCounter;
    uint256 public pointsLimit;
    uint32[] public sortedWinners;
    ValidationState public pValidationState;

    function validateWinnersChunk(uint32[] memory sortedChunk) public {
        require(sortedWinners.length + sortedChunk.length <= winnerCounter, ""Exceeds winner limit"");

        for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
            require(sortedChunk[i] >= sortedChunk[i + 1], ""Chunk not sorted"");
        }

        if (sortedWinners.length > 0) {
            require(sortedWinners[sortedWinners.length - 1] >= sortedChunk[0], ""Chunk out of order"");
        }

        for (uint256 i = 0; i < sortedChunk.length; i++) {
            sortedWinners.push(sortedChunk[i]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[sortedWinners.length - 1] == pointsLimit, ""Last winner doesn't match points limit"");
            pValidationState = ValidationState.OrderChecked;
        }
    }
}",43.11455178260803,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WinnerValidator is Ownable {
    enum ValidationState {Unchecked, OrderChecked}

    uint256 public winnerCounter = 1;
    uint256 public pointsLimit = 1;
    uint32[] public sortedWinners;
    ValidationState public pValidationState = ValidationState.Unchecked;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done here as per the rules provided.
    }

    function validateWinnersChunk(uint32[] memory sortedChunk) public {
        require(sortedWinners.length + sortedChunk.length <= winnerCounter, ""Exceeds winner limit"");

        for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
            require(sortedChunk[i] >= sortedChunk[i + 1], ""Chunk not sorted"");
        }

        if (sortedWinners.length > 0) {
            require(sortedWinners[sortedWinners.length - 1] >= sortedChunk[0], ""Chunk out of order"");
        }

        for (uint256 i = 0; i < sortedChunk.length; i++) {
            sortedWinners.push(sortedChunk[i]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[sortedWinners.length - 1] == pointsLimit, ""Last winner doesn't match points limit"");
            pValidationState = ValidationState.OrderChecked;
        }
    }
}"
527,The value in HAV for a given amount of USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceOracle {
    function price() external view returns (uint);
}

abstract contract USDtoHAVWrapper is Ownable {
    using SafeMath for uint256;

    PriceOracle public oracle;

    constructor(address _oracle) {
        oracle = PriceOracle(_oracle);
    }

    function safeDiv_dec(uint usd_dec, uint price) internal pure returns (uint) {
        require(price > 0, ""SafeMath: division by zero"");
        return usd_dec.div(price);
    }

    function USDtoHAV(uint usd_dec) public view priceNotStale returns (uint) {
        uint price = oracle.price();
        require(price > 0, ""Price is stale or incorrect"");
        return safeDiv_dec(usd_dec, price);
    }

    modifier priceNotStale() {
        require(oracle.price() != 0, ""Price is not available or has expired"");
        _;
    }
}",safeDiv_dec,"[{'function': 'safeDiv_dec', 'complexity': 1}, {'function': 'USDtoHAV', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeDiv_dec"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: division by zero""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",11.0,0.7224056368142985,0.0547345668571819,"pragma solidity ^0.8.0;

contract HavvenConverter {

    uint256 public price; //Example price, needs to be set elsewhere

    modifier priceNotStale() {
        // Add logic to check if price is stale
        _;
    }

    function safeDiv_dec(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }


    function USDtoHAV(uint256 usd_dec) public view priceNotStale returns (uint256) {
        return safeDiv_dec(usd_dec, price);
    }
}",41.783920764923096,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HavvenConverter is Ownable {
    uint256 public price;

    modifier priceNotStale() {
        // Add logic to check if price is stale
        _;
    }

    function safeDiv_dec(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }

    function USDtoHAV(uint256 usd_dec) public view priceNotStale returns (uint256) {
        return safeDiv_dec(usd_dec, price);
    }

    constructor() Ownable(msg.sender) {
        price = 1; // Safe non-zero value for uint256
    }
}"
3318,Return hash containing all of the information about the burnCarbonDollar ( ) metatransaction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MetaBurnHashWrapper is Ownable {
    using SafeMath for uint256;

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}",metaBurnHash,"[{'function': 'metaBurnHash', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""metaBurnHash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_stablecoin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""metaBurnCarbonDollar""}, {""type"": ""Identifier"", ""name"": ""_stablecoin""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}, {""type"": ""Identifier"", ""name"": ""_reward""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",0.0,0.9763008073011412,0.9427781070492712,"pragma solidity ^0.8.0;

contract CarbonDollar {

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public pure view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}",41.42959475517273,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CarbonDollar {
    address public constant STABLECOIN = 0x1111111111111111111111111111111111111111; // Replace with actual stablecoin address
    uint256 public constant AMOUNT = 1;
    uint256 public constant NONCE = 1;
    uint256 public constant REWARD = 1;
    bool public initialized = true;
    bytes32 public metaBurnHash;

    constructor() Ownable(msg.sender) {
        STABLECOIN = 0x1111111111111111111111111111111111111111; // Replace with actual stablecoin address
        AMOUNT = 1;
        NONCE = 1;
        REWARD = 1;
        initialized = true;
        metaBurnHash = keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", STABLECOIN, AMOUNT, NONCE, REWARD));
    }

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public pure view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}"
1663,Access point for the oracle to update the price of havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public price;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 days; // Example value, adjust as needed

    event PriceUpdated(uint newPrice, uint timeSent);

    function updatePrice(uint newPrice, uint timeSent) external onlyOwner {
        require(lastPriceUpdateTime < timeSent && timeSent < now.add(ORACLE_FUTURE_LIMIT), ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        price = newPrice;
        lastPriceUpdateTime = timeSent;
        emit PriceUpdated(newPrice, timeSent);
    }
}",updatePrice,"[{'function': 'updatePrice', 'complexity': 2}, {'function': 'rolloverFeePeriodIfElapsed', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}}, {""type"": ""stringLiteral"", ""value"": ""Timestamp must be greater than last update time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""ORACLE_FUTURE_LIMIT""}}}, {""type"": ""stringLiteral"", ""value"": ""Timestamp exceeds future limit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PriceUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newPrice""}, {""type"": ""Identifier"", ""name"": ""timeSent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""rolloverFeePeriodIfElapsed""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.8797125107100837,0.369207330490313,"pragma solidity ^0.8.0;

contract PriceOracle {

    uint256 public price;
    uint256 public lastPriceUpdateTime;
    uint256 public constant ORACLE_FUTURE_LIMIT = 60; // 60 seconds

    event PriceUpdated(uint256 newPrice, uint256 timestamp);

    function updatePrice(uint256 newPrice, uint256 timeSent) public {
        require(timeSent > lastPriceUpdateTime, ""Timestamp must be greater than last update time"");
        require(timeSent <= block.timestamp + ORACLE_FUTURE_LIMIT, ""Timestamp exceeds future limit"");

        price = newPrice;
        lastPriceUpdateTime = timeSent;

        emit PriceUpdated(newPrice, timeSent);
        rolloverFeePeriodIfElapsed();
    }

    function rolloverFeePeriodIfElapsed() internal virtual {
        //Implementation for fee period rollover.  To be implemented in a derived contract.
    }
}",42.33337998390198,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceOracle is Ownable {
    uint256 public price = 1;
    uint256 public lastPriceUpdateTime;
    uint256 public constant ORACLE_FUTURE_LIMIT = 60; // 60 seconds

    event PriceUpdated(uint256 newPrice, uint256 timestamp);

    constructor() Ownable(msg.sender) {
        lastPriceUpdateTime = block.timestamp;
    }

    function updatePrice(uint256 newPrice, uint256 timeSent) public {
        require(timeSent > lastPriceUpdateTime, ""Timestamp must be greater than last update time"");
        require(timeSent <= block.timestamp + ORACLE_FUTURE_LIMIT, ""Timestamp exceeds future limit"");

        price = newPrice;
        lastPriceUpdateTime = timeSent;

        emit PriceUpdated(newPrice, timeSent);
        rolloverFeePeriodIfElapsed();
    }

    function rolloverFeePeriodIfElapsed() internal virtual {
        //Implementation for fee period rollover.  To be implemented in a derived contract.
    }
}"
6383,Approve address to become creator of that pack,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetPackApproval {
    using SafeMath for uint256;

    struct AssetPack {
        address creator;
    }

    mapping(uint => AssetPack) public assetPacks;
    mapping(uint => address) public approvedTakeover;

    function approveTakeover(uint _assetPackId, address _newCreator) public {
        require(assetPacks[_assetPackId].creator == msg.sender);
        approvedTakeover[_assetPackId] = _newCreator;
    }
}",approveTakeover,"[{'function': 'approveTakeover', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveTakeover"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_assetPackId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newCreator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""creators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_assetPackId""}}}, {""type"": ""stringLiteral"", ""value"": ""Only the creator can approve a takeover.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedTakeover""}, ""index"": {""type"": ""Identifier"", ""name"": ""_assetPackId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newCreator""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.9305530333004468,0.5703815182048178,"pragma solidity ^0.8.0;

contract AssetPackContract {

    mapping(uint => address) public creators;
    mapping(uint => address) public approvedTakeover;

    function approveTakeover(uint _assetPackId, address _newCreator) public {
        require(msg.sender == creators[_assetPackId], ""Only the creator can approve a takeover."");
        approvedTakeover[_assetPackId] = _newCreator;
    }
}",41.469908714294434,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetPackContract is Ownable {
    mapping(uint => address) public creators;
    mapping(uint => address) public approvedTakeover;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            creators[i] = address(uint160(uint256(keccak256(abi.encodePacked(""creator"", i)))));
            approvedTakeover[i] = address(uint160(uint256(keccak256(abi.encodePacked(""approvedTakeover"", i)))));
        }
    }

    function approveTakeover(uint _assetPackId, address _newCreator) public {
        require(msg.sender == creators[_assetPackId], ""Only the creator can approve a takeover."");
        approvedTakeover[_assetPackId] = _newCreator;
    }
}"
5701,Returns the division of two numbers Function used for division operations inside the smartcontract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DivisionWrapper is Ownable {
    using SafeMath for uint256;

    function division(uint numerator, uint denominator) public view onlyOwner returns (uint result) {
        require(denominator != 0, ""Division by zero"");
        return numerator.div(denominator);
    }
}",division,"[{'function': 'division', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""division"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numerator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""denominator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""result"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""numerator""}, ""right"": {""type"": ""Identifier"", ""name"": ""denominator""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",8.0,0.6991064376494263,0.0637182843134805,"pragma solidity ^0.8.0;

contract Division {

    function division(uint256 numerator, uint256 denominator) public pure returns (uint256 result) {
        result = numerator / denominator;
    }
}",41.14532732963562,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Division is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function division(uint256 numerator, uint256 denominator) public pure returns (uint256 result) {
        require(denominator != 0, ""Division by zero"");
        result = numerator / denominator;
    }
}"
2851,Function used by the creator to set the presale limits,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PresaleAmountLimits {
    using SafeMath for uint256;

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public pure {
        require(_minPresaleAmount > 0, ""Minimum presale amount must be greater than 0"");
        require(_maxPresaleAmount > 0, ""Maximum presale amount must be greater than 0"");
        require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount"");
    }
}",setPresaleAmountLimits,"[{'function': 'setPresaleAmountLimits', 'complexity': 1}, {'function': 'owner', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPresaleAmountLimits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minPresaleAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxPresaleAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_minPresaleAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxPresaleAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Min amount must be less than or equal to max amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PresaleAmountLimitsSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""minPresaleAmount""}, {""type"": ""Identifier"", ""name"": ""maxPresaleAmount""}, {""type"": ""Identifier"", ""name"": ""_minPresaleAmount""}, {""type"": ""Identifier"", ""name"": ""_maxPresaleAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minPresaleAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minPresaleAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxPresaleAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxPresaleAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.710495014164403,0.3469345827092285,"pragma solidity ^0.8.0;

contract Presale {

    uint256 public minPresaleAmount;
    uint256 public maxPresaleAmount;

    event PresaleAmountLimitsSet(uint256 oldMinAmount, uint256 oldMaxAmount, uint256 newMinAmount, uint256 newMaxAmount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public onlyOwner {
        require(_minPresaleAmount <= _maxPresaleAmount, ""Min amount must be less than or equal to max amount"");

        emit PresaleAmountLimitsSet(minPresaleAmount, maxPresaleAmount, _minPresaleAmount, _maxPresaleAmount);

        minPresaleAmount = _minPresaleAmount;
        maxPresaleAmount = _maxPresaleAmount;
    }

    function owner() public view returns (address) {
        return owner;
    }
}",42.670894145965576,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Presale is Ownable {

    uint256 public minPresaleAmount = 1;
    uint256 public maxPresaleAmount = 2;

    event PresaleAmountLimitsSet(uint256 oldMinAmount, uint256 oldMaxAmount, uint256 newMinAmount, uint256 newMaxAmount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is already handled in the declaration
    }

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public onlyOwner {
        require(_minPresaleAmount <= _maxPresaleAmount, ""Min amount must be less than or equal to max amount"");

        emit PresaleAmountLimitsSet(minPresaleAmount, maxPresaleAmount, _minPresaleAmount, _maxPresaleAmount);

        minPresaleAmount = _minPresaleAmount;
        maxPresaleAmount = _maxPresaleAmount;
    }

    function owner() public view returns (address) {
        return super.owner();
    }
}"
5928,Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Authorizable is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address indexed operator, address indexed owner);

    function authorizeOperator(address _operator) public override onlyOwner {
        require(_operator != msg.sender, ""The operator must be different from the sender."");
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}",authorizeOperator,"[{'function': 'authorizeOperator', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""authorizeOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Operator cannot be the same as the sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""mAuthorized""}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuthorizedOperator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9620930583160466,0.6491440258202313,"pragma solidity ^0.8.0;

contract OperatorAuthorization {

    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address operator, address user);

    function authorizeOperator(address _operator) public {
        require(_operator != msg.sender, ""Operator cannot be the same as the sender"");
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}",41.46398878097534,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OperatorAuthorization is Ownable {
    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address operator, address user);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function authorizeOperator(address _operator) public {
        require(_operator != msg.sender, ""Operator cannot be the same as the sender"");
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}"
1383,Performs allowance transfer of asset balance between holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAsset {
    function __transferFromWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    IAsset public asset;

    constructor(address _assetAddress) {
        asset = IAsset(_assetAddress);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return asset.__transferFromWithReference(_from, _to, _value, """", msg.sender);
        }
        return false;
    }
}",transferFrom,"[{'function': '__transferFromWithReference', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient address cannot be zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""assetContract""}, ""memberName"": ""__transferFromWithReference""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""stringLiteral"", ""value"": """"}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.8810955869266579,0.6652972750202706,"pragma solidity ^0.8.0;

interface IAssetContract {
    function __transferFromWithReference(address _from, address _to, uint256 _value, string memory _reference) external returns (bool);
}

contract MyContract {
    IAssetContract public assetContract;

    constructor(address _assetContractAddress) {
        assetContract = IAssetContract(_assetContractAddress);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0), ""Recipient address cannot be zero"");
        return assetContract.__transferFromWithReference(_from, _to, _value, """");
    }
}",41.96410608291626,"pragma solidity ^0.8.0;

interface IAssetContract {
    function __transferFromWithReference(address _from, address _to, uint256 _value, string memory _reference) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IAssetContract public assetContract;

    constructor(address _assetContractAddress) Ownable(msg.sender) {
        assetContract = IAssetContract(_assetContractAddress);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0), ""Recipient address cannot be zero"");
        return assetContract.__transferFromWithReference(_from, _to, _value, """");
    }
}"
5667,Returns the address currently assigned ownership of a given token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract {
    using SafeMath for uint256;

    address[] public tokenIndexToOwner;

    function ownerOf(uint _tokenId) external view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0));
        return tokenIndexToOwner[_tokenId];
    }
}",ownerOf,"[{'function': 'ownerOf', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token does not exist""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.9805993530500322,0.6029987316381817,"pragma solidity ^0.8.0;

contract MyContract {
    mapping(uint256 => address) public tokenIndexToOwner;

    function ownerOf(uint256 _tokenId) public view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0), ""Token does not exist"");
        return tokenIndexToOwner[_tokenId];
    }
}",41.36878728866577,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(uint256 => address) public tokenIndexToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            tokenIndexToOwner[i] = address(uint160(i + 1));
        }
    }

    function ownerOf(uint256 _tokenId) public view returns (address) {
        require(_tokenId > 0 && _tokenId <= 3, ""Token does not exist"");
        return tokenIndexToOwner[_tokenId];
    }
}"
5392,"Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract LoanContract is Ownable {
    using SafeMath for uint256;

    struct Loan {
        address lender;
        address approvedTransfer;
    }

    mapping(uint256 => Loan) public loans;
    mapping(address => uint256) public lendersBalance;

    event Transfer(address indexed from, address indexed to, uint256 index);

    function transfer(address to, uint256 index) public returns (bool) {
        Loan storage loan = loans[index];
        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);
        require(to != address(0));
        loan.lender = to;
        loan.approvedTransfer = address(0);
        lendersBalance[msg.sender] = lendersBalance[msg.sender].sub(1);
        lendersBalance[to] = lendersBalance[to].add(1);
        emit Transfer(loan.lender, to, index);
        return true;
    }
}",transferLoan,"[{'function': 'transferLoan', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferLoan"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient address cannot be zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Loan""}, ""name"": ""loan"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""lender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""approvedTransfer""}}}, {""type"": ""stringLiteral"", ""value"": ""Unauthorized to transfer loan""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lendersBalance""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""lender""}}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""lender""}, ""right"": {""type"": ""Identifier"", ""name"": ""to""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""approvedTransfer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lendersBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""isPrefix"": False}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.8209266652711306,0.5400280680910555,"pragma solidity ^0.8.0;

contract LoanTransfer {

    struct Loan {
        address lender;
        address approvedTransfer;
        // ... other loan details
    }

    Loan[] public loans;
    mapping(address => uint256) public lendersBalance;

    event Transfer(address indexed from, address indexed to, uint256 indexed loanIndex);

    function transferLoan(address to, uint256 index) public {
        require(to != address(0), ""Recipient address cannot be zero"");
        Loan storage loan = loans[index];
        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer, ""Unauthorized to transfer loan"");

        lendersBalance[loan.lender]--;
        loan.lender = to;
        loan.approvedTransfer = address(0);
        lendersBalance[to]++;

        emit Transfer(msg.sender, to, index);
    }
}",42.070631980896,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoanTransfer is Ownable {

    struct Loan {
        address lender;
        address approvedTransfer;
        // ... other loan details
    }

    Loan[] public loans;
    mapping(address => uint256) public lendersBalance;

    event Transfer(address indexed from, address indexed to, uint256 indexed loanIndex);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        loans = [Loan({lender: 0x1111111111111111111111111111111111111111, approvedTransfer: address(0)}), Loan({lender: 0x2222222222222222222222222222222222222222, approvedTransfer: address(0)})];
        lendersBalance[0x1111111111111111111111111111111111111111] = 1;
        lendersBalance[0x2222222222222222222222222222222222222222] = 1;
    }

    function transferLoan(address to, uint256 index) public {
        require(to != address(0), ""Recipient address cannot be zero"");
        Loan storage loan = loans[index];
        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer, ""Unauthorized to transfer loan"");

        lendersBalance[loan.lender]--;
        loan.lender = to;
        loan.approvedTransfer = address(0);
        lendersBalance[to]++;

        emit Transfer(msg.sender, to, index);
    }
}"
6100,Allows a grant recipient to claim their vested tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenVesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 yearsClaimed;
        uint256 totalClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    IERC20 public token;

    event GrantTokensClaimed(address indexed recipient, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function calculateGrantClaim(address _recipient) internal view returns (uint256 yearsVested, uint256 amountVested) {
        // Implementation of the calculation logic for calculating vested tokens
        // This is a placeholder and should be replaced with actual implementation
        yearsVested = 0; // Example value
        amountVested = 0; // Example value
    }

    function claimVestedTokens(address _recipient) external {
        uint256 yearsVested;
        uint256 amountVested;
        (yearsVested, amountVested) = calculateGrantClaim(_recipient);
        require(amountVested > 0, ""amountVested is 0"");
        Grant storage tokenGrant = tokenGrants[_recipient];
        tokenGrant.yearsClaimed = yearsVested;
        tokenGrant.totalClaimed = tokenGrant.totalClaimed.add(amountVested);
        require(token.transfer(_recipient, amountVested), ""no tokens"");
        emit GrantTokensClaimed(_recipient, amountVested);
    }
}",claimVestedTokens,"[{'function': 'claimVestedTokens', 'complexity': 2}, {'function': 'calculateGrantClaim', 'complexity': 0}, {'function': 'vestedTokens', 'complexity': 0}, {'function': 'calculateVestedTokens', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}, {'function': 'add', 'complexity': 1}, {'function': 'sub', 'complexity': 1}, {'function': 'mul', 'complexity': 2}, {'function': 'div', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimVestedTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""yearsVested"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112fe98d0>}, {""type"": ""VariableDeclaration"", ""name"": ""amountVested"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112fe83d0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateGrantClaim""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amountVested""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""amountVested is 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenGrant""}, ""name"": ""grant"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenGrants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_recipient""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""yearsClaimed""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""yearsClaimed""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""yearsVested""}], ""names"": []}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalClaimed""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalClaimed""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountVested""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""no tokens""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""GrantTokensClaimed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.898152055781522,0.6637408674190272,"pragma solidity ^0.8.0;

contract TokenVesting {
    using SafeMath for uint256;

    struct TokenGrant {
        uint256 value;
        uint64 start;
        uint64 cliff;
        uint64 vesting;
        uint64 yearsClaimed;
        uint256 totalClaimed;
    }

    mapping(address => TokenGrant) public tokenGrants;
    IERC20 public token;

    event GrantTokensClaimed(address recipient, uint256 amount);

    constructor(IERC20 _token) {
        token = _token;
    }


    function claimVestedTokens(address _recipient) public {
        (uint256 yearsVested, uint256 amountVested) = calculateGrantClaim(_recipient);

        require(amountVested > 0, ""amountVested is 0"");

        TokenGrant storage grant = tokenGrants[_recipient];
        grant.yearsClaimed = grant.yearsClaimed.add(uint64(yearsVested));
        grant.totalClaimed = grant.totalClaimed.add(amountVested);

        require(token.transfer(_recipient, amountVested), ""no tokens"");

        emit GrantTokensClaimed(_recipient, amountVested);
    }

    function calculateGrantClaim(address _recipient) internal view returns (uint256, uint256) {
        TokenGrant memory grant = tokenGrants[_recipient];
        uint256 currentTime = block.timestamp;
        uint256 vestedAmount = vestedTokens(grant, uint64(currentTime));
        uint256 yearsVested = (currentTime.sub(uint256(grant.start))).div(31536000); //Approximation of a year in seconds.

        return (yearsVested, vestedAmount.sub(grant.totalClaimed));
    }

    function vestedTokens(TokenGrant memory grant, uint64 time) private pure returns (uint256) {
        return calculateVestedTokens(
            grant.value,
            uint256(time),
            uint256(grant.start),
            uint256(grant.cliff),
            uint256(grant.vesting)
        );
    }

    function calculateVestedTokens(
        uint256 tokens,
        uint256 time,
        uint256 start,
        uint256 cliff,
        uint256 vesting
    ) private pure returns (uint256) {
        if (time < cliff) return 0;
        if (time >= vesting) return tokens;
        return tokens.mul(time.sub(start)).div(vesting.sub(start));
    }

    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }

    library SafeMath {
        function add(uint256 a, uint256 b) internal pure returns (uint256) {
            uint256 c = a + b;
            require(c >= a, ""SafeMath: addition overflow"");
            return c;
        }

        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b <= a, ""SafeMath: subtraction overflow"");
            uint256 c = a - b;
            return c;
        }

        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            if (a == 0) {
                return 0;
            }
            uint256 c = a * b;
            require(c / a == b, ""SafeMath: multiplication overflow"");
            return c;
        }

        function div(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b > 0, ""SafeMath: division by zero"");
            uint256 c = a / b;
            return c;
        }
    }
}",46.591689348220825,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenVesting is IERC20 {
    using SafeMath for uint256;

    struct TokenGrant {
        uint256 value;
        uint64 start;
        uint64 cliff;
        uint64 vesting;
        uint64 yearsClaimed;
        uint256 totalClaimed;
    }

    mapping(address => TokenGrant) public tokenGrants;
    IERC20 public token;

    event GrantTokensClaimed(address recipient, uint256 amount);

    constructor(IERC20 _token) {
        require(_token != address(0), ""Token cannot be zero"");
        token = _token;
        // Initialize Ownable contract
        constructor() Ownable(msg.sender);
    }

    function claimVestedTokens(address _recipient) public {
        (uint256 yearsVested, uint256 amountVested) = calculateGrantClaim(_recipient);

        require(amountVested > 0, ""amountVested is 0"");

        TokenGrant storage grant = tokenGrants[_recipient];
        grant.yearsClaimed = grant.yearsClaimed.add(uint64(yearsVested));
        grant.totalClaimed = grant.totalClaimed.add(amountVested);

        require(token.transfer(_recipient, amountVested), ""no tokens"");

        emit GrantTokensClaimed(_recipient, amountVested);
    }

    function calculateGrantClaim(address _recipient) internal view returns (uint256, uint256) {
        TokenGrant memory grant = tokenGrants[_recipient];
        uint256 currentTime = block.timestamp;
        uint256 vestedAmount = vestedTokens(grant, uint64(currentTime));
        uint256 yearsVested = (currentTime.sub(uint256(grant.start))).div(31536000); //Approximation of a year in seconds.

        return (yearsVested, vestedAmount.sub(grant.totalClaimed));
    }

    function vestedTokens(TokenGrant memory grant, uint64 time) private pure returns (uint256) {
        return calculateVestedTokens(
            grant.value,
            uint256(time),
            uint256(grant.start),
            uint256(grant.cliff),
            uint256(grant.vesting)
        );
    }

    function calculateVestedTokens(
        uint256 tokens,
        uint256 time,
        uint256 start,
        uint256 cliff,
        uint256 vesting
    ) private pure returns (uint256) {
        if (time < cliff) return 0;
        if (time >= vesting) return tokens;
        return tokens.mul(time.sub(start)).div(vesting.sub(start));
    }

    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }

    library SafeMath {
        function add(uint256 a, uint256 b) internal pure returns (uint256) {
            uint256 c = a + b;
            require(c >= a, ""SafeMath: addition overflow"");
            return c;
        }

        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b <= a, ""SafeMath: subtraction overflow"");
            uint256 c = a - b;
            return c;
        }

        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            if (a == 0) {
                return 0;
            }
            uint256 c = a * b;
            require(c / a == b, ""SafeMath: multiplication overflow"");
            return c;
        }

        function div(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b > 0, ""SafeMath: division by zero"");
            uint256 c = a / b;
            return c;
        }
    }
}"
949,Emits ERC20 Approval event on this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function emitApprove(address _from, address _spender, uint _value) public onlyChronoBankPlatform {
        emit Approval(_from, _spender, _value);
    }
}",emitApproval,"[{'function': 'emitApproval', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""emitApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_platform"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyChronoBankPlatform"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_platform""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.892230903552104,0.5832012039914727,"pragma solidity ^0.8.0;

contract ChronoBankToken {

    event Approval(address indexed _from, address indexed _spender, uint256 _value);

    modifier onlyChronoBankPlatform(address _platform) {
        require(msg.sender == _platform, ""Caller is not ChronoBankPlatform"");
        _;
    }

    function emitApproval(address _platform, address _from, address _spender, uint256 _value) public onlyChronoBankPlatform(_platform) {
        emit Approval(_from, _spender, _value);
    }
}",41.89601969718933,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ChronoBankToken is Ownable {
    event Approval(address indexed _from, address indexed _spender, uint256 _value);

    modifier onlyChronoBankPlatform(address _platform) {
        require(msg.sender == _platform, ""Caller is not ChronoBankPlatform"");
        _;
    }

    function emitApproval(address _platform, address _from, address _spender, uint256 _value) public onlyChronoBankPlatform(_platform) {
        emit Approval(_from, _spender, _value);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
6735,Makes checkmark and deposits tokens on profiterole account to pay them later as bonuses for Treasury shares holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Treasury {
    function addDistributionPeriod() external;
}

abstract contract BonusDistributor is Ownable {
    using SafeMath for uint256;

    ERC20Interface public bonusToken;
    address public wallet;
    mapping(uint => Deposit) public distributionDeposits;
    uint public firstDepositDate;
    uint public lastDepositDate;
    bytes32 constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = 0x0;
    bytes32 constant PROFITEROLE_ERROR_TRANSFER_ERROR = 0x1;
    uint constant OK = 0;

    struct Deposit {
        uint amount;
        uint nextDepositDate;
        uint claimedAmount;
    }

    event DepositPendingAdded(uint indexed amount, address indexed depositor, uint indexed timestamp);

    modifier onlyDistributionSource() {
        require(msg.sender == wallet, ""Only the distribution source can call this function"");
        _;
    }

    constructor(address _bonusToken, address _wallet) {
        bonusToken = ERC20Interface(_bonusToken);
        wallet = _wallet;
    }

    function distributeBonuses(uint _amount) public onlyDistributionSource returns (uint) {
        ERC20Interface _bonusToken = ERC20Interface(bonusToken);
        if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {
            return uint(_emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE));
        }
        if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {
            return uint(_emitError(PROFITEROLE_ERROR_TRANSFER_ERROR));
        }
        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }
        uint _lastDepositDate = lastDepositDate;
        if (_lastDepositDate != 0) {
            distributionDeposits[_lastDepositDate].nextDepositDate = block.timestamp;
        }
        lastDepositDate = block.timestamp;
        distributionDeposits[block.timestamp] = Deposit(_amount, 0, 0);
        Treasury(treasury).addDistributionPeriod();
        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
        return OK;
    }

    function _emitError(bytes32 errorCode) internal pure returns (bytes4) {
        return bytes4(errorCode);
    }
}",distributeBonuses,"[{'function': 'allowance', 'complexity': 0}, {'function': 'distributeBonuses', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeBonuses"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_wallet"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""bonusToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""bonusTokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bonusToken""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bonusToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_wallet""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""PROFITEROLE_ERROR_TRANSFER_ERROR""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""firstDepositDate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""firstDepositDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastDepositDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""distributionDeposits""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DepositPendingAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyDistributionSource"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",37.0,0.716541829818207,0.3062561243162219,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
}

contract MyContract {
    uint256 public firstDepositDate;
    uint256 public lastDepositDate;
    mapping(uint256 => uint256) public distributionDeposits;
    address public bonusTokenAddress;
    // ... other state variables and modifiers ...

    event DepositPendingAdded(uint256 _amount, address _sender, uint256 _timestamp);

    modifier onlyDistributionSource() {
        // ... logic to check if the caller is authorized ...
        _;
    }

    function distributeBonuses(uint256 _amount, address payable _wallet) public onlyDistributionSource {
        IERC20 bonusToken = IERC20(bonusTokenAddress);
        uint256 allowance = bonusToken.allowance(msg.sender, address(this));

        require(allowance >= _amount, ""PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE"");

        require(bonusToken.transferFrom(msg.sender, _wallet, _amount), ""PROFITEROLE_ERROR_TRANSFER_ERROR"");

        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }

        lastDepositDate = block.timestamp;
        distributionDeposits[block.timestamp] = _amount;
        // ... treasury.addDistributionPeriod() call ...

        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
    }

    // ... other functions and state variables ...
}",43.486082553863525,"pragma solidity ^0.8.0;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public firstDepositDate;
    uint256 public lastDepositDate;
    mapping(uint256 => uint256) public distributionDeposits;
    address public bonusTokenAddress;

    constructor() Ownable(msg.sender) {
        // Initialize fixed, safe values
        firstDepositDate = 1; // Set to a non-zero value
        lastDepositDate = 0; // Set to a default value

        // Use placeholder values for ERC20 constructors
        IERC20 bonusToken = IERC20(""MyToken"", ""TKN"");

        // Initialize other state variables and modifiers
    }

    event DepositPendingAdded(uint256 _amount, address _sender, uint256 _timestamp);

    modifier onlyDistributionSource() {
        // ... logic to check if the caller is authorized ...
        _;
    }

    function distributeBonuses(uint256 _amount, address payable _wallet) public onlyDistributionSource {
        IERC20 bonusToken = IERC20(bonusTokenAddress);
        uint256 allowance = bonusToken.allowance(msg.sender, address(this));

        require(allowance >= _amount, ""PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE"");

        require(bonusToken.transferFrom(msg.sender, _wallet, _amount), ""PROFITEROLE_ERROR_TRANSFER_ERROR"");

        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }

        lastDepositDate = block.timestamp;
        distributionDeposits[block.timestamp] = _amount;
        // ... treasury.addDistributionPeriod() call ...

        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
    }

    // ... other functions and state variables ...
}"
2614,Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}",setApprovalForAll,"[{'function': 'setApprovalForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerOperators""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9855359080442704,0.8895260356363631,"pragma solidity ^0.8.0;

contract MyContract {

  mapping(address => mapping(address => bool)) public ownerOperators;

  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

  function setApprovalForAll(address _operator, bool _approved) public {
    ownerOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
}",41.504966020584106,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => mapping(address => bool)) public ownerOperators;
    bytes32 public initializedBytes32 = bytes32('init');
    string public initializedString = 'initialized';
    bool public initializedBool = true;
    address public initializedAddress1 = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public initializedAddress2 = 0x2222222222222222222222222222222222222222; // Replace with actual address

    constructor() Ownable(msg.sender) {
        ownerOperators[msg.sender][address(0)] = false;
        ownerOperators[address(0)][msg.sender] = true;
    }

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) public {
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}"
5641,Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for uint256;

    function destroy() public onlyOwner {
        selfdestruct(owner());
    }
}",destroy,"[{'function': 'destroy', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.8807572816018736,0.729836014355472,"pragma solidity ^0.8.0;

contract MyContract {
    address payable public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor() {
        owner = payable(msg.sender);
    }

    function destroy() public onlyOwner {
        selfdestruct(owner);
    }
}",41.37191700935364,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address payable public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = payable(msg.sender);
    }

    function destroy() public onlyOwner {
        selfdestruct(owner);
    }
}"
2847,Change the wallet where ether will be sent to when tokens are bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContractManager {
    function authorize(string memory contractName, address user) external view returns (bool);
}

abstract contract WalletWrapper is Ownable {
    using SafeMath for uint256;

    IContractManager public contractManager;
    string public contractName;
    address public wallet;

    event WalletAddressChanged(address indexed oldAddress, address indexed newAddress);

    constructor(IContractManager _contractManager, string memory _contractName, address _wallet) {
        contractManager = _contractManager;
        contractName = _contractName;
        wallet = _wallet;
    }

    function setWalletAddress(address _walletAddress) external {
        require(contractManager.authorize(contractName, msg.sender));
        require(_walletAddress != address(0));
        require(_walletAddress != wallet);
        address oldAddress = wallet;
        wallet = _walletAddress;
        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}",setWalletAddress,"[{'function': 'setWalletAddress', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setWalletAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_walletAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_walletAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Wallet address cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_walletAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""wallet""}}, {""type"": ""stringLiteral"", ""value"": ""New wallet address must be different from current address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""wallet""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""wallet""}, ""right"": {""type"": ""Identifier"", ""name"": ""_walletAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WalletAddressChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldAddress""}, {""type"": ""Identifier"", ""name"": ""_walletAddress""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyContractManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8410349749597996,0.5845400912395451,"pragma solidity ^0.8.0;

contract MyContract {
    address public wallet;
    address public contractManager;

    event WalletAddressChanged(address oldAddress, address newAddress);

    constructor(address _contractManager) {
        contractManager = _contractManager;
    }

    modifier onlyContractManager() {
        require(msg.sender == contractManager, ""Only contract manager can call this function"");
        _;
    }

    function setWalletAddress(address _walletAddress) public onlyContractManager {
        require(_walletAddress != address(0), ""Wallet address cannot be zero address"");
        require(_walletAddress != wallet, ""New wallet address must be different from current address"");

        address oldAddress = wallet;
        wallet = _walletAddress;

        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}",42.06213283538818,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public wallet;
    address public contractManager;

    event WalletAddressChanged(address oldAddress, address newAddress);

    constructor(address _contractManager) Ownable(msg.sender) {
        require(_contractManager != address(0), ""Invalid contract manager address"");
        contractManager = _contractManager;
        wallet = address(1); // Fixed value: 0x1111111111111111111111111111111111111111
    }

    modifier onlyContractManager() {
        require(msg.sender == contractManager, ""Only contract manager can call this function"");
        _;
    }

    function setWalletAddress(address _walletAddress) public onlyContractManager {
        require(_walletAddress != address(0), ""Wallet address cannot be zero address"");
        require(_walletAddress != wallet, ""New wallet address must be different from current address"");

        address oldAddress = wallet;
        wallet = _walletAddress;

        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}"
6644,"challenge the provided proposal ID , and put tokens at stake to do so .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Voting {
    struct Poll {
        uint commitStageLen;
        uint revealStageLen;
        uint quorum;
    }
    function startPoll(uint quorum, uint commitStageLen, uint revealStageLen) external returns (uint pollID);
    function pollMap(uint pollID) external view returns (uint commitEndDate, uint revealEndDate, bool resolved);
}

abstract contract ChallengeReparameterization {
    using SafeMath for uint;

    struct ParamProposal {
        uint deposit;
        uint challengeID;
    }

    struct Challenge {
        address challenger;
        uint rewardPool;
        uint stake;
        bool resolved;
        uint winningTokens;
    }

    mapping(bytes32 => ParamProposal) public proposals;
    mapping(uint => Challenge) public challenges;
    Token public token;
    Voting public voting;

    function get(string memory key) internal pure returns (uint value) {
        // This should be implemented to return the correct values based on the key.
        // For demonstration, let's assume it returns some fixed values.
        if (keccak256(abi.encodePacked(key)) == keccak256(""pDispensationPct"")) {
            return 10; // Example value for pDispensationPct
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pVoteQuorum"")) {
            return 30; // Example value for pVoteQuorum
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pCommitStageLen"")) {
            return 1 days; // Example value for commit stage length
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pRevealStageLen"")) {
            return 1 days; // Example value for reveal stage length
        }
        revert(""Unknown key"");
    }

    function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {
        ParamProposal memory prop = proposals[_propID];
        uint deposit = prop.deposit;
        require(propExists(_propID) && prop.challengeID == 0, ""Invalid proposal"");
        uint pollID = voting.startPoll(get(""pVoteQuorum""), get(""pCommitStageLen""), get(""pRevealStageLen""));
        challenges[pollID] = Challenge({
            challenger: msg.sender,
            rewardPool: SafeMath.sub(100, get(""pDispensationPct"")).mul(deposit).div(100),
            stake: deposit,
            resolved: false,
            winningTokens: 0
        });
        proposals[_propID].challengeID = pollID;
        require(token.transferFrom(msg.sender, address(this), deposit), ""Token transfer failed"");
        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);
        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
        return pollID;
    }

    function propExists(bytes32 _propID) internal view returns (bool) {
        return proposals[_propID].deposit > 0;
    }
}",challengeReparameterization,"[{'function': 'challengeReparameterization', 'complexity': 1}, {'function': 'pollMap', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""challengeReparameterization"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_propID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Proposal""}, ""name"": ""proposal"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_propID""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""challengeID""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Proposal already challenged""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""pollID"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""votingContract""}, ""memberName"": ""startPoll""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quorum""}, {""type"": ""Identifier"", ""name"": ""commitStageLength""}, {""type"": ""Identifier"", ""name"": ""revealStageLength""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""challenges""}, ""index"": {""type"": ""Identifier"", ""name"": ""pollID""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Challenge""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""deposit""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""deposit""}, {""type"": ""BooleanLiteral"", ""value"": False}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": [""challenger"", ""rewardPool"", ""stake"", ""resolved"", ""winningTokens""]}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""challengeID""}, ""right"": {""type"": ""Identifier"", ""name"": ""pollID""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""deposit""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""commitEndDate"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1134adbe0>}, {""type"": ""VariableDeclaration"", ""name"": ""revealEndDate"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1134ad780>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""votingContract""}, ""memberName"": ""pollMap""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""pollID""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_NewChallenge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_propID""}, {""type"": ""Identifier"", ""name"": ""pollID""}, {""type"": ""Identifier"", ""name"": ""commitEndDate""}, {""type"": ""Identifier"", ""name"": ""revealEndDate""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.8098153066125915,0.3518060854088132,"pragma solidity ^0.8.0;

contract Parameterizer {
    // ... other contract code ...

    struct Proposal {
        // ... other fields ...
        uint256 challengeID;
        uint256 deposit;
        // ... other fields ...
    }

    struct Challenge {
        address challenger;
        uint256 rewardPool;
        uint256 stake;
        bool resolved;
        uint256 winningTokens;
    }

    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => Challenge) public challenges;

    IVoting public votingContract; // Assuming an IVoting interface is defined

    uint256 public quorum;
    uint256 public commitStageLength;
    uint256 public revealStageLength;

    event _NewChallenge(uint256 indexed _propID, uint256 indexed pollID, uint256 commitEndDate, uint256 revealEndDate, address indexed challenger);

    function challengeReparameterization(uint256 _propID) public {
        Proposal storage proposal = proposals[_propID];
        require(proposal.challengeID == 0, ""Proposal already challenged"");

        uint256 pollID = votingContract.startPoll(quorum, commitStageLength, revealStageLength);

        challenges[pollID] = Challenge({
            challenger: msg.sender,
            rewardPool: proposal.deposit,
            stake: proposal.deposit,
            resolved: false,
            winningTokens: 0
        });

        proposal.challengeID = pollID;

        IERC20(tokenAddress).transferFrom(msg.sender, address(this), proposal.deposit); // Assuming tokenAddress is defined elsewhere

        (uint256 commitEndDate, uint256 revealEndDate) = votingContract.pollMap(pollID);

        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
    }

    // ... other contract code ...
}

interface IVoting {
    function startPoll(uint256 _quorum, uint256 _commitStageLength, uint256 _revealStageLength) external returns (uint256);
    function pollMap(uint256 _pollID) external view returns (uint256, uint256);
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}",44.227081060409546,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Parameterizer is Ownable {
    struct Proposal {
        uint256 challengeID;
        uint256 deposit;
    }

    struct Challenge {
        address challenger;
        uint256 rewardPool;
        uint256 stake;
        bool resolved;
        uint256 winningTokens;
    }

    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => Challenge) public challenges;

    IVoting public votingContract; // Assuming an IVoting interface is defined

    uint256 public quorum = 1;
    uint256 public commitStageLength = 1;
    uint256 public revealStageLength = 1;

    event _NewChallenge(uint256 indexed _propID, uint256 indexed pollID, uint256 commitEndDate, uint256 revealEndDate, address indexed challenger);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        quorum = 1;
        commitStageLength = 1;
        revealStageLength = 1;
    }

    function challengeReparameterization(uint256 _propID) public {
        Proposal storage proposal = proposals[_propID];
        require(proposal.challengeID == 0, ""Proposal already challenged"");

        uint256 pollID = votingContract.startPoll(quorum, commitStageLength, revealStageLength);

        challenges[pollID] = Challenge({
            challenger: msg.sender,
            rewardPool: proposal.deposit,
            stake: proposal.deposit,
            resolved: false,
            winningTokens: 0
        });

        proposal.challengeID = pollID;

        IERC20(tokenAddress).transferFrom(msg.sender, address(this), proposal.deposit); // Assuming tokenAddress is defined elsewhere

        (uint256 commitEndDate, uint256 revealEndDate) = votingContract.pollMap(pollID);

        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
    }

    // ... other contract code ...
}

interface IVoting {
    function startPoll(uint256 _quorum, uint256 _commitStageLength, uint256 _revealStageLength) external returns (uint256);
    function pollMap(uint256 _pollID) external view returns (uint256, uint256);
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}"
3277,Computes ( _numerator / _denominator ) 10 _scale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract FractionJoiner is Ownable {
    using SafeMath for uint256;

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) public pure returns (uint256) {
        if (_scale >= 0) {
            require(_scale <= 77, ""Scale must be between 0 and 77"");
            return _numerator.mul(10 ** uint256(_scale)).div(_denominator);
        } else {
            return (_numerator / _denominator) / 10 ** uint256(-_scale);
        }
    }
}",joinFraction,"[{'function': 'joinFraction', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""joinFraction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_numerator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_denominator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""int16""}, ""name"": ""_scale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_scale""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_scale""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""77"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""scaleFactor"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_scale""}], ""names"": []}}}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_numerator""}, ""right"": {""type"": ""Identifier"", ""name"": ""scaleFactor""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""_denominator""}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""_numerator""}, ""right"": {""type"": ""Identifier"", ""name"": ""_denominator""}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint16""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""-"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""_scale""}, ""isPrefix"": True}], ""names"": []}], ""names"": []}}], ""isArray"": False}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",3.0,0.9006464710216159,0.5872527528312704,"pragma solidity ^0.8.0;

contract FractionCalculator {

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) public pure returns (uint256) {
        if (_scale >= 0) {
            assert(_scale <= 77);
            uint256 scaleFactor = 10**uint256(_scale);
            return (_numerator * scaleFactor) / _denominator;
        } else {
            return (_numerator / _denominator) / (10**uint256(uint16(-_scale)));
        }
    }
}",41.67445802688599,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FractionCalculator is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) public pure returns (uint256) {
        if (_scale >= 0) {
            assert(_scale <= 77);
            uint256 scaleFactor = 10**uint256(_scale);
            return (_numerator * scaleFactor) / _denominator;
        } else {
            return (_numerator / _denominator) / (10**uint256(uint16(-_scale)));
        }
    }
}"
5822,Get current amount of tokens on Vault address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRntToken {
    function balanceOf() external view returns (uint256);
}

abstract contract Vault is Ownable {
    using SafeMath for uint256;

    IRntToken public rntToken;

    constructor(address _rntToken) {
        rntToken = IRntToken(_rntToken);
    }

    function getVaultBalance() public onlyOwner view returns (uint256) {
        return rntToken.balanceOf();
    }
}",getVaultBalance,"[{'function': 'getVaultBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getVaultBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rntToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAllowedAddresses"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",3.0,0.90175997087451,0.5448364887050657,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Vault is AccessControl {
    IERC20 public rntToken;
    bytes32 public constant ALLOWED_ADDRESSES_ROLE = keccak256(""ALLOWED_ADDRESSES_ROLE"");

    constructor(address _rntToken) {
        rntToken = IERC20(_rntToken);
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    modifier onlyAllowedAddresses() {
        require(hasRole(ALLOWED_ADDRESSES_ROLE, msg.sender), ""Caller is not allowed"");
        _;
    }

    function getVaultBalance() public view onlyAllowedAddresses returns (uint256) {
        return rntToken.balanceOf(address(this));
    }
}",42.13541150093079,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Vault is AccessControl, Ownable {
    IERC20 public rntToken;
    bytes32 public constant ALLOWED_ADDRESSES_ROLE = keccak256(""ALLOWED_ADDRESSES_ROLE"");

    mapping(address => uint256) public balanceOf;

 constructor(address _rntToken) Ownable(msg.sender) {
        rntToken = IERC20(_rntToken);
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    modifier onlyAllowedAddresses() {
        require(hasRole(ALLOWED_ADDRESSES_ROLE, msg.sender), ""Caller is not allowed"");
        _;
    }

    function getVaultBalance() public view onlyAllowedAddresses returns (uint256) {
        return rntToken.balanceOf(address(this));
    }
}"
1522,Transfer an amount of currency token from msg.sender account to another specified account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFxUSD {
    function getFxUSDAmount(string memory currency, uint amount) external view returns (uint);
}

interface ITransfer {
    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) external returns (bool success);
}

abstract contract Data {
    using SafeMath for uint;
    mapping(address => uint) public accountSpendingAmounts;
    IFxUSD public fxUSDContract;
    ITransfer public transferContract;

    function getFeeContract(Data storage self, address tokenAddress) internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(Data storage self, address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(Data storage self, address account, uint amount) internal returns (bool success) {
        self.accountSpendingAmounts[account] = amount;
        return true;
    }
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint;
    Data private dataInstance;

    constructor(address _dataAddress, address _fxUSDAddress, address _transferAddress) {
        dataInstance = Data(_dataAddress);
        fxUSDContract = IFxUSD(_fxUSDAddress);
        transferContract = ITransfer(_transferAddress);
    }

    function transfer(string memory currency, address to, uint amount, bytes memory data) public onlyOwner returns (bool success) {
        require(to != address(0), ""Error: `to` address cannot be null."");
        require(amount > 0, ""Error: `amount` must be greater than zero"");
        address feeContract = getFeeContract();
        uint fees = calculateFees(feeContract, amount);
        require(setAccountSpendingAmount(msg.sender, fxUSDContract.getFxUSDAmount(currency, amount)), ""Error: Unable to set spending amount for account."");
        require(forceTransfer(currency, msg.sender, to, amount, data), ""Error: Unable to transfer funds to account."");
        require(forceTransfer(currency, msg.sender, feeContract, fees, getFeeMsg(feeContract)), ""Error: Unable to transfer fees to fee contract."");
        return true;
    }

    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) internal returns (bool success) {
        // Implementation of forceTransfer logic
        require(transferContract.forceTransfer(currency, from, to, amount, data), ""Error: Transfer failed"");
        return true;
    }

    function getFeeContract() internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(address account, uint amount) internal returns (bool success) {
        dataInstance.accountSpendingAmounts[account] = amount;
        return true;
    }
}",transferWithFees,"[{'function': 'forceTransfer', 'complexity': -1}, {'function': 'setFeeContract', 'complexity': 0}, {'function': 'transferWithFees', 'complexity': 5}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setSpendingLimit', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferWithFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ICurrency""}, ""name"": ""currencyContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ICurrency""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""fees"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""setSpendingLimit""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Failed to set spending limit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currencyContract""}, ""memberName"": ""forceTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Failed to transfer currency to recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currencyContract""}, ""memberName"": ""forceTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""feeContract""}, {""type"": ""Identifier"", ""name"": ""fees""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Failed to transfer fees to fee contract""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.926463648768116,0.4707338448706483,"pragma solidity ^0.8.0;

interface ICurrency {
    function forceTransfer(address sender, address recipient, uint amount, bytes calldata data) external returns (bool);
}

contract MyContract {
    address public feeContract;

    function setFeeContract(address _feeContract) public {
        feeContract = _feeContract;
    }


    function transferWithFees(string memory currency, address to, uint amount, bytes memory data) public returns (bool) {
        require(to != address(0), ""Recipient address cannot be zero"");
        require(amount > 0, ""Amount must be greater than zero"");

        ICurrency currencyContract = ICurrency(address(this)); // Assuming this contract implements ICurrency

        uint fees = calculateFees(amount); //Implementation needed
        bool success = setSpendingLimit(msg.sender, amount); //Implementation needed
        require(success, ""Failed to set spending limit"");

        success = currencyContract.forceTransfer(msg.sender, to, amount, data);
        require(success, ""Failed to transfer currency to recipient"");

        success = currencyContract.forceTransfer(msg.sender, feeContract, fees, data);
        require(success, ""Failed to transfer fees to fee contract"");

        return true;
    }

    function calculateFees(uint amount) internal pure returns (uint) {
        //Implementation needed.  Example: 1% fee
        return amount / 100;
    }

    function setSpendingLimit(address user, uint amount) internal returns (bool) {
        //Implementation needed.  Example: updates a mapping of user spending limits
        return true;
    }
}",42.988276958465576,"pragma solidity ^0.8.0;

interface ICurrency {
    function forceTransfer(address sender, address recipient, uint amount, bytes calldata data) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public feeContract;
    address public currencyContract = address(this);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setFeeContract(address _feeContract) public onlyOwner {
        feeContract = _feeContract;
    }

    function transferWithFees(string memory currency, address to, uint amount, bytes memory data) public returns (bool) {
        require(to != address(0), ""Recipient address cannot be zero"");
        require(amount > 0, ""Amount must be greater than zero"");

        ICurrency _currencyContract = ICurrency(currencyContract);

        uint fees = calculateFees(amount); //Implementation needed
        bool success = setSpendingLimit(msg.sender, amount); //Implementation needed
        require(success, ""Failed to set spending limit"");

        success = _currencyContract.forceTransfer(msg.sender, to, amount, data);
        require(success, ""Failed to transfer currency to recipient"");

        success = _currencyContract.forceTransfer(msg.sender, feeContract, fees, data);
        require(success, ""Failed to transfer fees to fee contract"");

        return true;
    }

    function calculateFees(uint amount) internal pure returns (uint) {
        //Implementation needed.  Example: 1% fee
        return amount / 100;
    }

    function setSpendingLimit(address user, uint amount) internal returns (bool) {
        //Implementation needed.  Example: updates a mapping of user spending limits
        return true;
    }
}"
3064,Sender should check whether he has enough tokens to be transferred,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public onlyOwner {
        require(_recipients.length == _values.length);
        uint length = _recipients.length;
        for (uint i = 0; i < length; i++) {
            transfer(_recipients[i], _values[i]);
        }
    }
}",batchTransfer,"[{'function': 'batchTransfer', 'complexity': 3}]",4.0,{},44.0,0.8677421388007335,0.4069384092961496,"pragma solidity ^0.8.0;

contract BatchTransfer {

    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public payable {
        require(_recipients.length == _values.length, ""Recipients and values arrays must have the same length."");
        uint256 length = _recipients.length;
        for (uint256 i = 0; i < length; i++) {
            (bool success,) = _recipients[i].call{value: _values[i]}("""");
            require(success, ""Transfer failed."");
        }
    }
}",41.676204204559326,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BatchTransfer is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public payable {
        require(_recipients.length == _values.length, ""Recipients and values arrays must have the same length."");
        uint256 length = _recipients.length;
        for (uint256 i = 0; i < length; i++) {
            (bool success,) = _recipients[i].call{value: _values[i]}("""");
            require(success, ""Transfer failed."");
        }
    }
}"
6408,"owners : send ` value ` of tokens to address ` to ` , can be called if crowdsale failed and some of the investors refunded the ether","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenSender is Ownable {
    using SafeMath for uint256;

    IERC20 public m_token;
    enum State { ACTIVE, REFUNDING }
    State public currentState = State.REFUNDING;

    modifier validAddress(address to) {
        require(to != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bytes memory data = abi.encodePacked(msg.sig, msg.data);
        require(isOwner(txHash), ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State state) {
        require(currentState == state, ""Function not allowed in current state"");
        _;
    }

    constructor(address tokenAddress) {
        m_token = IERC20(tokenAddress);
    }

    function sendTokens(address to, uint value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(State.REFUNDING) {
        require(value > 0 && m_token.balanceOf(this) >= value);
        m_token.transfer(to, value);
    }
}",sendTokens,"[{'function': 'sendTokens', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlymanyowners"", ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}], ""names"": []}]}, {""type"": ""ModifierInvocation"", ""name"": ""requiresState"", ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.8905803909706715,0.336423353291238,"pragma solidity ^0.8.0;

// Assume necessary modifiers and state variables are defined elsewhere in the contract.  Examples below.

modifier validAddress(address _to) {
    require(_to != address(0), ""Invalid address"");
    _;
}

modifier onlymanyowners(bytes32 _hash) {
    //Implementation for multi-owner check using _hash.  Replace with actual logic.
    require(true, ""Only many owners can call this function"");
    _;
}

modifier requiresState(uint256 _state) {
    // Assume a state variable exists: uint256 public state;
    require(state == _state, ""Incorrect contract state"");
    _;
}

contract MyContract {
    uint256 public state;
    // ... other contract variables and functions ...

    function sendTokens(address to, uint value)
        public
        validAddress(to)
        onlymanyowners(keccak256(abi.encodePacked(to, value))) //Example hash, replace with actual logic
        requiresState(1) // Assuming 1 represents REFUNDING state
    {
        require(value > 0 && value <= address(this).balance, ""Invalid token amount"");
        payable(to).transfer(value);
    }
}",42.6454827785492,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public state;

    constructor() Ownable(msg.sender) {
        state = 1; // Set to a non-zero, safe value
    }

    modifier validAddress(address _to) {
        require(_to != address(0), ""Invalid address"");
        _;
    }

    modifier onlymanyowners(bytes32 _hash) {
        require(true, ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(uint256 _state) {
        require(state == _state, ""Incorrect contract state"");
        _;
    }

    function sendTokens(address to, uint value)
        public
        validAddress(to)
        onlymanyowners(keccak256(abi.encodePacked(to, value))) //Example hash, replace with actual logic
        requiresState(1) // Assuming 1 represents REFUNDING state
    {
        require(value > 0 && value <= address(this).balance, ""Invalid token amount"");
        payable(to).transfer(value);
    }
}"
6613,Sets the ` _newManager ` as manager for the ` _addr ` address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IManager {
    function getManager(address _addr) external view returns (address);
}

abstract contract ManagerWrapper is Ownable, SafeMath {
    mapping(address => address) public managers;
    event ManagerChanged(address indexed addr, address newManager);

    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, ""Not the manager"");
        managers[_addr] = (_newManager == _addr ? 0 : _newManager);
        emit ManagerChanged(_addr, _newManager);
    }
}",updateManager,"[{'function': 'updateManager', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}}, {""type"": ""stringLiteral"", ""value"": ""Not the manager""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_newManager""}, ""right"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newManager""}}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ManagerChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_addr""}, {""type"": ""Identifier"", ""name"": ""_newManager""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.7647375710621245,0.4556617785032402,"pragma solidity ^0.8.0;

contract ManagerContract {

    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    function updateManager(address _addr, address _newManager) public {
        require(msg.sender == managers[_addr], ""Not the manager"");
        if (_newManager == _addr) {
            managers[_addr] = address(0);
        } else {
            managers[_addr] = _newManager;
        }
        emit ManagerChanged(_addr, _newManager);
    }
}",41.627638816833496,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ManagerContract is Ownable {
    mapping(address => address) public managers;
    bytes32 public initialized;

    constructor() Ownable(msg.sender) {
        // Initialize all state variables to fixed, safe values
        managers[msg.sender] = msg.sender; // Set the initial manager to the sender
        initialized = bytes32('initialized');
    }

    event ManagerChanged(address indexed addr, address indexed newManager);

    function updateManager(address _addr, address _newManager) public {
        require(msg.sender == managers[_addr], ""Not the manager"");
        if (_newManager == _addr) {
            managers[_addr] = address(0);
        } else {
            managers[_addr] = _newManager;
        }
        emit ManagerChanged(_addr, _newManager);
    }
}"
799,Returns all the relevant information about a specific collectible .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Collectible {
    using SafeMath for uint256;

    struct Token {
        uint256 price;
        address owner;
    }

    mapping(uint256 => Token) public collectibleIdx;

    function getInitialPriceOfToken(uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate initial price of token
        return 0; // Placeholder, replace with actual implementation
    }

    function getNextPrice(uint256 currentPrice, uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate next selling price
        return currentPrice.mul(110).div(100); // Example: increase by 10%
    }

    function getToken(uint256 _tokenId) public view returns (
        uint256 tokenId,
        uint256 sellingPrice,
        address owner,
        uint256 nextSellingPrice
    ) {
        tokenId = _tokenId;
        Token storage token = collectibleIdx[_tokenId];
        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(_tokenId);
        }
        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
    }
}",getToken,"[{'function': 'getInitialPriceOfToken', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""nextSellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}, ""name"": ""token"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectibleIdx""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""price""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getInitialPriceOfToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""owner""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nextSellingPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextPrice""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sellingPrice""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",6.0,0.9717882994149728,0.753435626690484,"pragma solidity ^0.8.0;

contract MyContract {
    struct Token {
        uint256 price;
        address owner;
        // Add other relevant fields as needed
    }

    mapping(uint256 => Token) public collectibleIdx;

    function getInitialPriceOfToken(uint256 _tokenId) internal pure returns (uint256) {
        // Implement your logic to get the initial price
        return 100; //Example
    }

    function getNextPrice(uint256 _sellingPrice, uint256 _tokenId) internal pure returns (uint256) {
        // Implement your logic to calculate the next price
        return _sellingPrice * 2; //Example
    }


    function getToken(uint256 _tokenId) public view returns (uint256 sellingPrice, address owner, uint256 nextSellingPrice) {
        uint256 tokenId = _tokenId;
        Token memory token = collectibleIdx[tokenId];
        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(tokenId);
        }
        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, tokenId);
    }
}",42.80299162864685,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Token {
        uint256 price;
        address owner;
        // Add other relevant fields as needed
    }

    mapping(uint256 => Token) public collectibleIdx;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            collectibleIdx[i] = Token({price: 100, owner: addr});
        }
    }

    function getInitialPriceOfToken(uint256 _tokenId) internal pure returns (uint256) {
        // Implement your logic to get the initial price
        return 100; //Example
    }

    function getNextPrice(uint256 _sellingPrice, uint256 _tokenId) internal pure returns (uint256) {
        // Implement your logic to calculate the next price
        return _sellingPrice * 2; //Example
    }

    function getToken(uint256 _tokenId) public view returns (uint256 sellingPrice, address owner, uint256 nextSellingPrice) {
        uint256 tokenId = _tokenId;
        Token memory token = collectibleIdx[tokenId];
        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(tokenId);
        }
        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, tokenId);
    }
}"
5627,Changing versions does not affect existing tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract STFactoryWrapper is Ownable {
    using SafeMath for uint256;

    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external onlyOwner {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        // Assuming _setProtocolVersion is a function in the STFactory contract
        (bool success, ) = _STFactoryAddress.call(abi.encodeWithSignature(""setProtocolVersion(uint8, uint8, uint8)"", _major, _minor, _patch));
        require(success, ""External call failed"");
    }
}",setProtocolVersion,"[{'function': 'setProtocolVersion', 'complexity': 1}, {'function': '_setProtocolVersion', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setProtocolVersion"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_STFactoryAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_major"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_minor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_patch"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_STFactoryAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""0x address is not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setProtocolVersion""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_STFactoryAddress""}, {""type"": ""Identifier"", ""name"": ""_major""}, {""type"": ""Identifier"", ""name"": ""_minor""}, {""type"": ""Identifier"", ""name"": ""_patch""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.728450431403233,0.3631037614986742,"pragma solidity ^0.8.0;

contract ContractName {

    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) public {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        _setProtocolVersion(_STFactoryAddress, _major, _minor, _patch);
    }

    function _setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) internal virtual {
        //Implementation to set protocol version.  This is where you would interact with the _STFactoryAddress contract.
    }
}",41.73633289337158,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ContractName is Ownable {
    address public constant ST_FACTORY_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual value
    uint256 public constant MAJOR_VERSION = 1;
    uint256 public constant MINOR_VERSION = 1;
    uint256 public constant PATCH_VERSION = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) public {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        _setProtocolVersion(_STFactoryAddress, _major, _minor, _patch);
    }

    function _setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) internal virtual {
        //Implementation to set protocol version.  This is where you would interact with the _STFactoryAddress contract.
    }
}"
2373,Transfers tokens from a specified wallet address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
        require(_to != address(0), ""Invalid address."");
        return super.transferFrom(_from, _to, _value);
    }
}",transferFrom,"[{'function': 'transferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canTransfer"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,0.9427781070492712,"pragma solidity ^0.8.0;

contract MyToken {

    modifier canTransfer(address _from) {
        require(true, ""Transfer not allowed""); // Replace with actual transfer logic
        _;
    }

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
        require(_to != address(0), ""Invalid address"");
        return super.transferFrom(_from, _to, _value);
    }
}",41.52267456054688,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    string public name = 'initialized';
    string public symbol = 'TKN';
    uint8 public decimals = 18;
    uint256 public totalSupply = 1 * 10 ** (uint256(decimals));

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    uint256 public totalSupply;

 constructor() {
        Ownable.uint256 public totalSupply;

 constructor();
        balanceOf[msg.sender] = totalSupply;
    }

    modifier canTransfer(address _from) {
        require(true, ""Transfer not allowed""); // Replace with actual transfer logic
        _;
    }

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
        require(_to != address(0), ""Invalid address"");
        return super.transferFrom(_from, _to, _value);
    }
}"
3161,"Set `` _price_start '' , `` _price_constant1 '' and `` _price_exponent1 '' `` _price_constant2 '' and `` _price_exponent2 '' as the new starting price , price constant and price exponent for the auction price .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionDeployed, AuctionSetUp }
    Stages public stage;

    uint256 public price_start;
    uint256 public price_constant1;
    uint256 public price_exponent1;
    uint256 public price_constant2;
    uint256 public price_exponent2;

    function changePriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) public onlyOwner {
        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);
        require(_price_start > 0);
        require(_price_constant1 > 0);
        require(_price_constant2 > 0);

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}",setPriceCurve,"[{'function': 'setPriceCurve', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPriceCurve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_start"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_constant1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_exponent1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_constant2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_exponent2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionStage""}, ""memberName"": ""AuctionDeployed""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionStage""}, ""memberName"": ""AuctionSetUp""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid stage""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price_start""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Starting price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant1""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price constant 1 must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant2""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price constant 2 must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_start""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_start""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_constant1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_constant1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_exponent1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_exponent1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_constant2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_constant2""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_exponent2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_exponent2""}}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.9433139490767593,0.5457323972343452,"pragma solidity ^0.8.0;

contract Auction {
    enum AuctionStage { AuctionDeployed, AuctionSetUp, AuctionStarted, AuctionEnded }
    AuctionStage public stage;

    uint256 public price_start;
    uint256 public price_constant1;
    uint256 public price_exponent1;
    uint256 public price_constant2;
    uint256 public price_exponent2;

    function setPriceCurve(
        uint256 _price_start,
        uint256 _price_constant1,
        uint256 _price_exponent1,
        uint256 _price_constant2,
        uint256 _price_exponent2
    ) internal {
        require(stage == AuctionStage.AuctionDeployed || stage == AuctionStage.AuctionSetUp, ""Invalid stage"");
        require(_price_start > 0, ""Starting price must be greater than zero"");
        require(_price_constant1 > 0, ""Price constant 1 must be greater than zero"");
        require(_price_constant2 > 0, ""Price constant 2 must be greater than zero"");

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}",42.93416595458984,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    enum AuctionStage { AuctionDeployed, AuctionSetUp, AuctionStarted, AuctionEnded }
    AuctionStage public stage;

    uint256 public price_start = 1;
    uint256 public price_constant1 = 1;
    uint256 public price_exponent1 = 1;
    uint256 public price_constant2 = 1;
    uint256 public price_exponent2 = 1;

    constructor() Ownable(msg.sender) {
        stage = AuctionStage.AuctionDeployed;
    }

    function setPriceCurve(
        uint256 _price_start,
        uint256 _price_constant1,
        uint256 _price_exponent1,
        uint256 _price_constant2,
        uint256 _price_exponent2
    ) internal {
        require(stage == AuctionStage.AuctionDeployed || stage == AuctionStage.AuctionSetUp, ""Invalid stage"");
        require(_price_start > 0, ""Starting price must be greater than zero"");
        require(_price_constant1 > 0, ""Price constant 1 must be greater than zero"");
        require(_price_constant2 > 0, ""Price constant 2 must be greater than zero"");

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}"
1809,Nominate a new owner of this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    address public nominatedOwner;

    event OwnerNominated(address indexed newOwner);

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
}",acceptOwnership,"[{'function': 'nominateNewOwner', 'complexity': 0}, {'function': 'acceptOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""nominatedOwner""}}, {""type"": ""stringLiteral"", ""value"": ""You must be nominated to accept ownership""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""nominatedOwner""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nominatedOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.7999434650357908,0.0442202052227355,"pragma solidity ^0.8.0;

contract Ownable {
    address public nominated    address public owner;
    address public nominatedOwner;

    event OwnerNominated(address newOwner);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only the contract owner may perform this action"");
        _;
    }

    function nominateNewOwner(address _owner) public onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    function acceptOwnership() public {
        require(msg.sender == nominatedOwner, ""You must be nominated to accept ownership"");
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }
}",43.60494518280029,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public nominatedOwner;
    address public owner;
    bytes32 public initialized;

    event OwnerNominated(address newOwner);

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        nominatedOwner = address(0);
        initialized = bytes32('initialized');
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only the contract owner may perform this action"");
        _;
    }

    function nominateNewOwner(address _owner) public onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    function acceptOwnership() public {
        require(msg.sender == nominatedOwner, ""You must be nominated to accept ownership"");
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }
}"
5765,set minimal amount of ether which can be used to buy tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public minSellAmount;

    function setMinSellAmount(uint256 _minSellAmount) public onlyOwner {
        minSellAmount = _minSellAmount;
    }
}",setMinSellAmount,"[{'function': 'setMinSellAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinSellAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minSellAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minSellAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minSellAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public minSellAmount;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setMinSellAmount(uint256 _minSellAmount) public onlyOwner {
        minSellAmount = _minSellAmount;
    }
}",41.38693165779114,"pragma solidity ^0.8.0;

import ""Ownable/contracts/ownership/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public minSellAmount;

    constructor() Ownable(msg.sender) {
        minSellAmount = 1;
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    function setMinSellAmount(uint256 _minSellAmount) public onlyOwner {
        minSellAmount = _minSellAmount;
    }
}"
1032,Obtain the quantity which the next schedule entry will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingWrapper is Ownable {
    using SafeMath for uint256;

    uint constant QUANTITY_INDEX = 1;

    function getNextVestingEntry(address account) internal view returns (uint[] memory entry) {
        // This should be implemented by the actual contract that uses this wrapper.
        // For demonstration purposes, let's assume it returns a fixed array for any address.
        return [0, 100]; // Example: vesting quantity is 100 for any account
    }

    function getNextVestingQuantity(address account) external view returns (uint) {
        uint[] memory entry = getNextVestingEntry(account);
        return entry[QUANTITY_INDEX];
    }
}",getNextVestingEntry,"[{'function': 'getNextVestingQuantity', 'complexity': 0}, {'function': 'getNextVestingEntry', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNextVestingQuantity"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextVestingEntry""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}, ""index"": {""type"": ""Identifier"", ""name"": ""QUANTITY_INDEX""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.8959834132463097,0.1898031989177807,"pragma solidity ^0.8.0;

contract Vesting {

    uint256 constant QUANTITY_INDEX = 1;

    function getNextVestingQuantity(address account) public view returns (uint256) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }

    function getNextVestingEntry(address account) internal view returns (uint256[] memory) {
        //Implementation for getNextVestingEntry.  Replace this with your actual logic.
        //This is a placeholder and will need to be implemented based on your vesting schedule storage.
        return new uint256[](0);
    }
}",41.83535265922546,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Vesting is Ownable {
    uint256 constant QUANTITY_INDEX = 1;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getNextVestingQuantity(address account) public view returns (uint256) {
        return getNextVestingEntry(account)[QUANTITY_INDEX];
    }

    function getNextVestingEntry(address account) internal view returns (uint256[] memory) {
        //Implementation for getNextVestingEntry.  Replace this with your actual logic.
        //This is a placeholder and will need to be implemented based on your vesting schedule storage.
        return new uint256[](0);
    }
}"
2223,Verifies that two token requirements can be matched and that the tokens are formatted correctly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenVerifier is Ownable {
    using SafeMath for uint256;

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        return ((uint32(_buyTokens) == uint32(_sellToken >> 32)) && (uint32(_sellToken) == uint32(_buyTokens >> 32)) && (uint32(_buyTokens >> 32) <= uint32(_buyTokens)));
    }
}",verifyTokens,"[{'function': 'verifyTokens', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_buyTokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_sellToken"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""buyTokensLower"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyTokens""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""buyTokensUpper"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""_buyTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""sellTokenLower"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sellToken""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""sellTokenUpper"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""_sellToken""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""buyTokensLower""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellTokenUpper""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""sellTokenLower""}, ""right"": {""type"": ""Identifier"", ""name"": ""buyTokensUpper""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""buyTokensUpper""}, ""right"": {""type"": ""Identifier"", ""name"": ""buyTokensLower""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",27.0,0.7265067637854367,0.471594488397908,"pragma solidity ^0.8.0;

contract TokenVerifier {

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        uint32 buyTokensLower = uint32(_buyTokens);
        uint32 buyTokensUpper = uint32(_buyTokens >> 32);
        uint32 sellTokenLower = uint32(_sellToken);
        uint32 sellTokenUpper = uint32(_sellToken >> 32);

        return buyTokensLower == sellTokenUpper && sellTokenLower == buyTokensUpper && buyTokensUpper <= buyTokensLower;
    }
}",41.75639081001282,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenVerifier is Ownable {
    uint256 public constant BUY_TOKENS = 1;
    uint256 public constant SELL_TOKEN = 1;
    bytes32 public constant INITIALIZED = keccak256('init');

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already set to safe, non-corner-case values
    }

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        uint32 buyTokensLower = uint32(_buyTokens);
        uint32 buyTokensUpper = uint32(_buyTokens >> 32);
        uint32 sellTokenLower = uint32(_sellToken);
        uint32 sellTokenUpper = uint32(_sellToken >> 32);

        return buyTokensLower == sellTokenUpper && sellTokenLower == buyTokensUpper && buyTokensUpper <= buyTokensLower;
    }
}"
3500,"Transfers ` amount ` of ` token ` to ` dest ` , only used internally , and does not throw , will always return ` true ` or ` false `","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract PaymentWrapper is Ownable {
    using SafeMath for uint256;

    event Withdraw(uint indexed idDeposit, address indexed dest, ERC20 token, uint amount);

    function doPayment(uint _idDeposit, address _dest, ERC20 _token, uint _amount) public onlyOwner returns (bool) {
        if (_amount == 0) return true;
        if (address(_token) == address(0)) {
            require(_dest.send(_amount), ""Transfer failed"");
        } else {
            require(_token.transfer(_dest, _amount), ""Token transfer failed"");
        }
        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}",doPayment,"[{'function': 'transfer', 'complexity': 0}, {'function': 'doPayment', 'complexity': 8}]",6.0,{},45.0,0.8302427280335188,0.4369803828740588,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract PaymentContract {
    event Withdraw(uint256 _idDeposit, address _dest, address _token, uint256 _amount);

    function doPayment(uint256 _idDeposit, address _dest, address _token, uint256 _amount) public returns (bool) {
        if (_amount == 0) {
            return true;
        }

        if (_token == address(0)) {
            (bool success, ) = _dest.call{value: _amount}("""");
            if (!success) {
                return false;
            }
        } else {
            IERC20 token = IERC20(_token);
            if (!token.transfer(_dest, _amount)) {
                return false;
            }
        }

        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}",42.21132040023804,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract PaymentContract is Ownable {
    event Withdraw(uint256 _idDeposit, address _dest, address _token, uint256 _amount);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables can be done here if needed in the future
    }

    function doPayment(uint256 _idDeposit, address _dest, address _token, uint256 _amount) public returns (bool) {
        if (_amount == 0) {
            return true;
        }

        if (_token == address(0)) {
            (bool success, ) = _dest.call{value: _amount}("""");
            if (!success) {
                return false;
            }
        } else {
            IERC20 token = IERC20(_token);
            if (!token.transfer(_dest, _amount)) {
                return false;
            }
        }

        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}"
4517,returns the block number when the order being last modified .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;

    struct Order {
        uint256 blockNumber;
    }

    mapping(uint256 => Order) public orders;

    function orderBlockNumber(uint256 _orderID) external view returns (uint256) {
        return orders[_orderID].blockNumber;
    }
}",orderBlockNumber,"[{'function': 'orderBlockNumber', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""orderBlockNumber"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_orderID""}}, ""memberName"": ""blockNumber""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9707134457954306,0.6413865258981679,"pragma solidity ^0.8.0;

contract OrderBook {
    struct Order {
        uint256 blockNumber;
        // Add other order details as needed
    }

    mapping(bytes32 => Order) public orders;

    function orderBlockNumber(bytes32 _orderID) public view returns (uint256) {
        return orders[_orderID].blockNumber;
    }
}",41.60809946060181,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OrderBook is Ownable {
    struct Order {
        uint256 blockNumber;
        // Add other order details as needed
    }

    mapping(bytes32 => Order) public orders;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        bytes32 placeholder = bytes32('init');
    }

    function orderBlockNumber(bytes32 _orderID) public view returns (uint256) {
        return orders[_orderID].blockNumber;
    }
}"
868,batch send the current balance to the new version contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;
function migrateByAdmin_DQV (uint256[] inputs) external onlyAdmin {
    uint256 data = inputs[2];
    address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];
    address newContract = address(inputs[0]);
    for (uint256 i = 1; i < inputs.length; i += 4) {
        uint256 gasFee = inputs[i];
        data = inputs[i + 1];
        address user = userId2Address[data & USER_MASK];
        bytes32 hash = keccak256(this, gasFee, data & SIGN_MASK | uint256(token), newContract);
        require(verify(hash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 2]), bytes32(inputs[i + 3])));
        if (gasFee > 0) {
            uint256 paymentMethod = data & PAYMENT_METHOD_MASK;
            if (paymentMethod == PAY_BY_JOY) {
                balances[joyToken][user] = balances[joyToken][user].sub(gasFee);
                balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(gasFee);
            } else if (paymentMethod == PAY_BY_TOKEN) {
                balances[token][user] = balances[token][user].sub(gasFee);
                balances[token][joysoWallet] = balances[token][joysoWallet].add(gasFee);
            } else {
                balances[0][user] = balances[0][user].sub(gasFee);
                balances[0][joysoWallet] = balances[0][joysoWallet].add(gasFee);
            }
        }
        uint256 amount = balances[token][user];
        balances[token][user] = 0;
        if (token == 0) {
            Migratable(newContract).migrate.value(amount)(user, amount, token);
        } else {
            ERC20(token).approve(newContract, amount);
            Migratable(newContract).migrate(user, amount, token);
        }
    }
}
}",migrateBalances,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'migrateBalances', 'complexity': 9}, {'function': 'verify', 'complexity': 0}]",8.0,{},155.0,0.6215115553106669,0.1977731758595895,"pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract MyContract {
    address payable public joysoWallet; //Add Joyso wallet address here.
    //Add other necessary state variables here.

    function migrateBalances(uint256[] memory data) public {
        address newContractAddress = address(uint160(data[0]));
        address tokenAddress = address(uint160(data[2]));

        for (uint256 i = 3; i < data.length; i += 4) {
            uint256 gasFee = data[i];
            // Extract user ID and payment method from data[i+1]
            uint256 userId = (data[i+1] >> 128); // Assuming upper 128 bits are user ID
            uint8 paymentMethod = uint8(data[i+1] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); // Assuming lower 128 bits are payment method

            bytes32 hash = keccak256(abi.encodePacked(userId, paymentMethod, tokenAddress, newContractAddress));
            //Verify signature using verify(hash, data[i+2], data[i+3])

            require(verify(hash, data[i+2], data[i+3]), ""Invalid signature"");

            if (gasFee > 0) {
                //Deduct gas fee from user balance based on paymentMethod
            }

            uint256 userBalance;
            //Calculate userBalance based on tokenAddress and userId

            //Set user balance to zero.

            if (tokenAddress == address(0)) {
                (bool success, ) = newContractAddress.call{value: userBalance}(abi.encodeWithSignature(""migrate(address,uint256,address)"", msg.sender, userBalance, tokenAddress));
                require(success, ""Migration failed"");
            } else {
                IERC20(tokenAddress).approve(newContractAddress, userBalance);
                (bool success, ) = newContractAddress.call(abi.encodeWithSignature(""migrate(address,uint256,address)"", msg.sender, userBalance, tokenAddress));
                require(success, ""Migration failed"");
            }
        }
    }

    function verify(bytes32 hash, bytes memory signature, bytes memory pubKey) internal pure returns (bool) {
        //Implement signature verification logic here.  This will depend on your signature scheme.
        return true; //Replace with actual verification
    }
}",44.60010862350464,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address payable public joysoWallet;
    // Add other necessary state variables here.

    constructor() {
        joysoWallet = payable(address(uint160(uint256(1))));
        // Initialize other state variables to fixed, safe, non-corner-case values as per the rules provided.
    }

    function migrateBalances(uint256[] memory data) public {
        address newContractAddress = address(uint160(data[0]));
        address tokenAddress = address(uint160(data[2]));

        for (uint256 i = 3; i < data.length; i += 4) {
            uint256 gasFee = data[i];
            // Extract user ID and payment method from data[i+1]
            uint256 userId = (data[i+1] >> 128); // Assuming upper 128 bits are user ID
            uint8 paymentMethod = uint8(data[i+1] & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); // Assuming lower 128 bits are payment method

            bytes32 hash = keccak256(abi.encodePacked(userId, paymentMethod, tokenAddress, newContractAddress));
            //Verify signature using verify(hash, data[i+2], data[i+3])

            require(verify(hash, data[i+2], data[i+3]), ""Invalid signature"");

            if (gasFee > 0) {
                //Deduct gas fee from user balance based on paymentMethod
            }

            uint256 userBalance;
            //Calculate userBalance based on tokenAddress and userId

            //Set user balance to zero.

            if (tokenAddress == address(0)) {
                (bool success, ) = newContractAddress.call{value: userBalance}(abi.encodeWithSignature(""migrate(address,uint256,address)"", msg.sender, userBalance, tokenAddress));
                require(success, ""Migration failed"");
            } else {
                IERC20(tokenAddress).approve(newContractAddress, userBalance);
                (bool success, ) = newContractAddress.call(abi.encodeWithSignature(""migrate(address,uint256,address)"", msg.sender, userBalance, tokenAddress));
                require(success, ""Migration failed"");
            }
        }
    }

    function verify(bytes32 hash, bytes memory signature, bytes memory pubKey) internal pure returns (bool) {
        //Implement signature verification logic here.  This will depend on your signature scheme.
        return true; //Replace with actual verification
    }
}"
2092,Get a player 's current instant pot winnings .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    struct TeamData {
        uint256 mask;
        uint256 keys;
    }

    struct PlayerTeamData {
        uint256 mask;
        uint256 keys;
    }

    mapping(uint256 => mapping(uint256 => TeamData)) public teams_;
    mapping(uint256 => mapping(uint256 => mapping(uint256 => PlayerTeamData))) public playerTeams_;

    modifier isActivated(uint256 _gameID) {
        require(_gameID > 0 && _gameID < 10, ""Game must be activated"");
        _;
    }

    modifier isValidTeam(uint256 _gameID, uint256 _team) {
        require(_team > 0 && _team <= 3, ""Invalid team"");
        _;
    }

    function getPlayerInstWinning(uint256 _gameID, uint256 _pID, uint256 _team) public view isActivated(_gameID) isValidTeam(_gameID, _team) returns (uint256) {
        return (((teams_[_gameID][_team].mask).mul(playerTeams_[_pID][_gameID][_team].keys)) / (1000000000000000000)).sub(playerTeams_[_pID][_gameID][_team].mask));
    }
}",calculateWinningAmount,"[{'function': 'isActivated', 'complexity': 0}, {'function': 'isValidTeam', 'complexity': 0}, {'function': 'calculateWinningAmount', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateWinningAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_gameID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_pID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_team"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isActivated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_gameID""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Game not activated""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isValidTeam""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_gameID""}, {""type"": ""Identifier"", ""name"": ""_team""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid team""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mask"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""teams_""}, ""index"": {""type"": ""Identifier"", ""name"": ""_gameID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_team""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""playerKeys"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""playerTeams_""}, ""index"": {""type"": ""Identifier"", ""name"": ""_gameID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_pID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_team""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""result"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""mask""}, ""right"": {""type"": ""Identifier"", ""name"": ""playerKeys""}}], ""isArray"": False}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}}}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""playerTeams_""}, ""index"": {""type"": ""Identifier"", ""name"": ""_gameID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_pID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_team""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",46.0,0.8109830843075452,0.3483085209703959,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(uint256 => mapping(uint256 => uint256)) public teams_;
    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) public playerTeams_;

    function isActivated(uint256 _gameID) internal view returns (bool) {
        //Implementation for isActivated
    }

    function isValidTeam(uint256 _gameID, uint256 _team) internal view returns (bool) {
        //Implementation for isValidTeam
    }


    function calculateWinningAmount(uint256 _gameID, uint256 _pID, uint256 _team) public view returns (uint256) {
        require(isActivated(_gameID), ""Game not activated"");
        require(isValidTeam(_gameID, _team), ""Invalid team"");

        uint256 mask = teams_[_gameID][_team];
        uint256 playerKeys = playerTeams_[_gameID][_pID][_team];
        uint256 result = (mask * playerKeys) / 10**18;
        return result - playerTeams_[_gameID][_pID][_team];
    }
}",42.685975551605225,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(uint256 => mapping(uint256 => uint256)) public teams_;
    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) public playerTeams_;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            teams_[1][i] = 1; // uint256: Set to 1
            playerTeams_[1][i][i] = 1; // uint256: Set to 1
        }
    }

    function isActivated(uint256 _gameID) internal view returns (bool) {
        // Implementation for isActivated
        return true; // Placeholder, adjust as needed
    }

    function isValidTeam(uint256 _gameID, uint256 _team) internal view returns (bool) {
        // Implementation for isValidTeam
        return true; // Placeholder, adjust as needed
    }

    function calculateWinningAmount(uint256 _gameID, uint256 _pID, uint256 _team) public view returns (uint256) {
        require(isActivated(_gameID), ""Game not activated"");
        require(isValidTeam(_gameID, _team), ""Invalid team"");

        uint256 mask = teams_[_gameID][_team];
        uint256 playerKeys = playerTeams_[_gameID][_pID][_team];
        uint256 result = (mask * playerKeys) / 10**18;
        return result - playerTeams_[_gameID][_pID][_team];
    }
}"
1597,add more ether to use in oraclize queries,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/SafeMath.sol"";

abstract contract TopUpContract is Ownable {
    using SafeMath for uint256;

    function topUp() external payable {
        // Function implementation here
    }
}",,[],0.0,{},0.0,0.534870282726292,0.0,"pragma solidity ^0.8.0;

contract TopUpContract {
    receive() external payable {}
}",41.110764265060425,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TopUpContract is Ownable {
    receive() external payable {}

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        uint256 private constant INITIAL_VALUE = 1;
        address private constant ADDRESS_VALUES = address(uint160(uint256(keccak256('addr1'))));

        // No need to initialize other state variables as they are not defined in the provided contract.
    }
}"
3185,To check if an address is a contract or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractChecker is Ownable {
    using SafeMath for uint256;

    function isContract(address addr) public pure returns (bool _isContract) {
        require(addr != address(0));
        uint256 length;
        assembly {
            length := extcodesize(addr)
        }
        return (length > 0);
    }
}",isContract,"[{'function': 'isContract', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_isContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Address cannot be zero""}], ""names"": []}}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""_isContract""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""addr"", ""arguments"": []}]}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",8.0,0.8858753255939089,0.5808400692157698,"pragma solidity ^0.8.0;

contract ContractChecker {

    function isContract(address addr) public view returns (bool _isContract) {
        require(addr != address(0), ""Address cannot be zero"");
        assembly {
            _isContract := extcodesize(addr)
        }
    }
}",41.28311467170715,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ContractChecker is Ownable {
    function isContract(address addr) public view returns (bool _isContract) {
        require(addr != address(0), ""Address cannot be zero"");
        assembly {
            _isContract := extcodesize(addr)
        }
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
146,Add to the amount this member has bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function addAmountBoughtAsMember(address _member, uint256 _amountBought) external onlyOwner {
        // Add the logic to update the member's amount bought here.
        // For example:
        // members[_member] = members[_member].add(_amountBought);
    }
}",addTokensBought,"[{'function': 'addTokensBought', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addTokensBought"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_member"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountBought"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""index"": {""type"": ""Identifier"", ""name"": ""_member""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amountBought""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.6945880321168734,0.1270734283507419,"pragma solidity ^0.8.0;

contract TokenPurchaseTracker {
    mapping(address => uint256) public tokensBought;

    function addTokensBought(address _member, uint256 _amountBought) external {
        tokensBought[_member] += _amountBought;
    }
}",41.15551018714905,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenPurchaseTracker is Ownable {
    mapping(address => uint256) public tokensBought;
    address public constant DEFAULT_MEMBER = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_INIT = true;
    bytes32 public constant DEFAULT_INIT_BYTES32 = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addTokensBought(address _member, uint256 _amountBought) external {
        tokensBought[_member] += _amountBought;
    }
}"
5173,` msg.sender ` approves ` spender ` to spend ` value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Success }
    State public state = State.Initial;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function getState() internal pure returns (State) {
        return State.Success;
    }

    function approve(address spender, uint256 value) external returns (bool ok) {
        require(getState() == State.Success, ""Contract not in success state"");
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Success""}}, {""type"": ""stringLiteral"", ""value"": ""Contract in failure state""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.927236904055587,0.6233968407803632,"pragma solidity ^0.8.0;

contract Token {
    mapping (address => mapping (address => uint256)) internal _allowed;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    enum State { Success, Failure }
    State public state;

    function approve(address spender, uint256 value) public returns (bool) {
        require(state == State.Success, ""Contract in failure state"");
        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}",41.66415095329285,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping (address => mapping (address => uint256)) internal _allowed;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    enum State { Success, Failure }
    State public state = State.Success;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _allowed[address(0x111)][address(0x222)] = 1;
        _allowed[address(0x222)][address(0x333)] = 1;
        _allowed[address(0x333)][address(0x111)] = 1;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(state == State.Success, ""Contract in failure state"");
        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}"
4527,Funtion to let users claim their tokens at the end of ico process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenReward {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaim is Ownable {
    using SafeMath for uint256;

    enum State { Pending, Successful, Failed }
    State public state = State.Pending;

    mapping(address => uint256) public pending;
    ITokenReward public tokenReward;

    event LogContributorsPayout(address indexed user, uint256 amount);

    function claimTokensByUser() public {
        require(state == State.Successful, ""State must be Successful"");
        uint256 temp = pending[msg.sender];
        pending[msg.sender] = 0;
        require(tokenReward.transfer(msg.sender, temp), ""Token transfer failed"");
        emit LogContributorsPayout(msg.sender, temp);
    }
}",claimTokensByUser,"[{'function': 'claimTokensByUser', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokensByUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Successful""}}, {""type"": ""stringLiteral"", ""value"": ""Contract not in Successful state""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pending""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pending""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenReward""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogContributorsPayout""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.945549369774218,0.5151852230520115,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract YourContract {
    enum State {Pending, Successful, Failed}
    State public state;
    IERC20 public tokenReward;
    mapping(address => uint256) public pending;

    event LogContributorsPayout(address indexed contributor, uint256 amount);

    constructor(address _tokenReward) {
        tokenReward = IERC20(_tokenReward);
    }

    function claimTokensByUser() public {
        require(state == State.Successful, ""Contract not in Successful state"");
        uint256 amount = pending[msg.sender];
        pending[msg.sender] = 0;
        tokenReward.transfer(msg.sender, amount);
        emit LogContributorsPayout(msg.sender, amount);
    }


    // ... other functions ...
}",42.14514064788818,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract YourContract is Ownable {
    enum State {Pending, Successful, Failed}
    State public state;
    IERC20 public tokenReward;
    mapping(address => uint256) public pending;

    event LogContributorsPayout(address indexed contributor, uint256 amount);

    constructor(address _tokenReward) Ownable(msg.sender) {
        state = State.Pending; // Set to Pending instead of default (0)
        tokenReward = IERC20(_tokenReward);
    }

    function claimTokensByUser() public {
        require(state == State.Successful, ""Contract not in Successful state"");
        uint256 amount = pending[msg.sender];
        pending[msg.sender] = 0;
        tokenReward.transfer(msg.sender, amount);
        emit LogContributorsPayout(msg.sender, amount);
    }

    // ... other functions ...
}"
5993,"Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(uint256 => address) private tokenOwnerMap;
    mapping(address => bool) public approvedContractAddresses;

    function ownerOf(uint256 _tokenId) public view returns (address) {
        return tokenOwnerMap[_tokenId];
    }

    function isSenderApprovedFor(uint256 _tokenId) public view returns (bool) {
        return approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin;
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_from == ownerOf(_tokenId), ""wrong owner"");
        require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin), ""not an approved sender"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);
    }

    function _clearApprovalAndTransfer(address from, address to, uint256 tokenId) internal {
        require(from != address(0));
        require(to != address(0));
        require(ownerOf(tokenId) == from);

        // Clear existing approval
        delete tokenOwnerMap[tokenId];

        // Transfer ownership
        tokenOwnerMap[tokenId] = to;
    }
}",transferFrom,"[{'function': 'ownerOf', 'complexity': 0}, {'function': 'isSenderApprovedFor', 'complexity': 0}, {'function': '_clearApprovalAndTransfer', 'complexity': 1}, {'function': 'transferFrom', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isSenderApprovedFor""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedContractAddresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tx""}, ""memberName"": ""origin""}}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Not approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_from""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_clearApprovalAndTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.8865692542145653,0.1294999440759519,"pragma solidity ^0.8.0;

contract ERC721 {

    mapping(uint256 => address) private ownerByTokenId;
    mapping(address => bool) private approvedContractAddresses;
    mapping(uint256 => address) private approvedTransfers;


    function ownerOf(uint256 _tokenId) internal view returns (address) {
        return ownerByTokenId[_tokenId];
    }

    function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {
        return approvedTransfers[_tokenId] == msg.sender;
    }

    function _clearApprovalAndTransfer(address _to, uint256 _tokenId) internal {
        if (approvedTransfers[_tokenId] != address(0)) {
            approvedTransfers[_tokenId] = address(0);
        }
        ownerByTokenId[_tokenId] = _to;
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) external {
        address tokenOwner = ownerOf(_tokenId);
        require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwner == tx.origin), ""Not approved"");
        require(tokenOwner == _from, ""Incorrect owner"");
        _clearApprovalAndTransfer(_to, _tokenId);
    }
}",42.991530656814575,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ERC721 {
    // Mapping of token IDs to their owners
    mapping(uint256 => address) private ownerByTokenId;

    // Mapping of approved contract addresses
    mapping(address => bool) private approvedContractAddresses;

    // Mapping of approved transfers for each token ID
    mapping(uint256 => address) private approvedTransfers;

    // Constructor with initialization of instance variables
    constructor() {
        // Initialize ownerByTokenId with a fixed value (0x1111111111111111111111111111111111111111)
        ownerByTokenId[1] = 0x1111111111111111111111111111111111111111;

        // Initialize approvedContractAddresses with a fixed value (true)
        approvedContractAddresses[msg.sender] = true;

        // Initialize approvedTransfers with a fixed value (bytes32('init'))
        approvedTransfers[1] = bytes32('init');
    }

    function ownerOf(uint256 _tokenId) internal view returns (address) {
        return ownerByTokenId[_tokenId];
    }

    function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {
        return approvedTransfers[_tokenId] == msg.sender;
    }

    function _clearApprovalAndTransfer(address _to, uint256 _tokenId) internal {
        if (approvedTransfers[_tokenId] != address(0)) {
            approvedTransfers[_tokenId] = address(0);
        }
        ownerByTokenId[_tokenId] = _to;
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) external {
        address tokenOwner = ownerOf(_tokenId);
        require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwner == tx.origin), ""Not approved"");
        require(tokenOwner == _from, ""Incorrect owner"");
        _clearApprovalAndTransfer(_to, _tokenId);
    }
}"
2061,Checks if the notary 's signature to close the ` DataResponse ` is valid .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NotaryVerifier is Ownable {
    using SafeMath for uint256;

    function isNotaryVeredictValid(address order, address seller, address notary, bool wasAudited, bool isDataValid, bytes memory notarySignature) public pure returns (bool) {
        require(order != address(0));
        require(seller != address(0));
        require(notary != address(0));
        bytes32 hash = keccak256(abi.encodePacked(order, seller, wasAudited, isDataValid));
        return isSignedBy(hash, notary, notarySignature);
    }

    function isSignedBy(bytes32 hash, address signer, bytes memory signature) internal pure returns (bool) {
        require(signer != address(0));
        return signer == ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)), 27 + uint8(signature[64]), signature[:64], signature[64]);
    }
}",isSignedBy,"[{'function': 'verifyNotaryVerdict', 'complexity': -1}, {'function': 'isSignedBy', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isSignedBy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""r"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""s"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""v"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""r""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""signature"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""32""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""s""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""signature"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""64""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""v""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""byte"", ""arguments"": [{""type"": ""DecimalNumber"", ""value"": ""0""}, {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""signature"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""96""}]}]}]}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""v""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""27"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""v""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""27"", ""subdenomination"": None}}}]}, ""FalseBody"": None}, {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ecrecover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hash""}, {""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""signer""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",55.0,0.7830989470086778,0.1171316503496373,"pragma solidity ^0.8.0;

contract NotaryVerification {

    function verifyNotaryVerdict(
        address order,
        address seller,
        address notary,
        bool wasAudited,
        bool isDataValid,
        bytes memory notarySignature
    ) public pure returns (bool) {
        require(order != address(0), ""Order address cannot be zero"");
        require(seller != address(0), ""Seller address cannot be zero"");
        require(notary != address(0), ""Notary address cannot be zero"");

        bytes32 hash = keccak256(abi.encodePacked(order, seller, notary, wasAudited, isDataValid));
        return isSignedBy(hash, notarySignature, notary);
    }

    function isSignedBy(
        bytes32 hash,
        bytes memory signature,
        address signer
    ) internal pure returns (bool) {
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }

        if (v < 27) {
            v += 27;
        }

        return ecrecover(hash, v, r, s) == signer;
    }
}",43.03876304626465,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NotaryVerification is Ownable {
    function verifyNotaryVerdict(
        address order,
        address seller,
        address notary,
        bool wasAudited,
        bool isDataValid,
        bytes memory notarySignature
    ) public pure returns (bool) {
        require(order != address(0), ""Order address cannot be zero"");
        require(seller != address(0), ""Seller address cannot be zero"");
        require(notary != address(0), ""Notary address cannot be zero"");

        bytes32 hash = keccak256(abi.encodePacked(order, seller, notary, wasAudited, isDataValid));
        return isSignedBy(hash, notarySignature, notary);
    }

    function isSignedBy(
        bytes32 hash,
        bytes memory signature,
        address signer
    ) internal pure returns (bool) {
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }

        if (v < 27) {
            v += 27;
        }

        return ecrecover(hash, v, r, s) == signer;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
1609,Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeTokenFactory {
    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) external returns (MiniMeToken);
}

abstract contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    address public factory;
    string public name;
    uint8 public decimals;
    string public symbol;
    bool public transfersEnabled;
    uint256 public snapshotBlock;

    constructor(address _factory, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) {
        factory = _factory;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        transfersEnabled = _transfersEnabled;
        snapshotBlock = _snapshotBlock > block.number ? block.number : _snapshotBlock;
    }

    function changeController(address _newController) public onlyOwner {
        require(_newController != address(0), ""Invalid controller address"");
        // Controller logic here
    }
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    MiniMeTokenFactory public tokenFactory;

    event NewCloneToken(address indexed cloneTokenAddress, uint256 snapshotBlock);

    constructor(MiniMeTokenFactory _tokenFactory) {
        tokenFactory = _tokenFactory;
    }

    function createCloneToken(string memory _cloneTokenName, uint8 _cloneDecimalUnits, string memory _cloneTokenSymbol, uint256 _snapshotBlock, bool _transfersEnabled) public returns (address) {
        if (_snapshotBlock > block.number) {
            _snapshotBlock = block.number;
        }
        MiniMeToken cloneToken = tokenFactory.createCloneToken(address(this), _snapshotBlock, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled);
        cloneToken.changeController(msg.sender);
        emit NewCloneToken(address(cloneToken), _snapshotBlock);
        return address(cloneToken);
    }
}",createCloneToken,"[{'function': 'createCloneToken', 'complexity': 0}]",2.0,{},51.0,0.9002153631144192,0.6953521929567695,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./MiniMeTokenFactory.sol""; // Assuming MiniMeTokenFactory is defined elsewhere

contract MyToken is IERC20 {
    // ... other functions and variables ...

    event NewCloneToken(address indexed _cloneToken, uint256 _snapshotBlock);

    function createCloneToken(
        string memory _cloneTokenName,
        uint8 _cloneDecimalUnits,
        string memory _cloneTokenSymbol,
        uint256 _snapshotBlock,
        bool _transfersEnabled
    ) public returns (address) {
        if (_snapshotBlock > block.number) {
            _snapshotBlock = block.number;
        }

        MiniMeTokenFactory factory = MiniMeTokenFactory(0x....); // Replace with factory address

        address cloneTokenAddress = factory.createCloneToken(
            address(this),
            _snapshotBlock,
            _cloneTokenName,
            _cloneDecimalUnits,
            _cloneTokenSymbol,
            _transfersEnabled
        );

        MiniMeToken(cloneTokenAddress).changeController(msg.sender);

        emit NewCloneToken(cloneTokenAddress, _snapshotBlock);

        return cloneTokenAddress;
    }

    // ... other functions and variables ...
}",42.59129428863525,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./MiniMeTokenFactory.sol""; // Assuming MiniMeTokenFactory is defined elsewhere
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable, IERC20 {
    string public name;
    uint8 public decimals;
    string public symbol;
    uint256 public totalSupply;
    bool public transfersEnabled;

    constructor(string memory _name, uint8 _decimals, string memory _symbol, uint256 _totalSupply, bool _transfersEnabled) {
        name = _name;
        decimals = _decimals;
        symbol = _symbol;
        totalSupply = _totalSupply;
        transfersEnabled = _transfersEnabled;
    }

    function createCloneToken(
        string memory _cloneTokenName,
        uint8 _cloneDecimalUnits,
        string memory _cloneTokenSymbol,
        uint256 _snapshotBlock,
        bool _transfersEnabled
    ) public returns (address) {
        if (_snapshotBlock > block.number) {
            _snapshotBlock = block.number;
        }

        MiniMeTokenFactory factory = MiniMeTokenFactory(0x....); // Replace with factory address

        address cloneTokenAddress = factory.createCloneToken(
            address(this),
            _snapshotBlock,
            _cloneTokenName,
            _cloneDecimalUnits,
            _cloneTokenSymbol,
            _transfersEnabled
        );

        MiniMeToken(cloneTokenAddress).changeController(msg.sender);

        emit NewCloneToken(cloneTokenAddress, _snapshotBlock);

        return cloneTokenAddress;
    }

    // ... other functions and variables ...
}"
2752,"If you lock 50 % , the lockout time is six months .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _lockupBalances;
    mapping(address => uint256) private _lockupExpireTime;
    address public owner;
    uint256 public constant LOCKUP_TERM = 30 days; // Example lockup term, adjust as needed

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    function distribute(address _to, uint256 _value, uint256 _lockupRate) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_to != address(this));
        require(_lockupBalances[_to] == 0);
        require(_value <= _balances[owner]);
        require(_lockupRate == 50 || _lockupRate == 100);

        uint256 lockupValue = _value.mul(_lockupRate).div(100);
        uint256 givenValue = _value.sub(lockupValue);
        uint256 ExpireTime = now + LOCKUP_TERM;

        if (_lockupRate == 100) {
            ExpireTime += LOCKUP_TERM;
        }

        _balances[owner] = _balances[owner].sub(_value);
        _balances[_to] = _balances[_to].add(givenValue);
        _lockupBalances[_to] = _lockupBalances[_to].add(lockupValue);
        _lockupExpireTime[_to] = ExpireTime;

        emit Transfer(owner, _to, _value);

        return true;
    }
}",distributeTokens,"[{'function': 'distributeTokens', 'complexity': 7}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_lockupRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockedBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Recipient already has locked tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""50"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid lockup rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lockedAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""unlockedAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""Identifier"", ""name"": ""lockedAmount""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expirationTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""weeks""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""expirationTime""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""years""}}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""unlockedAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockedBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""lockedAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockupExpiration""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""expirationTime""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",54.0,0.7810480437932754,0.3637877180112885,"pragma solidity ^0.8.0;

contract TokenDistribution {
    address public owner;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public lockedBalances;
    mapping(address => uint256) public lockupExpiration;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    function distributeTokens(address _to, uint256 _value, uint256 _lockupRate) public {
        require(_to != address(0) && _to != address(this), ""Invalid recipient address"");
        require(lockedBalances[_to] == 0, ""Recipient already has locked tokens"");
        require(balances[owner] >= _value, ""Insufficient balance"");
        require(_lockupRate == 50 || _lockupRate == 100, ""Invalid lockup rate"");

        balances[owner] -= _value;

        uint256 lockedAmount = (_value * _lockupRate) / 100;
        uint256 unlockedAmount = _value - lockedAmount;

        uint256 expirationTime = block.timestamp + 1 weeks; // Default lockup period of 1 week
        if (_lockupRate == 100) {
            expirationTime = block.timestamp + 1 years; // Extend lockup period to 1 year for 100% lockup
        }

        balances[_to] += unlockedAmount;
        lockedBalances[_to] += lockedAmount;
        lockupExpiration[_to] = expirationTime;

        emit Transfer(owner, _to, _value);
    }
}",43.09308886528015,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenDistribution is Ownable {
    address public owner = msg.sender;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public lockedBalances;
    mapping(address => uint256) public lockupExpiration;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        balances[owner] = 1; // Initialize balance to non-zero safe value
    }

    function distributeTokens(address _to, uint256 _value, uint256 _lockupRate) public {
        require(_to != address(0) && _to != address(this), ""Invalid recipient address"");
        require(lockedBalances[_to] == 0, ""Recipient already has locked tokens"");
        require(balances[owner] >= _value, ""Insufficient balance"");
        require(_lockupRate == 50 || _lockupRate == 100, ""Invalid lockup rate"");

        balances[owner] -= _value;

        uint256 lockedAmount = (_value * _lockupRate) / 100;
        uint256 unlockedAmount = _value - lockedAmount;

        uint256 expirationTime = block.timestamp + 1 weeks; // Default lockup period of 1 week
        if (_lockupRate == 100) {
            expirationTime = block.timestamp + 1 years; // Extend lockup period to 1 year for 100% lockup
        }

        balances[_to] += unlockedAmount;
        lockedBalances[_to] += lockedAmount;
        lockupExpiration[_to] = expirationTime;

        emit Transfer(owner, _to, _value);
    }
}"
6641,Make bulk transfer of tokens to many addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        // Implementation of the transfer function
    }

    function transferToMany(address[] memory _addrs, uint256[] memory _amounts) public returns (bool) {
        require(_addrs.length == _amounts.length);
        for (uint256 i = 0; i < _addrs.length; i++) {
            require(transfer(_addrs[i], _amounts[i]));
        }
        return true;
    }
}",transferEtherBatch,"[{'function': 'transferEtherBatch', 'complexity': 5}]",6.0,{},45.0,0.716137462699513,0.2305794804970554,"pragma solidity ^0.8.0;

contract MultiTransfer {

    event TransferBatch(address[] _addrs, uint[] _amounts);

    function transferEtherBatch(address[] memory _addrs, uint[] memory _amounts) public payable returns (bool) {
        require(_addrs.length == _amounts.length, ""Lengths of arrays must match."");

        uint256 totalAmount = 0;
        for (uint256 i = 0; i < _amounts.length; i++) {
            totalAmount += _amounts[i];
            require(totalAmount <= msg.value, ""Insufficient funds."");
            require(_addrs[i] != address(0), ""Recipient address cannot be zero."");
            (bool success,) = payable(_addrs[i]).call{value: _amounts[i]}("""");
            require(success, ""Transfer failed."");
        }

        emit TransferBatch(_addrs, _amounts);
        return true;
    }
}",42.23508977890015,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiTransfer is Ownable {
    event TransferBatch(address[] _addrs, uint[] _amounts);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferEtherBatch(address[] memory _addrs, uint[] memory _amounts) public payable returns (bool) {
        require(_addrs.length == _amounts.length, ""Lengths of arrays must match."");

        uint256 totalAmount = 0;
        for (uint256 i = 0; i < _amounts.length; i++) {
            totalAmount += _amounts[i];
            require(totalAmount <= msg.value, ""Insufficient funds."");
            require(_addrs[i] != address(0), ""Recipient address cannot be zero."");
            (bool success,) = payable(_addrs[i]).call{value: _amounts[i]}("""");
            require(success, ""Transfer failed."");
        }

        emit TransferBatch(_addrs, _amounts);
        return true;
    }
}"
2380,The contract address is always the message sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721ReceiverWrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4) {
        require(_operator == address(this), ""Only this contract can receive ERC721 tokens"");
        require(_data.length > 0, ""Data must be non-empty"");
        require(_from != address(0), ""From address cannot be zero"");
        require(_tokenId > 0, ""Token ID must be greater than zero"");

        // Handle the ERC721 token transfer

        return IERC721Receiver(_operator).onERC721Received.selector;
    }
}",onERC721Received,"[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'onERC721Received', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""onERC721Received"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0x150b7a09"", ""subdenomination"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",37.0,0.4661245350325835,0.0520693028331563,"pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

contract ERC721Receiver is IERC721Receiver {

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4) {
        return 0x150b7a09;
    }
}",41.49319934844971,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}
import ""openzeppelin/SafeMath.sol"";
contract ERC721Receiver is IERC721Receiver, Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external override returns (bytes4) {
        return 0x150b7a09;
    }
}"
4661,"Sends an ` _amount ` of ` baseToken ` to ` _to ` from this contract , and it can only be called by the contract itself","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

abstract contract WrappedTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public baseToken;

    constructor(IERC20 _baseToken) {
        baseToken = _baseToken;
    }

    function transfer(address _to, uint256 _amount) external onlyOwner {
        if (address(baseToken) != 0) {
            require(baseToken.transfer(_to, _amount));
        } else {
            require(_to.send(_amount));
        }
    }
}",pose,"[{'function': 'transfer', 'complexity': 0}, {'function': 'pose', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""baseToken""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""baseToken""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""memberName"": ""send""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Send failed""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.9079306289884016,0.3649895349359994,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract MyContract {
    address public baseToken;

    function pose(address _to, uint256 _amount) public {
        if (baseToken != address(0)) {
            IERC20 token = IERC20(baseToken);
            require(token.transfer(_to, _amount), ""Transfer failed"");
        } else {
            require(payable(_to).send(_amount), ""Send failed"");
        }
    }
}",41.87431359291077,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public baseToken;
    bool public initialized = true;
    bytes32 public initBytes;

    constructor() Ownable(msg.sender) {
        baseToken = 0x1111111111111111111111111111111111111111; // Replace with actual token address
        initBytes = bytes32('init');
    }

    function pose(address _to, uint256 _amount) public {
        if (baseToken != address(0)) {
            IERC20 token = IERC20(baseToken);
            require(token.transfer(_to, _amount), ""Transfer failed"");
        } else {
            require(payable(_to).send(_amount), ""Send failed"");
        }
    }

    function initialize() public onlyOwner {
        baseToken = 0x2222222222222222222222222222222222222222; // Replace with actual token address
        initBytes = bytes32('initialized');
    }
}"
3343,Allow pre-approved user to take ownership of a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) public onlyOwner {
        // Implementation of the takeOwnership function
    }
}",takeOwnership,"[{'function': 'takeOwnership', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""currentOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""currentOwner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Already owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isApprovedForAll""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentOwner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getApproved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Not approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentOwner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.3387588661284184,0.10520850573092,"pragma solidity ^0.8.0;

import ""./ERC721.sol""; // Assuming ERC721 base contract is available

contract MyNFT is ERC721 {

    function takeOwnership(uint256 _tokenId) public {
        address currentOwner = ownerOf(_tokenId);
        require(currentOwner != msg.sender, ""Already owner"");
        require(isApprovedForAll(currentOwner, msg.sender) || getApproved(_tokenId) == msg.sender, ""Not approved"");
        _transfer(currentOwner, msg.sender, _tokenId);
    }
}",41.793978452682495,"pragma solidity ^0.8.0;

import ""./ERC721.sol""; // Assuming ERC721 base contract is available
import ""./Ownable.sol""; // Assuming Ownable base contract is available
import ""openzeppelin/SafeMath.sol"";
contract MyNFT is ERC721, Ownable {
    constructor() ERC721(""MyToken"", ""MYT"") Ownable(msg.sender) {}

    function takeOwnership(uint256 _tokenId) public {
        address currentOwner = ownerOf(_tokenId);
        require(currentOwner != msg.sender, ""Already owner"");
        require(isApprovedForAll(currentOwner, msg.sender) || getApproved(_tokenId) == msg.sender, ""Not approved"");
        _transfer(currentOwner, msg.sender, _tokenId);
    }
}"
6562,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) external payable returns (bool) {
        return true;
    }
}",makeProxyPayment,"[{'function': 'makeProxyPayment', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""makeProxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",6.0,0.7316086040676688,0.4608662469973654,"pragma solidity ^0.8.0;

contract ProxyPayment {

    function makeProxyPayment(address payable _owner) external payable returns (bool) {
        _owner.transfer(msg.value);
        return true;
    }
}",41.25158667564392,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ProxyPayment is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function makeProxyPayment(address payable _owner) external payable returns (bool) {
        _owner.transfer(msg.value);
        return true;
    }
}"
52,Function to claim any token stuck on contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface token {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Successful }
    State public state = State.Initial;

    address public creator;

    constructor(address _creator) {
        creator = _creator;
    }

    function claimTokens(token _address) public {
        require(state == State.Successful);
        require(msg.sender == creator);
        uint256 remainder = _address.balanceOf(address(this));
        require(_address.transfer(creator, remainder), ""Transfer failed"");
    }
}",claimTokens,"[{'function': 'claimTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Successful""}}, {""type"": ""stringLiteral"", ""value"": ""Contract not in Successful state""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""creator""}}, {""type"": ""stringLiteral"", ""value"": ""Only creator can claim tokens""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""creator""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.9302504001626156,0.3845122294522673,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    address public creator;
    enum State {Pending, Successful, Failed}
    State public state;

    constructor() {
        creator = msg.sender;
        state = State.Pending;
    }

    function claimTokens(address _token) public {
        require(state == State.Successful, ""Contract not in Successful state"");
        require(msg.sender == creator, ""Only creator can claim tokens"");
        IERC20 token = IERC20(_token);
        uint256 balance = token.balanceOf(address(this));
        token.transfer(creator, balance);
    }

    // ... other functions ...
}",41.931713581085205,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public creator;
    enum State {Pending, Successful, Failed}
    State public state;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        creator = msg.sender;
        state = State.Pending;
    }

    function claimTokens(address _token) public {
        require(state == State.Successful, ""Contract not in Successful state"");
        require(msg.sender == creator, ""Only creator can claim tokens"");
        IERC20 token = IERC20(_token);
        uint256 balance = token.balanceOf(address(this));
        token.transfer(creator, balance);
    }

    // ... other functions ...
}"
5414,Performs allowance transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _smbl, string memory _reference, address _sender) external returns (uint);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;

    constructor(address _chronoBankPlatform) {
        chronoBankPlatform = ChronoBankPlatform(_chronoBankPlatform);
    }

    function __transferFromWithReference(address _from, address _to, uint _value, string memory _reference, address _sender) public onlyOwner {
        require(chronoBankPlatform.proxyTransferFromWithReference(_from, _to, _value, bytes32(""smbl""), _reference, _sender) == 0, ""Transfer failed"");
    }
}",transferWithReference,"[{'function': 'transferWithReference', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferWithReference"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_reference"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IChronoBankPlatform""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""chronoBankPlatform""}], ""names"": []}, ""memberName"": ""proxyTransferFromWithReference""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_reference""}, {""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""smbl""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""success""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAccess"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.9191211284609154,0.4713337658891079,"pragma solidity ^0.8.0;

contract MyContract {

    address public chronoBankPlatform;
    address[] public authorizedAddresses;
    string public smbl;

    modifier onlyAccess() {
        bool allowed = false;
        for (uint i = 0; i < authorizedAddresses.length; i++) {
            if (msg.sender == authorizedAddresses[i]) {
                allowed = true;
                break;
            }
        }
        require(allowed, ""Not authorized"");
        _;
    }

    constructor(address _chronoBankPlatform, string memory _smbl, address[] memory _authorizedAddresses) {
        chronoBankPlatform = _chronoBankPlatform;
        smbl = _smbl;
        authorizedAddresses = _authorizedAddresses;
    }


    function transferWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender) public onlyAccess returns (bool) {
        bool success = IChronoBankPlatform(chronoBankPlatform).proxyTransferFromWithReference(_from, _to, _value, _reference, _sender, smbl);
        return success;
    }

    interface IChronoBankPlatform {
        function proxyTransferFromWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender, string memory _smbl) external returns (bool);
    }
}",42.7389554977417,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public chronoBankPlatform;
    address[] public authorizedAddresses;
    string public smbl;

    modifier onlyAccess() {
        bool allowed = false;
        for (uint i = 0; i < authorizedAddresses.length; i++) {
            if (msg.sender == authorizedAddresses[i]) {
                allowed = true;
                break;
            }
        }
        require(allowed, ""Not authorized"");
        _;
    }

    constructor(address _chronoBankPlatform, string memory _smbl, address[] memory _authorizedAddresses) Ownable(msg.sender) {
        chronoBankPlatform = _chronoBankPlatform;
        smbl = _smbl;
        authorizedAddresses = _authorizedAddresses;
    }

    function transferWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender) public onlyAccess returns (bool) {
        bool success = IChronoBankPlatform(chronoBankPlatform).proxyTransferFromWithReference(_from, _to, _value, _reference, _sender, smbl);
        return success;
    }

    interface IChronoBankPlatform {
        function proxyTransferFromWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender, string memory _smbl) external returns (bool);
    }
}"
3148,Finalize the auction - sets the final XCH token price and changes the auction stage after no bids are allowed anymore .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function transfer(address to, uint256 value) external returns (bool);
    function burn(uint256 amount) external;
}

abstract contract AuctionContract is Ownable {
    using SafeMath for uint256;

    enum Stages { NotStarted, AuctionStarted, AuctionEnded, AuctionCanceled }

    TokenInterface public token;
    address public walletAddress;
    uint256 public minPrice;
    uint256 public numTokensAuctioned;
    uint256 public softCap;
    uint256 public receivedWei;
    uint256 public endTime;
    uint256 public finalPrice;
    uint256 public tokenMultiplier;
    Stages public stage;

    event AuctionEnded(uint256 indexed finalPrice);
    event AuctionCanceled();

    constructor(address _token, address _walletAddress, uint256 _minPrice, uint256 _numTokensAuctioned, uint256 _softCap, uint256 _tokenMultiplier) {
        token = TokenInterface(_token);
        walletAddress = _walletAddress;
        minPrice = _minPrice;
        numTokensAuctioned = _numTokensAuctioned;
        softCap = _softCap;
        tokenMultiplier = _tokenMultiplier;
        stage = Stages.NotStarted;
    }

    function price() public view returns (uint256) {
        // Implement the logic to return the current price if needed
        return 0; // Placeholder, replace with actual implementation
    }

    function missingFundsToEndAuction() public view returns (uint256) {
        uint256 requiredWei = softCap;
        uint256 collectedWei = receivedWei;
        if (collectedWei >= requiredWei) {
            return 0;
        } else {
            return requiredWei - collectedWei;
        }
    }

    function finalizeAuction() public atStage(Stages.AuctionStarted) {
        require(price() == minPrice);
        endTime = block.timestamp;
        if (receivedWei < softCap) {
            token.transfer(walletAddress, numTokensAuctioned);
            stage = Stages.AuctionCanceled;
            emit AuctionCanceled();
            return;
        }
        walletAddress.transfer(receivedWei);
        uint256 missingFunds = missingFundsToEndAuction();
        if (missingFunds > 0) {
            uint256 soldTokens = tokenMultiplier.mul(receivedWei).div(price());
            uint256 burnTokens = numTokensAuctioned.sub(soldTokens);
            token.burn(burnTokens);
            numTokensAuctioned -= burnTokens;
        }
        finalPrice = tokenMultiplier.mul(receivedWei).div(numTokensAuctioned);
        stage = Stages.AuctionEnded;
        emit AuctionEnded(finalPrice);
        assert(finalPrice > 0);
    }
}",finalizeAuction,"[{'function': 'finalizeAuction', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""AuctionStarted""}}, {""type"": ""stringLiteral"", ""value"": ""Auction not started""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""price""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect price""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""endTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""receivedWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""softCap""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""walletAddress""}, {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""AuctionCanceled""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionCanceled""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""walletAddress""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receivedWei""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""missingFunds"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""softCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""receivedWei""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""missingFunds""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""soldTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""receivedWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""price""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""burnTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}, ""right"": {""type"": ""Identifier"", ""name"": ""soldTokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""burnTokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}, ""right"": {""type"": ""Identifier"", ""name"": ""burnTokens""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalPrice""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}, ""right"": {""type"": ""Identifier"", ""name"": ""receivedWei""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""AuctionEnded""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionEnded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""finalPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.832806596127903,0.5559211101736299,"pragma solidity ^0.8.0;

contract Auction {
    enum Stage {AuctionStarted, AuctionEnded, AuctionCanceled}

    uint256 public endTime;
    Stage public stage;
    uint256 public finalPrice;
    uint256 public receivedWei;
    uint256 public softCap;
    uint256 public numTokensAuctioned;
    uint256 public price;
    address payable public walletAddress;
    IERC20 public token;


    event AuctionCanceled();
    event AuctionEnded(uint256 _finalPrice);

    constructor(uint256 _softCap, uint256 _numTokensAuctioned, uint256 _price, address payable _walletAddress, IERC20 _token) {
        softCap = _softCap;
        numTokensAuctioned = _numTokensAuctioned;
        price = _price;
        walletAddress = _walletAddress;
        token = _token;
        stage = Stage.AuctionStarted;
    }

    function finalizeAuction() public {
        require(stage == Stage.AuctionStarted, ""Auction not started"");
        require(msg.value == price, ""Incorrect price"");

        endTime = block.timestamp;

        if (receivedWei < softCap) {
            token.transfer(walletAddress, numTokensAuctioned);
            stage = Stage.AuctionCanceled;
            emit AuctionCanceled();
        } else {
            walletAddress.transfer(receivedWei);
            uint256 missingFunds = softCap - receivedWei;
            if (missingFunds > 0) {
                uint256 soldTokens = receivedWei / price;
                uint256 burnTokens = numTokensAuctioned - soldTokens;
                token.burn(burnTokens);
                numTokensAuctioned -= burnTokens;
            }
            finalPrice = numTokensAuctioned / receivedWei;
            stage = Stage.AuctionEnded;
            emit AuctionEnded(finalPrice);
            assert(finalPrice > 0);
        }
    }

    receive() external payable {
        receivedWei += msg.value;
    }

    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
        function burn(uint256 amount) external;
    }
}",44.26564121246338,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    enum Stage {AuctionStarted, AuctionEnded, AuctionCanceled}

    uint256 public endTime;
    Stage public stage;
    uint256 public finalPrice;
    uint256 public receivedWei;
    uint256 public softCap;
    uint256 public numTokensAuctioned;
    uint256 public price;
    address payable public walletAddress;
    IERC20 public token;

    event AuctionCanceled();
    event AuctionEnded(uint256 _finalPrice);

    constructor(uint256 _softCap, uint256 _numTokensAuctioned, uint256 _price, address payable _walletAddress, IERC20 _token) Ownable(msg.sender) {
        softCap = _softCap;
        numTokensAuctioned = _numTokensAuctioned;
        price = _price;
        walletAddress = _walletAddress;
        token = _token;
        stage = Stage.AuctionStarted;
    }

    function finalizeAuction() public {
        require(stage == Stage.AuctionStarted, ""Auction not started"");
        require(msg.value == price, ""Incorrect price"");

        endTime = block.timestamp;

        if (receivedWei < softCap) {
            token.transfer(walletAddress, numTokensAuctioned);
            stage = Stage.AuctionCanceled;
            emit AuctionCanceled();
        } else {
            walletAddress.transfer(receivedWei);
            uint256 missingFunds = softCap - receivedWei;
            if (missingFunds > 0) {
                uint256 soldTokens = receivedWei / price;
                uint256 burnTokens = numTokensAuctioned - soldTokens;
                token.burn(burnTokens);
                numTokensAuctioned -= burnTokens;
            }
            finalPrice = numTokensAuctioned / receivedWei;
            stage = Stage.AuctionEnded;
            emit AuctionEnded(finalPrice);
            assert(finalPrice > 0);
        }
    }

    receive() external payable {
        receivedWei += msg.value;
    }

    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
        function burn(uint256 amount) external;
    }
}"
1735,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint earliestPayTime;
        uint securityGuardDelay;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}",pose,"[{'function': 'pose', 'complexity': 6}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_delay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid payment ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""payment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}, ""right"": {""type"": ""Identifier"", ""name"": ""maxSecurityGuardDelay""}}, {""type"": ""stringLiteral"", ""value"": ""Maximum delay exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""paid""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Payment already paid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""canceled""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Payment canceled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""earliestPayTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.7512581307307321,0.08900562874899,"pragma solidity ^0.8.0;

contract PaymentContract {
    struct Payment {
        uint256 securityGuardDelay;
        uint256 earliestPayTime;
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;
    uint256 public maxSecurityGuardDelay;

    function pose(uint256 _idPayment, uint256 _delay) public {
        require(_idPayment < authorizedPayments.length, ""Invalid payment ID"");
        Payment storage payment = authorizedPayments[_idPayment];
        require(payment.securityGuardDelay + _delay <= maxSecurityGuardDelay, ""Maximum delay exceeded"");
        require(!payment.paid, ""Payment already paid"");
        require(!payment.canceled, ""Payment canceled"");
        payment.securityGuardDelay += _delay;
        payment.earliestPayTime += _delay;
    }
}",41.95063924789429,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentContract is Ownable {
    struct Payment {
        uint256 securityGuardDelay;
        uint256 earliestPayTime;
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;
    uint256 public maxSecurityGuardDelay;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        maxSecurityGuardDelay = 1; // Set to 1 (never 0)
        authorizedPayments = [Payment({securityGuardDelay: 0, earliestPayTime: 0, paid: false, canceled: false})];
    }

    function pose(uint256 _idPayment, uint256 _delay) public {
        require(_idPayment < authorizedPayments.length, ""Invalid payment ID"");
        Payment storage payment = authorizedPayments[_idPayment];
        require(payment.securityGuardDelay + _delay <= maxSecurityGuardDelay, ""Maximum delay exceeded"");
        require(!payment.paid, ""Payment already paid"");
        require(!payment.canceled, ""Payment canceled"");
        payment.securityGuardDelay += _delay;
        payment.earliestPayTime += _delay;
    }
}"
170,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent, ""Time must be later than last update"");
        require(timeSent < (block.timestamp + ORACLE_FUTURE_LIMIT), ""Time must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}",updatePrices,"[{'function': 'updatePrices', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newEthPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newHavvenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""ORACLE_FUTURE_LIMIT""}}}}, {""type"": ""stringLiteral"", ""value"": ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newEthPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newHavvenPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PricesUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOracle"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.9046476033515156,0.6202993606065402,"pragma solidity ^0.8.0;

contract PriceOracle {

    uint256 public usdToEthPrice;
    uint256 public usdToHavPrice;
    uint256 public lastPriceUpdateTime;
    uint256 constant ORACLE_FUTURE_LIMIT = 1 hours; //Example value, adjust as needed

    modifier onlyOracle() {
        // Add logic here to restrict access to only the designated oracle
        _;
    }

    event PricesUpdated(uint256 ethPrice, uint256 havvenPrice, uint256 timestamp);

    function updatePrices(uint256 newEthPrice, uint256 newHavvenPrice, uint256 timeSent)
        external
        onlyOracle
    {
        require(lastPriceUpdateTime < timeSent && timeSent < block.timestamp + ORACLE_FUTURE_LIMIT,
            ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");

        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;

        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}",42.9560112953186,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceOracle is Ownable {
    uint256 public usdToEthPrice;
    uint256 public usdToHavPrice;
    uint256 public lastPriceUpdateTime;
    uint256 constant ORACLE_FUTURE_LIMIT = 1 hours; //Example value, adjust as needed

    modifier onlyOracle() {
        // Add logic here to restrict access to only the designated oracle
        _;
    }

    event PricesUpdated(uint256 ethPrice, uint256 havvenPrice, uint256 timestamp);

    constructor() Ownable(msg.sender) {
        usdToEthPrice = 1; // Set to 1 (never 0)
        usdToHavPrice = 1; // Set to 1 (never 0)
        lastPriceUpdateTime = block.timestamp; // Initialize with the current timestamp
    }

    function updatePrices(uint256 newEthPrice, uint256 newHavvenPrice, uint256 timeSent)
        external
        onlyOracle
    {
        require(lastPriceUpdateTime < timeSent && timeSent < block.timestamp + ORACLE_FUTURE_LIMIT,
            ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");

        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;

        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}"
5043,This function burns all B2BK tokens on the address that caused this function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed user, uint256 amount);

    function burn() external isFinalized {
        uint256 _balance = balanceOf[msg.sender];
        assert(_balance > 0);
        totalSupply = totalSupply.sub(_balance);
        balanceOf[msg.sender] = 0;
        emit Burn(msg.sender, _balance);
    }
}",burn,"[{'function': 'burn', 'complexity': 1}, {'function': 'sub', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Balance is zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_balance""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.9631830746655144,0.7181605923347949,"pragma solidity ^0.8.0;

contract MyToken {
    using SafeMath for uint256;

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    event Burn(address indexed burner, uint256 amount);

    function burn() public {
        uint256 _balance = balanceOf[msg.sender];
        require(_balance > 0, ""Balance is zero"");
        totalSupply = totalSupply.sub(_balance);
        balanceOf[msg.sender] = 0;
        emit Burn(msg.sender, _balance);
    }
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}",42.19320583343506,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply = 1000000000000000000;
    mapping(address => uint256) public balanceOf;
    event Burn(address indexed burner, uint256 amount);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        balanceOf[owner()] = totalSupply;
    }

    function burn() public {
        uint256 _balance = balanceOf[msg.sender];
        require(_balance > 0, ""Balance is zero"");
        totalSupply = totalSupply.sub(_balance);
        balanceOf[msg.sender] = 0;
        emit Burn(msg.sender, _balance);
    }
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }
}"
3040,This function returns the signature of configure function,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getInitFunction() public pure returns (bytes4) {
        return 0x0;
    }
}",getInitFunction,"[{'function': 'getInitFunction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getInitFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""init()""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",5.0,0.7882009414442889,0.473968384351404,"pragma solidity ^0.8.0;

contract GetInitFunction {

    function getInitFunction() public pure returns (bytes4) {
        return bytes4(keccak256(""init()""));
    }
}",40.9388427734375,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract GetInitFunction is Ownable {
    uint256 public constant _INIT_VALUE = 1;
    address public constant _ADDRESS_VALUE = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant _BOOL_VALUE = true;
    string public constant _STRING_VALUE = 'initialized';
    bytes32 public constant _BYTES32_VALUE = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        uint256[] memory initArray = new uint256[](1);
        initArray[0] = _INIT_VALUE;

        address[] memory initAddresses = new address[](2);
        initAddresses[0] = _ADDRESS_VALUE;
        initAddresses[1] = 0x2222222222222222222222222222222222222222; // Replace with actual address

        bool[] memory initBools = new bool[](1);
        initBools[0] = _BOOL_VALUE;

        string[] memory initStrings = new string[](2);
        initStrings[0] = _STRING_VALUE;
        initStrings[1] = 'another initialized value';

        bytes32[] memory initBytes32s = new bytes32[](3);
        initBytes32s[0] = _BYTES32_VALUE;
        initBytes32s[1] = bytes32('another bytes32 value');
        initBytes32s[2] = 0x3333333333333333333333333333333333333333; // Replace with actual address

        // Initialize parent contracts
        super._initArray(initArray);
        super._initAddresses(initAddresses);
        super._initBools(initBools);
        super._initStrings(initStrings);
        super._initBytes32s(initBytes32s);
    }

    function getInitFunction() public pure returns (bytes4) {
        return bytes4(keccak256(""init()""));
    }
}"
4025,Converts WT0 to CarbonUSD for the user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ConversionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;
    bool public paused = false;

    event ConvertedToCUSD(address indexed user, uint256 amount);

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _burn(address account, uint256 amount) internal {
        require(balances[account] >= amount, ""Burn amount exceeds balance"");
        balances[account] = balances[account].sub(amount);
    }

    function _mintCUSD(address account, uint256 amount) internal {
        balances[account] = balances[account].add(amount);
    }

    function convertWT(uint256 _amount) public whenNotPaused requiresPermission {
        require(balanceOf(msg.sender) >= _amount, ""Conversion amount should be less than balance"");
        _burn(msg.sender, _amount);
        _mintCUSD(msg.sender, _amount);
        emit ConvertedToCUSD(msg.sender, _amount);
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}",convertWT,"[{'function': 'convertWT', 'complexity': 2}, {'function': '_burn', 'complexity': 0}, {'function': '_mintCUSD', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""convertWT"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient WT balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mintCUSD""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ConvertedToCUSD""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""requiresPermission"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9268665370461938,0.6646047884547065,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract YourContract {
    using SafeMath for uint256;

    // ... other contract code ...

    event ConvertedToCUSD(address indexed sender, uint256 amount);

    modifier requiresPermission() {
        // Add your permission logic here
        _;
    }

    modifier whenNotPaused() {
        // Add your pause logic here
        _;
    }


    function convertWT(uint256 _amount) public requiresPermission whenNotPaused {
        require(balanceOf[msg.sender] >= _amount, ""Insufficient WT balance"");
        _burn(msg.sender, _amount);
        _mintCUSD(msg.sender, _amount);
        emit ConvertedToCUSD(msg.sender, _amount);
    }

    // ... other contract functions, including _burn and _mintCUSD ...

    mapping(address => uint256) public balanceOf;

    function _burn(address account, uint256 amount) internal {
        balanceOf[account] = balanceOf[account].sub(amount);
    }

    function _mintCUSD(address account, uint256 amount) internal {
        // Add your CUSD minting logic here.  This likely involves another contract.
        // Example:  icusd.mint(account, amount);
    }
}",42.8422167301178,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    // ... other contract code ...

    event ConvertedToCUSD(address indexed sender, uint256 amount);

    modifier requiresPermission() {
        // Add your permission logic here
        _;
    }

    modifier whenNotPaused() {
        // Add your pause logic here
        _;
    }

    function convertWT(uint256 _amount) public requiresPermission whenNotPaused {
        require(balanceOf[msg.sender] >= _amount, ""Insufficient WT balance"");
        _burn(msg.sender, _amount);
        _mintCUSD(msg.sender, _amount);
        emit ConvertedToCUSD(msg.sender, _amount);
    }

    // ... other contract functions, including _burn and _mintCUSD ...

    mapping(address => uint256) public balanceOf;

    function _burn(address account, uint256 amount) internal {
        balanceOf[account] = balanceOf[account].sub(amount);
    }

    function _mintCUSD(address account, uint256 amount) internal {
        // Add your CUSD minting logic here.  This likely involves another contract.
        // Example:  icusd.mint(account, amount);
    }

    constructor() Ownable(msg.sender) {
        balanceOf[msg.sender] = 1000; // Initialize the balance of the owner to 1
    }
}"
281,Announces intent to cancel tokens using ` slowCancel `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Offer {
        address maker;
        uint256 availableAmount;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint256) public announcedCancellations;
    uint256 public cancelAnnounceDelay;

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint256 canCancelAt);

    function announceCancel(bytes32 _offerHash) external {
        Offer memory offer = offers[_offerHash];
        require(offer.maker == msg.sender, ""Invalid sender"");
        require(offer.availableAmount > 0, ""Offer already cancelled"");
        uint256 canCancelAt = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = canCancelAt;
        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);
    }
}",announceCancel,"[{'function': 'announceCancel', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_offerHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Offer""}, ""name"": ""offer"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_offerHash""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""maker""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""availableAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Offer already cancelled""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""cancellationTimestamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""cancelAnnounceDelay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""announcedCancellations""}, ""index"": {""type"": ""Identifier"", ""name"": ""_offerHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""cancellationTimestamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CancelAnnounce""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""cancellationTimestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9047904890230202,0.6298263750365581,"pragma solidity ^0.8.0;

contract OfferContract {

    uint256 public cancelAnnounceDelay;
    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint256) public announcedCancellations;

    struct Offer {
        address maker;
        uint256 availableAmount;
        // ... other offer details ...
    }

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint256 cancellationTimestamp);

    function announceCancel(bytes32 _offerHash) public {
        Offer storage offer = offers[_offerHash];
        require(msg.sender == offer.maker, ""Invalid sender"");
        require(offer.availableAmount > 0, ""Offer already cancelled"");
        uint256 cancellationTimestamp = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = cancellationTimestamp;
        emit CancelAnnounce(msg.sender, _offerHash, cancellationTimestamp);
    }
}",42.12832403182984,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OfferContract is Ownable {
    uint256 public cancelAnnounceDelay;
    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint256) public announcedCancellations;

    struct Offer {
        address maker;
        uint256 availableAmount;
        // ... other offer details ...
    }

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint256 cancellationTimestamp);

    constructor() Ownable(msg.sender) {
        cancelAnnounceDelay = 1;
        offers[_offerHash] = Offer({maker: address(0x111), availableAmount: 1});
        announcedCancellations[_offerHash] = block.timestamp + cancelAnnounceDelay;
    }

    function announceCancel(bytes32 _offerHash) public {
        Offer storage offer = offers[_offerHash];
        require(msg.sender == offer.maker, ""Invalid sender"");
        require(offer.availableAmount > 0, ""Offer already cancelled"");
        uint256 cancellationTimestamp = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = cancellationTimestamp;
        emit CancelAnnounce(msg.sender, _offerHash, cancellationTimestamp);
    }
}"
5915,This is public rather than external so we can call super.unpause without using an expensive CALL .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool private paused = false;

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0));
        require(siringAuction != address(0));
        require(geneScience != address(0));
        require(lottery != address(0));
        require(variation != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}",unpause,"[{'function': 'unpause', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""saleAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""saleAuction address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""siringAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""siringAuction address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""geneScience""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""geneScience address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""lottery""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""lottery address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""variation""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""variation address not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""newContractAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""newContractAddress must be address(0)""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_unpause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCEO"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.9525930370692252,0.5652571624192554,"pragma solidity ^0.8.0;

contract MyContract is Pausable {

    address public saleAuction;
    address public siringAuction;
    address public geneScience;
    address public lottery;
    address public variation;
    address public newContractAddress;

    modifier onlyCEO() {
        // Add CEO role check logic here.  Replace with your actual CEO determination.
        require(msg.sender == 0x123, ""Only CEO can call this function"");
        _;
    }

    modifier whenPaused() {
        require(paused(), ""Contract is not paused"");
        _;
    }

    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0), ""saleAuction address not set"");
        require(siringAuction != address(0), ""siringAuction address not set"");
        require(geneScience != address(0), ""geneScience address not set"");
        require(lottery != address(0), ""lottery address not set"");
        require(variation != address(0), ""variation address not set"");
        require(newContractAddress == address(0), ""newContractAddress must be address(0)"");
        _unpause();
    }
}",42.557833433151245,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Pausable, Ownable {
    address public saleAuction = 0x111;
    address public siringAuction = 0x222;
    address public geneScience = 0x333;
    address public lottery = 0x444;
    address public variation = 0x555;
    address public newContractAddress = address(0);

    modifier onlyCEO() {
        // Add CEO role check logic here.  Replace with your actual CEO determination.
        require(msg.sender == 0x123, ""Only CEO can call this function"");
        _;
    }

    modifier whenPaused() {
        require(paused(), ""Contract is not paused"");
        _;
    }

    constructor() Ownable(msg.sender) {
        saleAuction = 0x111;
        siringAuction = 0x222;
        geneScience = 0x333;
        lottery = 0x444;
        variation = 0x555;
        newContractAddress = address(0);
    }

    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0), ""saleAuction address not set"");
        require(siringAuction != address(0), ""siringAuction address not set"");
        require(geneScience != address(0), ""geneScience address not set"");
        require(lottery != address(0), ""lottery address not set"");
        require(variation != address(0), ""variation address not set"");
        require(newContractAddress == address(0), ""newContractAddress must be address(0)"");
        _unpause();
    }
}"
1091,"owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IContract {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    event EtherSent(address indexed to, uint256 value);

    struct State {
        bool succeeded;
    }

    mapping(bytes32 => bool) private manyOwners;
    mapping(address => State) public states;

    modifier validAddress(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bool allowed = manyOwners[txHash];
        require(allowed, ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State memory state) {
        require(state.succeeded, ""Function cannot be called in current state"");
        _;
    }

    function sendEther(address to, uint256 value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(states[msg.sender]) {
        require(value > 0 && address(this).balance >= value, ""Insufficient balance"");
        (bool success,) = to.call{value: value}("""");
        require(success, ""Transfer failed"");
        emit EtherSent(to, value);
    }
}",sendEther,"[{'function': 'sendEther', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendEther"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""EtherSent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlymanyowners"", ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}], ""names"": []}]}, {""type"": ""ModifierInvocation"", ""name"": ""requiresState"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""SUCCEEDED""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",49.0,0.9041481240955518,0.5264530046523374,"pragma solidity ^0.8.0;

contract MyContract {

    enum State {
        PENDING,
        SUCCEEDED,
        FAILED
    }

    State public currentState;

    modifier validAddress(address _to) {
        require(_to != address(0), ""Invalid address"");
        _;
    }

    modifier onlymanyowners(bytes32 _hash) {
        //Implementation for multi-owner approval using _hash
        _;
    }

    modifier requiresState(State _state) {
        require(currentState == _state, ""Incorrect contract state"");
        _;
    }

    event EtherSent(address indexed _to, uint _value);

    function sendEther(address to, uint value)
        public
        validAddress(to)
        onlymanyowners(keccak256(abi.encodePacked(to, value)))
        requiresState(State.SUCCEEDED)
    {
        require(value > 0, ""Value must be greater than zero"");
        require(address(this).balance >= value, ""Insufficient balance"");
        payable(to).transfer(value);
        emit EtherSent(to, value);
    }
}",42.40985107421875,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {

    enum State {
        PENDING,
        SUCCEEDED,
        FAILED
    }

    State public currentState = State.PENDING;

    modifier validAddress(address _to) {
        require(_to != address(0), ""Invalid address"");
        _;
    }

    modifier onlymanyowners(bytes32 _hash) {
        //Implementation for multi-owner approval using _hash
        _;
    }

    modifier requiresState(State _state) {
        require(currentState == _state, ""Incorrect contract state"");
        _;
    }

    event EtherSent(address indexed _to, uint _value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        currentState = State.PENDING;
    }

    function sendEther(address to, uint value)
        public
        validAddress(to)
        onlymanyowners(keccak256(abi.encodePacked(to, value)))
        requiresState(State.SUCCEEDED)
    {
        require(value > 0, ""Value must be greater than zero"");
        require(address(this).balance >= value, ""Insufficient balance"");
        payable(to).transfer(value);
        emit EtherSent(to, value);
    }
}"
2215,Notifies the controller about an approval allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovalWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_amount.add(1).sub(1) == _amount, ""SafeMath: addition overflow"");
        require(_owner != address(0), ""_owner is zero address"");
        require(_spender != address(0), ""_spender is zero address"");

        emit Approval(_owner, _spender, _amount);

        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8451318434801054,0.6194742586931967,"pragma solidity ^0.8.0;

contract ERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Approval(address indexed owner, address indexed spender, uint256 amount);

    function approve(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_owner != address(0), ""ERC20: approve from the zero address"");
        require(_spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
        return true;
    }
}",41.85511994361877,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Approval(address indexed owner, address indexed spender, uint256 amount);

    function approve(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_owner != address(0), ""ERC20: approve from the zero address"");
        require(_spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
        return true;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ERC20 {
    address public owner;
    uint256 public constant INITIAL_SUPPLY = 1;

    constructor() {
        owner = msg.sender;
        _balances[msg.sender] = INITIAL_SUPUPPLY;
    }
}"
5767,Withdraws tokens other than DGZ to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function anyTokenWithdrawal(address _address, uint _amount) public onlyOwner {
        require(_address != address(tokenReward), ""Cannot withdraw from the reward token."");
        StandardToken token = StandardToken(_address);
        token.transfer(beneficiary, _amount);
        TokensWithdrawn(beneficiary, _address, _amount);
    }
}",anyTokenWithdrawal,"[{'function': 'transfer', 'complexity': 0}, {'function': 'anyTokenWithdrawal', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""anyTokenWithdrawal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_address""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenReward""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot withdraw from tokenReward contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""StandardToken""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""StandardToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensWithdraw""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.8404624706779038,0.5674994299774138,"pragma solidity ^0.8.0;

interface StandardToken {
    function transfer(address to, uint256 value) external returns (bool);
}

contract MyContract {
    address public tokenReward;

    event TokensWithdraw(address beneficiary, address tokenAddress, uint256 amount);

    constructor(address _tokenReward) {
        tokenReward = _tokenReward;
    }

    function anyTokenWithdrawal(address _address, uint256 _amount) public {
        require(_address != tokenReward, ""Cannot withdraw from tokenReward contract"");
        StandardToken token = StandardToken(_address);
        token.transfer(msg.sender, _amount);
        emit TokensWithdraw(msg.sender, _address, _amount);
    }
}",41.90142750740051,"pragma solidity ^0.8.0;

interface StandardToken {
    function transfer(address to, uint256 value) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public tokenReward;

    event TokensWithdraw(address beneficiary, address tokenAddress, uint256 amount);

    constructor(address _tokenReward) Ownable(msg.sender) {
        tokenReward = _tokenReward;
    }

    function anyTokenWithdrawal(address _address, uint256 _amount) public {
        require(_address != tokenReward, ""Cannot withdraw from tokenReward contract"");
        StandardToken token = StandardToken(_address);
        token.transfer(msg.sender, _amount);
        emit TokensWithdraw(msg.sender, _address, _amount);
    }
}"
3863,Claim token after token sale based on stake .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EthealTokenWrapper {
    using SafeMath for uint256;

    address public ethealController;
    mapping(address => uint256) public stakes;
    uint256 public rate;
    uint256 public tokenBalance;
    bool public paused = false;

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokens);

    modifier afterSaleSuccess() {
        // Assuming some condition for sale success is checked here.
        require(true, ""Sale must have succeeded"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {
        uint256 stake = stakes[_beneficiary];
        require(stake > 0);
        stakes[_beneficiary] = 0;
        uint256 tokens = stake.mul(rate);
        tokenBalance = tokenBalance.sub(tokens);
        ethealController.call(abi.encodeWithSignature(""addHodlerStake(address,uint256)"", _beneficiary, tokens.mul(2)));
        require(ethealController.call(abi.encodeWithSignature(""ethealToken()"")).delegatecall(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _beneficiary, tokens)));
        emit TokenClaimed(msg.sender, _beneficiary, stake, tokens);
    }
}",claimTokenFor,"[{'function': 'claimTokenFor', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokenFor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""stake"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""stake""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary has no stake""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensToClaim"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stake""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToClaim""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokensToClaim""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ethealController""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stake""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ethealToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""tokensToClaim""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenClaimed""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""stake""}, {""type"": ""Identifier"", ""name"": ""tokensToClaim""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""afterSaleSuccess"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",35.0,0.8222375929599868,0.4039721855460167,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract YourContract {
    using SafeMath for uint256;

    // ... other contract variables and modifiers ...

    uint256 public tokenBalance;
    mapping(address => uint256) public stakes;
    address public ethealController;
    IERC20 public ethealToken; // Assuming ERC20 token

    modifier afterSaleSuccess() {
        // ... logic to check if sale was successful ...
        _;
    }

    modifier whenNotPaused() {
        // ... logic to check if contract is not paused ...
        _;
    }

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokensClaimed);

    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {
        uint256 stake = stakes[_beneficiary];
        require(stake > 0, ""Beneficiary has no stake"");

        uint256 tokensToClaim = stake.mul(rate); // Assuming 'rate' is defined elsewhere
        require(tokenBalance >= tokensToClaim, ""Insufficient token balance"");

        stakes[_beneficiary] = 0;
        tokenBalance = tokenBalance.sub(tokensToClaim);
        ethealController.transfer(stake.mul(2)); // Assuming transfer function exists

        ethealToken.transfer(_beneficiary, tokensToClaim);

        emit TokenClaimed(msg.sender, _beneficiary, stake, tokensToClaim);
    }

    // ... rest of the contract ...
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}",43.20737600326538,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    // Fixed, safe values
    address public constant ETHEREAL_CONTROLLER = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant DEFAULT_BENEFICIARY = 0x2222222222222222222222222222222222222222; // Replace with actual address

    // Non-corner-case values
    uint256 public tokenBalance = 1;
    mapping(address => uint256) public stakes = {DEFAULT_BENEFICIARY: 1};
    address public ethealController = ETHEREAL_CONTROLLER;
    IERC20 public ethealToken; // Assuming ERC20 token

    constructor() Ownable(msg.sender) {
        // Initialize parent contract
        super();
    }

    modifier afterSaleSuccess() {
        require(true, ""Sale was not successful"");
        _;
    }

    modifier whenNotPaused() {
        require(!isPaused(), ""Contract is paused"");
        _;
    }

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokensClaimed);

    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {
        uint256 stake = stakes[_beneficiary];
        require(stake > 0, ""Beneficiary has no stake"");

        uint256 tokensToClaim = stake.mul(rate); // Assuming 'rate' is defined elsewhere
        require(tokenBalance >= tokensToClaim, ""Insufficient token balance"");

        stakes[_beneficiary] = 0;
        tokenBalance = tokenBalance.sub(tokensToClaim);
        ethealController.transfer(stake.mul(2)); // Assuming transfer function exists

        ethealToken.transfer(_beneficiary, tokensToClaim);

        emit TokenClaimed(msg.sender, _beneficiary, stake, tokensToClaim);
    }

    // ... rest of the contract ...
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}"
6728,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event ForceTransfer(address indexed sender, address indexed from, address indexed to, uint256 value, bool verified, bytes log);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) public onlyController {
        require(_to != address(0));
        require(_value <= balances[_from]);
        bool verified = _updateTransfer(_from, _to, _value, _data);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit ForceTransfer(msg.sender, _from, _to, _value, verified, _log);
        emit Transfer(_from, _to, _value);
    }

    function _updateTransfer(address _from, address _to, uint256 _value, bytes memory _data) internal returns (bool) {
        // Implement the logic for updating transfer here
        return true; // Placeholder
    }
}",forceTransfer,"[{'function': 'forceTransfer', 'complexity': 2}, {'function': '_updateTransfer', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""forceTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_log"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_updateTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ForceTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""BooleanLiteral"", ""value"": True}, {""type"": ""Identifier"", ""name"": ""_log""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.8269288962310796,0.6098530435755314,"pragma solidity ^0.8.0;

contract MyToken {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ForceTransfer(address indexed initiator, address indexed from, address indexed to, uint256 value, bool verified, string log);

    function forceTransfer(address _from, address _to, uint256 _value, bytes calldata _data, string memory _log) public {
        require(_to != address(0), ""ERC20: transfer to the zero address"");
        require(balances[_from] >= _value, ""ERC20: transfer amount exceeds balance"");

        _updateTransfer(_from, _to, _value, _data);
        balances[_from] -= _value;
        balances[_to] += _value;

        emit ForceTransfer(msg.sender, _from, _to, _value, true, _log);
        emit Transfer(_from, _to, _value);
    }

    function _updateTransfer(address _from, address _to, uint256 _value, bytes memory _data) internal virtual {
        //Additional logic can be added here
    }
}",42.484195947647095,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ForceTransfer(address indexed initiator, address indexed from, address indexed to, uint256 value, bool verified, string log);

    constructor() Ownable(msg.sender) {
        balances[owner()] = 1; // Initialize the balance of the owner to 1
    }

    function forceTransfer(address _from, address _to, uint256 _value, bytes calldata _data, string memory _log) public {
        require(_to != address(0), ""ERC20: transfer to the zero address"");
        require(balances[_from] >= _value, ""ERC20: transfer amount exceeds balance"");

        _updateTransfer(_from, _to, _value, _data);
        balances[_from] -= _value;
        balances[_to] += _value;

        emit ForceTransfer(msg.sender, _from, _to, _value, true, _log);
        emit Transfer(_from, _to, _value);
    }

    function _updateTransfer(address _from, address _to, uint256 _value, bytes memory _data) internal virtual {
        //Additional logic can be added here
    }
}"
691,Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Validator {
    using SafeMath for uint256;

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        require(validator != address(0), ""Invalid validator address"");
        require(attributeTypeID > 0, ""Invalid attribute type ID"");
        return true;
    }
}",canIssueAttributeType,"[{'function': 'canIssueAttributeType', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""canIssueAttributeType"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validatorPermissions""}, ""index"": {""type"": ""Identifier"", ""name"": ""validator""}}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",15.0,0.7022344948393706,0.2169763121601481,"pragma solidity ^0.8.0;

contract AttributeIssuer {

    mapping(address => mapping(uint256 => bool)) public validatorPermissions;

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        return validatorPermissions[validator][attributeTypeID];
    }
}",41.234668254852295,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttributeIssuer is Ownable {
    mapping(address => mapping(uint256 => bool)) public validatorPermissions;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
876,Initialize Finance app for Vault at ` _vault ` with period length of ` @ transformTime ( _periodDuration ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface Vault {
    function isContract() external view returns (bool);
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool inactive;
    }

    Vault public vault;
    Settings public settings;
    mapping(uint => Payment) public payments;
    uint public paymentsNextIndex;
    uint public transactionsNextIndex;

    event Initialized();

    error VaultNotContract(string message);
    error InitPeriodTooShort(string message);

    constructor() {
        settings.periodDuration = 0;
    }

    function initialize(Vault _vault, uint64 _periodDuration) external onlyOwner {
        require(_vault.isContract(), ""ERROR_VAULT_NOT_CONTRACT"");
        vault = _vault;
        if (_periodDuration < 1 days) revert InitPeriodTooShort(""ERROR_INIT_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        payments[0].inactive = true;
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;
        _newPeriod(getTimestamp64());
    }

    function getTimestamp64() internal view returns (uint64) {
        return uint64(block.timestamp);
    }

    struct Settings {
        uint64 periodDuration;
    }
}",initialize,"[{'function': 'initialize', 'complexity': 4}, {'function': 'isContract', 'complexity': 0}, {'function': 'getTimestamp64', 'complexity': 0}, {'function': '_newPeriod', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_vault"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isInitialized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Contract already initialized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_vault""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid vault address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""86400"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Period duration must be at least 1 day""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""vault""}, ""right"": {""type"": ""Identifier"", ""name"": ""_vault""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payments""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Payment""}, ""arguments"": [{""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paymentsNextIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transactionsNextIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_newPeriod""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTimestamp64""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isInitialized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Initialized""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.8427993388872546,0.2882496876845664,"pragma solidity ^0.8.0;

contract MyContract {
    // ... other contract code ...

    struct Settings {
        uint64 periodDuration;
    }

    struct Payment {
        bool inactive;
        // ... other Payment struct members ...
    }

    Settings public settings;
    Payment[] public payments;
    uint256 public paymentsNextIndex;
    uint256 public transactionsNextIndex;
    address public vault;
    bool public isInitialized;

    event Initialized();

    function initialize(address _vault, uint64 _periodDuration) public {
        require(!isInitialized, ""Contract already initialized"");
        require(isContract(_vault), ""Invalid vault address"");
        require(_periodDuration >= 86400, ""Period duration must be at least 1 day"");

        vault = _vault;
        settings.periodDuration = _periodDuration;
        payments.push(Payment(true)); // Mark first payment as inactive
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;
        _newPeriod(getTimestamp64());
        isInitialized = true;
        emit Initialized();
    }

    function isContract(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }

    function getTimestamp64() internal view returns (uint64) {
        return uint64(block.timestamp);
    }

    function _newPeriod(uint64 _timestamp) internal {
        // ... _newPeriod function logic ...
    }

    // ... other contract code ...
}",43.19234681129456,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Settings {
        uint64 periodDuration;
    }

    struct Payment {
        bool inactive;
        // ... other Payment struct members ...
    }

    Settings public settings;
    Payment[] public payments;
    uint256 public paymentsNextIndex;
    uint256 public transactionsNextIndex;
    address public vault;
    bool public isInitialized;

    event Initialized();

    constructor(address _vault, uint64 _periodDuration) Ownable() {
        require(!isInitialized, ""Contract already initialized"");
        require(isContract(_vault), ""Invalid vault address"");
        require(_periodDuration >= 86400, ""Period duration must be at least 1 day"");

        vault = _vault;
        settings.periodDuration = _periodDuration;
        payments.push(Payment(true)); // Mark first payment as inactive
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;
        _newPeriod(getTimestamp64());
        isInitialized = true;
        emit Initialized();
    }

    function isContract(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }

    function getTimestamp64() internal view returns (uint64) {
        return uint64(block.timestamp);
    }

    function _newPeriod(uint64 _timestamp) internal {
        // ... _newPeriod function logic ...
    }

    // ... other contract code ...
}"
2491,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",enableTransfers,"[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableTransfers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9738926552368172,0.7611606003349892,"pragma solidity ^0.8.0;

contract MyContract {
    bool public transfersEnabled;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
        transfersEnabled = true;
    }

    function enableTransfers(bool _transfersEnabled) external onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",41.59635519981384,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool public transfersEnabled;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        transfersEnabled = true;
    }

    function enableTransfers(bool _transfersEnabled) external onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}"
1924,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    address private _crowdsaleAgent;

    modifier onlyCrowdsaleAgent() {
        require(_crowdsaleAgent == msg.sender, ""Only crowdsale agent can call this function"");
        _;
    }

    constructor(address crowdsaleAgent) {
        _crowdsaleAgent = crowdsaleAgent;
    }

    function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
}",mintToken,"[{'function': 'hasRole', 'complexity': 0}, {'function': 'mintToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCrowdsaleAgent"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyCrowdsaleAgent() {
        // Replace this with your actual role check mechanism
        require(hasRole(""CrowdsaleAgent"", msg.sender), ""Caller is not a CrowdsaleAgent"");
        _;
    }

    function hasRole(string memory role, address account) public view virtual returns (bool) {
        // Replace with your actual role check implementation
        return false; // Placeholder
    }


    function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
}",42.237101554870605,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply = 1000000000000000000; // Set to 1 (never 0)

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyCrowdsaleAgent() {
        require(hasRole(""CrowdsaleAgent"", msg.sender), ""Caller is not a CrowdsaleAgent"");
        _;
    }

    function hasRole(string memory role, address account) public view virtual returns (bool) {
        // Replace with your actual role check implementation
        return false; // Placeholder
    }

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        balanceOf[address(0x111)] = 1; // Set to fixed value
        balanceOf[address(0x222)] = 1; // Set to fixed value
        balanceOf[address(0x333)] = 1; // Set to fixed value
    }

    function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
}"
2485,"if there is an unresolvable problem , users can call to this function to get a refund .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256[]) public ownedTokens;
    uint256 public constant STARTING_PRICE = 1 ether; // Example value, adjust as needed

    modifier hasFinalized() {
        require(finalized, ""Function can only be called after the event has finalized"");
        _;
    }

    bool public finalized = true; // Set to false if there's an initialization phase or other conditions

    function emergencyWithdraw() external hasFinalized {
        uint256 balance = STARTING_PRICE.mul(ownedTokens[msg.sender].length);
        delete ownedTokens[msg.sender];
        msg.sender.transfer(balance);
    }
}",emergencyWithdraw,"[{'function': 'emergencyWithdraw', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""emergencyWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceToWithdraw"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""STARTING_PRICE""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownedTokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""length""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownedTokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balanceToWithdraw""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyFinalized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.92623374103473,0.1794742704535724,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public STARTING_PRICE = 10; //Example price, replace with actual value.
    mapping(address => uint256[]) public ownedTokens;
    mapping(address => bool) public hasFinalized;

    modifier onlyFinalized() {
        require(hasFinalized[msg.sender], ""Participation not finalized"");
        _;
    }

    function emergencyWithdraw() public onlyFinalized {
        uint256 balanceToWithdraw = STARTING_PRICE * ownedTokens[msg.sender].length;
        delete ownedTokens[msg.sender];
        payable(msg.sender).transfer(balanceToWithdraw);
    }
}",41.81237530708313,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public STARTING_PRICE = 10; //Example price, replace with actual value.
    mapping(address => uint256[]) public ownedTokens;
    mapping(address => bool) public hasFinalized;

    modifier onlyFinalized() {
        require(hasFinalized[msg.sender], ""Participation not finalized"");
        _;
    }

    function emergencyWithdraw() public onlyFinalized {
        uint256 balanceToWithdraw = STARTING_PRICE * ownedTokens[msg.sender].length;
        delete ownedTokens[msg.sender];
        payable(msg.sender).transfer(balanceToWithdraw);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        STARTING_PRICE = 10;
        // Example fixed address values:
        // address addr1 = 0x1111111111111111111111111111111111111111;
        // address addr2 = 0x2222222222222222222222222222222222222222;
        // address addr3 = 0x3333333333333333333333333333333333333333;
    }
}"
1164,Allows recovery addresses to trigger the recovery process for an Identity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentityRecovery {
    using SafeMath for uint256;

    struct RecoveryLog {
        uint timestamp;
        bytes32 membersHash;
    }

    struct AssociatedAddresses {
        address[] members;
    }

    struct Identity {
        AssociatedAddresses associatedAddresses;
    }

    mapping(uint => Identity) public identityDirectory;
    mapping(uint => RecoveryLog) public recoveryLogs;
    mapping(uint => address) public recoveryAddressChangeLogs;
    uint8 private constant RECOVERY_PERMISSION = 27;

    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp) public {
        require(_identityExists(ein), ""Identity does not exist."");
        require(_hasIdentity(newAssociatedAddress, false), ""New associated address is not a valid identity."");
        require(canRecover(ein), ""Cannot trigger recovery yet."");
        require(isSigned(newAssociatedAddress, keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), ""I authorize being added to this Identity via recovery."", ein, newAssociatedAddress, timestamp))), ""Permission denied."");
        require(canChangeRecoveryAddress(ein) || msg.sender == recoveryAddressChangeLogs[ein], ""Only the current or previously removed recovery address can trigger recovery."");

        Identity storage _identity = identityDirectory[ein];
        recoveryLogs[ein] = RecoveryLog(block.timestamp, keccak256(abi.encodePacked(_identity.associatedAddresses.members)));
        emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);
        resetIdentityData(_identity, msg.sender, false);
        addAssociatedAddress(ein, newAssociatedAddress);
    }

    function _identityExists(uint ein) internal view returns (bool) {
        return address(uint160(uint256(keccak256(abi.encodePacked(""identity"", ein)))) % 10**40) != address(0);
    }

    function _hasIdentity(address addr, bool isRecoveryAddress) internal view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function canRecover(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function isSigned(address signer, bytes32 hash) internal pure returns (bool) {
        require(signer != address(0), ""ECDSA: invalid signature"");
        return signer == ecrecover(hash, v, r, s);
    }

    function canChangeRecoveryAddress(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function resetIdentityData(Identity storage identity, address newOwner, bool isRecoveryAddress) internal {
        // Implementation omitted for brevity
    }

    function addAssociatedAddress(uint ein, address newAssociatedAddress) internal {
        // Implementation omitted for brevity
    }

    event RecoveryTriggered(address indexed initiator, uint indexed ein, address[] members, address newAssociatedAddress);
}",triggerRecovery,"[{'function': 'triggerRecovery', 'complexity': 0}, {'function': 'canTriggerRecovery', 'complexity': 0}, {'function': 'resetIdentityData', 'complexity': 0}, {'function': 'addAssociatedAddress', 'complexity': 0}]",2.0,{},121.0,0.3265599209274876,0.176769740777496,"pragma solidity ^0.8.0;

contract IdentityRecovery {

    // Define necessary structs and events here...

    function triggerRecovery(
        uint256 ein,
        address newAssociatedAddress,
        uint8 v,
        bytes32 r,
        bytes32 s,
        uint256 timestamp
    ) public {
        // 1. Checks if the recovery can be triggered for the given EIN.
        require(canTriggerRecovery(ein), ""Recovery cannot be triggered"");

        // 2. Retrieves the identity from identityDirectory using the EIN.
        // ...

        // 3. Determines whether the current recovery address or the recently removed recovery address is allowed to trigger the recovery.
        // ...

        // 4. Validates the ECDSA signature provided by the caller against a message that includes the newAssociatedAddress, timestamp, and other relevant data.
        // ...

        // 5. Records the recovery event in recoveryLogs.
        // ...

        // 6. Resets identity-related data using resetIdentityData function.
        // ...

        // 7. Adds the new associated address to the identity using addAssociatedAddress function.
        // ...

        emit RecoveryTriggered(msg.sender, ein, /* previous addresses */, newAssociatedAddress);
    }


    //Helper functions canTriggerRecovery, resetIdentityData, addAssociatedAddress should be defined here.  These are placeholders.
    function canTriggerRecovery(uint256 ein) internal view returns (bool) {
        return true; // Replace with actual logic
    }

    function resetIdentityData(uint256 ein) internal {
        // Replace with actual logic
    }

    function addAssociatedAddress(uint256 ein, address newAddress) internal {
        // Replace with actual logic
    }

    event RecoveryTriggered(address indexed sender, uint256 indexed ein, bytes previousAddresses, address indexed newAssociatedAddress);

    // ... other structs, mappings, and functions ...
}",43.46225357055664,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract IdentityRecovery is Ownable {
    // Define necessary structs and events here...

    uint256 public ein;
    address public newAssociatedAddress;
    uint8 public v;
    bytes32 public r;
    bytes32 public s;
    uint256 public timestamp;

    constructor() Ownable(msg.sender) {
        ein = 1; // Set to a fixed value
        newAssociatedAddress = address(0x1111111111111111111111111111111111111111); // Use a fixed address
        v = 1; // Set to a fixed value
        r = bytes32('init'); // Set to a fixed string value
        s = bytes32('init'); // Set to a fixed string value
        timestamp = block.timestamp; // Set to the current timestamp
    }

    function triggerRecovery(
        uint256 _ein,
        address _newAssociatedAddress,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        uint256 _timestamp
    ) public {
        require(canTriggerRecovery(_ein), ""Recovery cannot be triggered"");

        // 1. Retrieves the identity from identityDirectory using the EIN.
        // ...

        // 2. Determines whether the current recovery address or the recently removed recovery address is allowed to trigger the recovery.
        // ...

        // 3. Validates the ECDSA signature provided by the caller against a message that includes the newAssociatedAddress, timestamp, and other relevant data.
        // ...

        // 4. Records the recovery event in recoveryLogs.
        // ...

        // 5. Resets identity-related data using resetIdentityData function.
        // ...

        // 6. Adds the new associated address to the identity using addAssociatedAddress function.
        // ...

        emit RecoveryTriggered(msg.sender, _ein, /* previous addresses */, _newAssociatedAddress);
    }

    function canTriggerRecovery(uint256 ein) internal view returns (bool) {
        return true; // Replace with actual logic
    }

    function resetIdentityData(uint256 ein) internal {
        // Replace with actual logic
    }

    function addAssociatedAddress(uint256 ein, address newAddress) internal {
        // Replace with actual logic
    }

    event RecoveryTriggered(address indexed sender, uint256 indexed ein, bytes previousAddresses, address indexed newAssociatedAddress);

    // ... other structs, mappings, and functions ...
}"
461,Checks whether a contract implements an ERC165 interface or not without using nor updating the cache .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

abstract contract ImplementsERC165InterfaceNoCache is Ownable {
    using SafeMath for uint256;

    bytes4 constant ERC165ID = 0x01ffc9a7;
    bytes4 constant INVALID_ID = 0xffffffff;

    function noThrowCall(address _contract, bytes4 _interfaceId) internal view returns (uint256 success, uint256 result) {
        (success, result) = address(_contract).staticcall(abi.encodeWithSelector(ERC165.supportsInterface.selector, _interfaceId));
    }

    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;
        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }
}",implementsERC165InterfaceNoCache,"[{'function': 'implementsERC165InterfaceNoCache', 'complexity': 7}]",7.0,{},68.0,0.7303760523124379,0.3616206376745528,"pragma solidity ^0.8.0;

function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) internal view returns (bool) {
    bytes4 constant ERC165ID = 0x01ffc9a7;
    bytes4 constant INVALID_ID = 0xffffffff;

    (bool success, bytes memory result) = _contract.staticcall(abi.encodeWithSignature(""supportsInterface(bytes4)"", ERC165ID));
    if (!success || abi.decode(result, (bool)) == false) {
        return false;
    }

    (success, result) = _contract.staticcall(abi.encodeWithSignature(""supportsInterface(bytes4)"", INVALID_ID));
    if (success && abi.decode(result, (bool)) == true) {
        return false;
    }

    (success, result) = _contract.staticcall(abi.encodeWithSignature(""supportsInterface(bytes4)"", _interfaceId));
    if (success && abi.decode(result, (bool)) == true) {
        return true;
    }

    return false;
}",42.48184537887573,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    // Fixed, safe values for uint/uint256
    uint public constant FIXED_UINT = 1;
    uint256 public constant FIXED_UINT256 = 2;

    // Fixed address values
    address public constant FIXED_ADDRESS_1 = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant FIXED_ADDRESS_2 = 0x2222222222222222222222222222222222222222; // Replace with actual address
    address public constant FIXED_ADDRESS_3 = 0x3333333333333333333333333333333333333333; // Replace with actual address

    // Fixed boolean value
    bool public constant FIXED_BOOL = true;

    // Fixed string value
    string public constant FIXED_STRING = 'initialized';

    // Fixed bytes32 value
    bytes32 public constant FIXED_BYTES32 = bytes32('init');

    // Placeholder values for ERC20 uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor
    string public constant TOKEN_NAME = 'MyToken';
    address public constant TOKEN_ADDRESS = 0x...; // Replace with actual token address

    // Ownable contract initialization
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) internal view returns (bool) {
        bytes4 constant ERC165ID = 0x01ffc9a7;
        bytes4 constant INVALID_ID = 0xffffffff;

        (bool success, bytes memory result) = _contract.staticcall(abi.encodeWithSignature(""supportsInterface(bytes4)"", ERC165ID));
        if (!success || abi.decode(result, (bool)) == false) {
            return false;
        }

        (success, result) = _contract.staticcall(abi.encodeWithSignature(""supportsInterface(bytes4)"", INVALID_ID));
        if (success && abi.decode(result, (bool)) == true) {
            return false;
        }

        (success, result) = _contract.staticcall(abi.encodeWithSignature(""supportsInterface(bytes4)"", _interfaceId));
        if (success && abi.decode(result, (bool)) == true) {
            return true;
        }

        return false;
    }
}"
3202,Retreive account ID associated with a user 's address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public accountByAddress;

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address));
        return accountByAddress[_address];
    }

    function addressBelongsToAccount(address _address) internal view virtual returns (bool);
}",addressBelongsToAccount,"[{'function': 'addressBelongsToAccount', 'complexity': 0}, {'function': 'accountIdForAddress', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""accountIdForAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addressBelongsToAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Address does not belong to an account""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accountByAddress""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.8046207738391257,0.1333622550836506,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(address => uint256) public accountByAddress;

    function addressBelongsToAccount(address _address) internal view returns (bool) {
        // Replace with your actual logic to check if address belongs to an account
        return accountByAddress[_address] != 0;
    }

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address), ""Address does not belong to an account"");
        return accountByAddress[_address];
    }
}",41.61337447166443,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => uint256) public accountByAddress;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    constructor() Ownable(msg.sender) {
        accountByAddress[DEFAULT_ADDRESS] = 1;
        accountByAddress[msg.sender] = 1; // Initialize with a non-zero value
    }

    function addressBelongsToAccount(address _address) internal view returns (bool) {
        return accountByAddress[_address] != 0;
    }

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address), ""Address does not belong to an account"");
        return accountByAddress[_address];
    }
}"
5007,Get the index of PixelCon ` ( _tokenId ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        require(_tokenId != 0, ""Invalid token ID"");
        // Assuming the logic to retrieve the index is implemented here.
        return uint64(_tokenId);
    }
}",getTokenIndex,"[{'function': 'getTokenIndex', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIdToIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",8.0,0.7997604907132341,0.1615723743305001,"pragma solidity ^0.8.0;

contract TokenIndex {

    mapping(uint256 => uint64) public tokenIdToIndex;

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        return tokenIdToIndex[_tokenId];
    }
}",41.26261258125305,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenIndex is Ownable {
    mapping(uint256 => uint64) public tokenIdToIndex;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        tokenIdToIndex[1] = 1; // Example initialization for a specific token ID
        tokenIdToIndex[2] = 2; // Example initialization for another token ID
        tokenIdToIndex[3] = 3; // Example initialization for yet another token ID
    }

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        return tokenIdToIndex[_tokenId];
    }
}"
1993,Throws if ` _tokenId ` is not a valid NFT .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public idToApprovals;

    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address) {
        return idToApprovals[_tokenId];
    }
}",getApproved,"[{'function': '_exists', 'complexity': 0}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'getApproved', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_exists"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",4.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyNFT {

    mapping (uint256 => address) private idToApprovals;

    modifier validNFToken(uint256 _tokenId) {
        require(_exists(_tokenId), ""ERC721: invalid token ID"");
        _;
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return tokenId < totalSupply();
    }

    function totalSupply() internal pure returns (uint256) {
        return 100; //Example, replace with actual logic
    }


    function getApproved(
        uint256 _tokenId
    )
        public
        view
        validNFToken(_tokenId)
        returns (address)
    {
        return idToApprovals[_tokenId];
    }
}",42.14992308616638,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyNFT is Ownable {
    mapping (uint256 => address) private idToApprovals;

    modifier validNFToken(uint256 _tokenId) {
        require(_exists(_tokenId), ""ERC721: invalid token ID"");
        _;
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return tokenId < totalSupply();
    }

    function totalSupply() internal pure returns (uint256) {
        return 100; //Example, replace with actual logic
    }

    function getApproved(
        uint256 _tokenId
    )
        public
        view
        validNFToken(_tokenId)
        returns (address)
    {
        return idToApprovals[_tokenId];
    }

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 100; // Example value, replace with actual logic
        for (uint256 i = 1; i <= initialSupply; i++) {
            idToApprovals[i] = address(uint160(i)); // Using sequential addresses starting from 0x1111111111111111111111111111111111111111
        }
    }
}"
3377,Check the total supply of the token ~ ERC-20 Standard,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 internal totalSupply_;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint8 _decimals) {
        totalSupply_ = totalSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() external constant returns (uint256) {
        return totalSupply_;
    }
}",totalSupply,"[{'function': 'totalSupply', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""totalSupply""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.959675015722895,0.5445178846139404,"pragma solidity ^0.8.0;

contract MyToken {
    uint256 public totalSupply;

    function totalSupply() public view returns (uint256) {
        return totalSupply;
    }
}",41.3551242351532,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    uint256 public totalSupply = 1000000000000000000;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // No need to initialize totalSupply again as it's already set in the state variable declaration
    }

    function totalSupply() public view returns (uint256) {
        return totalSupply;
    }
}"
1589,Transfer Spork tokens from ` msg.sender ` to another account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        if (balances[_to].add(_amount).lte(balances[_to])) return false;
        if (balances[msg.sender].lt(_amount)) return false;
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
}",transfer,"[{'function': 'transfer', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""stringLiteral"", ""value"": ""Overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.739890326010736,0.3649102675282362,"pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _amount) public returns (bool) {
        require(balances[msg.sender] >= _amount, ""Insufficient balance"");
        require(balances[_to] + _amount >= balances[_to], ""Overflow"");

        balances[msg.sender] -= _amount;
        balances[_to] += _amount;

        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
}",41.62788820266724,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance for the owner
    }

    function transfer(address _to, uint256 _amount) public returns (bool) {
        require(balances[msg.sender] >= _amount, ""Insufficient balance"");
        require(balances[_to] + _amount >= balances[_to], ""Overflow"");

        balances[msg.sender] -= _amount;
        balances[_to] += _amount;

        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
}"
1356,Set value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint) public uIntStorage;

    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool success) {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        uIntStorage[_key] = _value;
        return true;
    }

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(""ROLE_PLATFORM_OPERATIVE_REPRESENTATIVE"") {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",setUint,"[{'function': 'setUint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""uIntStorage""}, ""index"": {""type"": ""Identifier"", ""name"": ""_key""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.5308531164307057,0.0087432322743664,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(bytes32 => uint) public uIntStorage;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool) {
        uIntStorage[_key] = _value;
        return true;
    }
}",41.7823634147644,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(bytes32 => uint) public uIntStorage;

    constructor() Ownable(msg.sender) {
        // No need to initialize owner again as it's done in the parent constructor
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool) {
        uIntStorage[_key] = _value;
        return true;
    }
}"
232,get token price in cents depending on the current date,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;
    address private constant ROLE_PLATFORM_OPERATIVE = 0x0; // Placeholder for platform operator representative role

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function getPrice() public view returns (uint) {
        for (uint i = c_priceChangeDates.length - 2; i > 0; i--) {
            if (getTime() >= c_priceChangeDates[i]) {
                return c_tokenPrices[i];
            }
        }
        return c_tokenPrices[0];
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",getPrice,"[{'function': 'getTime', 'complexity': 0}, {'function': 'getPrice', 'complexity': 4}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""c_priceChangeDates""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""c_tokenPrices""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""No price data available""}], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""c_priceChangeDates""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""c_tokenPrices""}, ""memberName"": ""length""}}, ""TrueBody"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Price data mismatch""}], ""names"": []}}, ""FalseBody"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""c_priceChangeDates""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getTime""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""c_priceChangeDates""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""c_tokenPrices""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}]}, ""FalseBody"": None}]}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""c_tokenPrices""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",35.0,0.739608472069878,0.4404740180715408,"pragma solidity ^0.8.0;

contract PriceOracle {

    uint256[] public c_priceChangeDates;
    uint256[] public c_tokenPrices;

    function getTime() internal view returns (uint256) {
        return block.timestamp;
    }

    function getPrice() public view returns (uint256) {
        if (c_priceChangeDates.length == 0 || c_tokenPrices.length ==0 ) revert(""No price data available"");
        if (c_priceChangeDates.length != c_tokenPrices.length) revert(""Price data mismatch"");

        for (uint256 i = c_priceChangeDates.length - 1; i > 0; i--) {
            if (getTime() >= c_priceChangeDates[i]) {
                return c_tokenPrices[i];
            }
        }
        return c_tokenPrices[0];
    }
}",42.21670198440552,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceOracle is Ownable {
    uint256[] public c_priceChangeDates;
    uint256[] public c_tokenPrices;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        c_priceChangeDates = [1]; // Set to 1 (never 0)
        c_tokenPrices = [1]; // Set to 1 (never 0)
    }

    function getTime() internal view returns (uint256) {
        return block.timestamp;
    }

    function getPrice() public view returns (uint256) {
        if (c_priceChangeDates.length == 0 || c_tokenPrices.length == 0) revert(""No price data available"");
        if (c_priceChangeDates.length != c_tokenPrices.length) revert(""Price data mismatch"");

        for (uint256 i = c_priceChangeDates.length - 1; i > 0; i--) {
            if (getTime() >= c_priceChangeDates[i]) {
                return c_tokenPrices[i];
            }
        }
        return c_tokenPrices[0];
    }
}"
5169,Set the Havven contract that the issuance controller uses to issue Havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HavvenWrapper is Ownable {
    using SafeMath for uint256;

    Havven public havven;

    event HavvenUpdated(Havven indexed newHavven);

    function setHavven(Havven _havven) external onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}",setHavven,"[{'function': 'setHavven', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setHavven"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_havven"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""havven""}, ""right"": {""type"": ""Identifier"", ""name"": ""_havven""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""HavvenUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_havven""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.955188463409972,0.709421400618421,"pragma solidity ^0.8.0;

contract MyContract {

    address public havven;
    address public owner;

    event HavvenUpdated(address havven);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setHavven(address _havven) public onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}",41.83577466011048,"pragma solidity ^0.8.0;

import ""Ownable/contracts/ownership/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public havven;
    address public owner;

    event HavvenUpdated(address havven);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        havven = address(0x111); // Fixed value for initialization
    }

    function setHavven(address _havven) public onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}"
277,sell new tokens during the round 0 all except logo,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public halted = false;
    mapping(address => bool) public signers;

    function setHalted(bool _halted) external onlyOwner {
        halted = _halted;
    }

    function addSigner(address signer) external onlyOwner {
        signers[signer] = true;
    }

    function removeSigner(address signer) external onlyOwner {
        signers[signer] = false;
    }

    function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 v, bytes32 r, bytes32 s) public notHalted() payable {
        address recoveredSigner = verify(keccak256(abi.encodePacked(msg.sender)), v, r, s);
        require(signers[recoveredSigner] == true);
        require(msg.value > 0);
        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        // Implementation of the buy logic
    }
}",buy,"[{'function': 'verify', 'complexity': 0}, {'function': 'buy', 'complexity': 2}, {'function': 'internalBuy', 'complexity': 0}, {'function': 'addSigner', 'complexity': 0}, {'function': 'haltContract', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""x"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""y"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sizeA"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sizeB"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Must send ETH""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recoveredSigner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""verify""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_v""}, {""type"": ""Identifier"", ""name"": ""_r""}, {""type"": ""Identifier"", ""name"": ""_s""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""signers""}, ""index"": {""type"": ""Identifier"", ""name"": ""recoveredSigner""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""internalBuy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""x""}, {""type"": ""Identifier"", ""name"": ""y""}, {""type"": ""Identifier"", ""name"": ""sizeA""}, {""type"": ""Identifier"", ""name"": ""sizeB""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""notHalted"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",22.0,0.8287684734911568,0.5508553998753373,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(address => bool) public signers;
    bool public halted;

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function verify(address signer, uint8 _v, bytes32 _r, bytes32 _s) internal view returns (address) {
        bytes32 messageHash = keccak256(abi.encodePacked(signer));
        address recoveredSigner = ecrecover(messageHash, _v, _r, _s);
        return recoveredSigner;
    }


    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 _v, bytes32 _r, bytes32 _s) public payable notHalted {
        require(msg.value > 0, ""Must send ETH"");
        address recoveredSigner = verify(msg.sender, _v, _r, _s);
        require(signers[recoveredSigner], ""Invalid signature"");
        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        //Implementation for buying logic
    }

    function addSigner(address _signer) public {
        signers[_signer] = true;
    }

    function haltContract() public {
        halted = true;
    }
}",43.19585990905762,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => bool) public signers;
    bool public halted;

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        signers[msg.sender] = true;
        halted = false;
    }

    function verify(address signer, uint8 _v, bytes32 _r, bytes32 _s) internal view returns (address) {
        bytes32 messageHash = keccak256(abi.encodePacked(signer));
        address recoveredSigner = ecrecover(messageHash, _v, _r, _s);
        return recoveredSigner;
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 _v, bytes32 _r, bytes32 _s) public payable notHalted {
        require(msg.value > 0, ""Must send ETH"");
        address recoveredSigner = verify(msg.sender, _v, _r, _s);
        require(signers[recoveredSigner], ""Invalid signature"");
        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        //Implementation for buying logic
    }

    function addSigner(address _signer) public {
        signers[_signer] = true;
    }

    function haltContract() public {
        halted = true;
    }
}"
3181,This function is disabled during the funding .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function getState() external view returns (uint8);
    function balances(address) external view returns (uint256);
    function upgradeAgent() external view returns (address);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _token) {
        token = IToken(_token);
    }

    function transfer(address to, uint256 value) external returns (bool ok) {
        require(getState() == 0, ""State is not Success"");
        require(to != address(0), ""Invalid recipient address"");
        require(to != token.upgradeAgent(), ""Recipient is upgrade agent"");

        uint256 senderBalance = token.balances(msg.sender);
        if (senderBalance >= value && value > 0) {
            senderBalance = senderBalance.sub(value);
            token.balances(msg.sender) = senderBalance;
            token.balances(to) = token.balances(to).add(value);
            emit Transfer(msg.sender, to, value);
            return true;
        }
        return false;
    }

    function getState() internal view returns (uint8) {
        return token.getState();
    }
}",transfer,"[{'function': 'transfer', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ContractState""}, ""memberName"": ""Success""}}, {""type"": ""stringLiteral"", ""value"": ""Contract is not in Success state""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}}, {""type"": ""stringLiteral"", ""value"": ""Transfer to upgrade agent is not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.8420892198396676,0.4192135332918226,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    enum ContractState { Success, Failure }
    ContractState public state;
    address public upgradeAgent;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(address _upgradeAgent) {
        upgradeAgent = _upgradeAgent;
        state = ContractState.Success;
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(state == ContractState.Success, ""Contract is not in Success state"");
        require(to != address(0), ""Transfer to the zero address"");
        require(to != upgradeAgent, ""Transfer to upgrade agent is not allowed"");
        require(balances[msg.sender] >= value, ""Insufficient balance"");
        require(value > 0, ""Transfer value must be greater than zero"");

        balances[msg.sender] = balances[msg.sender].sub(value);
        balances[to] = balances[to].add(value);

        emit Transfer(msg.sender, to, value);
        return true;
    }
}",43.05654335021973,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    enum ContractState { Success, Failure }
    ContractState public state;
    address public upgradeAgent;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(address _upgradeAgent) Ownable(msg.sender) {
        require(_upgradeAgent != address(0), ""Invalid upgrade agent address"");
        upgradeAgent = _upgradeAgent;
        state = ContractState.Success;
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(state == ContractState.Success, ""Contract is not in Success state"");
        require(to != address(0), ""Transfer to the zero address"");
        require(to != upgradeAgent, ""Transfer to upgrade agent is not allowed"");
        require(balances[msg.sender] >= value, ""Insufficient balance"");
        require(value > 0, ""Transfer value must be greater than zero"");

        balances[msg.sender] = balances[msg.sender].sub(value);
        balances[to] = balances[to].add(value);

        emit Transfer(msg.sender, to, value);
        return true;
    }
}"
4086,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

   function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
}

}",isApprovedForAll,"[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isApprovedForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_operatorApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",15.0,0.6929266306633448,0.7039848207052138,"pragma solidity ^0.8.0;

contract ERC721 {

    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function isApprovedForAll(address _owner, address _operator) public view virtual returns (bool) {
        return _operatorApprovals[_owner][_operator];
    }
}",41.20244598388672,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ERC721 is Ownable {
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isApprovedForAll(address _owner, address _operator) public view virtual returns (bool) {
        return _operatorApprovals[_owner][_operator];
    }
}"
79,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public memeIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerOf(_tokenId) == _owner;
    }

    function ownerOf(uint256 _tokenId) public pure returns (address) {
        // This is a placeholder for the actual implementation of ownerOf.
        // The real implementation should be provided by the contract that inherits this wrapper.
        require(false, ""ownerOf not implemented"");
    }
}",_owns,"[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owns""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not the owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""memeIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.5320558173201078,0.0605371506876297,"pragma solidity ^0.8.0;

contract MyContract {
    mapping(uint256 => address) public memeIndexToApproved;
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) external {
        require(_owns(msg.sender, _tokenId), ""Caller is not the owner"");
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        // Replace with your actual ownership logic.  This is a placeholder.
        //  For example, you might have a mapping like `mapping(uint256 => address) public ownerOf;`
        //  and return `ownerOf[_tokenId] == _owner;`
        return true; // Placeholder - replace with your actual ownership check
    }
}",42.30612325668335,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(uint256 => address) public memeIndexToApproved;
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            memeIndexToApproved[i] = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
        }
    }

    function approve(address _to, uint256 _tokenId) external {
        require(_owns(msg.sender, _tokenId), ""Caller is not the owner"");
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        // Replace with your actual ownership logic.  This is a placeholder.
        // For example, you might have a mapping like `mapping(uint256 => address) public ownerOf;`
        // and return `ownerOf[_tokenId] == _owner;`
        return true; // Placeholder - replace with your actual ownership check
    }
}"
3424,Get the name of collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollectionRegistry is Ownable {
    using SafeMath for uint256;

    uint256 public totalCollections;
    mapping(uint64 => bytes8) private collectionNames;

    modifier validIndex(uint64 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (bytes8) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        return collectionNames[_collectionIndex];
    }

    function setTotalCollections(uint256 newTotalCollections) public onlyOwner {
        totalCollections = newTotalCollections;
    }

    function setCollectionName(uint64 _collectionIndex, bytes8 _name) public onlyOwner validIndex(_collectionIndex) {
        collectionNames[_collectionIndex] = _name;
    }
}",getCollectionName,"[{'function': 'getCollectionName', 'complexity': 1}, {'function': 'totalCollections', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCollectionName"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalCollections""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Collection does not exist""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionNames""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validIndex"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_collectionIndex""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9759644270535128,0.8935248372106969,"pragma solidity ^0.8.0;

contract CollectionRegistry {

    string[] public collectionNames;

    modifier validIndex(uint64 _index) {
        require(_index < collectionNames.length, ""Index out of bounds"");
        _;
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (string memory) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        return collectionNames[_collectionIndex];
    }

    function totalCollections() public view returns (uint64) {
        return uint64(collectionNames.length);
    }
}",41.77685070037842,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CollectionRegistry is Ownable {
    string[] public collectionNames;

    modifier validIndex(uint64 _index) {
        require(_index < collectionNames.length, ""Index out of bounds"");
        _;
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (string memory) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        return collectionNames[_collectionIndex];
    }

    function totalCollections() public view returns (uint64) {
        return uint64(collectionNames.length);
    }

    constructor() Ownable(msg.sender) {
        collectionNames = [""Collection1"", ""Collection2"", ""Collection3""]; // Fixed values for demonstration
    }
}"
4496,This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ICOContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoEndDate;
    bool public paused = false;

    mapping(address => bool) public whitelistedAddresses;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        require(whitelistedAddresses[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
        icoEndDate = _date;
    }
}",setICOEndDate,"[{'function': 'setICOEndDate', 'complexity': 1}, {'function': 'addWhitelistAddress', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setICOEndDate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_date"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""icoEndDate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ICO end date already set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoEndDate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_date""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyWhitelisted"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8269143693091291,0.4226469376227503,"pragma solidity ^0.8.0;

contract ICO {

    uint256 public icoEndDate;
    address[] public whitelistedAddresses;
    bool public paused;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        bool isWhitelisted = false;
        for (uint i = 0; i < whitelistedAddresses.length; i++) {
            if (msg.sender == whitelistedAddresses[i]) {
                isWhitelisted = true;
                break;
            }
        }
        require(isWhitelisted, ""Caller is not whitelisted"");
        _;
    }


    function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
        require(icoEndDate == 0, ""ICO end date already set"");
        icoEndDate = _date;
    }

    function addWhitelistAddress(address _address) public {
        whitelistedAddresses.push(_address);
    }

    function pause() public onlyWhitelisted {
        paused = true;
    }

    function unpause() public onlyWhitelisted {
        paused = false;
    }
}",42.51260590553284,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ICO is Ownable {
    uint256 public icoEndDate;
    address[] public whitelistedAddresses;
    bool public paused;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        bool isWhitelisted = false;
        for (uint i = 0; i < whitelistedAddresses.length; i++) {
            if (msg.sender == whitelistedAddresses[i]) {
                isWhitelisted = true;
                break;
            }
        }
        require(isWhitelisted, ""Caller is not whitelisted"");
        _;
    }

    constructor() Ownable(msg.sender) {
        icoEndDate = 1; // Set to a fixed value
        whitelistedAddresses.push(0x1111111111111111111111111111111111111111); // Use a fixed address
        paused = false; // Initialize to false
    }

    function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
        require(icoEndDate == 1, ""ICO end date already set"");
        icoEndDate = _date;
    }

    function addWhitelistAddress(address _address) public {
        whitelistedAddresses.push(_address);
    }

    function pause() public onlyWhitelisted {
        paused = true;
    }

    function unpause() public onlyWhitelisted {
        paused = false;
    }
}"
1334,Adding ` _backer.address ( ) ` as an early backer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct backerData {
        uint tokenPrice;
        uint tokenAmount;
        bytes32 privatePhraseHash;
        bool claimed;
        bool redeemed;
        uint rank;
    }

    address[] public earlyBackerList;
    address[] public backersAddresses;
    mapping(address => backerData[]) public backers;
    uint public prepaidUnits;
    uint public claimedUnits;
    uint public promissoryUnits;
    uint public lastPrice;
    uint public numOfBackers;

    event AddedPrepaidTokensEvent(address indexed backer, uint indexed index, uint tokenPrice, uint tokenAmount);

    modifier founderCall() {
        require(msg.sender == owner(), ""Only the founder can call this function"");
        _;
    }

    function setPrepaid(address _backer, uint _tokenPrice, uint _tokenAmount, string memory _privatePhrase, uint _backerRank) external founderCall returns (uint) {
        require(_tokenPrice > 0 && _tokenAmount > 0);
        require(claimedUnits == 0);
        require(_tokenAmount.add(prepaidUnits).add(claimedUnits) <= promissoryUnits);
        if (earlyBackerList.length == numOfBackers && backers[_backer].length == 0) {
            earlyBackerList.push(_backer);
            backersAddresses.push(_backer);
        }
        backers[_backer].push(backerData(_tokenPrice, _tokenAmount, keccak256(abi.encodePacked(_privatePhrase, _backer)), true, false, _backerRank));
        prepaidUnits = prepaidUnits.add(_tokenAmount);
        lastPrice = _tokenPrice;
        emit AddedPrepaidTokensEvent(_backer, backers[_backer].length - 1, _tokenPrice, _tokenAmount);
        return backers[_backer].length - 1;
    }
}",addPrepaidEntry,"[{'function': 'addPrepaidEntry', 'complexity': 5}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""addPrepaidEntry"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_backer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_privatePhrase"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_backerRank"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token price cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token amount cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""memberName"": ""tokenAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""backersAddresses""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""maxBackers""}}}, {""type"": ""stringLiteral"", ""value"": ""Backer limit reached""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""memberName"": ""tokenAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""earlyBackerList""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""backersAddresses""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backer""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Backer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenPrice""}, {""type"": ""Identifier"", ""name"": ""_tokenAmount""}, {""type"": ""Identifier"", ""name"": ""_privatePhrase""}, {""type"": ""Identifier"", ""name"": ""_backerRank""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""prepaidUnits""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenPrice""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AddedPrepaidTokensEvent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backer""}, {""type"": ""Identifier"", ""name"": ""_tokenPrice""}, {""type"": ""Identifier"", ""name"": ""_tokenAmount""}, {""type"": ""Identifier"", ""name"": ""_privatePhrase""}, {""type"": ""Identifier"", ""name"": ""_backerRank""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",45.0,0.7512094455709653,0.375303127818087,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public prepaidUnits;
    uint256 public lastPrice;
    uint256 public maxBackers;
    address[] public earlyBackerList;
    address[] public backersAddresses;
    mapping(address => Backer) public backers;

    struct Backer {
        uint256 tokenPrice;
        uint256 tokenAmount;
        string privatePhrase;
        uint256 backerRank;
    }

    event AddedPrepaidTokensEvent(address backer, uint256 tokenPrice, uint256 tokenAmount, string privatePhrase, uint256 backerRank);

    constructor(uint256 _maxBackers) {
        maxBackers = _maxBackers;
    }

    function addPrepaidEntry(address _backer, uint256 _tokenPrice, uint256 _tokenAmount, string memory _privatePhrase, uint256 _backerRank) public {
        require(_tokenPrice > 0, ""Token price cannot be zero"");
        require(_tokenAmount > 0, ""Token amount cannot be zero"");
        require(backers[_backer].tokenAmount == 0 || backersAddresses.length < maxBackers, ""Backer limit reached"");

        if (backers[_backer].tokenAmount == 0) {
            earlyBackerList.push(_backer);
            backersAddresses.push(_backer);
        }

        backers[_backer] = Backer(_tokenPrice, _tokenAmount, _privatePhrase, _backerRank);
        prepaidUnits += _tokenAmount;
        lastPrice = _tokenPrice;

        emit AddedPrepaidTokensEvent(_backer, _tokenPrice, _tokenAmount, _privatePhrase, _backerRank);
    }
}",43.448288679122925,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public prepaidUnits;
    uint256 public lastPrice;
    uint256 public maxBackers;
    address[] public earlyBackerList;
    address[] public backersAddresses;
    mapping(address => Backer) public backers;

    struct Backer {
        uint256 tokenPrice;
        uint256 tokenAmount;
        string privatePhrase;
        uint256 backerRank;
    }

    event AddedPrepaidTokensEvent(address backer, uint256 tokenPrice, uint256 tokenAmount, string privatePhrase, uint256 backerRank);

    constructor(uint256 _maxBackers) Ownable(msg.sender) {
        maxBackers = _maxBackers;
        prepaidUnits = 1; // Set to 1 (never 0)
        lastPrice = 1; // Set to 1
    }

    function addPrepaidEntry(address _backer, uint256 _tokenPrice, uint256 _tokenAmount, string memory _privatePhrase, uint256 _backerRank) public {
        require(_tokenPrice > 0, ""Token price cannot be zero"");
        require(_tokenAmount > 0, ""Token amount cannot be zero"");
        require(backers[_backer].tokenAmount == 0 || backersAddresses.length < maxBackers, ""Backer limit reached"");

        if (backers[_backer].tokenAmount == 0) {
            earlyBackerList.push(_backer);
            backersAddresses.push(_backer);
        }

        backers[_backer] = Backer(_tokenPrice, _tokenAmount, _privatePhrase, _backerRank);
        prepaidUnits += _tokenAmount;
        lastPrice = _tokenPrice;

        emit AddedPrepaidTokensEvent(_backer, _tokenPrice, _tokenAmount, _privatePhrase, _backerRank);
    }
}"
517,Used to intialize the variables of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public maxHolderPercentage;

    modifier onlyFactory() {
        require(msg.sender == factory, ""Only the factory can call this function"");
        _;
    }

    address private factory;

    constructor() {
        // Initialize the factory address in the constructor or later
    }

    function configure(uint256 _maxHolderPercentage) public onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}",configure,"[{'function': 'configure', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""configure"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxHolderPercentage"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxHolderPercentage""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxHolderPercentage""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyFactory"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public maxHolderPercentage;
    address public factory;

    modifier onlyFactory() {
        require(msg.sender == factory, ""Only factory can call this function"");
        _;
    }

    constructor(address _factory) {
        factory = _factory;
    }

    function configure(uint256 _maxHolderPercentage) public onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}",41.52132272720337,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public maxHolderPercentage;
    address public factory;

    modifier onlyFactory() {
        require(msg.sender == factory, ""Only factory can call this function"");
        _;
    }

    constructor(address _factory) Ownable(_factory) {
        factory = _factory;
        maxHolderPercentage = 1; // Set to a non-zero value
    }

    function configure(uint256 _maxHolderPercentage) public onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}"
3727,Core logic of the ` decreaseApproval ` function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20Store {
    function allowed(address _owner, address _spender) external view returns (uint256);
    function setAllowance(address _owner, address _spender, uint256 _value) external;
}

interface IERC20Proxy {
    function emitApproval(address _owner, address _spender, uint256 _value) external;
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20Store public erc20Store;
    IERC20Proxy public erc20Proxy;

    constructor(address _erc20Store, address _erc20Proxy) {
        erc20Store = IERC20Store(_erc20Store);
        erc20Proxy = IERC20Proxy(_erc20Proxy);
    }

    function decreaseApprovalWithSender(address _sender, address _spender, uint256 _subtractedValue) public onlyOwner returns (bool) {
        require(_spender != address(0));
        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);
        uint256 newAllowance = currentAllowance.sub(_subtractedValue);
        require(newAllowance <= currentAllowance);
        erc20Store.setAllowance(_sender, _spender, newAllowance);
        erc20Proxy.emitApproval(_sender, _spender, newAllowance);
        return true;
    }
}",decreaseAllowance,"[{'function': 'decreaseAllowance', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_subtractedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: decreased allowance of zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""erc20Store""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_subtractedValue""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""newAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: decreased allowance below zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""erc20Store""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newAllowance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20Proxy""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""newAllowance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.7810245675307909,0.442713357003987,"pragma solidity ^0.8.0;

import ""./IERC20.sol""; // Assuming IERC20 interface is defined here

contract YourContract {
    IERC20 public erc20Proxy; // Assuming erc20Proxy is defined elsewhere
    mapping(address => mapping(address => uint256)) internal erc20Store;


    constructor(address _erc20Proxy) {
        erc20Proxy = IERC20(_erc20Proxy);
    }

    function decreaseAllowance(address _sender, address _spender, uint256 _subtractedValue) public {
        require(_spender != address(0), ""ERC20: decreased allowance of zero address"");
        uint256 currentAllowance = erc20Store[_sender][_spender];
        uint256 newAllowance = currentAllowance - _subtractedValue;
        require(newAllowance <= currentAllowance, ""ERC20: decreased allowance below zero"");
        erc20Store[_sender][_spender] = newAllowance;
        erc20Proxy.approve(_sender, _spender, newAllowance);
    }
}",42.45488333702088,"pragma solidity ^0.8.0;

import ""./IERC20.sol""; // Assuming IERC20 interface is defined here
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Importing Ownable from OpenZeppelin
import ""openzeppelin/SafeMath.sol"";
contract YourContract is Ownable {
    IERC20 public erc20Proxy; // Assuming erc20Proxy is defined elsewhere
    mapping(address => mapping(address => uint256)) internal erc20Store;

    constructor(address _erc20Proxy) Ownable(msg.sender) {
        erc20Proxy = IERC20(_erc20Proxy);
    }

    function decreaseAllowance(address _sender, address _spender, uint256 _subtractedValue) public {
        require(_spender != address(0), ""ERC20: decreased allowance of zero address"");
        uint256 currentAllowance = erc20Store[_sender][_spender];
        uint256 newAllowance = currentAllowance - _subtractedValue;
        require(newAllowance <= currentAllowance, ""ERC20: decreased allowance below zero"");
        erc20Store[_sender][_spender] = newAllowance;
        erc20Proxy.approve(_sender, _spender, newAllowance);
    }
}"
5953,"Sets the address of another contract to handle the requests of this contract , it can be used to deprecate this Oracle","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    address public fallback;

    function setFallback(address _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}",setFallback,"[{'function': 'setFallback', 'complexity': 0}]",1.0,{},0.0,0.9803782466519412,0.8578928092681435,"pragma solidity ^0.8.0;

contract MyContract {
    address private owner;
    address payable public fallback;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setFallback(address payable _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}",41.53215146064758,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address private owner;
    address payable public fallback;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function."");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function setFallback(address payable _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}"
6776,Sends fees to the request burning address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public requestBurnerContract;

    constructor(address _requestBurnerContract) {
        requestBurnerContract = _requestBurnerContract;
    }

    function collectForREQBurning(uint256 _amount) internal {
        require(_amount > 0, ""Amount must be greater than zero"");
        (bool success, ) = requestBurnerContract.call{value: _amount}("""");
        require(success, ""Transfer failed"");
    }
}",collectForBurning,"[{'function': 'transfer', 'complexity': 0}, {'function': 'collectForBurning', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""collectForBurning"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requestBurnerContract""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.7383849971543575,0.0499336313303902,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenCollector {
    IERC20 public requestBurnerContract;

    constructor(address _requestBurnerContract) {
        requestBurnerContract = IERC20(_requestBurnerContract);
    }

    function collectForBurning(uint256 _amount) external {
        requestBurnerContract.transfer(address(this), _amount);
    }
}",41.8161199092865,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenCollector is Ownable {
    IERC20 public requestBurnerContract;

    constructor(address _requestBurnerContract) Ownable(msg.sender) {
        requestBurnerContract = IERC20(_requestBurnerContract);
    }

    function collectForBurning(uint256 _amount) external {
        requestBurnerContract.transfer(address(this), _amount);
    }
}"
1286,Verifies a broker 's signature for an order opening .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public brokers;

    function verifyOpenSignature(address _trader, bytes memory _signature, bytes32 _orderID) external view returns (bool) {
        bytes memory data = abi.encodePacked(""Republic Protocol: open: "", _trader, _orderID);
        address signer = Utils.addr(data, _signature);
        return brokers[signer];
    }
}",addr,"[{'function': 'verifyOpenSignature', 'complexity': 0}, {'function': 'addr', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addr"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""sig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""r"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""s"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""v"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""r""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""sig"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""32""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""s""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""sig"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""64""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""v""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""byte"", ""arguments"": [{""type"": ""DecimalNumber"", ""value"": ""0""}, {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""sig"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""96""}]}]}]}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""v""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""27"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""v""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""27"", ""subdenomination"": None}}}]}, ""FalseBody"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ecrecover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hash""}, {""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",39.0,0.5767328811879766,0.0224176254359767,"pragma solidity ^0.8.0;

contract BrokerVerifier {

    mapping(address => bool) public brokers;

    function verifyOpenSignature(address _trader, bytes memory _signature, uint256 _orderID) public view returns (bool) {
        bytes32 hash = keccak256(abi.encodePacked(""Republic Protocol: open: "", _trader, _orderID));
        address signer = Utils.addr(hash, _signature);
        return brokers[signer];
    }


    library Utils {
        function addr(bytes32 hash, bytes memory sig) internal pure returns (address) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            assembly {
                r := mload(add(sig, 32))
                s := mload(add(sig, 64))
                v := byte(0, mload(add(sig, 96)))
            }
            if (v < 27) {
                v += 27;
            }
            return ecrecover(hash, v, r, s);
        }
    }
}",42.533838510513306,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract BrokerVerifier {
    mapping(address => bool) public brokers;
    address public owner;
    uint256 public orderIDCounter = 1;
    bytes32 public signatureHash;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        owner = msg.sender;
        brokers[msg.sender] = true;
        signatureHash = bytes32('init');
    }

    function verifyOpenSignature(address _trader, bytes memory _signature, uint256 _orderID) public view returns (bool) {
        bytes32 hash = keccak256(abi.encodePacked(""Republic Protocol: open: "", _trader, _orderID));
        address signer = Utils.addr(hash, _signature);
        return brokers[signer];
    }

    library Utils {
        function addr(bytes32 hash, bytes memory sig) internal pure returns (address) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            assembly {
                r := mload(add(sig, 32))
                s := mload(add(sig, 64))
                v := byte(0, mload(add(sig, 96)))
            }
            if (v < 27) {
                v += 27;
            }
            return ecrecover(hash, v, r, s);
        }
    }
}"
5432,Set the minimum required havven balance to have standing to bring a motion .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public minStandingBalance;

    function setMinStandingBalance(uint balance) external onlyOwner {
        minStandingBalance = balance;
    }
}",setMinStandingBalance,"[{'function': 'setMinStandingBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinStandingBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minStandingBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9657344849556724,0.5266403878479267,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public minStandingBalance;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setMinStandingBalance(uint256 balance) public onlyOwner {
        minStandingBalance = balance;
    }
}",41.29232573509216,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public minStandingBalance;

    constructor() Ownable(msg.sender) {
        minStandingBalance = 1;
    }

    function setMinStandingBalance(uint256 balance) public onlyOwner {
        minStandingBalance = balance;
    }
}"
6260,"Opens a new channel or tops up an existing one , compatibility with ERC 223 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token;
    mapping(address => bool) public trusted_contracts;

    constructor(address _token, address[] memory _trustedContracts) {
        require(_token != address(0), ""Invalid token address"");
        token = _token;
        for (uint i = 0; i < _trustedContracts.length; i++) {
            trusted_contracts[_trustedContracts[i]] = true;
        }
    }

    function createChannelPrivate(address _sender, address _receiver, uint256 _deposit) internal virtual;

    function updateInternalBalanceStructs(address _sender, address _receiver, uint32 _openBlockNumber, uint256 _deposit) internal virtual;

    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) external {
        require(msg.sender == token, ""Sender must be the token contract"");
        require(_deposit <= type(uint192).max, ""Deposit exceeds uint192 limit"");
        uint256 deposit = uint256(_deposit);
        require(deposit == _deposit, ""Deposit conversion overflow"");

        uint256 length = _data.length;
        require(length == 40 || length == 44, ""Invalid data length"");

        address channel_sender_address = addressFromBytes(_data, 0x20);
        require(_sender_address == channel_sender_address || trusted_contracts[_sender_address], ""Unauthorized sender"");

        address channel_receiver_address = addressFromBytes(_data, 0x34);
        if (length == 40) {
            createChannelPrivate(channel_sender_address, channel_receiver_address, deposit);
        } else {
            uint32 open_block_number = uint32(blockNumberFromBytes(_data, 0x48));
            updateInternalBalanceStructs(channel_sender_address, channel_receiver_address, open_block_number, deposit);
        }
    }

    function addressFromBytes(bytes memory _data, uint256 offset) internal pure returns (address addr) {
        assembly {
            addr := mload(add(_data, add(0x20, offset)))
        }
    }

    function blockNumberFromBytes(bytes memory _data, uint256 offset) internal pure returns (uint32 block_number) {
        assembly {
            block_number := mload(add(_data, add(0x48, offset)))
        }
    }
}",tokenFallback,"[{'function': 'tokenFallback', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenFallback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_deposit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot call tokenFallback from this contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_deposit""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint192""}], ""names"": []}, ""memberName"": ""max""}}, {""type"": ""stringLiteral"", ""value"": ""Deposit exceeds uint192 limit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_data""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""40"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_data""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""44"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid data length""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""openingBlock"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_data"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""20""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""receiver""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_data"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""40""}]}]}}, {""type"": ""AssemblyIf"", ""condition"": {""type"": ""AssemblyExpression"", ""functionName"": ""eq"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_data"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""60""}]}]}, {""type"": ""DecimalNumber"", ""value"": ""0""}]}, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""openingBlock""}], ""expression"": {""type"": ""DecimalNumber"", ""value"": ""0""}}]}}, {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""openingBlock""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_data"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""60""}]}]}}]}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",73.0,0.8422390697845085,0.3369785915001036,"pragma solidity ^0.8.0;

contract MyContract {

    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) public {
        require(msg.sender != address(this), ""Cannot call tokenFallback from this contract"");
        require(_deposit <= type(uint192).max, ""Deposit exceeds uint192 limit"");
        require(_data.length == 40 || _data.length == 44, ""Invalid data length"");

        address sender;
        address receiver;
        uint256 openingBlock;

        assembly {
            sender := mload(add(_data, 20))
            receiver := mload(add(_data, 40))
            if eq(mload(add(_data, 60)), 0) {
                openingBlock := 0
            } else {
                openingBlock := mload(add(_data, 60))
            }
        }


        //Further logic to handle channel creation or update based on sender, receiver, openingBlock and _deposit
    }
}",42.74003720283508,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant MAX_DEPOSIT = 2**32 - 1;
    address public constant DEFAULT_SENDER_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant DEFAULT_RECEIVER_ADDRESS = 0x2222222222222222222222222222222222222222; // Replace with actual address

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        uint256 _deposit = MAX_DEPOSIT;
        bytes32 _data = bytes32('init');
        bool _isInitialized = true;

        // Set default values for other state variables (if any)
        // For example:
        // string public constant DEFAULT_CHANNEL_NAME = 'My Channel';
    }

    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) public {
        require(msg.sender != address(this), ""Cannot call tokenFallback from this contract"");
        require(_deposit <= MAX_DEPOSIT, ""Deposit exceeds uint limit"");
        require(bytes32(_data) == bytes32('init'), ""Invalid data"");

        // Further logic to handle channel creation or update based on sender, receiver, openingBlock and _deposit
    }
}"
3890,Transfers ETH according to the data held within the specified payment id ( internal function ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LiquidPledging {
    function confirmPayment(uint64, uint256) external;
}

struct Payment {
    uint256 amount;
    address dest;
    uint64 ref;
    PaymentStatus state;
}

enum PaymentStatus { Pending, Paid }

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    LiquidPledging public liquidPledging;
    Payment[] public payments;

    event ConfirmPayment(uint256 indexed idPayment, uint64 ref);

    function doConfirmPayment(uint256 _idPayment) external onlyOwner {
        require(_idPayment < payments.length);
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending);
        p.state = PaymentStatus.Paid;
        liquidPledging.confirmPayment(uint64(p.ref), p.amount);
        payable(p.dest).transfer(p.amount);
        emit ConfirmPayment(_idPayment, p.ref);
    }
}",doConfirmPayment,"[{'function': 'doConfirmPayment', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""doConfirmPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payments""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid payment ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""p"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentStatus""}, ""memberName"": ""Pending""}}, {""type"": ""stringLiteral"", ""value"": ""Payment not pending""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentStatus""}, ""memberName"": ""Paid""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ILiquidPledging""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""liquidPledging""}], ""names"": []}, ""memberName"": ""confirmPayment""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""reference""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""destination""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ConfirmPayment""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_idPayment""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""reference""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.950832236534582,0.5550678984932167,"pragma solidity ^0.8.0;

enum PaymentStatus {Pending, Paid}

struct Payment {
    address payable destination;
    uint256 amount;
    string reference;
    PaymentStatus state;
}

contract MyContract {
    Payment[] public payments;
    address public liquidPledging;

    event ConfirmPayment(uint256 _idPayment, string _reference);

    constructor(address _liquidPledging) {
        liquidPledging = _liquidPledging;
    }

    function doConfirmPayment(uint256 _idPayment) public {
        require(_idPayment < payments.length, ""Invalid payment ID"");
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending, ""Payment not pending"");
        p.state = PaymentStatus.Paid;
        ILiquidPledging(liquidPledging).confirmPayment(p.reference, p.amount);
        p.destination.transfer(p.amount);
        emit ConfirmPayment(_idPayment, p.reference);
    }

    interface ILiquidPledging {
        function confirmPayment(string memory _reference, uint256 _amount) external;
    }
}",42.90971899032593,"pragma solidity ^0.8.0;

enum PaymentStatus {Pending, Paid}

struct Payment {
    address payable destination;
    uint256 amount;
    string reference;
    PaymentStatus state;
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    Payment[] public payments;
    address public liquidPledging;

    event ConfirmPayment(uint256 _idPayment, string _reference);

    constructor(address _liquidPledging) Ownable(msg.sender) {
        liquidPledging = _liquidPledging;
        // Initialize state variables with safe non-corner-case values
        Payment[] memory initialPayments = new Payment[](0);
        payments = initialPayments;
    }

    function doConfirmPayment(uint256 _idPayment) public {
        require(_idPayment < payments.length, ""Invalid payment ID"");
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending, ""Payment not pending"");
        p.state = PaymentStatus.Paid;
        ILiquidPledging(liquidPledging).confirmPayment(p.reference, p.amount);
        p.destination.transfer(p.amount);
        emit ConfirmPayment(_idPayment, p.reference);
    }

    interface ILiquidPledging {
        function confirmPayment(string memory _reference, uint256 _amount) external;
    }
}"
3719,only the admin is allowed to change the admin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public admin;

    event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);

    modifier validate_address(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    function changeAdmin(address newAdmin) public validate_address(newAdmin) onlyOwner {
        if (admin == newAdmin) revert();
        emit AdminOwnershipTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}",changeAdmin,"[{'function': 'changeAdmin', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newAdmin""}, ""right"": {""type"": ""Identifier"", ""name"": ""admin""}}, {""type"": ""stringLiteral"", ""value"": ""New admin address cannot be the same as the current admin""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldAdmin"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""admin""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""admin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAdmin""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AdminOwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldAdmin""}, {""type"": ""Identifier"", ""name"": ""newAdmin""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""validateAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""newAdmin""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.8695612332823935,0.2671879569034687,"pragma solidity ^0.8.0;

contract MyContract {
    address public admin;

    event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier validateAddress(address _address) {
        require(_address != address(0), ""Invalid address"");
        _;
    }

    constructor(address _admin) {
        admin = _admin;
    }

    function changeAdmin(address newAdmin) public onlyAdmin validateAddress(newAdmin) {
        require(newAdmin != admin, ""New admin address cannot be the same as the current admin"");
        address oldAdmin = admin;
        admin = newAdmin;
        emit AdminOwnershipTransferred(oldAdmin, newAdmin);
    }
}",42.28500556945801,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public admin;

    event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier validateAddress(address _address) {
        require(_address != address(0), ""Invalid address"");
        _;
    }

    constructor(address _admin) {
        admin = _admin;
    }

    function changeAdmin(address newAdmin) public onlyAdmin validateAddress(newAdmin) {
        require(newAdmin != admin, ""New admin address cannot be the same as the current admin"");
        address oldAdmin = admin;
        admin = newAdmin;
        emit AdminOwnershipTransferred(oldAdmin, newAdmin);
    }
}"
4898,Announces intent to withdraw tokens using ` slowWithdraw `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AnnounceWithdrawalWrapper is Ownable {
    using SafeMath for uint256;

    struct AnnouncedWithdrawal {
        uint256 canWithdrawAt;
        uint256 amount;
    }

    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;
    uint256 public withdrawAnnounceDelay;

    constructor(uint256 _withdrawAnnounceDelay) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }

    function announceWithdraw(address _token, uint256 _amount) external onlyOwner {
        require(_amount <= balances[msg.sender][_token], ""Amount too high"");
        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];
        uint256 canWithdrawAt = block.timestamp + withdrawAnnounceDelay;
        announcement.canWithdrawAt = canWithdrawAt;
        announcement.amount = _amount;
        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
    }
}",announceWithdrawal,"[{'function': 'announceWithdrawal', 'complexity': 2}, {'function': 'checkBalance', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceWithdrawal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""checkBalance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""canWithdrawAtTimestamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""withdrawAnnounceDelay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""announcedWithdrawals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AnnouncedWithdrawal""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""canWithdrawAtTimestamp""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WithdrawAnnounce""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""canWithdrawAtTimestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.7817488998998845,0.2559488534420899,"pragma solidity ^0.8.0;

contract WithdrawalAnnouncer {

    uint256 public withdrawAnnounceDelay;
    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;

    struct AnnouncedWithdrawal {
        uint256 amount;
        uint256 canWithdrawAt;
    }

    event WithdrawAnnounce(address indexed user, address indexed token, uint256 amount, uint256 canWithdrawAt);

    constructor(uint256 _withdrawAnnounceDelay) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }


    function announceWithdrawal(address _token, uint256 _amount) public {
        require(_amount > 0, ""Amount must be greater than zero"");

        // Assume a balance check function exists elsewhere, replace with your actual balance check
        require(checkBalance(_token, _amount), ""Insufficient balance"");

        uint256 canWithdrawAtTimestamp = block.timestamp + withdrawAnnounceDelay;
        announcedWithdrawals[msg.sender][_token] = AnnouncedWithdrawal(_amount, canWithdrawAtTimestamp);

        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAtTimestamp);
    }

    // Placeholder for balance check - replace with your actual implementation
    function checkBalance(address _token, uint256 _amount) internal view returns (bool) {
        // Replace this with your actual balance check logic
        // Example:  IERC20(_token).balanceOf(msg.sender) >= _amount
        return true;
    }
}",43.0279541015625,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WithdrawalAnnouncer is Ownable {
    uint256 public withdrawAnnounceDelay;
    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;

    struct AnnouncedWithdrawal {
        uint256 amount;
        uint256 canWithdrawAt;
    }

    event WithdrawAnnounce(address indexed user, address indexed token, uint256 amount, uint256 canWithdrawAt);

    mapping(address => uint256) public balanceOf;

 constructor(uint256 _withdrawAnnounceDelay) Ownable(msg.sender) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }

    function announceWithdrawal(address _token, uint256 _amount) public {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(checkBalance(_token, _amount), ""Insufficient balance"");

        uint256 canWithdrawAtTimestamp = block.timestamp + withdrawAnnounceDelay;
        announcedWithdrawals[msg.sender][_token] = AnnouncedWithdrawal(_amount, canWithdrawAtTimestamp);

        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAtTimestamp);
    }

    function checkBalance(address _token, uint256 _amount) internal view returns (bool) {
        // Replace this with your actual balance check logic
        // Example:  IERC20(_token).balanceOf(msg.sender) >= _amount
        return true;
    }
}"
2359,Count the number of attribute types defined by the registry .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeCounter {
    using SafeMath for uint256;

    uint256[] private _attributeTypes;

    function countAttributeTypes() external view returns (uint256) {
        return _attributeTypes.length;
    }
}",addAttributeType,"[{'function': 'addAttributeType', 'complexity': 2}, {'function': 'countAttributeTypes', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAttributeType"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_attributeType"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_attributeType""}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_attributeType""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""attributeTypeCount""}, ""isPrefix"": False}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.596007944263841,0.0278546851736488,"pragma solidity ^0.8.0;

contract AttributeCounter {
    mapping(string => bool) attributeTypes;
    uint256 public attributeTypeCount;

    function addAttributeType(string memory _attributeType) public {
        if (!attributeTypes[_attributeType]) {
            attributeTypes[_attributeType] = true;
            attributeTypeCount++;
        }
    }

    function countAttributeTypes() public view returns (uint256) {
        return attributeTypeCount;
    }
}",41.52128958702088,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttributeCounter is Ownable {
    mapping(string => bool) private attributeTypes;
    uint256 public attributeTypeCount;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        attributeTypeCount = 1;
    }

    function addAttributeType(string memory _attributeType) public {
        if (!attributeTypes[_attributeType]) {
            attributeTypes[_attributeType] = true;
            attributeTypeCount++;
        }
    }

    function countAttributeTypes() public view returns (uint256) {
        return attributeTypeCount;
    }
}"
239,Register a new child universe after a fork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IUniverse {
    function getWinningChildUniverse() external view returns (address);
}

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",initialize,"[{'function': 'initialize', 'complexity': 2}, {'function': 'getWinningChildUniverse', 'complexity': 0}, {'function': 'pose', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""initialUniverse"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""initialized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Contract already initialized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""latest_universe""}, ""right"": {""type"": ""Identifier"", ""name"": ""initialUniverse""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""initialized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.4786800624947012,0.0251829881736136,"pragma solidity ^0.8.0;

contract UniverseForker {

    uint256 public latest_universe;
    bool public initialized;

    modifier onlyInitialized() {
        require(initialized, ""Contract not initialized"");
        _;
    }

    function initialize(uint256 initialUniverse) public {
        require(!initialized, ""Contract already initialized"");
        latest_universe = initialUniverse;
        initialized = true;
    }


    function getWinningChildUniverse(uint256 universeId) public view returns (uint256) {
        //Implementation to get winning child universe.  Replace with actual logic.
        return universeId + 1; // Placeholder
    }

    function pose() public onlyInitialized {
        latest_universe = getWinningChildUniverse(latest_universe);
    }
}",41.97071599960327,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract UniverseForker is Ownable {
    uint256 public latest_universe;
    bool public initialized;

    modifier onlyInitialized() {
        require(initialized, ""Contract not initialized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        latest_universe = 1; // Set to 1 (never 0)
        initialized = true; // Set to true
    }

    function initialize(uint256 initialUniverse) public {
        require(!initialized, ""Contract already initialized"");
        latest_universe = initialUniverse;
        initialized = true;
    }

    function getWinningChildUniverse(uint256 universeId) public view returns (uint256) {
        //Implementation to get winning child universe.  Replace with actual logic.
        return universeId + 1; // Placeholder
    }

    function pose() public onlyInitialized {
        latest_universe = getWinningChildUniverse(latest_universe);
    }
}"
4301,` callPlugins ` calls ` callPluginsPledge ` once for the transfer context and once for the receiving context .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint amount) internal returns (uint allowedAmount) {
        allowedAmount = amount;
        allowedAmount = callPluginsPledge(before, fromPledge, fromPledge, toPledge, allowedAmount);
        allowedAmount = callPluginsPledge(before, toPledge, fromPledge, toPledge, allowedAmount);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",callPlugins,"[{'function': 'callPlugins', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""callPlugins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""before"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""fromPledge"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""toPledge"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""allowedAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""callPluginsPledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""before""}, {""type"": ""Identifier"", ""name"": ""fromPledge""}, {""type"": ""Identifier"", ""name"": ""fromPledge""}, {""type"": ""Identifier"", ""name"": ""allowedAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""callPluginsPledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""before""}, {""type"": ""Identifier"", ""name"": ""toPledge""}, {""type"": ""Identifier"", ""name"": ""toPledge""}, {""type"": ""Identifier"", ""name"": ""allowedAmount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.5649148132802191,0.0346527313220127,"pragma solidity ^0.8.0;

contract PluginManager {

    uint256 public allowedAmount;

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint256 amount) internal {
        allowedAmount = amount;
        callPluginsPledge(before, fromPledge, fromPledge, allowedAmount);
        callPluginsPledge(before, toPledge, toPledge, allowedAmount);
    }

    function callPluginsPledge(bool before, uint64 fromPledge, uint64 toPledge, uint256 amount) internal virtual;
}",41.76102828979492,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PluginManager is Ownable {
    uint256 public allowedAmount;

    constructor() Ownable(msg.sender) {
        allowedAmount = 1; // Set to a non-zero, safe value for uint256
    }

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint256 amount) internal {
        allowedAmount = amount;
        callPluginsPledge(before, fromPledge, fromPledge, allowedAmount);
        callPluginsPledge(before, toPledge, toPledge, allowedAmount);
    }

    function callPluginsPledge(bool before, uint64 fromPledge, uint64 toPledge, uint256 amount) internal virtual;
}"
2476,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}",burn,"[{'function': 'burn', 'complexity': 1}, {'function': 'add', 'complexity': 1}, {'function': 'sub', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9912164244917232,0.8902284565158869,"pragma solidity ^0.8.0;

contract MyToken {
    using SafeMath for uint256;

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) public returns (bool) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
}",42.64695477485657,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply = 1000000000000000000;
    mapping(address => uint256) public balanceOf;
    event Burn(address indexed from, uint256 value);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        balanceOf[owner()] = 1;
        totalSupply = 1000000000000000000;
    }

    function burn(uint256 _value) public returns (bool) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
}"
2621,Only registrations in future can be removed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function unregister(
        bytes32 _key,
        address _address,
        uint _timestamp,
        uint _gasLimit,
        uint _gasPrice
    ) external returns (uint) {
        // Function body here
    }
}",unregister,"[{'function': 'unregister', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""unregister"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_timestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_gasLimit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_gasPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""memberName"": ""balance""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_gasLimit""}, ""right"": {""type"": ""Identifier"", ""name"": ""_gasPrice""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to cover transaction cost""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Unregistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_key""}, {""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""_timestamp""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.6939386155025462,0.1023204442684948,"pragma solidity ^0.8.0;

contract Unregistration {

    event Unregistered(bytes32 _key, address _address, uint256 _timestamp);

    function unregister(bytes32 _key, address _address, uint256 _timestamp, uint256 _gasLimit, uint256 _gasPrice) external {
        require(msg.sender.balance >= _gasLimit * _gasPrice, ""Insufficient balance to cover transaction cost"");
        // Add any necessary logic to check timestamp validity and other unregistration constraints here.
        // Example: require(_timestamp >= block.timestamp - 60, ""Timestamp is invalid"");

        // Add logic to remove the association between _key and _address.  This will depend on your data structure.  Example below assumes a mapping:
        // delete registrations[_key];

        emit Unregistered(_key, _address, _timestamp);
    }
}",42.03684639930725,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Unregistration is Ownable {
    event Unregistered(bytes32 _key, address _address, uint256 _timestamp);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function unregister(bytes32 _key, address _address, uint256 _timestamp, uint256 _gasLimit, uint256 _gasPrice) external {
        require(msg.sender.balance >= _gasLimit * _gasPrice, ""Insufficient balance to cover transaction cost"");
        // Add any necessary logic to check timestamp validity and other unregistration constraints here.
        // Example: require(_timestamp >= block.timestamp - 60, ""Timestamp is invalid"");

        // Add logic to remove the association between _key and _address.  This will depend on your data structure.  Example below assumes a mapping:
        // delete registrations[_key];

        emit Unregistered(_key, _address, _timestamp);
    }
}"
2632,the goal the campaign must reach in order for it to succeed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Crowdfunding {
    using SafeMath for uint256;

    uint256 public totalAmountRaised;

    function amountRaised() public view returns (uint256) {
        return totalAmountRaised;
    }
}",amountRaised,"[{'function': 'amountRaised', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""amountRaised"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""amount""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9377559304077624,0.855526185871245,"pragma solidity ^0.8.0;

contract Fundraiser {
    uint256 public amount;

    function amountRaised() public view returns (uint256) {
        return amount;
    }
}",41.16527676582336,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Fundraiser is Ownable {
    uint256 public amount;

    constructor() Ownable(msg.sender) {
        amount = 1;
    }

    function amountRaised() public view returns (uint256) {
        return amount;
    }
}"
827,approving image to be taken from specific address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract MarketplaceWrapper is Ownable {
    using SafeMath for uint256;

    address public marketplaceContract;

    constructor(address _marketplaceContract) {
        require(_marketplaceContract != address(0), ""Invalid marketplace contract address"");
        marketplaceContract = _marketplaceContract;
    }

    function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyOwner {
        require(msg.sender == marketplaceContract, ""Only the marketplace contract can call this function"");
        require(isApprovedOrOwner(_from, _imageId), ""The token is not approved or owned by the sender"");
        clearApproval(_from, _imageId);
        removeTokenFrom(_from, _imageId);
        addTokenTo(_to, _imageId);
        emit Transfer(_from, _to, _imageId);
    }
}",transferFromMarketplace,"[{'function': 'isApprovedOrOwner', 'complexity': 0}, {'function': 'transferFromMarketplace', 'complexity': 2}, {'function': '_indexOf', 'complexity': 3}, {'function': 'setMarketplaceContract', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFromMarketplace"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_imageId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isApprovedOrOwner""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not approved or owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_tokenApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_imageId""}}, ""isPrefix"": True}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""indexFrom"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_indexOf""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""indexFrom""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}, {""type"": ""stringLiteral"", ""value"": ""Token not owned by from address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""indexFrom""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_owners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_imageId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyMarketplaceContract"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.5618471208003133,0.4423037152858354,"pragma solidity ^0.8.0;

contract MyContract {

    // Define necessary state variables (replace with your actual implementation)
    mapping(uint256 => address) private _owners;
    mapping(address => uint256[]) private _ownedTokens;
    mapping(uint256 => address) private _tokenApprovals;
    address private _marketplaceContract;


    modifier onlyMarketplaceContract() {
        require(msg.sender == _marketplaceContract, ""Only marketplace contract can call this function"");
        _;
    }

    function isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        address owner = _owners[tokenId];
        return (spender == owner || _tokenApprovals[tokenId] == spender);
    }

    function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyMarketplaceContract {
        require(isApprovedOrOwner(msg.sender, _imageId), ""Caller is not approved or owner"");

        delete _tokenApprovals[_imageId];

        uint256 indexFrom = _indexOf(_ownedTokens[_from], _imageId);
        require(indexFrom != type(uint256).max, ""Token not owned by from address"");
        _ownedTokens[_from][indexFrom] = _ownedTokens[_from][_ownedTokens[_from].length - 1];
        _ownedTokens[_from].pop();

        _owners[_imageId] = _to;
        _ownedTokens[_to].push(_imageId);

        emit Transfer(_from, _to, _imageId);
    }

    function _indexOf(uint256[] storage array, uint256 value) internal view returns (uint256) {
        for (uint256 i = 0; i < array.length; i++) {
            if (array[i] == value) {
                return i;
            }
        }
        return type(uint256).max;
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    //Set Marketplace Contract Address
    function setMarketplaceContract(address marketplaceAddress) public {
        _marketplaceContract = marketplaceAddress;
    }
}",44.1367871761322,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    // Define necessary state variables (replace with your actual implementation)
    mapping(uint256 => address) private _owners;
    mapping(address => uint256[]) private _ownedTokens;
    mapping(uint256 => address) private _tokenApprovals;
    address private _marketplaceContract;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe values
        _owners[1] = 0x1111111111111111111111111111111111111111; // Replace with actual owner address
        _ownedTokens[1].push(1);
        _tokenApprovals[1] = 0x2222222222222222222222222222222222222222; // Replace with actual approval address
        _marketplaceContract = 0x3333333333333333333333333333333333333333; // Replace with actual marketplace contract address
    }

    modifier onlyMarketplaceContract() {
        require(msg.sender == _marketplaceContract, ""Only marketplace contract can call this function"");
        _;
    }

    function isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        address owner = _owners[tokenId];
        return (spender == owner || _tokenApprovals[tokenId] == spender);
    }

    function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyMarketplaceContract {
        require(isApprovedOrOwner(msg.sender, _imageId), ""Caller is not approved or owner"");

        delete _tokenApprovals[_imageId];

        uint256 indexFrom = _indexOf(_ownedTokens[_from], _imageId);
        require(indexFrom != type(uint256).max, ""Token not owned by from address"");
        _ownedTokens[_from][indexFrom] = _ownedTokens[_from][_ownedTokens[_from].length - 1];
        _ownedTokens[_from].pop();

        _owners[_imageId] = _to;
        _ownedTokens[_to].push(_imageId);

        emit Transfer(_from, _to, _imageId);
    }

    function _indexOf(uint256[] storage array, uint256 value) internal view returns (uint256) {
        for (uint256 i = 0; i < array.length; i++) {
            if (array[i] == value) {
                return i;
            }
        }
        return type(uint256).max;
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    //Set Marketplace Contract Address
    function setMarketplaceContract(address marketplaceAddress) public onlyOwner {
        _marketplaceContract = marketplaceAddress;
    }
}"
3458,"http : //solidity.readthedocs.io/en/develop/contracts.html # fallback-function we dont need recieve ETH always , only in State.Sale from externally accounts .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum State { Sale, Paused }
    State public currentState = State.Sale;

    function byTokens() internal view virtual;

    modifier atState(State state) {
        require(currentState == state, ""Not in the correct state"");
        _;
    }

    function () external payable atState(State.Sale) {
        byTokens();
    }
}",byTokens,"[{'function': 'byTokens', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""byTokens""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""atState"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Sale""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",,0.6449745353062215,0.0805111000764593,"pragma solidity ^0.8.0;

contract MyContract {
    enum State {Sale, Finished}
    State public currentState;

    modifier atState(State _state) {
        require(currentState == _state, ""Incorrect contract state"");
        _;
    }

    function byTokens() internal {
        //Implementation for byTokens() function.  This is a placeholder.
    }


    function buyTokens() public payable atState(State.Sale) {
        byTokens();
    }
}",41.3154079914093,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    enum State { Sale, Finished }
    State public currentState = State.Sale;

    modifier atState(State _state) {
        require(currentState == _state, ""Incorrect contract state"");
        _;
    }

    function byTokens() internal {
        //Implementation for byTokens() function.  This is a placeholder.
    }

    function buyTokens() public payable atState(State.Sale) {
        byTokens();
    }

    constructor() Ownable(msg.sender) {
        currentState = State.Sale;
    }
}"
5648,Creates a checkpoint that can be used to query historical balances / totalSuppy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CheckpointModule is Ownable {
    using SafeMath for uint256;

    event LogCheckpointCreated(uint256 indexed checkpointId, uint256 timestamp);

    uint256 public currentCheckpointId = 0;
    constanst CHECKPOINT_KEY = bytes32(""CHECKPOINT_KEY"");

    modifier onlyModule(bytes32 moduleKey, bool allowed) {
        require(moduleKey == CHECKPOINT_KEY && allowed, ""Only the module can call this function."");
        _;
    }

    function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns (uint256) {
        require(currentCheckpointId < type(uint256).max.sub(1));
        currentCheckpointId = currentCheckpointId.add(1);
        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
        return currentCheckpointId;
    }
}",createCheckpoint,"[{'function': 'createCheckpoint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCheckpoint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}, {""type"": ""stringLiteral"", ""value"": ""Checkpoint overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, ""isPrefix"": False}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogCheckpointCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.676519782460318,0.3494859479955601,"pragma solidity ^0.8.0;

contract CheckpointContract {

    uint256 public currentCheckpointId;

    event LogCheckpointCreated(uint256 checkpointId, uint256 timestamp);

    function createCheckpoint() public {
        require(currentCheckpointId < type(uint256).max, ""Checkpoint overflow"");
        currentCheckpointId++;
        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
    }
}",41.623451709747314,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CheckpointContract is Ownable {
    uint256 public currentCheckpointId;

    event LogCheckpointCreated(uint256 checkpointId, uint256 timestamp);

    constructor() Ownable(msg.sender) {
        currentCheckpointId = 1; // Set to 1 (never 0)
    }

    function createCheckpoint() public {
        require(currentCheckpointId < type(uint256).max, ""Checkpoint overflow"");
        currentCheckpointId++;
        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
    }
}"
5200,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Invalid value"");
        require(msg.sender == _from || msg.sender == _to, ""Only the sender or recipient can call this function"");

        uint256 fromBalance = balanceOf[_from];
        require(_value <= fromBalance, ""Insufficient funds"");
        balanceOf[_from] = fromBalance.sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;
    }
}",transferFrom,"[{'function': 'transferFrom', 'complexity': 3}, {'function': 'approve', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",43.0,0.7839672136694524,0.3447269007614613,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    uint256 public totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",43.18569350242615,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    uint256 public totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalSupply = 1000000000000000000;
        balances[msg.sender] = 1000;
        allowed[msg.sender][address(this)] = 1;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
5602,Allows the owner to destroy the contract and return the tokens to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for IERC20;
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function destroy() public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");
        token.transfer(owner(), balance);
        selfdestruct(payable(owner()));
    }
}",pose,"[{'function': 'pose', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.9333030181872332,0.6886365564732174,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract is Ownable {

    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function pose() public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        token.transfer(owner(), balance);
        selfdestruct(payable(owner()));
    }
}",41.59541130065918,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {

    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function pose() public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        token.transfer(owner(), balance);
        selfdestruct(payable(owner()));
    }
}"
1932,Called to obtain the loyalty reward balance of any given member,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 stakeBalance;
        uint256 previouslyAppliedLoyaltyBalance;
    }

    mapping(address => Member) public members;
    uint256 public loyaltyPeriodDays;
    uint256 public loyaltyRewardAmount;

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256 loyaltyReward) {
        require(members[memberAddress].startOfLoyaltyRewardEligibility != 0, ""Member not eligible for loyalty rewards"");
        uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;
        Member storage thisMember = members[memberAddress];
        uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;
        loyaltyReward = thisMember.previouslyAppliedLoyaltyBalance;
        if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {
            uint256 numWholePeriods = elapsedTimeSinceEligible / loyaltyPeriodSeconds;
            uint256 rewardForEachPeriod = thisMember.stakeBalance * loyaltyRewardAmount / 100;
            loyaltyReward += rewardForEachPeriod * numWholePeriods;
        }
    }
}",getLoyaltyRewardBalance,"[{'function': 'getLoyaltyRewardBalance', 'complexity': 1}, {'function': 'mul', 'complexity': 2}, {'function': 'div', 'complexity': 1}, {'function': 'add', 'complexity': 1}, {'function': 'sub', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLoyaltyRewardBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""memberAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""loyaltyPeriodSeconds"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""loyaltyPeriodDays""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""86400"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Member""}, ""name"": ""member"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""memberAddress""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""member""}, ""memberName"": ""startOfLoyaltyRewardEligibility""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""loyaltyReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""member""}, ""memberName"": ""previouslyAppliedLoyaltyBalance""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""loyaltyPeriodSeconds""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numberOfLoyaltyPeriods"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""elapsedTime""}, {""type"": ""Identifier"", ""name"": ""loyaltyPeriodSeconds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""rewardPerPeriod"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""member""}, ""memberName"": ""stakeBalance""}, {""type"": ""Identifier"", ""name"": ""loyaltyRewardAmount""}], ""names"": []}, {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""loyaltyReward""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""loyaltyReward""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rewardPerPeriod""}, {""type"": ""Identifier"", ""name"": ""numberOfLoyaltyPeriods""}], ""names"": []}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""Identifier"", ""name"": ""loyaltyReward""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",15.0,0.8100831683283428,0.2784058400482638,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract LoyaltyReward {
    uint256 public loyaltyPeriodDays;
    mapping(address => Member) public members;

    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 stakeBalance;
        uint256 previouslyAppliedLoyaltyBalance;
    }
    uint256 public loyaltyRewardAmount;


    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256) {
        uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 86400;
        Member memory member = members[memberAddress];
        uint256 elapsedTime = block.timestamp - member.startOfLoyaltyRewardEligibility;
        uint256 loyaltyReward = member.previouslyAppliedLoyaltyBalance;

        if (elapsedTime >= loyaltyPeriodSeconds) {
            uint256 numberOfLoyaltyPeriods = SafeMath.div(elapsedTime, loyaltyPeriodSeconds);
            uint256 rewardPerPeriod = SafeMath.div(SafeMath.mul(member.stakeBalance, loyaltyRewardAmount), 100);
            loyaltyReward = SafeMath.add(loyaltyReward, SafeMath.mul(rewardPerPeriod, numberOfLoyaltyPeriods));
        }

        return loyaltyReward;
    }
}

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
}",44.243425369262695,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";

contract LoyaltyReward {
    using SafeMath for uint256;

    uint256 public loyaltyPeriodDays = 1; // Set to 1 (never 0)
    mapping(address => Member) public members;

    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 stakeBalance;
        uint256 previouslyAppliedLoyaltyBalance;
    }

    uint256 public loyaltyRewardAmount = 10; // Set to a fixed value for safety and testing purposes

    constructor() {
        initializeContract();
    }

    function initializeContract() internal {
        // Initialize state variables with safe, non-corner-case values
        loyaltyPeriodDays = 30; // A reasonable default period in days
        loyaltyRewardAmount = 15; // Example value for reward percentage

        // Fixed address values for demonstration purposes
        members[address(0x111)] = Member({
            startOfLoyaltyRewardEligibility: block.timestamp,
            stakeBalance: 1000,
            previouslyAppliedLoyaltyBalance: 0
        });

        members[address(0x222)] = Member({
            startOfLoyaltyRewardEligibility: block.timestamp,
            stakeBalance: 1500,
            previouslyAppliedLoyaltyBalance: 0
        });

        members[address(0x333)] = Member({
            startOfLoyaltyRewardEligibility: block.timestamp,
            stakeBalance: 2000,
            previouslyAppliedLoyaltyBalance: 0
        });
    }

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256) {
        uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 86400;
        Member memory member = members[memberAddress];
        uint256 elapsedTime = block.timestamp - member.startOfLoyaltyRewardEligibility;
        uint256 loyaltyReward = member.previouslyAppliedLoyaltyBalance;

        if (elapsedTime >= loyaltyPeriodSeconds) {
            uint256 numberOfLoyaltyPeriods = elapsedTime / loyaltyPeriodSeconds;
            uint256 rewardPerPeriod = (member.stakeBalance * loyaltyRewardAmount) / 100;
            loyaltyReward = loyaltyReward + (rewardPerPeriod * numberOfLoyaltyPeriods);
        }

        return loyaltyReward;
    }
}

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        uint256 c = a / b;
        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        uint256 c = a - b;
        return c;
    }
}"
4568,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfersEnabled() external view returns (bool);
    function doTransfer(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
    }

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(token.transfersEnabled(), ""Transfers are disabled"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        return token.doTransfer(msg.sender, _to, _amount);
    }
}",doTransfer,"[{'function': 'transfer', 'complexity': 1}, {'function': 'doTransfer', 'complexity': 1}, {'function': 'setTransfersEnabled', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transfersEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers are disabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.487564308743686,0.2818964796524624,"pragma solidity ^0.8.0;

contract MyContract {
    bool public transfersEnabled;

    function transfer(address _to, uint256 _amount) public returns (bool) {
        require(transfersEnabled, ""Transfers are disabled"");
        doTransfer(msg.sender, _to, _amount);
        return true;
    }

    function doTransfer(address _from, address _to, uint256 _amount) internal virtual {
        //Implementation of the transfer logic.  This is where you would typically interact with ERC20 transfer functions or similar.
        //Example (replace with your actual transfer logic):
        require(_amount > 0, ""Amount must be greater than zero"");
        //Your transfer logic here.  This might involve updating balances etc.
    }

    function setTransfersEnabled(bool _enabled) public {
        transfersEnabled = _enabled;
    }
}",42.1702082157135,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool public transfersEnabled;

    constructor() Ownable(msg.sender) {
        transfersEnabled = true; // Set to true instead of false, as it's the default state for a boolean variable but not its zero value.
    }

    function transfer(address _to, uint256 _amount) public returns (bool) {
        require(transfersEnabled, ""Transfers are disabled"");
        doTransfer(msg.sender, _to, _amount);
        return true;
    }

    function doTransfer(address _from, address _to, uint256 _amount) internal virtual {
        require(_amount > 0, ""Amount must be greater than zero"");
    }

    function setTransfersEnabled(bool _enabled) public {
        transfersEnabled = _enabled;
    }
}"
5799,Set the contract address of the rent auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RentAuction {
    function isRentAuction() external view returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    RentAuction public rentAuctionContract;

    function setRentAuctionContractAddress(address _address) external onlyOwner {
        RentAuction _contract = RentAuction(_address);
        require(_contract.isRentAuction());
        rentAuctionContract = _contract;
    }
}",setRentAuctionContract,"[{'function': 'setRentAuctionContract', 'complexity': 1}]",2.0,{},22.0,0.914985805945829,0.3994463928700864,"pragma solidity ^0.8.0;

contract MyContract {

    address public owner;
    RentAuction public rentAuctionContract;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    interface RentAuction {
        function isRentAuction() external view returns (bool);
    }

    function setRentAuctionContract(address _address) public onlyOwner {
        RentAuction rentAuction = RentAuction(_address);
        require(rentAuction.isRentAuction(), ""Invalid Rent Auction contract address"");
        rentAuctionContract = rentAuction;
    }
}",42.04857039451599,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner = msg.sender;
    RentAuction public rentAuctionContract;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    interface RentAuction {
        function isRentAuction() external view returns (bool);
    }

    function setRentAuctionContract(address _address) public onlyOwner {
        RentAuction rentAuction = RentAuction(_address);
        require(rentAuction.isRentAuction(), ""Invalid Rent Auction contract address"");
        rentAuctionContract = rentAuction;
    }
}"
694,Withdraw any accumulated fees to the specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for address;

    function withdraw(address payable addr) public onlyOwner {
        uint256 balance = address(this).balance;
        addr.transfer(balance);
    }
}",withdrawFunds,"[{'function': 'withdrawFunds', 'complexity': 1}]",2.0,{},18.0,0.7906099679838998,0.2772514145538133,"pragma solidity ^0.8.0;

contract MyContract {

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function."");
        _;
    }

    function withdrawFunds(address payable addr) public onlyOwner {
        (bool success, ) = addr.call{value: address(this).balance}("""");
        require(success, ""Transfer failed."");
    }
}",41.62859034538269,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address private owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function."");
        _;
    }

    function withdrawFunds(address payable addr) public onlyOwner {
        (bool success, ) = addr.call{value: address(this).balance}("""");
        require(success, ""Transfer failed."");
    }
}"
6751,Returns the amount of tokens approved by the owner that can be transferred to the spender 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance (address tokenOwner, address spender) public view returns (uint remaining) {
    return allowed[tokenOwner][spender];
}
}",allowance,"[{'function': 'allowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9777412554692626,0.8056920633274978,"pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) internal allowed;

    function allowance(address tokenOwner, address spender) public view returns (uint256) {
        return allowed[tokenOwner][spender];
    }
}",41.33904123306274,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) internal allowed;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        allowed[address(0x111)][address(0x222)] = 1;
        allowed[address(0x222)][address(0x333)] = 1;
    }

    function allowance(address tokenOwner, address spender) public view returns (uint256) {
        return allowed[tokenOwner][spender];
    }
}"
2680,Assigns bonus tokens to the specific contributor .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BonusAssignment {
    using SafeMath for uint256;

    uint256 public bonusProvided;
    mapping(address => uint256) public bonusHolders;

    event BonusAssigned(address indexed investor, uint256 bonus);

    function assignBonus(address _investor, uint256 _bonus) internal {
        if (_bonus == 0) {
            return;
        }
        bonusProvided = bonusProvided.add(_bonus);
        bonusHolders[_investor] = bonusHolders[_investor].add(_bonus);
        emit BonusAssigned(_investor, _bonus);
    }
}",assignBonus,"[{'function': 'assignBonus', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""assignBonus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_investor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_bonus"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_bonus""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Bonus amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""bonusProvided""}, ""right"": {""type"": ""Identifier"", ""name"": ""_bonus""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bonusHolders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_investor""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_bonus""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BonusAssigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_investor""}, {""type"": ""Identifier"", ""name"": ""_bonus""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.6693731924726627,0.4039063436101364,"pragma solidity ^0.8.0;

contract BonusAssignment {

    uint256 public bonusProvided;
    mapping(address => uint256) public bonusHolders;

    event BonusAssigned(address indexed investor, uint256 bonusAmount);

    function assignBonus(address _investor, uint256 _bonus) public {
        require(_bonus > 0, ""Bonus amount must be greater than zero"");
        bonusProvided += _bonus;
        bonusHolders[_investor] += _bonus;
        emit BonusAssigned(_investor, _bonus);
    }
}",41.91254234313965,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BonusAssignment is Ownable {
    uint256 public bonusProvided = 1;
    mapping(address => uint256) public bonusHolders;

    event BonusAssigned(address indexed investor, uint256 bonusAmount);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function assignBonus(address _investor, uint256 _bonus) public {
        require(_bonus > 0, ""Bonus amount must be greater than zero"");
        bonusProvided += _bonus;
        bonusHolders[_investor] += _bonus;
        emit BonusAssigned(_investor, _bonus);
    }
}"
3939,"Change the address of the registryAdmin , who has the privilege to create new accounts","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public registryAdmin;

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}",setRegistryAdmin,"[{'function': 'setRegistryAdmin', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRegistryAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newRegistryAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_oldRegistryAdmin"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""registryAdmin""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""registryAdmin""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newRegistryAdmin""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {
    address public registryAdmin;
    address public owner;

    constructor() {
        owner = msg.sender;
        registryAdmin = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function."");
        _;
    }

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}",41.69847655296326,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public registryAdmin;
    address public owner;

    constructor(address _owner) {
        owner = _owner;
        registryAdmin = _owner;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function."");
        _;
    }

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}"
3322,"Returns the contribution to be used as part of the transaction , and any refund value if expected .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Contribution {
        uint256 amount;
        bool processed;
    }

    mapping(address => Contribution) public contributions;
    uint256 public preSaleCap;

    event PresaleCapUpdated(uint256 newCap);
    event AllowedContributionCheck(uint256 allowedContribution, AllowedContributionState state);

    enum AllowedContributionState { WhitelistClosed, Whitelisted }

    function processContribution() public isValidContribution returns (uint256, uint256) {
        if (!honourWhitelist()) {
            var (allowedContribution, refundAmount) = getAllowedContribution();
            AllowedContributionCheck(allowedContribution, AllowedContributionState.WhitelistClosed);
            preSaleCap = preSaleCap.sub(allowedContribution);
            PresaleCapUpdated(preSaleCap);
            return (allowedContribution, refundAmount);
        }

        var (whiteListedAllowedContribution, whiteListedRefundAmount) = getAllowedContribution();
        if (whitelist[msg.sender] > 0) {
            return processWhitelistedContribution(whiteListedAllowedContribution, whiteListedRefundAmount);
        }

        revert();
    }

    function isValidContribution() internal view returns (bool) {
        // Implement your validation logic here
        return true;
    }

    function honourWhitelist() internal view returns (bool) {
        // Implement your whitelist check logic here
        return false;
    }

    function getAllowedContribution() internal view returns (uint256, uint256) {
        // Implement your logic to calculate allowed contribution and refund amount here
        return (0, 0);
    }

    function processWhitelistedContribution(uint256 whiteListedAllowedContribution, uint256 whiteListedRefundAmount) internal returns (uint256, uint256) {
        // Implement your logic for processing whitelisted contributions here
        return (whiteListedAllowedContribution, whiteListedRefundAmount);
    }
}",processContribution,"[{'function': 'honourWhitelist', 'complexity': 0}, {'function': 'getAllowedContribution', 'complexity': 0}, {'function': 'AllowedContributionCheck', 'complexity': 0}, {'function': 'processWhitelistedContribution', 'complexity': 0}, {'function': 'processContribution', 'complexity': 5}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""processContribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowedContribution"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refundAmount"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""Identifier"", ""name"": ""isValidContribution""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""honourWhitelist""}, ""arguments"": [], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""allowedContribution""}, {""type"": ""Identifier"", ""name"": ""refundAmount""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getAllowedContribution""}, ""arguments"": [], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AllowedContributionCheck""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""allowedContribution""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""preSaleCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""allowedContribution""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PresaleCapUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""preSaleCap""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""allowedContribution""}, {""type"": ""Identifier"", ""name"": ""refundAmount""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""processWhitelistedContribution""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Not whitelisted""}], ""names"": []}}]}}]}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""allowedContribution""}, {""type"": ""Identifier"", ""name"": ""refundAmount""}], ""isArray"": False}]}, ""visibility"": ""private"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.9070465677155276,0.5458058752853134,"pragma solidity ^0.8.0;

contract Presale {
    uint256 public preSaleCap;
    mapping(address => uint256) public whitelist;
    // ... other state variables and modifiers ...

    event PresaleCapUpdated(uint256 newCap);

    modifier isValidContribution() {
        // ... validation logic ...
        _;
    }

    function honourWhitelist() internal view returns (bool) {
        // ... logic to check whitelist status ...
    }

    function getAllowedContribution() internal view returns (uint256, uint256) {
        // ... logic to calculate allowed contribution and refund ...
    }

    function AllowedContributionCheck(uint256 _allowedContribution) internal {
        // ... logic for allowed contribution check and setting WhitelistClosed state ...
    }

    function processWhitelistedContribution(uint256 _allowedContribution, uint256 _refundAmount) internal {
        // ... logic to process whitelisted contribution ...
    }


    function processContribution() private returns (uint256, uint256) {
        uint256 allowedContribution;
        uint256 refundAmount;

        isValidContribution;

        if (!honourWhitelist()) {
            (allowedContribution, refundAmount) = getAllowedContribution();
            AllowedContributionCheck(allowedContribution);
            preSaleCap -= allowedContribution;
            emit PresaleCapUpdated(preSaleCap);
        } else {
            if (whitelist[msg.sender] > 0) {
                (allowedContribution, refundAmount) = processWhitelistedContribution(whitelist[msg.sender], 0);
            } else {
                revert(""Not whitelisted"");
            }
        }

        return (allowedContribution, refundAmount);
    }
}",44.02103900909424,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Presale is Ownable {
    uint256 public preSaleCap = 1;
    mapping(address => uint256) public whitelist;

    event PresaleCapUpdated(uint256 newCap);

    modifier isValidContribution() {
        // ... validation logic ...
        _;
    }

    function honourWhitelist() internal view returns (bool) {
        // ... logic to check whitelist status ...
    }

    function getAllowedContribution() internal view returns (uint256, uint256) {
        // ... logic to calculate allowed contribution and refund ...
    }

    function AllowedContributionCheck(uint256 _allowedContribution) internal {
        // ... logic for allowed contribution check and setting WhitelistClosed state ...
    }

    function processWhitelistedContribution(uint256 _allowedContribution, uint256 _refundAmount) internal {
        // ... logic to process whitelisted contribution ...
    }

    constructor() Ownable(msg.sender) {
        preSaleCap = 1;
    }

    function processContribution() private returns (uint256, uint256) {
        uint256 allowedContribution;
        uint256 refundAmount;

        isValidContribution;

        if (!honourWhitelist()) {
            (allowedContribution, refundAmount) = getAllowedContribution();
            AllowedContributionCheck(allowedContribution);
            preSaleCap -= allowedContribution;
            emit PresaleCapUpdated(preSaleCap);
        } else {
            if (whitelist[msg.sender] > 0) {
                (allowedContribution, refundAmount) = processWhitelistedContribution(whitelist[msg.sender], 0);
            } else {
                revert(""Not whitelisted"");
            }
        }

        return (allowedContribution, refundAmount);
    }
}"
3650,Method for setting a registered issuer firm authority,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface StorageInterface {
    function setBool(bytes32 id, bool value) external returns (bool);
    function setString(bytes32 id, string memory value) external returns (bool);
}

abstract contract Data {
    using SafeMath for uint256;
    StorageInterface public storageContract;

    constructor(address _storageAddress) {
        storageContract = StorageInterface(_storageAddress);
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) internal returns (bool success) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");
        bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));
        require(storageContract.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        require(storageContract.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        return true;
    }

    function isRegisteredFirm(string memory firm) internal view returns (bool) {
        // Implement the logic to check if a firm is registered
        // This is just a placeholder implementation
        bytes32 id = keccak256(abi.encodePacked(""registered.firm"", firm));
        return true; // Replace with actual storage retrieval logic
    }
}",setRegisteredAuthority,"[{'function': 'setString', 'complexity': 0}, {'function': 'isRegisteredFirm', 'complexity': 0}, {'function': 'setRegisteredAuthority', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRegisteredAuthority"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""issuerFirm"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""authorityAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isRegisteredFirm""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""issuerFirm""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: `issuerFirm` must be registered.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id_a"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registered.authority""}, {""type"": ""Identifier"", ""name"": ""issuerFirm""}, {""type"": ""Identifier"", ""name"": ""authorityAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id_b"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registered.authority.firm""}, {""type"": ""Identifier"", ""name"": ""authorityAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Storage""}, ""memberName"": ""setBool""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id_a""}, {""type"": ""Identifier"", ""name"": ""approved""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Storage""}, ""memberName"": ""setString""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id_b""}, {""type"": ""Identifier"", ""name"": ""issuerFirm""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9866176991264576,0.9145012709541048,"pragma solidity ^0.8.0;

interface IStorage {
    function setBool(bytes32 key, bool value) external returns (bool);
    function setString(bytes32 key, string memory value) external returns (bool);
}

contract MyContract {
    IStorage public Storage;

    constructor(address _storageAddress) {
        Storage = IStorage(_storageAddress);
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool) {
        //Implementation for isRegisteredFirm
        //This is a placeholder, replace with your actual implementation.
        return true; //Replace with your logic
    }


    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) public returns (bool) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");

        bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));

        require(Storage.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        require(Storage.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");

        return true;
    }
}",42.84279179573059,"pragma solidity ^0.8.0;

interface IStorage {
    function setBool(bytes32 key, bool value) external returns (bool);
    function setString(bytes32 key, string memory value) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IStorage public Storage;

    constructor(address _storageAddress) Ownable(msg.sender) {
        Storage = IStorage(_storageAddress);
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool) {
        //Implementation for isRegisteredFirm
        //This is a placeholder, replace with your actual implementation.
        return true; //Replace with your logic
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) public returns (bool) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");

        bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));

        require(Storage.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        require(Storage.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");

        return true;
    }
}"
4267,"Returns holder id for the specified address , creates it if needed .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderRegistration {
    using SafeMath for uint256;

    struct HoldersData {
        uint countryCode;
        bool operational;
        uint sendLimPerDay;
        uint sendLimPerMonth;
        uint holderAddressCount;
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
    }

    bytes32[] public holderIndex;
    mapping(bytes32 => uint) public holderAddress2Id;
    uint public holdersCount;
    mapping(address => bytes32) public holderAddress2ExternalId;
    HoldersData[] public holders;
    address public oracle;

    uint constant MAX_TOKEN_HOLDER_NUMBER = 10000;
    uint constant OK = 1;

    modifier onlyOracleOrOwner() {
        require(msg.sender == owner() || msg.sender == oracle, ""Only owner or oracle can call this function"");
        _;
    }

    constructor() {
        holdersCount = 0;
    }

    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {
        require(_holderAddress != address(0));
        require(holderIndex[_externalHolderId] == bytes32(0));
        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];
        require(_holderIndex == 0);
        _createCountryId(_countryCode);
        _holderIndex = holdersCount.add(1);
        holdersCount = _holderIndex;
        HoldersData storage _holderData = holders[_holderIndex];
        _holderData.countryCode = _countryCode;
        _holderData.operational = true;
        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;
        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;
        uint _firstAddressIndex = 1;
        _holderData.holderAddressCount = _firstAddressIndex;
        _holderData.address2Index[_holderAddress] = _firstAddressIndex;
        _holderData.index2Address[_firstAddressIndex] = _holderAddress;
        holderIndex[_externalHolderId] = bytes32(_holderIndex);
        holderAddress2Id[_holderAddress] = _externalHolderId;
        emit HolderRegistered(_externalHolderId, _holderIndex, _countryCode);
        return OK;
    }

    function _createCountryId(uint _countryCode) internal {
        // Implementation for creating country ID
    }

    event HolderRegistered(bytes32 indexed externalHolderId, uint indexed holderIndex, uint countryCode);
}",registerHolder,"[{'function': '_createCountryId', 'complexity': 1}, {'function': '_emitHolderRegistered', 'complexity': 0}, {'function': 'registerHolder', 'complexity': 3}]",10.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerHolder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_externalHolderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_holderAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_countryCode"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_holderAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Zero address not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""External ID already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderAddress2Id""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderAddress""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Address already registered""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newCountryId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createCountryId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_countryCode""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newHolderIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""holdersCount""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""newHolderIndex""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Holder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newCountryId""}, {""type"": ""BooleanLiteral"", ""value"": True}, {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newHolderIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderAddress2Id""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_emitHolderRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_externalHolderId""}, {""type"": ""Identifier"", ""name"": ""newHolderIndex""}, {""type"": ""Identifier"", ""name"": ""newCountryId""}], ""names"": []}}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",76.0,0.7064542914182721,0.2771778561781913,"pragma solidity ^0.8.0;

contract HolderRegistry {

    uint256 public holdersCount;
    mapping(bytes32 => uint256) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    mapping(uint256 => Holder) public holders;
    mapping(string => uint256) public countryId;

    struct Holder {
        uint256 countryId;
        bool operational;
        uint256 sendingLimit;
    }

    event HolderRegistered(bytes32 indexed externalHolderId, uint256 indexed holderIndex, uint256 countryId);

    function _createCountryId(string memory _countryCode) internal returns (uint256) {
        uint256 id = countryId[_countryCode];
        if (id == 0) {
            id = countryId[_countryCode] = countryId.length() + 1;
        }
        return id;
    }


    function _emitHolderRegistered(bytes32 _externalHolderId, uint256 _holderIndex, uint256 _countryId) internal {
        emit HolderRegistered(_externalHolderId, _holderIndex, _countryId);
    }

    function registerHolder(bytes32 _externalHolderId, address _holderAddress, string memory _countryCode) public returns (uint256) {
        require(_holderAddress != address(0), ""Zero address not allowed"");
        require(holderIndex[_externalHolderId] == 0, ""External ID already registered"");
        require(holderAddress2Id[_holderAddress] == 0, ""Address already registered"");

        uint256 newCountryId = _createCountryId(_countryCode);
        uint256 newHolderIndex = holdersCount++;
        holders[newHolderIndex] = Holder(newCountryId, true, 100); //Example limit
        holderIndex[_externalHolderId] = newHolderIndex;
        holderAddress2Id[_holderAddress] = _externalHolderId;
        _emitHolderRegistered(_externalHolderId, newHolderIndex, newCountryId);
        return 1; //OK
    }
}",43.88931775093079,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HolderRegistry is Ownable {
    uint256 public holdersCount;
    mapping(bytes32 => uint256) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    mapping(uint256 => Holder) public holders;
    mapping(string => uint256) public countryId;

    struct Holder {
        uint256 countryId;
        bool operational;
        uint256 sendingLimit;
    }

    event HolderRegistered(bytes32 indexed externalHolderId, uint256 indexed holderIndex, uint256 countryId);

    constructor() Ownable(msg.sender) {
        holdersCount = 0;
        // Initialize mappings with safe non-corner-case values
        holderAddress2Id[address(1)] = bytes32('init');
        holderAddress2Id[address(2)] = bytes32('init2');
        holderAddress2Id[address(3)] = bytes32('init3');
    }

    function _createCountryId(string memory _countryCode) internal returns (uint256) {
        uint256 id = countryId[_countryCode];
        if (id == 0) {
            id = countryId[_countryCode] = countryId.length() + 1;
        }
        return id;
    }

    function _emitHolderRegistered(bytes32 _externalHolderId, uint256 _holderIndex, uint256 _countryId) internal {
        emit HolderRegistered(_externalHolderId, _holderIndex, _countryId);
    }

    function registerHolder(bytes32 _externalHolderId, address _holderAddress, string memory _countryCode) public returns (uint256) {
        require(_holderAddress != address(0), ""Zero address not allowed"");
        require(holderIndex[_externalHolderId] == 0, ""External ID already registered"");
        require(holderAddress2Id[_holderAddress] == 0, ""Address already registered"");

        uint256 newCountryId = _createCountryId(_countryCode);
        uint256 newHolderIndex = holdersCount++;
        holders[newHolderIndex] = Holder(newCountryId, true, 100); //Example limit
        holderIndex[_externalHolderId] = newHolderIndex;
        holderAddress2Id[_holderAddress] = _externalHolderId;
        _emitHolderRegistered(_externalHolderId, newHolderIndex, newCountryId);
        return 1; //OK
    }
}"
5707,` onlyOwner ` An efficient way to cancel multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiCancel(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal virtual;
}",multiCancel,"[{'function': 'multiCancel', 'complexity': 1}, {'function': 'doCancelPayment', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_idPayments"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doCancelPayment""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9873240394535692,0.9061874434879644,"pragma solidity ^0.8.0;

contract PaymentContract {

    // ... other contract code ...

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    function multiCancel(uint256[] memory _idPayments) public onlyOwner {
        for (uint256 i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal {
        //Implementation to cancel a single payment.  This will update the contract's state.
    }

    // ... other contract code ...

    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }

}",41.996739864349365,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentContract is Ownable {

    // ... other contract code ...

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    function multiCancel(uint256[] memory _idPayments) public onlyOwner {
        for (uint256 i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal {
        //Implementation to cancel a single payment.  This will update the contract's state.
    }

    // ... other contract code ...

}"
32,Allows the owner of this contract to set the currentPrice for each token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;
    uint256 public currentPrice;

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}",setCurrentPrice,"[{'function': 'setCurrentPrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCurrentPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public currentPrice;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}",41.54405808448792,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public currentPrice;
    address public owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        currentPrice = 1;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}"
2463,Gets a given contract address by bytes32 in order to save gas,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractRegistry is Ownable {
    using SafeMath for uint256;

    address public registryAddress;
    bytes32 private constant REGISTRY_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    constructor(address _registryAddress) {
        registryAddress = _registryAddress;
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
        bytes32 _name32 = keccak256(abi.encodePacked(_name));
        assembly {
            let _registry := sload(REGISTRY_SLOT)
            let _pointer := mload(0x40)
            mstore(_pointer, _signature)
            mstore(add(_pointer, 0x04), _name32)
            let result := staticcall(gas(), _registry, _pointer, 0x24, _pointer, 0x20)
            if iszero(result) {
                revert(0, 0)
            }
            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}",getContractAddress,"[{'function': 'getContractAddress', 'complexity': 1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""_signature"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""getContractAddress32(bytes32)""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_name32"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_registry"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint160""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""sload""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""registry_slot""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""_pointer""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""HexNumber"", ""value"": ""0x40""}]}}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""_signature"", ""arguments"": []}]}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x04""}]}, {""type"": ""AssemblyExpression"", ""functionName"": ""_name32"", ""arguments"": []}]}, {""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""result""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""staticcall"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""gas"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""_registry"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x24""}, {""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x20""}]}}, {""type"": ""AssemblyIf"", ""condition"": {""type"": ""AssemblyExpression"", ""functionName"": ""iszero"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""result"", ""arguments"": []}]}, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyExpression"", ""functionName"": ""revert"", ""arguments"": [{""type"": ""DecimalNumber"", ""value"": ""0""}, {""type"": ""DecimalNumber"", ""value"": ""0""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""_contractAddress""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}]}}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""HexNumber"", ""value"": ""0x40""}, {""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x24""}]}]}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",14.0,0.9512379518086408,0.9003428981548299,"pragma solidity ^0.8.0;

contract ContractRetriever {

    uint256 internal registry_slot;

    constructor(address registryAddress) {
        registry_slot = uint256(uint160(registryAddress));
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
        bytes32 _name32 = keccak256(abi.encodePacked(_name));
        address _registry = address(uint160(sload(registry_slot)));
        assembly {
            let _pointer := mload(0x40)
            mstore(_pointer, _signature)
            mstore(add(_pointer, 0x04), _name32)
            let result := staticcall(gas(), _registry, _pointer, 0x24, _pointer, 0x20)
            if iszero(result) { revert(0, 0) }
            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}",42.80638575553894,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ContractRetriever is Ownable {
    uint256 internal registry_slot;

    constructor(address registryAddress) Ownable(msg.sender) {
        require(registryAddress != address(0), ""Invalid registry address"");
        registry_slot = uint256(uint160(registryAddress));
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
        bytes32 _name32 = keccak256(abi.encodePacked(_name));
        address _registry = address(uint160(sload(registry_slot)));
        assembly {
            let _pointer := mload(0x40)
            mstore(_pointer, _signature)
            mstore(add(_pointer, 0x04), _name32)
            let result := staticcall(gas(), _registry, _pointer, 0x24, _pointer, 0x20)
            if iszero(result) { revert(0, 0) }
            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}"
1777,"Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeManager is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        bool exists;
        uint256 minimumStake;
    }

    mapping(uint256 => AttributeType) private _attributeTypes;

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) external onlyOwner {
        require(_attributeTypes[ID].exists, ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID].minimumStake = minimumRequiredStake;
    }
}",setAttributeTypeMinimumRequiredStake,"[{'function': 'isAttributeType', 'complexity': 0}, {'function': 'setAttributeTypeMinimumRequiredStake', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAttributeTypeMinimumRequiredStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""minimumRequiredStake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isAttributeType""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ID""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""unable to set minimum stake, no attribute type with the provided ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""ID""}}, ""memberName"": ""minimumStake""}, ""right"": {""type"": ""Identifier"", ""name"": ""minimumRequiredStake""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.8129601880559267,0.7692180976814641,"pragma solidity ^0.8.0;

contract MyContract {

    struct AttributeType {
        uint256 minimumStake;
        // other fields...
    }

    mapping(uint256 => AttributeType) internal _attributeTypes;

    function isAttributeType(uint256 _id) internal view returns (bool) {
        return _attributeTypes[_id].minimumStake != 0; // Or any other suitable check
    }

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) public {
        require(isAttributeType(ID), ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID].minimumStake = minimumRequiredStake;
    }
}",41.86825466156006,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct AttributeType {
        uint256 minimumStake;
        // other fields...
    }

    mapping(uint256 => AttributeType) internal _attributeTypes;

    function isAttributeType(uint256 _id) internal view returns (bool) {
        return _attributeTypes[_id].minimumStake != 0; // Or any other suitable check
    }

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) public {
        require(isAttributeType(ID), ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID].minimumStake = minimumRequiredStake;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables according to the rules
        for (uint256 i = 1; i <= 3; i++) {
            _attributeTypes[i] = AttributeType({minimumStake: uint256(i)});
        }
    }
}"
2431,"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public controller;

    function () external payable {
        require(isContract(controller), ""Controller must be a contract"");
        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender), ""Proxy payment failed"");
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

interface TokenController {
    function proxyPayment() external payable returns (bool);
}",isContract,"[{'function': 'isContract', 'complexity': 0}]",1.0,{},20.0,0.9579891117876096,0.8166920319485289,"pragma solidity ^0.8.0;

contract MyContract {
    address public controller;

    constructor(address _controller) {
        controller = _controller;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }

    receive() external payable {
        require(isContract(controller), ""Controller is not a contract"");
        (bool success,) = controller.call{value: msg.value}(abi.encodeWithSignature(""proxyPayment(uint256,address)"", msg.value, msg.sender));
        require(success, ""Proxy payment failed"");
    }
}",41.83789253234863,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public controller;

    constructor(address _controller) Ownable(msg.sender) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }

    receive() external payable {
        require(isContract(controller), ""Controller is not a contract"");
        (bool success,) = controller.call{value: msg.value}(abi.encodeWithSignature(""proxyPayment(uint256,address)"", msg.value, msg.sender));
        require(success, ""Proxy payment failed"");
    }
}"
1613,Calculate the halving hash rate of a miner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",getMyCurrentHashRate,"[{'function': 'currentHalving', 'complexity': 0}, {'function': 'getHashRateOf', 'complexity': 0}, {'function': 'getMyCurrentHashRate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMyCurrentHashRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""halvingPeriod"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentHalving""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""hashRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getHashRateOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""halvingPeriod""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BooleanLiteral"", ""value"": True}, {""type"": ""Identifier"", ""name"": ""hashRate""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",31.0,0.5990361655442424,0.0364908214010408,"pragma solidity ^0.8.0;

contract MiningContract {

    function currentHalving() internal view virtual returns (uint256) {
        //Implementation for currentHalving()
    }

    function getHashRateOf(address miner, uint256 halvingIndex) internal view virtual returns (uint256) {
        //Implementation for getHashRateOf()
    }

    function getMyCurrentHashRate() public view returns (bool, uint256) {
        uint256 halvingPeriod = currentHalving();
        uint256 hashRate = getHashRateOf(msg.sender, halvingPeriod);
        return (true, hashRate);
    }
}",41.8792998790741,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MiningContract is Ownable {
    uint256 public constant DEFAULT_HALVING = 1;
    address public constant DEFAULT_MINER_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_IS_MINED = true;
    bytes32 public constant DEFAULT_INIT = bytes32('init');

    constructor() Ownable(msg.sender) {
        _setHalving(DEFAULT_HALVING);
        _setMinerAddress(DEFAULT_MINER_ADDRESS);
        _setIsMined(DEFAULT_IS_MINED);
        _setInit(DEFAULT_INIT);
    }

    function currentHalving() internal view virtual returns (uint256) {
        return _getHalving();
    }

    function getHashRateOf(address miner, uint256 halvingIndex) internal view virtual returns (uint256) {
        return _getHashRate(miner, halvingIndex);
    }

    function getMyCurrentHashRate() public view returns (bool, uint256) {
        uint256 halvingPeriod = currentHalving();
        uint256 hashRate = getHashRateOf(msg.sender, halvingPeriod);
        return (_isMined(), hashRate);
    }

    // Helper functions to access and modify state variables
    function _getHalving() internal view returns (uint256) {
        return _halving;
    }

    function _setHalving(uint256 value) internal {
        require(value != 0, ""Halving cannot be zero"");
        _halving = value;
    }

    function _getHashRate(address miner, uint256 halvingIndex) internal view returns (uint256) {
        return _hashRates[miner][halvingIndex];
    }

    function _setMinerAddress(address value) internal {
        require(value != address(0), ""Miner address cannot be zero"");
        _minerAddress = value;
    }

    function _getIsMined() internal view returns (bool) {
        return _isMined;
    }

    function _setIsMined(bool value) internal {
        require(value, ""Mined status cannot be false"");
        _isMined = value;
    }

    function _getInit() internal view returns (bytes32) {
        return _init;
    }

    function _setInit(bytes32 value) internal {
        require(value != bytes32(0), ""Initialization value cannot be zero"");
        _init = value;
    }

    uint256 public halving;
    address public minerAddress;
    bool public isMined;
    bytes32 public init;

    constructor() Ownable(msg.sender) {
        halving = DEFAULT_HALVING;
        minerAddress = DEFAULT_MINER_ADDRESS;
        isMined = DEFAULT_IS_MINED;
        init = DEFAULT_INIT;
    }
}"
2278,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleToken is Ownable {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _owner, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_owner, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) internal pure returns (address) {
        if (_signature.length != 65) return address(0);
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(_signature, (uint8, bytes32, bytes32));
        return ecrecover(_hash, v, r, s);
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);

        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));

        nonces[_signature] = true;
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);

        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);

        return true;
    }
}",increaseApprovalPreSigned,"[{'function': 'increaseApprovalPreSigned', 'complexity': 4}, {'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}]",4.0,{},134.0,0.843831004014822,0.5917812011191775,"pragma solidity ^0.8.0;

contract MyToken {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(bytes => bool) public nonces;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed from, address indexed spender, uint256 addedValue, uint256 fee, bytes signature);

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public {
        require(_spender != address(0), ""Spender address cannot be zero"");
        require(!nonces[_signature], ""Signature has already been used"");

        bytes32 hash = keccak256(abi.encodePacked(_spender, _addedValue, _fee, _nonce));
        address from = ecrecover(hash, uint8(_signature[64]), _signature[0:32], _signature[32:64]);
        require(from != address(0), ""Invalid signature"");

        nonces[_signature] = true;
        allowed[from][_spender] += _addedValue;
        balances[from] -= _fee;
        balances[msg.sender] += _fee;

        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, _addedValue, _fee, _signature);
    }

    function increaseApprovalPreSignedHashing(address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_spender, _addedValue, _fee, _nonce));
    }

}",44.08357238769531,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(bytes => bool) public nonces;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed from, address indexed spender, uint256 addedValue, uint256 fee, bytes signature);

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000;
        allowed[msg.sender][address(0)] = 1;
        nonces[bytes32('init')] = true;
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public {
        require(_spender != address(0), ""Spender address cannot be zero"");
        require(!nonces[_signature], ""Signature has already been used"");

        bytes32 hash = keccak256(abi.encodePacked(_spender, _addedValue, _fee, _nonce));
        address from = ecrecover(hash, uint8(_signature[64]), _signature[0:32], _signature[32:64]);
        require(from != address(0), ""Invalid signature"");

        nonces[_signature] = true;
        allowed[from][_spender] += _addedValue;
        balances[from] -= _fee;
        balances[msg.sender] += _fee;

        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, _addedValue, _fee, _signature);
    }

    function increaseApprovalPreSignedHashing(address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_spender, _addedValue, _fee, _nonce));
    }
}"
4847,Function that is called when transaction target is contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ContractReceiver {
    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    function transferToContract(address _to, uint256 _value, bytes memory _data) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
}",transfer,"[{'function': 'tokenFallback', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ContractReceiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""memberName"": ""tokenFallback""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.8295752098124676,0.6406124903639503,"pragma solidity ^0.8.0;

interface ContractReceiver {
    function tokenFallback(address _from, uint256 _value, bytes memory _data) external;
}

contract MyToken {
    mapping(address => uint256) public balances;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);

    function transfer(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        ContractReceiver(_to).tokenFallback(msg.sender, _value, _data);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
}",42.352783203125,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface ContractReceiver {
    function tokenFallback(address _from, uint256 _value, bytes memory _data) external;
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable, ContractReceiver {
    mapping(address => uint256) public balances;
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set initial balance to 1 for the owner
    }

    function transfer(address _to, uint256 _value, bytes memory _data) public override returns (bool) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        ContractReceiver(_to).tokenFallback(msg.sender, _value, _data);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
}"
1565,Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MintWrapper is Ownable {
    using SafeMath for uint256;

    function mint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) public onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }
}",doMint,"[{'function': 'mint', 'complexity': 0}, {'function': 'doMint', 'complexity': 2}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}, {'function': 'allowance', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 0}, {'function': 'increaseAllowance', 'complexity': 0}, {'function': 'decreaseAllowance', 'complexity': 0}, {'function': '_transfer', 'complexity': 1}, {'function': '_approve', 'complexity': 2}, {'function': 'name', 'complexity': 0}, {'function': 'symbol', 'complexity': 0}, {'function': 'decimals', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""doMint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenHolder""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: mint to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: mint amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenHolder""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_tokenHolder""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.6045040801152314,0.1958618765530216,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";


contract MyToken is Ownable, IERC20 {

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }


    function mint(address _tokenHolder, uint256 _amount, bytes calldata _operatorData) public onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }

    function doMint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) internal {
        require(_tokenHolder != address(0), ""ERC20: mint to the zero address"");
        require(_amount > 0, ""ERC20: mint amount must be greater than zero"");

        _totalSupply += _amount;
        _balances[_tokenHolder] += _amount;
        emit Transfer(address(0), _tokenHolder, _amount);
    }


    // IERC20 functions (implementation omitted for brevity)
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }


    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(balanceOf(sender) >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",47.37641668319702,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable, IERC20 {
    // Mapping to store balances of each account
    mapping(address => uint256) private _balances;

    // Mapping to store allowances for each account
    mapping(address => mapping(address => uint256)) private _allowances;

    // Total supply of tokens
    uint256 private _totalSupply;

    // Token name and symbol
    string private _name = ""MyToken"";
    string private _symbol = ""TKN"";

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize total supply to 1 (never 0)
        _totalSupply = 1000000000000000000;

        // Initialize balances for each account
        _balances[msg.sender] = _totalSupply;

        // Emit event to indicate initialization
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function mint(address _tokenHolder, uint256 _amount, bytes calldata _operatorData) public onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }

    function doMint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) internal {
        require(_tokenHolder != address(0), ""ERC20: mint to the zero address"");
        require(_amount > 0, ""ERC20: mint amount must be greater than zero"");

        // Update total supply
        _totalSupply += _amount;

        // Update balances for each account
        _balances[_tokenHolder] += _amount;

        // Emit event to indicate transfer
        emit Transfer(address(0), _tokenHolder, _amount);
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(balanceOf(sender) >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual override returns (uint8) {
        return 18;
    }
}"
5534,Returns the timestamp at which the question will be/was finalized,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Question {
        uint32 finalize_ts;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalizeTS(bytes32 question_id) public view returns (uint32) {
        return questions[question_id].finalize_ts;
    }
}",getFinalizeTS,"[{'function': 'getFinalizeTS', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getFinalizeTS"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""finalize_ts""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9762744596616142,0.8153551038173115,"pragma solidity ^0.8.0;

contract QuestionContract {

    struct Question {
        uint256 finalize_ts;
        // Add other question fields as needed
    }

    mapping(bytes32 => Question) public questions;

    function getFinalizeTS(bytes32 question_id) public view returns (uint256) {
        return questions[question_id].finalize_ts;
    }
}",41.39754843711853,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract QuestionContract is Ownable {
    struct Question {
        uint256 finalize_ts;
        // Add other question fields as needed
    }

    mapping(bytes32 => Question) public questions;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        bytes32 placeholder = bytes32('init');
        questions[placeholder] = Question({ finalize_ts: 1 });
    }

    function getFinalizeTS(bytes32 question_id) public view returns (uint256) {
        return questions[question_id].finalize_ts;
    }
}"
2081,Become owner of a deed for which you are currently approved,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IDeed {
    function takeOwnership(uint256 _deedId) external payable;
}

abstract contract Deed is Ownable, SafeMath {
    struct DeedInfo {
        address owner;
        bool isOwner;
    }

    mapping(uint256 => DeedInfo) private _deeds;
    uint256 public constant DEED_PRICE = 1 ether; // Example price, adjust as needed

    function takeOwnership(uint256 _deedId) external payable {
        require(_deedId > 0, ""Invalid deed ID"");
        require(msg.value >= DEED_PRICE, ""Insufficient payment"");
        require(!_deeds[_deedId].isOwner, ""Deed is already owned"");
        _deeds[_deedId].owner = msg.sender;
        _deeds[_deedId].isOwner = true;
        emit DeedOwnershipTransferred(_deedId, msg.sender);
    }
}",buyDeed,"[{'function': 'buyDeed', 'complexity': 3}, {'function': 'setPrice', 'complexity': 1}]",4.0,{},50.0,0.8254906497155339,0.2464928489388165,"pragma solidity ^0.8.0;

contract DeedRegistry {

    mapping(uint256 => address) public owner;
    mapping(uint256 => uint256) public price;

    event OwnershipTransferred(uint256 indexed deedId, address indexed previousOwner, address indexed newOwner);

    function buyDeed(uint256 _deedId) public payable {
        require(msg.value >= price[_deedId], ""Insufficient funds"");
        require(owner[_deedId] == address(0), ""Deed already owned"");
        address previousOwner = owner[_deedId];
        owner[_deedId] = msg.sender;
        (bool success, ) = payable(previousOwner).call{value: msg.value}("""");
        require(success, ""Transfer failed."");
        emit OwnershipTransferred(_deedId, previousOwner, msg.sender);
    }

    function setPrice(uint256 _deedId, uint256 _newPrice) public {
        require(owner[_deedId] == msg.sender, ""Only owner can set price"");
        price[_deedId] = _newPrice;
    }

}",42.137587547302246,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract DeedRegistry is Ownable {

    mapping(uint256 => address) public owner;
    mapping(uint256 => uint256) public price;

    event OwnershipTransferred(uint256 indexed deedId, address indexed previousOwner, address indexed newOwner);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            owner[i] = address(uint160(uint256(keccak256(abi.encodePacked('owner', i)))));
            price[i] = 1; // Set to 1 (never 0)
        }
    }

    function buyDeed(uint256 _deedId) public payable {
        require(msg.value >= price[_deedId], ""Insufficient funds"");
        require(owner[_deedId] == address(0), ""Deed already owned"");
        address previousOwner = owner[_deedId];
        owner[_deedId] = msg.sender;
        (bool success, ) = payable(previousOwner).call{value: msg.value}("""");
        require(success, ""Transfer failed."");
        emit OwnershipTransferred(_deedId, previousOwner, msg.sender);
    }

    function setPrice(uint256 _deedId, uint256 _newPrice) public {
        require(owner[_deedId] == msg.sender, ""Only owner can set price"");
        price[_deedId] = _newPrice;
    }

}"
790,Allows the owner of the contract to update the address of the RenExBrokerVerifier contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RenExBrokerVerifier {
    using SafeMath for uint256;

    address public brokerVerifierContract;

    event LogBrokerVerifierContractUpdated(address indexed oldBrokerVerifierContract, address indexed newBrokerVerifierContract);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {
        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}",updateBrokerVerifierContract,"[{'function': 'updateBrokerVerifierContract', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateBrokerVerifierContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newBrokerVerifierContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogBrokerVerifierContractUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""brokerVerifierContract""}, {""type"": ""Identifier"", ""name"": ""_newBrokerVerifierContract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""brokerVerifierContract""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newBrokerVerifierContract""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9503448290168254,0.7417090125042293,"pragma solidity ^0.8.0;

contract MyContract {

    address public brokerVerifierContract;
    address public owner;

    event LogBrokerVerifierContractUpdated(address indexed oldBrokerVerifierContract, address indexed newBrokerVerifierContract);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _brokerVerifierContract) {
        owner = msg.sender;
        brokerVerifierContract = _brokerVerifierContract;
    }

    function updateBrokerVerifierContract(address _newBrokerVerifierContract) public onlyOwner {
        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}",42.689030170440674,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {

    address public brokerVerifierContract;
    address public owner;

    event LogBrokerVerifierContractUpdated(address indexed oldBrokerVerifierContract, address indexed newBrokerVerifierContract);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _brokerVerifierContract) {
        owner = msg.sender;
        brokerVerifierContract = _brokerVerifierContract;
    }

    function updateBrokerVerifierContract(address _newBrokerVerifierContract) public onlyOwner {
        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}"
1335,Owner : Withdraw excess funds which do n't belong to Bskt Token holders,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply_;
    uint256 public creationUnit_;

    constructor(uint256 _totalSupply, uint256 _creationUnit) {
        require(_totalSupply > 0 && _creationUnit > 0, ""Invalid parameters"");
        totalSupply_ = _totalSupply;
        creationUnit_ = _creationUnit;
    }

    function getQuantity(address token) internal view returns (uint256 quantity, bool ok) {
        // Implement your logic to determine the quantity here
        // For example:
        // if (/* some condition */) {
        //     return (quantity, true);
        // } else {
        //     return (0, false);
        // }
        revert(""Not implemented"");
    }

    function withdrawExcessToken(address token) external onlyOwner {
        ERC20 erc20 = ERC20(token);
        uint256 amountOwned = erc20.balanceOf(address(this));
        uint256 quantity;
        bool ok;
        (quantity, ok) = getQuantity(token);
        uint256 withdrawAmount;
        if (ok) {
            withdrawAmount = amountOwned.sub(totalSupply_.div(creationUnit_).mul(quantity));
        } else {
            withdrawAmount = amountOwned;
        }
        require(erc20.transfer(owner(), withdrawAmount), ""Transfer failed"");
    }
}",withdrawExcessToken,"[{'function': 'getQuantity', 'complexity': 0}, {'function': 'withdrawExcessToken', 'complexity': 4}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawExcessToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""erc20"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""ok"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""ok""}, {""type"": ""Identifier"", ""name"": ""quantity""}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getQuantity""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""withdrawAmount"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""ok""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountToKeep"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawAmount""}, ""right"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amountToKeep""}}, ""TrueExpression"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amountToKeep""}}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""withdrawAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.8772582097318574,0.4842160191384694,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract YourContract is Ownable {

    function getQuantity(address token) public view returns (bool ok, uint256 quantity) {
        //Implementation for getQuantity function.  Replace this with your actual logic.
        //This example always returns false, indicating failure.  Adapt as needed.
        return (false, 0);
    }


    function withdrawExcessToken(address token) public onlyOwner {
        IERC20 erc20 = IERC20(token);
        uint256 balance = erc20.balanceOf(address(this));
        bool ok;
        uint256 quantity;
        (ok, quantity) = getQuantity(token);

        uint256 withdrawAmount;
        if (ok) {
            // Replace with your actual calculation based on total supply and creation unit.
            uint256 amountToKeep = 0; // Replace with your calculation
            withdrawAmount = balance > amountToKeep ? balance - amountToKeep : 0;
        } else {
            withdrawAmount = balance;
        }

        require(erc20.transfer(owner(), withdrawAmount), ""Transfer failed"");
    }
}",42.62324380874634,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract YourContract is Ownable {
    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 fixedUint = 1;
        address fixedAddress1 = address(0x111);
        address fixedAddress2 = address(0x222);
        bool fixedBool = true;
        string memory fixedString = 'initialized';
        bytes32 fixedBytes32 = bytes32('init');
    }

    function getQuantity(address token) public view returns (bool ok, uint256 quantity) {
        //Implementation for getQuantity function.  Replace this with your actual logic.
        //This example always returns false, indicating failure.  Adapt as needed.
        return (false, 0);
    }

    function withdrawExcessToken(address token) public onlyOwner {
        IERC20 erc20 = IERC20(token);
        uint256 balance = erc20.balanceOf(address(this));
        bool ok;
        uint256 quantity;
        (ok, quantity) = getQuantity(token);

        uint256 withdrawAmount;
        if (ok) {
            // Replace with your actual calculation based on total supply and creation unit.
            uint256 amountToKeep = 0; // Replace with your calculation
            withdrawAmount = balance > amountToKeep ? balance - amountToKeep : 0;
        } else {
            withdrawAmount = balance;
        }

        require(erc20.transfer(owner(), withdrawAmount), ""Transfer failed"");
    }
}"
3433,Permit ` msg.sender ` to set its NeuroChain Address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NeuroChainWrapper {
    using SafeMath for uint256;

    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string addressString, uint256 timestamp, bool isRegistered);

    function setNeuroChainAddress(string memory neurochainAddress) public {
        require(bytes(neurochainAddress).length > 0, ""Invalid address"");
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}",setNeuroChainAddress,"[{'function': 'setNeuroChainAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNeuroChainAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""neurochainAddress"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""neuroChainAddresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""neurochainAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NeuroChainAddressSet""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""neurochainAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.8191017885758862,0.5325738440694628,"pragma solidity ^0.8.0;

contract NeuroChainAddressRegistry {

    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string neurochainAddress, uint256 timestamp, bool indexed success);

    function setNeuroChainAddress(string memory neurochainAddress) public {
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}",41.53302693367005,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NeuroChainAddressRegistry is Ownable {
    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string neurochainAddress, uint256 timestamp, bool indexed success);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        neuroChainAddresses[msg.sender] = ""initial"";
    }

    function setNeuroChainAddress(string memory neurochainAddress) public {
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}"
465,Get the token balance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Storage {
    function getUint(bytes32 key) external view returns (uint);
}

abstract contract Data {
    Storage public immutable Storage;

    constructor(Storage _storage) {
        Storage = _storage;
    }
}

abstract contract TokenBalanceWrapper is Ownable, SafeMath {
    function getForwardedAccount(Data storage self, address account) internal view virtual returns (address);

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint balance) {
        bytes32 id = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));
        return self.Storage.getUint(id);
    }
}",getTokenBalance,"[{'function': 'getForwardedAccount', 'complexity': 0}, {'function': 'getTokenBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Data""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""token.balance""}, {""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getForwardedAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""self""}, {""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",5.0,0.880126129906291,0.7488763670114149,"pragma solidity ^0.8.0;

contract TokenBalance {

    struct Data {
        mapping(bytes32 => uint256) balances;
    }

    function getForwardedAccount(Data storage self, address account) internal pure returns (address) {
        return account; // Replace with actual forwarding logic if needed
    }


    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint256 balance) {
        bytes32 id = keccak256(abi.encodePacked(""token.balance"", currency, getForwardedAccount(self, account)));
        balance = self.balances[id];
    }
}",41.68147468566895,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenBalance is Ownable {
    struct Data {
        mapping(bytes32 => uint256) balances;
    }

    function getForwardedAccount(Data storage self, address account) internal pure returns (address) {
        return account; // Replace with actual forwarding logic if needed
    }

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint256 balance) {
        bytes32 id = keccak256(abi.encodePacked(""token.balance"", currency, getForwardedAccount(self, account)));
        balance = self.balances[id];
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        Data storage dataInstance;
        for (uint256 i = 0; i < 3; i++) {
            if (i == 0) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                dataInstance.balances[bytes32('init')] = uint256(keccak256(abi.encodePacked(""uint256"", i)));
            } else {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                dataInstance.balances[bytes32('init')] = uint256(keccak256(abi.encodePacked(""uint256"", i)));
            }
        }
    }
}"
5228,A getter that searches the delegationChain for the level of authority a specific delegate has within a Pledge,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledge {
    uint64 public constant NOTFOUND = type(uint64).max;
    uint64[] public delegationChain;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getDelegateIdx(Pledge p, uint64 idDelegate) external returns (uint64) {
        for (uint i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) return uint64(i);
        }
        return NOTFOUND;
    }
}",getDelegateIdx,"[{'function': 'getDelegateIdx', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDelegateIdx"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Pledge""}, ""name"": ""p"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""idDelegate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""delegationChain""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""delegationChain""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""idDelegate""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""i""}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""NOTFOUND""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",0.0,0.9429787251595948,0.6579347836803356,"pragma solidity ^0.8.0;

contract DelegateFinder {

    uint64 constant NOTFOUND = type(uint64).max;

    struct Pledge {
        uint64[] delegationChain;
    }

    function getDelegateIdx(Pledge memory p, uint64 idDelegate) public pure returns (uint64) {
        for (uint64 i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) {
                return i;
            }
        }
        return NOTFOUND;
    }
}",41.7696545124054,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DelegateFinder is Ownable {
    uint64 constant NOTFOUND = type(uint64).max;

    struct Pledge {
        uint64[] delegationChain;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        NOTFOUND = 18446744073709551615; // Set to type(uint64).max
    }

    function getDelegateIdx(Pledge memory p, uint64 idDelegate) public pure returns (uint64) {
        for (uint64 i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) {
                return i;
            }
        }
        return NOTFOUND;
    }
}"
3288,Distirbutes a different quantity of tokens to all the specified addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Airdrop {
        address tokenSC;
    }

    mapping(uint => Airdrop) public airdrops;

    function distributeVariable(uint index, address[] memory _addrs, uint[] memory _vals) public onlyOwner {
        if (timeGone(index) == true) {
            Airdrop storage airdrop = airdrops[index];
            for (uint i = 0; i < _addrs.length; ++i) {
                require(SafeMath.mul(_vals[i], 1 ether) <= address(airdrop.tokenSC).balance, ""Insufficient balance"");
                airdrop.tokenSC.call(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _addrs[i], _vals[i]));
            }
        } else {
            revert(""Distribution Failed: Countdown not finished yet"");
        }
    }

    function timeGone(uint index) public view returns (bool) {
        // Implement your logic to check if the countdown is finished for the given index
        return true; // Placeholder, replace with actual implementation
    }
}",distributeAirdrop,"[{'function': 'addAirdrop', 'complexity': 0}, {'function': 'timeGone', 'complexity': 0}, {'function': 'distributeAirdrop', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeAirdrop"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_addrs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_vals"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""timeGone""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Distribution Failed: Countdown not finished yet""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Airdrop""}, ""name"": ""airdropData"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""airdrops""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_vals""}, ""memberName"": ""length""}}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""airdropData""}, ""memberName"": ""tokenSC""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_vals""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",41.0,0.8056302421284162,0.2924969790652411,"pragma solidity ^0.8.0;

contract AirdropDistributor {

    struct Airdrop {
        uint256 startTime;
        uint256 duration;
        address tokenSC;
    }

    Airdrop[] public airdrops;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addAirdrop(uint256 _startTime, uint256 _duration, address _tokenSC) public onlyOwner {
        airdrops.push(Airdrop(_startTime, _duration, _tokenSC));
    }

    function timeGone(uint256 index) public view returns (bool) {
        Airdrop memory airdropData = airdrops[index];
        return block.timestamp >= airdropData.startTime + airdropData.duration;
    }


    function distributeAirdrop(uint256 index, address[] memory _addrs, uint256[] memory _vals) public onlyOwner {
        require(timeGone(index), ""Distribution Failed: Countdown not finished yet"");
        Airdrop memory airdropData = airdrops[index];
        require(_addrs.length == _vals.length);
        for (uint256 i = 0; i < _addrs.length; i++) {
            IERC20(airdropData.tokenSC).transfer(_addrs[i], _vals[i]);
        }
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}",43.06154727935791,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract AirdropDistributor {

    struct Airdrop {
        uint256 startTime;
        uint256 duration;
        address tokenSC;
    }

    Airdrop[] public airdrops;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function addAirdrop(uint256 _startTime, uint256 _duration, address _tokenSC) public onlyOwner {
        airdrops.push(Airdrop(_startTime, _duration, _tokenSC));
    }

    function timeGone(uint256 index) public view returns (bool) {
        Airdrop memory airdropData = airdrops[index];
        return block.timestamp >= airdropData.startTime + airdropData.duration;
    }

    function distributeAirdrop(uint256 index, address[] memory _addrs, uint256[] memory _vals) public onlyOwner {
        require(timeGone(index), ""Distribution Failed: Countdown not finished yet"");
        Airdrop memory airdropData = airdrops[index];
        require(_addrs.length == _vals.length);
        for (uint256 i = 0; i < _addrs.length; i++) {
            IERC20(airdropData.tokenSC).transfer(_addrs[i], _vals[i]);
        }
    }
}

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}"
110,This method should be called by the owner before the contribution period starts This initializes most of the parameters,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function totalSupply() external view returns (uint256);
    function controller() external view returns (address);
    function decimals() external view returns (uint8);
}

interface DynamicCeiling {
    function getBlockNumber() external view returns (uint256);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    MiniMeToken public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    DynamicCeiling public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    MiniMeToken public SGT;
    uint256 public maxSGTSupply;

    function initialize(address _snt, address _sntController, uint256 _startBlock, uint256 _endBlock, address _dynamicCeiling, address _destEthDevs, address _destTokensReserve, address _destTokensSgt, address _destTokensDevs, address _sgt, uint256 _maxSGTSupply) public onlyOwner {
    require(address(SNT) == 0x0);
    SNT = MiniMeToken(_snt);
    require(SNT.totalSupply() == 0);
    require(SNT.controller() == address(this));
    require(SNT.decimals() == 18);
    require(_sntController != 0x0);
    sntController = _sntController;
    require(_startBlock >= getBlockNumber());
    require(_startBlock < _endBlock);
    startBlock = _startBlock;
    endBlock = _endBlock;
    require(_dynamicCeiling != 0x0);
    dynamicCeiling = DynamicCeiling(_dynamicCeiling);
    require(_destEthDevs != 0x0);
    destEthDevs = _destEthDevs;
    require(_destTokensReserve != 0x0);
    destTokensReserve = _destTokensReserve;
    require(_destTokensSgt != 0x0);
    destTokensSgt = _destTokensSgt;
    require(_destTokensDevs != 0x0);
    destTokensDevs = _destTokensDevs;
    require(_sgt != 0x0);
    SGT = MiniMeToken(_sgt);
    require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());
    maxSGTSupply = _maxSGTSupply;
}
}",initialize,"[{'function': 'initialize', 'complexity': 0}]",14.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_snt"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sntController"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_endBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_dynamicCeiling"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_destEthDevs"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_destTokensReserve"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_destTokensSgt"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_destTokensDevs"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_sgt"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxSGTSupply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""SNT""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""SNT already set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""SNT""}, ""right"": {""type"": ""Identifier"", ""name"": ""_snt""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SNT""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""SNT total supply not zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SNT""}, ""memberName"": ""controller""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""SNT controller not this contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SNT""}, ""memberName"": ""decimals""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""SNT decimals not 18""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_sntController""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""_sntController is zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sntController""}, ""right"": {""type"": ""Identifier"", ""name"": ""_sntController""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_startBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}, {""type"": ""stringLiteral"", ""value"": ""Start block is less than current block""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_startBlock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_endBlock""}}, {""type"": ""stringLiteral"", ""value"": ""Start block is greater than or equal to end block""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""startBlock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startBlock""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""endBlock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_endBlock""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_dynamicCeiling""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""_dynamicCeiling is zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""dynamicCeiling""}, ""right"": {""type"": ""Identifier"", ""name"": ""_dynamicCeiling""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_destEthDevs""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""_destEthDevs is zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""destEthDevs""}, ""right"": {""type"": ""Identifier"", ""name"": ""_destEthDevs""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_destTokensReserve""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""_destTokensReserve is zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""destTokensReserve""}, ""right"": {""type"": ""Identifier"", ""name"": ""_destTokensReserve""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_destTokensSgt""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""_destTokensSgt is zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""destTokensSgt""}, ""right"": {""type"": ""Identifier"", ""name"": ""_destTokensSgt""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_destTokensDevs""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""_destTokensDevs is zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""destTokensDevs""}, ""right"": {""type"": ""Identifier"", ""name"": ""_destTokensDevs""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""SGT""}, ""right"": {""type"": ""Identifier"", ""name"": ""_sgt""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_maxSGTSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SGT""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Max SGT supply less than current supply""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxSGTSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxSGTSupply""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",45.0,0.9542077948117308,0.4785572270620684,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    address public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    IERC20 public SGT;
    uint256 public maxSGTSupply;

    function initialize(
        IERC20 _snt,
        address _sntController,
        uint256 _startBlock,
        uint256 _endBlock,
        address _dynamicCeiling,
        address _destEthDevs,
        address _destTokensReserve,
        address _destTokensSgt,
        address _destTokensDevs,
        IERC20 _sgt,
        uint256 _maxSGTSupply
    ) public {
        require(address(SNT) == address(0), ""SNT already set"");
        SNT = _snt;
        require(SNT.totalSupply() == 0, ""SNT total supply not zero"");
        require(SNT.controller() == address(this), ""SNT controller not this contract"");
        require(SNT.decimals() == 18, ""SNT decimals not 18"");
        require(_sntController != address(0), ""_sntController is zero address"");
        sntController = _sntController;
        require(_startBlock >= block.number, ""Start block is less than current block"");
        require(_startBlock < _endBlock, ""Start block is greater than or equal to end block"");
        startBlock = _startBlock;
        endBlock = _endBlock;
        require(_dynamicCeiling != address(0), ""_dynamicCeiling is zero address"");
        dynamicCeiling = _dynamicCeiling;
        require(_destEthDevs != address(0), ""_destEthDevs is zero address"");
        destEthDevs = _destEthDevs;
        require(_destTokensReserve != address(0), ""_destTokensReserve is zero address"");
        destTokensReserve = _destTokensReserve;
        require(_destTokensSgt != address(0), ""_destTokensSgt is zero address"");
        destTokensSgt = _destTokensSgt;
        require(_destTokensDevs != address(0), ""_destTokensDevs is zero address"");
        destTokensDevs = _destTokensDevs;
        SGT = _sgt;
        require(_maxSGTSupply >= SGT.totalSupply(), ""Max SGT supply less than current supply"");
        maxSGTSupply = _maxSGTSupply;
    }
}",45.07304120063782,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    address public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    IERC20 public SGT;
    uint256 public maxSGTSupply;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize variables to fixed, safe values
        SNT = IERC20(0x1111111111111111111111111111111111111111); // Replace with actual token address
        sntController = msg.sender;
        startBlock = 1; // Never set to 0
        endBlock = block.timestamp + 1; // Set to a future timestamp
        dynamicCeiling = 0x2222222222222222222222222222222222222222; // Replace with actual address
        destEthDevs = 0x3333333333333333333333333333333333333333; // Replace with actual address
        destTokensReserve = 0x444...; // Replace with actual address
        destTokensSgt = 0x555...; // Replace with actual address
        destTokensDevs = 0x666...; // Replace with actual address
        SGT = IERC20(""MyToken"", ""TKN""); // Use placeholder values for ERC20 uint256 public totalSupply;

 constructor
        maxSGTSupply = 1; // Never set to 0
    }

    function initialize(
        IERC20 _snt,
        address _sntController,
        uint256 _startBlock,
        uint256 _endBlock,
        address _dynamicCeiling,
        address _destEthDevs,
        address _destTokensReserve,
        address _destTokensSgt,
        address _destTokensDevs,
        IERC20 _sgt,
        uint256 _maxSGTSupply
    ) public {
        require(address(SNT) == address(0), ""SNT already set"");
        SNT = _snt;
        require(SNT.totalSupply() == 0, ""SNT total supply not zero"");
        require(SNT.controller() == address(this), ""SNT controller not this contract"");
        require(SNT.decimals() == 18, ""SNT decimals not 18"");
        require(_sntController != address(0), ""_sntController is zero address"");
        sntController = _sntController;
        require(_startBlock >= block.number, ""Start block is less than current block"");
        require(_startBlock < _endBlock, ""Start block is greater than or equal to end block"");
        startBlock = _startBlock;
        endBlock = _endBlock;
        require(_dynamicCeiling != address(0), ""_dynamicCeiling is zero address"");
        dynamicCeiling = _dynamicCeiling;
        require(_destEthDevs != address(0), ""_destEthDevs is zero address"");
        destEthDevs = _destEthDevs;
        require(_destTokensReserve != address(0), ""_destTokensReserve is zero address"");
        destTokensReserve = _destTokensReserve;
        require(_destTokensSgt != address(0), ""_destTokensSgt is zero address"");
        destTokensSgt = _destTokensSgt;
        require(_destTokensDevs != address(0), ""_destTokensDevs is zero address"");
        destTokensDevs = _destTokensDevs;
        SGT = _sgt;
        require(_maxSGTSupply >= SGT.totalSupply(), ""Max SGT supply less than current supply"");
        maxSGTSupply = _maxSGTSupply;
    }
}"
2093,Get all details of PixelCon # ` ( _tokenIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPixelCon {
    function totalSupply() external view returns (uint256);
}

struct PixelCon {
    uint256 tokenId;
    uint64 collectionIndex;
    uint32 dateCreated;
}

struct TokenLookup {
    address owner;
    address creator;
    uint64 tokenIndex;
}

mapping(uint256 => PixelCon) public pixelcons;
mapping(uint256 => TokenLookup) public tokenLookup;
mapping(uint256 => bytes8) public pixelconNames;

function getTokenDataByIndex(uint64 _tokenIndex, IPixelCon pixelConContract) public view returns (uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated) {
    require(_tokenIndex < pixelConContract.totalSupply(), ""PixelCon index is out of bounds"");
    PixelCon storage pixelcon = pixelcons[_tokenIndex];
    TokenLookup storage lookupData = tokenLookup[pixelcon.tokenId];
    return (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner, pixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);
}",getTokenInfo,"[{'function': 'getTokenInfo', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenIndex""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelcons""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Index out of bounds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PixelCon""}, ""name"": ""pixelCon"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pixelcons""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenIndex""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""tokenId""}, {""type"": ""Identifier"", ""name"": ""_tokenIndex""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""collectionIndex""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""creator""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""dateCreated""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",48.0,0.7671517642199006,0.2310672947474396,"pragma solidity ^0.8.0;

contract PixelConContract {

    struct PixelCon {
        uint256 tokenId;
        uint256 collectionIndex;
        address owner;
        address creator;
        bytes8 name;
        uint256 dateCreated;
    }

    PixelCon[] public pixelcons;
    mapping(uint256 => uint256) public tokenIdToIndex;


    function getTokenInfo(uint256 _tokenIndex) public view returns (uint256, uint256, uint256, address, address, bytes8, uint256) {
        require(_tokenIndex < pixelcons.length, ""Index out of bounds"");
        PixelCon memory pixelCon = pixelcons[_tokenIndex];
        return (pixelCon.tokenId, _tokenIndex, pixelCon.collectionIndex, pixelCon.owner, pixelCon.creator, pixelCon.name, pixelCon.dateCreated);
    }
}",42.21665596961975,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract PixelConContract {
    struct PixelCon {
        uint256 tokenId;
        uint256 collectionIndex;
        address owner;
        address creator;
        bytes8 name;
        uint256 dateCreated;
    }

    PixelCon[] public pixelcons;
    mapping(uint256 => uint256) public tokenIdToIndex;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        for (uint256 i = 0; i < pixelcons.length; i++) {
            PixelCon memory pixelCon = PixelCon(
                1, // tokenId
                1, // collectionIndex
                address(0x1111111111111111111111111111111111111111), // owner
                address(0x2222222222222222222222222222222222222222), // creator
                bytes8('initialized'), // name
                1643723900, // dateCreated (in seconds since Unix epoch)
            );
            pixelcons[i] = pixelCon;
        }
    }

    function getTokenInfo(uint256 _tokenIndex) public view returns (uint256, uint256, uint256, address, address, bytes8, uint256) {
        require(_tokenIndex < pixelcons.length, ""Index out of bounds"");
        PixelCon memory pixelCon = pixelcons[_tokenIndex];
        return (
            pixelCon.tokenId,
            _tokenIndex,
            pixelCon.collectionIndex,
            pixelCon.owner,
            pixelCon.creator,
            pixelCon.name,
            pixelCon.dateCreated
        );
    }
}"
2971,Get the approved address for a single NFT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 private _totalSupply;
    mapping(uint40 => address) public cutieIndexToApproved;
    mapping(uint40 => address) public cutieIndexToOwner;
    mapping(address => bool) public addressToApprovedAll;

    function getApproved(uint256 _tokenId) external view returns (address) {
        require(_tokenId <= _totalSupply());

        if (cutieIndexToApproved[uint40(_tokenId)] != address(0)) {
            return cutieIndexToApproved[uint40(_tokenId)];
        }

        address owner = cutieIndexToOwner[uint40(_tokenId)];
        return addressToApprovedAll[owner];
    }

    function _totalSupply() internal view returns (uint256) {
        return _totalSupply;
    }
}",getApproved,"[{'function': 'getApproved', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getApproved"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, {""type"": ""stringLiteral"", ""value"": ""Token ID exceeds total supply""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""approvedAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cutieIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""approvedAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""approvedAddress""}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cutieIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addressToApprovedAll""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canBeStoredIn40Bits"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",16.0,0.8690527558137771,0.4624473017327999,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(uint256 => address) public cutieIndexToApproved;
    mapping(uint256 => address) public cutieIndexToOwner;
    mapping(address => address) public addressToApprovedAll;
    uint256 public totalSupply;

    modifier canBeStoredIn40Bits(uint256 _tokenId) {
        require(_tokenId < 2**40, ""Token ID too large"");
        _;
    }

    function getApproved(uint256 _tokenId) public view canBeStoredIn40Bits(_tokenId) returns (address) {
        require(_tokenId <= totalSupply, ""Token ID exceeds total supply"");
        address approvedAddress = cutieIndexToApproved[_tokenId];
        if (approvedAddress != address(0)) {
            return approvedAddress;
        }
        address owner = cutieIndexToOwner[_tokenId];
        return addressToApprovedAll[owner];
    }
}",42.15458559989929,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(uint256 => address) public cutieIndexToApproved;
    mapping(uint256 => address) public cutieIndexToOwner;
    mapping(address => address) public addressToApprovedAll;
    uint256 public totalSupply = 1000000000000000000;

    modifier canBeStoredIn40Bits(uint256 _tokenId) {
        require(_tokenId < 2**40, ""Token ID too large"");
        _;
    }

    function getApproved(uint256 _tokenId) public view canBeStoredIn40Bits(_tokenId) returns (address) {
        require(_tokenId <= totalSupply, ""Token ID exceeds total supply"");
        address approvedAddress = cutieIndexToApproved[_tokenId];
        if (approvedAddress != address(0)) {
            return approvedAddress;
        }
        address owner = cutieIndexToOwner[_tokenId];
        return addressToApprovedAll[owner];
    }

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        totalSupply = 1000000000000000000;
    }
}"
2241,Gets absolute issued hardcap volume which means it will be greater than softcap value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap.add(tokenHardcapIssuedValue);
    }
}",tokenHardcapIssued,"[{'function': 'tokenHardcapIssued', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenHardcapIssued"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenSoftcap""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenHardcapIssuedValue""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.8180463846247854,0.650185334030003,"pragma solidity ^0.8.0;

contract TokenContract {
    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    constructor(uint _tokenSoftcap) {
        tokenSoftcap = _tokenSoftcap;
    }

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap + tokenHardcapIssuedValue;
    }
}",41.38081192970276,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is Ownable {
    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    constructor(uint _tokenSoftcap) Ownable(msg.sender) {
        require(_tokenSoftcap > 0, ""Token softcap must be greater than zero"");
        tokenSoftcap = _tokenSoftcap;
        tokenHardcapIssuedValue = 0; // Safe non-corner-case value
    }

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap + tokenHardcapIssuedValue;
    }
}"
4491,Exchange ETH to SNX while insisting on a particular set of rates .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchange {
    function exchangeEtherForSynthetix() external payable returns (uint);
}

interface IPricing {
    function usdToEthPrice() external view returns (uint);
    function usdToSnxPrice() external view returns (uint);
}

abstract contract ExchangeWrapper is Ownable, IExchange {
    using SafeMath for uint;

    IPricing public pricing;
    bool public paused = false;

    constructor(address _pricing) {
        pricing = IPricing(_pricing);
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }

    function exchangeEtherForSynthetixAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate) public payable override returns (uint) {
        require(!paused, ""Contract is paused"");
        require(guaranteedEtherRate == pricing.usdToEthPrice(), ""Guaranteed ether rate would not be received"");
        require(guaranteedSynthetixRate == pricing.usdToSnxPrice(), ""Guaranteed synthetix rate would not be received"");
        return exchangeEtherForSynthetix();
    }

    function exchangeEtherForSynthetix() public payable override returns (uint) {
        // Implementation of the actual exchange logic
        // This is a placeholder for the actual implementation
        return 0;
    }
}",exchangeEtherForSynthetixAtRate,"[{'function': 'usdToSnxPrice', 'complexity': 0}, {'function': 'exchangeEtherForSynthetix', 'complexity': 0}, {'function': 'exchangeEtherForSynthetixAtRate', 'complexity': 2}]",5.0,{},36.0,0.8363734722852596,0.3073659652163724,"pragma solidity ^0.8.0;

interface IPriceOracle {
    function usdToEthPrice() external view returns (uint256);
    function usdToSnxPrice() external view returns (uint256);
}

interface IExchange {
    function exchangeEtherForSynthetix(uint256 _amount) external payable returns (uint256);
}


contract ExchangeWrapper {

    IPriceOracle public priceOracle;
    IExchange public exchange;

    constructor(address _priceOracle, address _exchange) {
        priceOracle = IPriceOracle(_priceOracle);
        exchange = IExchange(_exchange);
    }

    function exchangeEtherForSynthetixAtRate(uint256 guaranteedEtherRate, uint256 guaranteedSynthetixRate) public payable returns (uint256) {
        require(guaranteedEtherRate == priceOracle.usdToEthPrice(), ""Guaranteed Ether rate does not match oracle price."");
        require(guaranteedSynthetixRate == priceOracle.usdToSnxPrice(), ""Guaranteed Synthetix rate does not match oracle price."");
        return exchange.exchangeEtherForSynthetix{value: msg.value}(msg.value);
    }
}",42.545994997024536,"pragma solidity ^0.8.0;

interface IPriceOracle {
    function usdToEthPrice() external view returns (uint256);
    function usdToSnxPrice() external view returns (uint256);
}

interface IExchange {
    function exchangeEtherForSynthetix(uint256 _amount) external payable returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract ExchangeWrapper is Ownable {

    IPriceOracle public priceOracle;
    IExchange public exchange;

    constructor(address _priceOracle, address _exchange) Ownable(msg.sender) {
        require(_priceOracle != address(0), ""Invalid Price Oracle address"");
        require(_exchange != address(0), ""Invalid Exchange address"");
        priceOracle = IPriceOracle(_priceOracle);
        exchange = IExchange(_exchange);
    }

    function exchangeEtherForSynthetixAtRate(uint256 guaranteedEtherRate, uint256 guaranteedSynthetixRate) public payable returns (uint256) {
        require(guaranteedEtherRate == priceOracle.usdToEthPrice(), ""Guaranteed Ether rate does not match oracle price."");
        require(guaranteedSynthetixRate == priceOracle.usdToSnxPrice(), ""Guaranteed Synthetix rate does not match oracle price."");
        return exchange.exchangeEtherForSynthetix{value: msg.value}(msg.value);
    }
}"
4173,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract {
    using SafeMath for uint256;

    enum Error { NO_ERROR, SOME_ERROR }

    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {
        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);
        if (err != Error.NO_ERROR) {
            return (uint(err), 0, 0);
        }
        return (0, supplyValue, borrowValue);
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        // Implement the logic of calculateAccountValuesInternal here
        // For demonstration purposes, let's assume it returns some values based on userAddress
        return (Error.NO_ERROR, 100, 50);
    }
}",calculateAccountValuesInternal,"[{'function': 'calculateAccountValues', 'complexity': 1}, {'function': 'calculateAccountValuesInternal', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateAccountValues"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""err"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Error""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1132a7460>}, {""type"": ""VariableDeclaration"", ""name"": ""supplyValue"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1132a4600>}, {""type"": ""VariableDeclaration"", ""name"": ""borrowValue"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1132a5be0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAccountValuesInternal""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""userAddress""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""err""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""err""}], ""names"": []}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""supplyValue""}, {""type"": ""Identifier"", ""name"": ""borrowValue""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.8687776588502201,0.2760585458783398,"pragma solidity ^0.8.0;

enum Error {
    NO_ERROR,
    CALCULATION_ERROR
}

contract MyContract {

    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {
        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);
        if (err != Error.NO_ERROR) {
            return (uint(err), 0, 0);
        }
        return (0, supplyValue, borrowValue);
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        // Replace this with your actual calculation logic
        uint supply;
        uint borrow;

        //Simulate an error condition for testing
        if(userAddress == address(0)){
            return (Error.CALCULATION_ERROR, 0, 0);
        } else {
            supply = 100;
            borrow = 50;
            return (Error.NO_ERROR, supply, borrow);
        }
    }
}",42.10646629333496,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

enum Error {
    NO_ERROR,
    CALCULATION_ERROR
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        supplyValue = 100;
        borrowValue = 50;
    }

    uint public supplyValue;
    uint public borrowValue;

    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {
        (Error err, uint supplyValue_, uint borrowValue_) = calculateAccountValuesInternal(userAddress);
        if (err != Error.NO_ERROR) {
            return (uint(err), 0, 0);
        }
        return (0, supplyValue_, borrowValue_);
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        // Replace this with your actual calculation logic
        if (userAddress == address(0)) {
            return (Error.CALCULATION_ERROR, 0, 0);
        } else {
            return (Error.NO_ERROR, supplyValue, borrowValue);
        }
    }
}"
4418,Create a new payment channel between two parties,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NettingChannelRegistry is Ownable {
    using SafeMath for uint256;

    struct Data {
        address token;
        address[][] nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint) partyhash_to_channelpos;
        address[] all_channels;
        mapping(address => mapping(address => uint)) node_index;
    }

    Data data;

    function newChannel(address partner, uint settle_timeout) external returns (address) {
        Data storage self = data;
        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];
        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint channel_pos = self.partyhash_to_channelpos[party_hash];
        address new_channel_address = new NettingChannelContract(self.token, msg.sender, partner, settle_timeout);
        if (channel_pos != 0) {
            address settled_channel = self.all_channels[channel_pos - 1];
            require(!contractExists(settled_channel));
            uint caller_pos = self.node_index[msg.sender][partner];
            uint partner_pos = self.node_index[partner][msg.sender];
            self.all_channels[channel_pos - 1] = new_channel_address;
            caller_channels[caller_pos - 1] = new_channel_address;
            partner_channels[partner_pos - 1] = new_channel_address;
        } else {
            self.all_channels.push(new_channel_address);
            caller_channels.push(new_channel_address);
            partner_channels.push(new_channel_address);
            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;
            self.node_index[msg.sender][partner] = caller_channels.length;
            self.node_index[partner][msg.sender] = partner_channels.length;
        }
        return new_channel_address;
    }

    function contractExists(address contractAddress) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(contractAddress) }
        return size > 0;
    }
}",newChannel,"[{'function': 'newChannel', 'complexity': 3}, {'function': 'sortAddresses', 'complexity': 1}, {'function': 'contractExists', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""newChannel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""partner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""settle_timeout"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""caller_channels"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""nodeaddress_to_channeladdresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""partner_channels"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""nodeaddress_to_channeladdresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""sortedAddresses"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortAddresses""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""partner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""party_hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedAddresses""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedAddresses""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""channel_pos"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""partyhash_to_channelpos""}, ""index"": {""type"": ""Identifier"", ""name"": ""party_hash""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""settledChannelAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""all_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""contractExists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""settledChannelAddress""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Settled channel contract still exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""all_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""caller_channels""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""partner_channels""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""all_channels""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""partyhash_to_channelpos""}, ""index"": {""type"": ""Identifier"", ""name"": ""party_hash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""channel_pos""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""caller_channels""}, ""memberName"": ""length""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""partner_channels""}, ""memberName"": ""length""}}}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""NettingChannelContract""}, ""name"": ""newChannelContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""NettingChannelContract""}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""partner""}, {""type"": ""Identifier"", ""name"": ""settle_timeout""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""all_channels""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newChannelContract""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""caller_channels""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newChannelContract""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""partner_channels""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newChannelContract""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",76.0,0.9335627863777058,0.2529561744438357,"pragma solidity ^0.8.0;

contract NettingChannelManager {

    struct Data {
        address[] all_channels;
        mapping(address => address[]) nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        mapping(address => mapping(uint256 => uint256)) node_index;
    }

    Data public data;

    function newChannel(address partner, uint256 settle_timeout) public {
        address[] storage caller_channels = data.nodeaddress_to_channeladdresses[msg.sender];
        address[] storage partner_channels = data.nodeaddress_to_channeladdresses[partner];

        address[] memory sortedAddresses = sortAddresses(msg.sender, partner);
        bytes32 party_hash = keccak256(abi.encodePacked(sortedAddresses[0], sortedAddresses[1]));

        uint256 channel_pos = data.partyhash_to_channelpos[party_hash];

        if (channel_pos > 0) {
            address settledChannelAddress = data.all_channels[channel_pos -1];
            require(!contractExists(settledChannelAddress), ""Settled channel contract still exists"");
            data.all_channels[channel_pos - 1] = address(0); //Placeholder for new channel address
            caller_channels[data.node_index[msg.sender][channel_pos-1]] = address(0); //Placeholder for new channel address
            partner_channels[data.node_index[partner][channel_pos-1]] = address(0); //Placeholder for new channel address

        } else {
            channel_pos = data.all_channels.length + 1;
            data.partyhash_to_channelpos[party_hash] = channel_pos;
            data.node_index[msg.sender][channel_pos -1] = caller_channels.length;
            data.node_index[partner][channel_pos -1] = partner_channels.length;
        }

        //Assume NettingChannelContract constructor takes settle_timeout as parameter
        NettingChannelContract newChannelContract = new NettingChannelContract(msg.sender, partner, settle_timeout);
        data.all_channels.push(address(newChannelContract));
        caller_channels.push(address(newChannelContract));
        partner_channels.push(address(newChannelContract));
    }

    function sortAddresses(address a, address b) internal pure returns (address[] memory) {
        if (a < b) {
            return new address[](2);
        } else {
            return new address[](2);
        }
    }

    function contractExists(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }
}

contract NettingChannelContract {
    constructor(address a, address b, uint256 timeout) {
        //Implementation of NettingChannelContract
    }
}",45.55375003814697,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NettingChannelManager is Ownable {

    struct Data {
        address[] all_channels;
        mapping(address => address[]) nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        mapping(address => mapping(uint256 => uint256)) node_index;
    }

    Data public data;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        data.all_channels = new address[](0);
    }

    function newChannel(address partner, uint256 settle_timeout) public {
        require(partner != address(0), ""Invalid partner address"");
        address[] storage caller_channels = data.nodeaddress_to_channeladdresses[msg.sender];
        address[] storage partner_channels = data.nodeaddress_to_channeladdresses[partner];

        address[] memory sortedAddresses = sortAddresses(msg.sender, partner);
        bytes32 party_hash = keccak256(abi.encodePacked(sortedAddresses[0], sortedAddresses[1]));

        uint256 channel_pos = data.partyhash_to_channelpos[party_hash];

        if (channel_pos > 0) {
            address settledChannelAddress = data.all_channels[channel_pos - 1];
            require(!contractExists(settledChannelAddress), ""Settled channel contract still exists"");
            data.all_channels[channel_pos - 1] = address(0); //Placeholder for new channel address
            caller_channels[data.node_index[msg.sender][channel_pos - 1]] = address(0); //Placeholder for new channel address
            partner_channels[data.node_index[partner][channel_pos - 1]] = address(0); //Placeholder for new channel address
        } else {
            channel_pos = data.all_channels.length + 1;
            data.partyhash_to_channelpos[party_hash] = channel_pos;
            data.node_index[msg.sender][channel_pos - 1] = caller_channels.length;
            data.node_index[partner][channel_pos - 1] = partner_channels.length;
        }

        // Assume NettingChannelContract constructor takes settle_timeout as parameter
        NettingChannelContract newChannelContract = new NettingChannelContract(msg.sender, partner, settle_timeout);
        data.all_channels.push(address(newChannelContract));
        caller_channels.push(address(newChannelContract));
        partner_channels.push(address(newChannelContract));
    }

    function sortAddresses(address a, address b) internal pure returns (address[] memory) {
        if (a < b) {
            return [a, b];
        } else {
            return [b, a];
        }
    }

    function contractExists(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract NettingChannelContract {
    constructor(address a, address b, uint256 timeout) {
        // Implementation of NettingChannelContract
    }
}"
6848,from ` _from ` will be sended ` _value ` tokens to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public approved;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        approved[_from][msg.sender] = approved[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}",transferFrom,"[{'function': 'transferFrom', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.92688282996981,0.6434483791383646,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(allowances[_from][msg.sender] >= _value);
        require(balances[_from] >= _value);
        require(_value > 0);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }
}",42.45895838737488,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Initial balance for the contract owner
        allowances[msg.sender][address(this)] = type(uint256).max; // Infinite allowance for self (contract itself)
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(allowances[_from][msg.sender] >= _value);
        require(balances[_from] >= _value);
        require(_value > 0);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }
}"
967,Sets the message sender as the winner if they have completed the hunt,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    bool public grace = false;
    uint[] public locations;
    mapping(address => Hunter[]) public hunters;
    address public winner;
    uint public timeOfWin;

    struct Hunter {
        uint block;
        bytes32 encryptKey;
    }

    event WonEvent(address indexed winner);

    function checkWin(uint[] memory decryptKeys) public {
        require(!grace, ""Grace period is active"");
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        uint lastBlock = 0;
        bool won = true;

        for (uint i = 0; i < locations.length; i++) {
            require(hunters[msg.sender][i].block > lastBlock, ""Blocks must be in increasing order"");
            lastBlock = hunters[msg.sender][i].block;

            if (locations[i] != 0) {
                uint storedVal = uint(keccak256(abi.encodePacked(hunters[msg.sender][i].encryptKey ^ decryptKeys[i])));
                won = won && (locations[i] == storedVal);
            }
        }

        require(won, ""Not all conditions are met"");

        if (won) {
            timeOfWin = block.timestamp;
            winner = msg.sender;
            grace = true;
            emit WonEvent(winner);
        }
    }
}",checkWin,"[{'function': 'checkWin', 'complexity': 12}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkWin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""decryptKeys"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""grace""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Game is in grace period""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""decryptKeys""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""locations""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect number of keys""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""allMatch"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""prevBlockNumber"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""locations""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""prevBlockNumber""}}, {""type"": ""stringLiteral"", ""value"": ""Replay attack detected""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""prevBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""submissionBlockNumbers""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""blockNumber""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""locations""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""decryptedValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""^"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""locations""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""decryptKeys""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""decryptedValue""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""allMatch""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, "";""]}, ""FalseBody"": None}]}, ""FalseBody"": None}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""allMatch""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeOfWin""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""winner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""grace""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WonEvent""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.8101752402915291,0.3697162994590726,"pragma solidity ^0.8.0;

contract Game {

    uint256[] public locations;
    uint256 public timeOfWin;
    address public winner;
    bool public grace;
    uint256[] public submissionBlockNumbers;

    event WonEvent(address indexed winner);

    function checkWin(uint256[] memory decryptKeys) public {
        require(!grace, ""Game is in grace period"");
        require(decryptKeys.length == locations.length, ""Incorrect number of keys"");

        bool allMatch = true;
        uint256 prevBlockNumber = 0;

        for (uint256 i = 0; i < locations.length; i++) {
            uint256 blockNumber = block.number;
            require(blockNumber > prevBlockNumber, ""Replay attack detected"");
            prevBlockNumber = blockNumber;
            submissionBlockNumbers.push(blockNumber);

            if (locations[i] != 0) {
                uint256 decryptedValue = locations[i] ^ decryptKeys[i];
                if (decryptedValue != i + 1) {
                    allMatch = false;
                    break;
                }
            }
        }

        if (allMatch) {
            timeOfWin = block.timestamp;
            winner = msg.sender;
            grace = true;
            emit WonEvent(msg.sender);
        }
    }
}",42.79661464691162,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Game is Ownable {
    uint256[] public locations;
    uint256 public timeOfWin;
    address public winner;
    bool public grace;
    uint256[] public submissionBlockNumbers;

    event WonEvent(address indexed winner);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        locations = [1, 2, 3]; // Fixed array of length 3 initialized to specific values
        timeOfWin = block.timestamp; // Set to current timestamp
        winner = msg.sender; // Address set to the deployer's address
        grace = true; // Bool set to true
    }

    function checkWin(uint256[] memory decryptKeys) public {
        require(!grace, ""Game is in grace period"");
        require(decryptKeys.length == locations.length, ""Incorrect number of keys"");

        bool allMatch = true;
        uint256 prevBlockNumber = 0;

        for (uint256 i = 0; i < locations.length; i++) {
            uint256 blockNumber = block.number;
            require(blockNumber > prevBlockNumber, ""Replay attack detected"");
            prevBlockNumber = blockNumber;
            submissionBlockNumbers.push(blockNumber);

            if (locations[i] != 0) {
                uint256 decryptedValue = locations[i] ^ decryptKeys[i];
                if (decryptedValue != i + 1) {
                    allMatch = false;
                    break;
                }
            }
        }

        if (allMatch) {
            timeOfWin = block.timestamp;
            winner = msg.sender;
            grace = true;
            emit WonEvent(msg.sender);
        }
    }
}"
5478,Allow users to buy tokens for ` _buyExchangeRate ` eth and sell tokens for ` _sellExchangeRate ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExchangeRateSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    function setExchangeRate(uint256 _sellExchangeRate, uint256 _buyExchangeRate) public onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}",setExchangeRates,"[{'function': 'setExchangeRates', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setExchangeRates"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_sellExchangeRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_buyExchangeRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellExchangeRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_sellExchangeRate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyExchangeRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyExchangeRate""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9716341005719484,0.8979542144404234,"pragma solidity ^0.8.0;

contract ExchangeRateSetter {

    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function setExchangeRates(uint256 _sellExchangeRate, uint256 _buyExchangeRate) public onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }

    function owner() public view returns (address) {
        return owner;
    }
}",41.85934281349182,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ExchangeRateSetter is Ownable {
    uint256 public sellExchangeRate = 1;
    uint256 public buyExchangeRate = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setExchangeRates(uint256 _sellExchangeRate, uint256 _buyExchangeRate) public onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}"
1010,Fills a offer that has been previously made using ` makeOffer ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Assuming _v, _r, and _s are state variables or parameters passed to the function
    bytes32 private constant EIP191_PREFIX = 0x1901;

    constructor() Ownable() {}

    function fillOffer(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint64 _nonce, uint8 v, bytes32 r, bytes32 s) external onlyOwner {
        require(_recoverAddress(keccak256(abi.encodePacked(EIP191_PREFIX, ""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce)), v, r, s) == _filler, ""Invalid signature"");
        bytes32 msgHash = keccak256(abi.encodePacked(""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
        _validateAndAddHash(msgHash);
        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    function _validateAndAddHash(bytes32 hash) internal virtual;

    function _fill(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount) internal virtual;
}",fillOffer,"[{'function': '_recoverAddress', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}, {'function': '_fill', 'complexity': 0}, {'function': 'fillOffer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""fillOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_filler"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_offerHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountToTake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_feeAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""msgHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_filler""}, {""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""_amountToTake""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recoveredAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recoverAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""msgHash""}, {""type"": ""Identifier"", ""name"": ""_v""}, {""type"": ""Identifier"", ""name"": ""_r""}, {""type"": ""Identifier"", ""name"": ""_s""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""recoveredAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_filler""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_validateAndAddHash""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""msgHash""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_fill""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_filler""}, {""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""_amountToTake""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCoordinator"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyActiveState"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.9051114664795544,0.5615993732734342,"pragma solidity ^0.8.0;

contract CoordinatorContract {

    // Assume these modifiers and functions are defined elsewhere in the contract
    modifier onlyCoordinator() {
        // ...
        _;
    }

    modifier onlyActiveState() {
        // ...
        _;
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        // ...
    }

    function _validateAndAddHash(bytes32 hash) internal {
        // ...
    }

    function _fill(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount) internal {
        // ...
    }


    function fillOffer(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public onlyCoordinator onlyActiveState {
        bytes32 msgHash = keccak256(abi.encodePacked(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
        address recoveredAddress = _recoverAddress(msgHash, _v, _r, _s);
        require(recoveredAddress == _filler, ""Invalid signature"");
        _validateAndAddHash(msgHash);
        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
    }
}",43.143096923828125,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CoordinatorContract is Ownable {
    modifier onlyCoordinator() {
        // ...
        _;
    }

    modifier onlyActiveState() {
        // ...
        _;
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        // ...
    }

    function _validateAndAddHash(bytes32 hash) internal {
        // ...
    }

    function _fill(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount) internal {
        // ...
    }

    function fillOffer(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public onlyCoordinator onlyActiveState {
        bytes32 msgHash = keccak256(abi.encodePacked(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
        address recoveredAddress = _recoverAddress(msgHash, _v, _r, _s);
        require(recoveredAddress == _filler, ""Invalid signature"");
        _validateAndAddHash(msgHash);
        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
1790,Update the Synthetix Drawing Rights exchange rate based on other rates already updated .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public xdrParticipants;
    mapping(address => uint256) public rates;
    mapping(string => uint256) public lastRateUpdateTimes;

    event RatesUpdated(bytes4[] currencyCode, uint256[] rate);

    function updateXDRRate(uint timeSent) external onlyOwner {
        uint total = 0;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            total = rates[xdrParticipants[i]].add(total);
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;

        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";

        uint[] memory eventRate = new uint[](1);
        eventRate[0] = rates[""XDR""];

        emit RatesUpdated(eventCurrencyCode, eventRate);
    }
}",updateXDRRate,"[{'function': 'updateXDRRate', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateXDRRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""total"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""xdrParticipants""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""total""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""xdrParticipants""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}, ""right"": {""type"": ""Identifier"", ""name"": ""total""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lastRateUpdateTimes""}, ""index"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""length"": None}, ""name"": ""eventCurrencyCode"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""eventCurrencyCode""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""eventRate"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""eventRate""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""total""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RatesUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""eventCurrencyCode""}, {""type"": ""Identifier"", ""name"": ""eventRate""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.9228795132858416,0.7495933308697189,"pragma solidity ^0.8.0;

contract XDRRateUpdater {

    mapping(bytes4 => uint) public rates;
    mapping(bytes4 => uint) public lastRateUpdateTimes;
    bytes4[] public xdrParticipants;

    event RatesUpdated(bytes4[] currencyCodes, uint[] rates);

    function updateXDRRate(uint timeSent) public {
        uint total;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            total += rates[xdrParticipants[i]];
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;
        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";
        uint[] memory eventRate = new uint[](1);
        eventRate[0] = total;
        emit RatesUpdated(eventCurrencyCode, eventRate);
    }
}",42.513235092163086,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract XDRRateUpdater is Ownable {
    mapping(bytes4 => uint) public rates;
    mapping(bytes4 => uint) public lastRateUpdateTimes;
    bytes4[] public xdrParticipants;

    event RatesUpdated(bytes4[] currencyCodes, uint[] rates);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 0; i < 3; i++) {
            xdrParticipants.push(bytes4(uint(keccak256(abi.encodePacked(""address"", i)))));
        }
        rates[""XDR""] = 1; // Set to 1 (never 0)
        lastRateUpdateTimes[""XDR""] = block.timestamp; // Use current timestamp
    }

    function updateXDRRate(uint timeSent) public {
        uint total;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            total += rates[xdrParticipants[i]];
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;
        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";
        uint[] memory eventRate = new uint[](1);
        eventRate[0] = total;
        emit RatesUpdated(eventCurrencyCode, eventRate);
    }
}"
3704,Buy tokens from contract by sending ethereum to contract address with no minimum contribution,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint public buyPrice = 100; // Example price, adjust as needed
    Token token;

    mapping(address => uint256) public balanceOf;
    address public creator;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(Token _token, address _creator) {
        token = _token;
        creator = _creator;
    }

    function () external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint amount = msg.value.mul(buyPrice);
        uint amountRaised;
        amountRaised = amountRaised.add(msg.value);
        require(token.balanceOf(creator) >= amount, ""Insufficient balance of creator"");
        require(msg.value > 0, ""Amount must be greater than zero"");
        token.transfer(msg.sender, amount);
        token.transfer(creator, msg.value);
    }
}",buyTokens,"[{'function': 'buyTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Ether value must be non-negative""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensToTransfer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""buyPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""creator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToTransfer""}}, {""type"": ""stringLiteral"", ""value"": ""Creator has insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""amountRaised""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToTransfer""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""creator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToTransfer""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""creator""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokensToTransfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""creator""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountRaised""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",,0.8229637677722,0.117148774800355,"pragma solidity ^0.8.0;

contract TokenContract {
    address payable public creator;
    mapping(address => uint256) public balanceOf;
    uint256 public amountRaised;
    uint256 public buyPrice;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 _buyPrice) {
        creator = payable(msg.sender);
        buyPrice = _buyPrice;
    }

    function buyTokens() public payable {
        require(msg.value >= 0, ""Ether value must be non-negative"");
        uint256 tokensToTransfer = msg.value / buyPrice;
        require(balanceOf[creator] >= tokensToTransfer, ""Creator has insufficient balance"");
        amountRaised += msg.value;
        balanceOf[msg.sender] += tokensToTransfer;
        balanceOf[creator] -= tokensToTransfer;
        emit Transfer(creator, msg.sender, tokensToTransfer);
        payable(creator).transfer(amountRaised);
    }
}",42.5127215385437,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is Ownable {
    address payable public creator = payable(address(0x111));
    mapping(address => uint256) public balanceOf;
    uint256 public amountRaised = 0;
    uint256 public buyPrice = 1 ether; // Assuming ether is used for token purchase

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        creator = payable(msg.sender);
        balanceOf[creator] = 1000; // Initial tokens for the creator
    }

    function buyTokens() public payable {
        require(msg.value >= 0, ""Ether value must be non-negative"");
        uint256 tokensToTransfer = msg.value / buyPrice;
        require(balanceOf[creator] >= tokensToTransfer, ""Creator has insufficient balance"");
        amountRaised += msg.value;
        balanceOf[msg.sender] += tokensToTransfer;
        balanceOf[creator] -= tokensToTransfer;
        emit Transfer(creator, msg.sender, tokensToTransfer);
        payable(creator).transfer(amountRaised);
    }
}"
2468,"Decentralizes the contract , this operation can not be undone","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function removeOwnership(address _dece) public onlyOwner {
        require(_dece == 0xdece);
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}",removeOwnership,"[{'function': 'removeOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_dece"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_dece""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0xdece"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipRemoved""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.987846822689049,0.8087405797366504,"pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    address public newOwnerCandidate;

    event OwnershipRemoved();

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function removeOwnership(address _dece) external onlyOwner {
        require(_dece == 0xdece, ""Invalid address"");
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}",41.46460103988648,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public owner;
    address public newOwnerCandidate;

    event OwnershipRemoved();

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function removeOwnership(address _dece) external onlyOwner {
        require(_dece == 0xdece, ""Invalid address"");
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}"
97,This is public rather than external so it can be called by derived contracts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused = true;

    modifier onlyManager() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}",unpause,"[{'function': 'unpause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {
    bool public paused;
    address public manager;

    modifier onlyManager() {
        require(msg.sender == manager, ""Not authorized"");
        _;
    }

    constructor() {
        manager = msg.sender;
        paused = false;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}",41.35605955123901,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool public paused;
    address public manager;

    modifier onlyManager() {
        require(msg.sender == manager, ""Not authorized"");
        _;
    }

    constructor() Ownable() {
        manager = msg.sender;
        paused = false;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}"
5181,Checks if an address ` _address ` is one of 3rd party owners ( origin owner is not included ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Role { ROLE_THIRDPARTY_OWNER }
    mapping(address => mapping(Role => bool)) public ownerRoles;

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return ownerRoles[_address][ROLE_THIRDPARTY_OWNER];
    }
}",isThirdPartyOwner,"[{'function': 'isThirdPartyOwner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isThirdPartyOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerRoles""}, ""memberName"": ""hasEqual""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""ROLE_THIRDPARTY_OWNER""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",3.0,0.7597089278207207,0.6187934993051338,"pragma solidity ^0.8.0;

contract MyContract {

    // Assume ownerRoles and ROLE_THIRDPARTY_OWNER are defined elsewhere in the contract

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return ownerRoles.hasEqual(_address, ROLE_THIRDPARTY_OWNER);
    }
}",41.41028499603272,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    // Assume ownerRoles and ROLE_THIRDPARTY_OWNER are defined elsewhere in the contract

    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(OWNER) {
        // Initialize other state variables here, if needed
    }

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return ownerRoles.hasEqual(_address, ROLE_THIRDPARTY_OWNER);
    }
}"
4562,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ISecurityToken {
    function totalSupplyAt(uint256 checkpointId) external view returns (uint256);
    function balanceOfAt(address account, uint256 checkpointId) external view returns (uint256);
    function currentCheckpointId() external view returns (uint256);
}

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    struct Dividend {
        uint256 checkpointId;
        uint256 creationTime;
        uint256 maturity;
        uint256 expiry;
        uint256 amount;
        uint256 totalSupply;
        uint256 claimedAmount;
        bool isClaimed;
        uint256 claimableDays;
        uint256 penaltyPercentage;
        bytes32 name;
        mapping(address => bool) dividendExcluded;
    }

    Dividend[] public dividends;
    ISecurityToken public securityToken;
    uint256 public constant EXCLUDED_ADDRESS_LIMIT = 100;

    event EtherDividendDeposited(address indexed sender, uint256 checkpointId, uint256 time, uint256 maturity, uint256 expiry, uint256 amount, uint256 totalSupply, uint256 dividendIndex, bytes32 name);

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, ""Too many addresses excluded"");
        require(_expiry > _maturity, ""Expiry is before maturity"");
        require(_expiry > block.timestamp, ""Expiry is in the past"");
        require(msg.value > 0, ""No dividend sent"");
        require(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId(), ""Invalid checkpoint ID"");
        require(_name[0] != 0, ""Invalid name"");

        uint256 dividendIndex = dividends.length;
        uint256 currentSupply = ISecurityToken(securityToken).totalSupplyAt(_checkpointId);
        uint256 excludedSupply = 0;
        dividends.push(Dividend({
            checkpointId: _checkpointId,
            creationTime: block.timestamp,
            maturity: _maturity,
            expiry: _expiry,
            amount: msg.value,
            totalSupply: 0,
            claimedAmount: 0,
            isClaimed: false,
            claimableDays: 0,
            penaltyPercentage: 0,
            name: _name,
            dividendExcluded: new mapping(address => bool)(address(0))
        }));

        for (uint256 j = 0; j < _excluded.length; j++) {
            require(_excluded[j] != address(0), ""Invalid address"");
            require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], ""Duped exclude address"");
            excludedSupply = excludedSupply.add(ISecurityToken(securityToken).balanceOfAt(_excluded[j], _checkpointId));
            dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;
        }

        dividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);
        emit EtherDividendDeposited(msg.sender, _checkpointId, block.timestamp, _maturity, _expiry, msg.value, currentSupply, dividendIndex, _name);
    }
}",createDividend,"[{'function': 'createDividend', 'complexity': 16}, {'function': 'getCheckpointSupply', 'complexity': 0}, {'function': 'getCurrentCheckpointId', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",12.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maturity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_checkpointId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excluded"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_EXCLUDED""}}, {""type"": ""stringLiteral"", ""value"": ""Too many excluded addresses""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expiry""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maturity""}}, {""type"": ""stringLiteral"", ""value"": ""Expiry must be after maturity""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expiry""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Expiry must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Ether value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_checkpointId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getCurrentCheckpointId""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Checkpoint ID is invalid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Dividend name cannot be empty""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""supply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getCheckpointSupply""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_checkpointId""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalExcludedSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Dividend""}, ""name"": ""newDividend"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Dividend""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maturity""}, {""type"": ""Identifier"", ""name"": ""_expiry""}, {""type"": ""Identifier"", ""name"": ""_checkpointId""}, {""type"": ""Identifier"", ""name"": ""_excluded""}, {""type"": ""Identifier"", ""name"": ""_name""}, {""type"": ""Identifier"", ""name"": ""supply""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newDividend""}, ""memberName"": ""isExcluded""}], ""names"": [""maturity"", ""expiry"", ""checkpointId"", ""excluded"", ""name"", ""totalSupply"", ""isExcluded""]}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid excluded address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isDuplicate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""j""}, ""right"": {""type"": ""Identifier"", ""name"": ""i""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""j""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isDuplicate""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isDuplicate""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Duplicate excluded address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newDividend""}, ""memberName"": ""isExcluded""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalExcludedSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newDividend""}, ""memberName"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalExcludedSupply""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newDividend""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""EtherDividendDeposited""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""Identifier"", ""name"": ""_maturity""}, {""type"": ""Identifier"", ""name"": ""_expiry""}, {""type"": ""Identifier"", ""name"": ""_checkpointId""}, {""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",85.0,0.824332159845665,0.3841595946426942,"pragma solidity ^0.8.0;

contract DividendContract {

    struct Dividend {
        uint256 maturity;
        uint256 expiry;
        uint256 checkpointId;
        address[] excluded;
        string name;
        uint256 totalSupply;
        mapping(address => bool) isExcluded;
    }

    Dividend[] public dividends;
    uint256 public constant MAX_EXCLUDED = 100;

    event EtherDividendDeposited(uint256 indexed dividendIndex, uint256 maturity, uint256 expiry, uint256 checkpointId, string name);


    function createDividend(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, string memory _name) public payable {
        require(_excluded.length <= MAX_EXCLUDED, ""Too many excluded addresses"");
        require(_expiry > _maturity, ""Expiry must be after maturity"");
        require(_expiry > block.timestamp, ""Expiry must be in the future"");
        require(msg.value > 0, ""Ether value must be greater than zero"");
        // Assuming getCheckpointSupply and getCurrentCheckpointId are defined elsewhere
        require(_checkpointId <= getCurrentCheckpointId(), ""Checkpoint ID is invalid"");
        require(bytes(_name).length > 0, ""Dividend name cannot be empty"");

        uint256 supply = getCheckpointSupply(_checkpointId);
        uint256 totalExcludedSupply = 0;

        Dividend memory newDividend = Dividend({
            maturity: _maturity,
            expiry: _expiry,
            checkpointId: _checkpointId,
            excluded: _excluded,
            name: _name,
            totalSupply: supply,
            isExcluded: newDividend.isExcluded
        });

        for (uint256 i = 0; i < _excluded.length; i++) {
            require(_excluded[i] != address(0), ""Invalid excluded address"");
            bool isDuplicate = false;
            for (uint256 j = 0; j < i; j++) {
                if (_excluded[i] == _excluded[j]) {
                    isDuplicate = true;
                    break;
                }
            }
            require(!isDuplicate, ""Duplicate excluded address"");
            newDividend.isExcluded[_excluded[i]] = true;
            // Assuming balanceOf is defined elsewhere
            totalExcludedSupply += balanceOf(_excluded[i]);
        }

        newDividend.totalSupply -= totalExcludedSupply;
        dividends.push(newDividend);

        emit EtherDividendDeposited(dividends.length - 1, _maturity, _expiry, _checkpointId, _name);
    }

    // Placeholder functions -  replace with actual implementations
    function getCheckpointSupply(uint256 _checkpointId) internal view returns (uint256) {
        return 1000; // Replace with actual logic
    }

    function getCurrentCheckpointId() internal view returns (uint256) {
        return 1; // Replace with actual logic
    }

    function balanceOf(address account) internal view returns (uint256) {
        return 100; // Replace with actual logic
    }
}",45.369059324264526,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DividendContract is Ownable {
    struct Dividend {
        uint256 maturity;
        uint256 expiry;
        uint256 checkpointId;
        address[] excluded;
        string name;
        uint256 totalSupply;
        mapping(address => bool) isExcluded;
    }

    Dividend[] public dividends;
    uint256 public constant MAX_EXCLUDED = 100;

    event EtherDividendDeposited(uint256 indexed dividendIndex, uint256 maturity, uint256 expiry, uint256 checkpointId, string name);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        dividends = [];
    }

    function createDividend(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, string memory _name) public payable {
        require(_excluded.length <= MAX_EXCLUDED, ""Too many excluded addresses"");
        require(_expiry > _maturity, ""Expiry must be after maturity"");
        require(_expiry > block.timestamp, ""Expiry must be in the future"");
        require(msg.value > 0, ""Ether value must be greater than zero"");
        require(_checkpointId <= getCurrentCheckpointId(), ""Checkpoint ID is invalid"");
        require(bytes(_name).length > 0, ""Dividend name cannot be empty"");

        uint256 supply = getCheckpointSupply(_checkpointId);
        uint256 totalExcludedSupply = 0;

        Dividend memory newDividend = Dividend({
            maturity: _maturity,
            expiry: _expiry,
            checkpointId: _checkpointId,
            excluded: _excluded,
            name: _name,
            totalSupply: supply,
            isExcluded: newMapping(address)
        });

        for (uint256 i = 0; i < _excluded.length; i++) {
            require(_excluded[i] != address(0), ""Invalid excluded address"");
            bool isDuplicate = false;
            for (uint256 j = 0; j < i; j++) {
                if (_excluded[i] == _excluded[j]) {
                    isDuplicate = true;
                    break;
                }
            }
            require(!isDuplicate, ""Duplicate excluded address"");
            newDividend.isExcluded[_excluded[i]] = true;
            totalExcludedSupply += balanceOf(_excluded[i]);
        }

        newDividend.totalSupply -= totalExcludedSupply;
        dividends.push(newDividend);

        emit EtherDividendDeposited(dividends.length - 1, _maturity, _expiry, _checkpointId, _name);
    }

    function getCheckpointSupply(uint256 _checkpointId) internal view returns (uint256) {
        return 1000; // Replace with actual logic
    }

    function getCurrentCheckpointId() internal view returns (uint256) {
        return 1; // Replace with actual logic
    }

    function balanceOf(address account) internal view returns (uint256) {
        return 100; // Replace with actual logic
    }
}"
6025,Adds a token deposit to ` deposits [ ] ` ; only the ` owner ` can call this function and it will only work if the account sending the tokens has called ` approve ( ) ` so that this contract can call ` transferFrom ( ) ` and take the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenDeposit is Ownable {
    using SafeMath for uint256;

    struct Deposit {
        uint blockNumber;
        ERC20 token;
        uint amount;
    }

    Deposit[] public deposits;

    event NewDeposit(uint indexed id, ERC20 indexed token, uint amount);

    function newTokenDeposit(ERC20 _token, uint _amount, uint _block) public onlyOwner returns (uint _idDeposit) {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_block < block.number, ""Block number must be less than current block number"");
        require(_token.transferFrom(msg.sender, address(this), _amount), ""Token transfer failed"");

        _idDeposit = deposits.length;
        Deposit storage d = deposits[_idDeposit];
        d.blockNumber = _block == 0 ? block.number - 1 : _block;
        d.token = _token;
        d.amount = _amount;

        emit NewDeposit(_idDeposit, _token, _amount);
    }
}",deposit,"[{'function': 'deposit', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_block"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""blockNumber"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_block""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""_block""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}, {""type"": ""stringLiteral"", ""value"": ""Block number must be in the past""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""depositId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""memberName"": ""length""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Deposit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""depositId""}, {""type"": ""Identifier"", ""name"": ""blockNumber""}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NewDeposit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""depositId""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",45.0,0.8773306153492558,0.4763848112337585,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract DepositContract {

    struct Deposit {
        uint256 id;
        uint256 blockNumber;
        IERC20 token;
        uint256 amount;
    }

    Deposit[] public deposits;

    event NewDeposit(uint256 indexed depositId, address indexed token, uint256 amount);

    function deposit(IERC20 _token, uint256 _amount, uint256 _block) public {
        require(_amount > 0, ""Amount must be greater than zero"");
        uint256 blockNumber = _block == 0 ? block.number - 1 : _block;
        require(blockNumber < block.number, ""Block number must be in the past"");
        uint256 depositId = deposits.length;
        _token.transferFrom(msg.sender, address(this), _amount);
        deposits.push(Deposit(depositId, blockNumber, _token, _amount));
        emit NewDeposit(depositId, address(_token), _amount);
    }
}",42.36492133140564,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DepositContract is Ownable {
    struct Deposit {
        uint256 id;
        uint256 blockNumber;
        IERC20 token;
        uint256 amount;
    }

    Deposit[] public deposits;

    event NewDeposit(uint256 indexed depositId, address indexed token, uint256 amount);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
        // For ERC20 or similar constructors requiring arguments, use placeholder values like 'MyToken'
    }

    function deposit(IERC20 _token, uint256 _amount, uint256 _block) public {
        require(_amount > 0, ""Amount must be greater than zero"");
        uint256 blockNumber = _block == 0 ? block.number - 1 : _block;
        require(blockNumber < block.number, ""Block number must be in the past"");
        uint256 depositId = deposits.length;
        _token.transferFrom(msg.sender, address(this), _amount);
        deposits.push(Deposit(depositId, blockNumber, _token, _amount));
        emit NewDeposit(depositId, address(_token), _amount);
    }
}"
521,set the ticker registration fee in POLY tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PolyRegistration {
    using SafeMath for uint256;

    uint256 public registrationFee;

    event LogChangePolyRegisterationFee(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(registrationFee != _registrationFee);
        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
        registrationFee = _registrationFee;
    }
}",changePolyRegisterationFee,"[{'function': 'changePolyRegisterationFee', 'complexity': 1}, {'function': 'owner', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""changePolyRegisterationFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_registrationFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_registrationFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""registrationFee""}}, {""type"": ""stringLiteral"", ""value"": ""New fee must be different from current fee""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogChangePolyRegisterationFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""registrationFee""}, {""type"": ""Identifier"", ""name"": ""_registrationFee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""registrationFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_registrationFee""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.98706051942016,0.634529611711301,"pragma solidity ^0.8.0;

contract PolygonRegistration {

    uint256 public registrationFee;

    event LogChangePolyRegisterationFee(uint256 oldRegistrationFee, uint256 newRegistrationFee);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(_registrationFee != registrationFee, ""New fee must be different from current fee"");
        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
        registrationFee = _registrationFee;
    }

    function owner() public view returns (address) {
        return owner;
    }
}",42.192517042160034,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming you have an import for Ownable
import ""openzeppelin/SafeMath.sol"";
contract PolygonRegistration is Ownable {
    uint256 public registrationFee;

    event LogChangePolyRegisterationFee(uint256 oldRegistrationFee, uint256 newRegistrationFee);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        registrationFee = 1;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(_registrationFee != registrationFee, ""New fee must be different from current fee"");
        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
        registrationFee = _registrationFee;
    }

    function owner() public view override returns (address) {
        return super.owner();
    }
}"
2313,Set both ico min at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoMin;
    uint256 public preIcoLimit;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public onlyOwner {
        require(newIcoMin > 0, ""New ICO minimum must be greater than zero"");
        require(newPreIcoLimit > 0, ""New pre-ICO limit must be greater than zero"");
        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;
        updatePrices();
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Block number must be greater than current block number or zero"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(name, url, blockNumber);
    }
}",setIcosMinLimit,"[{'function': 'setIcosMinLimit', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcosMinLimit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newIcoMin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPreIcoLimit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newIcoMin""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""newIcoMin must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newPreIcoLimit""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""newPreIcoLimit must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoMin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newIcoMin""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preIcoLimit""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPreIcoLimit""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9544438976686008,0.6796839365925623,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public icoMin;
    uint256 public preIcoLimit;
    address public owner;

    modifier isOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public isOwner {
        require(newIcoMin > 0, ""newIcoMin must be greater than 0"");
        require(newPreIcoLimit > 0, ""newPreIcoLimit must be greater than 0"");
        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;
        updatePrices();
    }

    function updatePrices() internal {
        //Implementation for updating prices
    }
}",42.073461055755615,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {

    uint256 public icoMin;
    uint256 public preIcoLimit;
    address public owner;

    modifier isOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    constructor() Ownable(msg.sender) {
        icoMin = 1;
        preIcoLimit = 1;
        owner = msg.sender;
    }

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public isOwner {
        require(newIcoMin > 0, ""newIcoMin must be greater than 0"");
        require(newPreIcoLimit > 0, ""newPreIcoLimit must be greater than 0"");
        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;
        updatePrices();
    }

    function updatePrices() internal {
        //Implementation for updating prices
    }
}"
1838,Keep a US Citizen 's tokens for one year .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool claimed;
    }

    mapping(address => Holding) public heldTokens;
    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    function hold(address who, uint256 quantity) public onlyOwner {
        require(who != address(0), ""The null address cannot own tokens."");
        require(quantity > 0, ""Quantity must be greater than zero."");
        require(!isExistingHolding(who), ""Cannot overwrite an existing holding, use a new wallet."");

        Holding memory holding = Holding(quantity, block.timestamp + oneYear, false);
        heldTokens[who] = holding;
        emit TokensHeld(who, holding.quantity, holding.releaseDate);
    }

    function isExistingHolding(address who) internal view returns (bool) {
        return heldTokens[who].quantity > 0;
    }

    uint256 constant oneYear = 365 days;
}",hold,"[{'function': 'hold', 'complexity': 4}, {'function': 'isExistingHolding', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""hold"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""who""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Quantity must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isExistingHolding""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Holding already exists""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""releaseDate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""31536000"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""heldTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Holding""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""releaseDate""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensHeld""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""releaseDate""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.9072444722028064,0.53913514745554,"pragma solidity ^0.8.0;

contract TokenHolder {

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isReleased;
    }

    mapping(address => Holding) public heldTokens;

    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    function hold(address who, uint256 quantity) public {
        require(who != address(0), ""Address cannot be zero"");
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(!isExistingHolding(who), ""Holding already exists"");

        uint256 releaseDate = block.timestamp + 31536000; // One year from now

        heldTokens[who] = Holding(quantity, releaseDate, false);

        emit TokensHeld(who, quantity, releaseDate);
    }

    function isExistingHolding(address who) public view returns (bool) {
        return heldTokens[who].quantity > 0;
    }
}",42.47772979736328,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenHolder is Ownable {
    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isReleased;
    }

    mapping(address => Holding) public heldTokens;

    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            heldTokens[addr] = Holding(1, block.timestamp + 31536000, false);
        }
    }

    function hold(address who, uint256 quantity) public {
        require(who != address(0), ""Address cannot be zero"");
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(!isExistingHolding(who), ""Holding already exists"");

        uint256 releaseDate = block.timestamp + 31536000; // One year from now

        heldTokens[who] = Holding(quantity, releaseDate, false);

        emit TokensHeld(who, quantity, releaseDate);
    }

    function isExistingHolding(address who) public view returns (bool) {
        return heldTokens[who].quantity > 0;
    }
}"
6404,Adds multiple addresses to the administrator list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdminManagement is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    function addManyAdmins(_accounts: address[]) external onlyOwner returns (bool) {
        for (uint8 i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            if (account != address(0) && !admins[account] && account != owner()) {
                admins[account] = true;
                emit AdminAdded(_accounts[i]);
            }
        }
        return true;
    }
}",addAdmins,"[{'function': 'addAdmins', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAdmins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_accounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_accounts""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Account cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Account is already an admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Owner cannot be added as admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AdminAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",64.0,0.902926640639596,0.3988037895677906,"pragma solidity ^0.8.0;

contract AdminManager {

    mapping(address => bool) public admins;
    address public owner;

    event AdminAdded(address indexed account);

    modifier onlyAdmin() {
        require(admins[msg.sender], ""Caller is not an admin"");
        _;
    }

    constructor() {
        owner = msg.sender;
        admins[msg.sender] = true;
    }

    function addAdmins(address[] memory _accounts) public onlyAdmin returns (bool) {
        for (uint256 i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            require(account != address(0), ""Account cannot be zero address"");
            require(!admins[account], ""Account is already an admin"");
            require(account != owner, ""Owner cannot be added as admin"");
            admins[account] = true;
            emit AdminAdded(account);
        }
        return true;
    }
}",42.24203777313232,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AdminManager is Ownable {
    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    modifier onlyAdmin() {
        require(admins[msg.sender], ""Caller is not an admin"");
        _;
    }

    constructor() Ownable(msg.sender) {
        admins[_owner] = true;
    }

    function addAdmins(address[] memory _accounts) public onlyOwner returns (bool) {
        for (uint256 i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            require(account != address(0), ""Account cannot be zero address"");
            require(!admins[account], ""Account is already an admin"");
            require(account != owner(), ""Owner cannot be added as admin"");
            admins[account] = true;
            emit AdminAdded(account);
        }
        return true;
    }
}"
892,Sets the default fee for burning CarbonDollar into a whitelisted stablecoin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public defaultFee;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;
        if (oldFee != defaultFee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}",setDefaultFee,"[{'function': 'setDefaultFee', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setDefaultFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldFee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""defaultFee""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""defaultFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""oldFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DefaultFeeChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldFee""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9793515164487224,0.9184678024441792,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public defaultFee;
    address public owner;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;
        if (oldFee != _fee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}",41.94003582000733,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public defaultFee = 1;
    address public owner = msg.sender;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;
        if (oldFee != _fee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}"
3332,"Gets all the open data orders , that is all the DataOrders that are still receiving new DataResponses .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OpenOrdersWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address userAddress;
        uint256 amount;
    }

    mapping(uint256 => Order) public orders;
    uint256 public orderCount;

    function getOpenOrders() public view returns (address[] memory) {
        address[] memory openOrders = new address[](orderCount);
        for (uint256 i = 0; i < orderCount; i++) {
            openOrders[i] = orders[i].userAddress;
        }
        return openOrders;
    }
}",getOpenOrders,"[{'function': 'getOpenOrders', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getOpenOrders"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""openOrders""}, ""memberName"": ""addresses""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",29.0,0.487868890490597,0.1425042222854427,"pragma solidity ^0.8.0;

contract OpenOrders {
    struct OpenOrdersStruct {
        address[] addresses;
    }

    OpenOrdersStruct public openOrders;

    function getOpenOrders() public view returns (address[] memory) {
        return openOrders.addresses;
    }
}",41.179473876953125,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OpenOrders is Ownable {
    struct OpenOrdersStruct {
        address[] addresses;
    }

    OpenOrdersStruct public openOrders = OpenOrdersStruct({addresses: [address(0x111), address(0x222), address(0x333)]});

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getOpenOrders() public view returns (address[] memory) {
        return openOrders.addresses;
    }
}"
2110,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public converterRamp;

    event SetConverterRamp(address oldConverterRamp, address newConverterRamp);

    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}",setConverterRamp,"[{'function': 'setConverterRamp', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_converterRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetConverterRamp""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""converterRamp""}, {""type"": ""Identifier"", ""name"": ""_converterRamp""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""converterRamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""_converterRamp""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9819847172109382,0.8985396083419646,"pragma solidity ^0.8.0;

contract MyContract {

    address public converterRamp;
    address private owner;

    event SetConverterRamp(address indexed oldConverterRamp, address indexed newConverterRamp);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setConverterRamp(address _converterRamp) public onlyOwner returns (bool) {
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}",41.95938777923584,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public converterRamp;

    event SetConverterRamp(address indexed oldConverterRamp, address indexed newConverterRamp);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    constructor(address _converterRamp) Ownable(msg.sender) {
        converterRamp = _converterRamp;
    }

    function setConverterRamp(address _converterRamp) public onlyOwner returns (bool) {
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}"
1438,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;
    mapping(bytes => bool) public signatures;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _token, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27 + uint8(_signature[64]), bytes32(_signature[:32]), bytes32(_signature[32:64]));
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender address is not provided"");
        require(signatures[_signature] == false, ""No Signature"");
        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0), ""From address is not provided"");
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        signatures[_signature] = true;
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}",increaseApprovalPreSigned,"[{'function': 'increaseApprovalPreSigned', 'complexity': 4}, {'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""increaseApprovalPreSigned"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_addedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Spender cannot be zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""increaseApprovalPreSignedHashing""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_addedValue""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hash""}, ""memberName"": ""recover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""signatures""}, ""index"": {""type"": ""Identifier"", ""name"": ""hash""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Signature already used""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_addedValue""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""signatures""}, ""index"": {""type"": ""Identifier"", ""name"": ""hash""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_addedValue""}}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalPreSigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_addedValue""}}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",122.0,0.8225388230602129,0.6064973335532783,"pragma solidity ^0.8.0;

import ""./ECDSA.sol"";

contract MyContract {
    using ECDSA for bytes32;

    mapping(bytes32 => bool) public signatures;
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed signer, address indexed spender, address indexed feePayer, uint256 newAllowance, uint256 fee);

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender cannot be zero address"");

        bytes32 hash = increaseApprovalPreSignedHashing(_spender, _addedValue, _fee, _nonce);
        address from = hash.recover(_signature);
        require(from != address(0), ""Invalid signature"");
        require(!signatures[hash], ""Signature already used"");

        uint256 currentAllowance = allowances[from][_spender];
        allowances[from][_spender] = currentAllowance + _addedValue;
        balances[from] -= _fee;
        balances[msg.sender] += _fee;
        signatures[hash] = true;

        emit Approval(from, _spender, currentAllowance + _addedValue);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, currentAllowance + _addedValue, _fee);

        return true;
    }

    function increaseApprovalPreSignedHashing(address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_spender, _addedValue, _fee, _nonce));
    }

    // ... other functions ...
}",43.79423213005066,"pragma solidity ^0.8.0;

import ""./ECDSA.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import path for Ownable
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using ECDSA for bytes32;

    mapping(bytes32 => bool) public signatures;
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed signer, address indexed spender, address indexed feePayer, uint256 newAllowance, uint256 fee);

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            if (i == 0) balances[address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))))] = 1;
            else balances[address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))))] = 1;
        }
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender cannot be zero address"");

        bytes32 hash = increaseApprovalPreSignedHashing(_spender, _addedValue, _fee, _nonce);
        address from = hash.recover(_signature);
        require(from != address(0), ""Invalid signature"");
        require(!signatures[hash], ""Signature already used"");

        uint256 currentAllowance = allowances[from][_spender];
        allowances[from][_spender] = currentAllowance + _addedValue;
        balances[from] -= _fee;
        balances[msg.sender] += _fee;
        signatures[hash] = true;

        emit Approval(from, _spender, currentAllowance + _addedValue);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, currentAllowance + _addedValue, _fee);

        return true;
    }

    function increaseApprovalPreSignedHashing(address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_spender, _addedValue, _fee, _nonce));
    }

    // ... other functions ...
}"
2532,Remove an address owned by a holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderManager is Ownable {
    using SafeMath for uint256;

    struct HoldersData {
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
        uint holderAddressCount;
    }

    mapping(bytes32 => uint) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    HoldersData[] public holders;

    event HolderAddressRemoved(bytes32 indexed externalHolderId, address indexed removedAddress, uint holderIndex);

    function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {
        uint _holderIndex = holderIndex[_externalHolderId];
        require(_holderIndex != 0);
        HoldersData storage _holderData = holders[_holderIndex];
        uint _tempIndex = _holderData.address2Index[_address];
        require(_tempIndex != 0);
        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];
        _holderData.address2Index[_lastAddress] = _tempIndex;
        _holderData.index2Address[_tempIndex] = _lastAddress;
        delete _holderData.address2Index[_address];
        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);
        delete holderAddress2Id[_address];
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
        return OK;
    }

    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _address, uint _holderIndex) internal {
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
    }
}",removeHolderAddress,"[{'function': 'removeHolderAddress', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeHolderAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_externalHolderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_holderIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""externalHolderId2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Holder does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tempIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""address2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tempIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Address not associated with holder""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_lastAddressIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}, ""memberName"": ""addresses""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_lastAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}, ""memberName"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_lastAddressIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}, ""memberName"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tempIndex""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_lastAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""address2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_lastAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tempIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}, ""memberName"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_lastAddressIndex""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}, ""memberName"": ""addresses""}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""address2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}, ""memberName"": ""holderAddressCount""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderAddress2Id""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""isPrefix"": True}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""HolderAddressRemoved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""_holderIndex""}, {""type"": ""Identifier"", ""name"": ""_externalHolderId""}], ""names"": []}}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",45.0,0.8323452747476953,0.2461909301396033,"pragma solidity ^0.8.0;

contract HolderRegistry {

    mapping(bytes32 => uint256) public externalHolderId2Index;
    struct Holder {
        uint256 holderAddressCount;
        address[] addresses;
    }
    Holder[] public holders;
    mapping(address => uint256) public address2Index;
    mapping(address => bytes32) public holderAddress2Id;

    event HolderAddressRemoved(address indexed _address, uint256 indexed _holderIndex, bytes32 indexed _externalHolderId);

    function removeHolderAddress(bytes32 _externalHolderId, address _address) public returns (uint256) {
        uint256 _holderIndex = externalHolderId2Index[_externalHolderId];
        require(_holderIndex > 0, ""Holder does not exist"");

        uint256 _tempIndex = address2Index[_address];
        require(_tempIndex > 0, ""Address not associated with holder"");

        uint256 _lastAddressIndex = holders[_holderIndex].addresses.length - 1;
        address _lastAddress = holders[_holderIndex].addresses[_lastAddressIndex];

        holders[_holderIndex].addresses[_tempIndex] = _lastAddress;
        address2Index[_lastAddress] = _tempIndex;

        delete holders[_holderIndex].addresses[_lastAddressIndex];
        holders[_holderIndex].addresses.pop();

        delete address2Index[_address];
        holders[_holderIndex].holderAddressCount--;
        delete holderAddress2Id[_address];

        emit HolderAddressRemoved(_address, _holderIndex, _externalHolderId);
        return 1; // OK
    }
}",43.02354955673218,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HolderRegistry is Ownable {
    mapping(bytes32 => uint256) public externalHolderId2Index;
    struct Holder {
        uint256 holderAddressCount;
        address[] addresses;
    }
    Holder[] public holders;
    mapping(address => uint256) public address2Index;
    mapping(address => bytes32) public holderAddress2Id;

    event HolderAddressRemoved(address indexed _address, uint256 indexed _holderIndex, bytes32 indexed _externalHolderId);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        holders = [Holder({ holderAddressCount: 0, addresses: [] })];
        address2Index[address(0)] = 1;
        holderAddress2Id[address(0)] = bytes32('init');
    }

    function removeHolderAddress(bytes32 _externalHolderId, address _address) public returns (uint256) {
        uint256 _holderIndex = externalHolderId2Index[_externalHolderId];
        require(_holderIndex > 0, ""Holder does not exist"");

        uint256 _tempIndex = address2Index[_address];
        require(_tempIndex > 0, ""Address not associated with holder"");

        uint256 _lastAddressIndex = holders[_holderIndex].addresses.length - 1;
        address _lastAddress = holders[_holderIndex].addresses[_lastAddressIndex];

        holders[_holderIndex].addresses[_tempIndex] = _lastAddress;
        address2Index[_lastAddress] = _tempIndex;

        delete holders[_holderIndex].addresses[_lastAddressIndex];
        holders[_holderIndex].addresses.pop();

        delete address2Index[_address];
        holders[_holderIndex].holderAddressCount--;
        delete holderAddress2Id[_address];

        emit HolderAddressRemoved(_address, _holderIndex, _externalHolderId);
        return 1; // OK
    }
}"
339,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CardInterface {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
    }

    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        address owner = cardTokenToOwner[_tokenId];
        require(owner != address(0));
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
    }
}",getCard,"[{'function': 'getCard', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCard"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Card does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToPosition""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""name""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""token""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.9927662398458962,0.8729118929672821,"pragma solidity ^0.8.0;

contract CardContract {
    struct Card {
        string name;
        uint256 token;
    }

    Card[] public cards;
    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        address owner = cardTokenToOwner[_tokenId];
        require(owner != address(0), ""Card does not exist"");

        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
    }
}",42.09907245635986,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CardContract is Ownable {
    struct Card {
        string name;
        uint256 token;
    }

    Card[] public cards;
    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        cards.push(Card({name: ""Card1"", token: 1}));
        cards.push(Card({name: ""Card2"", token: 1}));
        cards.push(Card({name: ""Card3"", token: 1}));

        // Initialize mappings with fixed values
        cardTokenToOwner[0] = address(0x111);
        cardTokenToOwner[1] = address(0x222);
        cardTokenToOwner[2] = address(0x333);

        cardTokenToPosition[0] = 0;
        cardTokenToPosition[1] = 1;
        cardTokenToPosition[2] = 2;
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        address owner = cardTokenToOwner[_tokenId];
        require(owner != address(0), ""Card does not exist"");

        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
    }
}"
4993,"Reclaim an expired , non-empty swap into a multisig","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Multisig {
        address owner;
        address authority;
        uint deposit;
    }

    struct Swap {
        uint amount;
        uint expirationTime;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;
    mapping(bytes32 => Swap) public hashIdToSwap;

    function reclaimExpiredSwaps(bytes32 msigId, bytes32 swapId) public {
        require(hashIdToMultisig[msigId].owner == msg.sender || hashIdToMultisig[msigId].authority == msg.sender, ""Only the owner or authority of the multisig can reclaim expired swaps"");
        require(block.timestamp >= hashIdToSwap[swapId].expirationTime, ""The swap has not yet expired"");
        uint amount = hashIdToSwap[swapId].amount;
        assert(hashIdToMultisig[msigId].deposit.add(amount) >= hashIdToMultisig[msigId].deposit, ""Insufficient funds in the multisig to reclaim the swap"");
        delete hashIdToSwap[swapId];
        hashIdToMultisig[msigId].deposit = hashIdToMultisig[msigId].deposit.add(amount);
    }
}",reclaimExpiredSwaps,"[{'function': 'reclaimExpiredSwaps', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimExpiredSwaps"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""msigId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""swapId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authority""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}}}, {""type"": ""stringLiteral"", ""value"": ""Unauthorized""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Swap""}, ""name"": ""swap"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToSwap""}, ""index"": {""type"": ""Identifier"", ""name"": ""swapId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""expirationTime""}}, {""type"": ""stringLiteral"", ""value"": ""Swap not expired""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""amount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""msigDeposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""msigDeposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}}, {""type"": ""stringLiteral"", ""value"": ""Overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToSwap""}, ""index"": {""type"": ""Identifier"", ""name"": ""swapId""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""msigDeposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.7198168544994968,0.1689906021755957,"pragma solidity ^0.8.0;

contract MyContract {
    // Define necessary structs and mappings here...  (Example below)
    struct Swap {
        uint256 amount;
        uint256 expirationTime;
    }

    mapping(bytes32 => Swap) public hashIdToSwap;
    mapping(uint256 => uint256) public msigDeposits;
    // ... other state variables ...

    function reclaimExpiredSwaps(uint256 msigId, bytes32 swapId) public {
        // Check caller permissions (replace with your actual permission check)
        require(msg.sender == owner || msg.sender == authority[msigId], ""Unauthorized"");

        Swap storage swap = hashIdToSwap[swapId];
        require(block.timestamp >= swap.expirationTime, ""Swap not expired"");

        uint256 amount = swap.amount;
        require(msigDeposits[msigId] + amount >= msigDeposits[msigId], ""Overflow""); //SafeMath check

        delete hashIdToSwap[swapId];
        msigDeposits[msigId] += amount;
    }

    // ... other functions and state variables ...
    address public owner;
    mapping(uint256 => address) public authority;

}",42.611403465271,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Swap {
        uint256 amount;
        uint256 expirationTime;
    }

    mapping(bytes32 => Swap) public hashIdToSwap;
    mapping(uint256 => uint256) public msigDeposits;

    function reclaimExpiredSwaps(uint256 msigId, bytes32 swapId) public {
        require(msg.sender == owner || msg.sender == authority[msigId], ""Unauthorized"");

        Swap storage swap = hashIdToSwap[swapId];
        require(block.timestamp >= swap.expirationTime, ""Swap not expired"");

        uint256 amount = swap.amount;
        require(msigDeposits[msigId] + amount >= msigDeposits[msigId], ""Overflow""); //SafeMath check

        delete hashIdToSwap[swapId];
        msigDeposits[msigId] += amount;
    }

    mapping(uint256 => address) public authority;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            if (i == 1) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                // Assuming the addresses should be set to specific values for testing or deployment purposes
                // You may need to adjust these based on actual requirements
                emit AddressSet(addr);
            } else if (i == 2) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                // Assuming the addresses should be set to specific values for testing or deployment purposes
                emit AddressSet(addr);
            } else if (i == 3) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                // Assuming the addresses should be set to specific values for testing or deployment purposes
                emit AddressSet(addr);
            }
        }
    }

    event AddressSet(address indexed addr);
}"
5531,Revoke vote for transaction Can be called only by authorized user,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper {
    using SafeMath for uint256;

    function revoke(bytes32 _key) external returns (uint256) {
        return _revoke(_key, msg.sender);
    }

    function _revoke(bytes32 _key, address _account) internal virtual returns (uint256) {
        // Implementation of the revoke logic
    }
}",revoke,"[{'function': 'revoke', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""revoke"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_revoke""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_key""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9684671504945084,0.7417090125042293,"pragma solidity ^0.8.0;

contract KeyRevocation {

    function revoke(bytes32 _key) public returns (uint) {
        return _revoke(_key, msg.sender);
    }

    function _revoke(bytes32 _key, address _sender) internal returns (uint);
}",41.06416153907776,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract KeyRevocation is Ownable {
    bytes32 public constant INITIALIZED = keccak256(""init"");
    mapping(bytes32 => bool) public revokedKeys;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 safeUint = 1;
        address safeAddress1 = address(0x111);
        address safeAddress2 = address(0x222);
        bool safeBool = true;
        string memory safeString = ""initialized"";
        bytes32 safeBytes32 = bytes32('init');

        // Assign initialized values to state variables
        revokedKeys[INITIALIZED] = safeBool;
    }

    function revoke(bytes32 _key) public returns (uint) {
        require(!revokedKeys[_key], ""Key already revoked"");
        revokedKeys[_key] = true;
        return 1; // Return a non-zero value indicating success
    }

    function _revoke(bytes32 _key, address _sender) internal returns (uint) {
        require(!revokedKeys[_key], ""Key already revoked"");
        revokedKeys[_key] = true;
        return 1; // Return a non-zero value indicating success
    }
}"
6063,A user has redeemed a top-up voucher for phone credit .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VoucherRedemption {
    using SafeMath for uint256;

    mapping(address => Order) public orderBook;

    struct Order {
        uint256 price;
    }

    event VoucherRedeemed(uint256 voucherCode, address indexed voucherOwner, address indexed tokenSeller, uint256 quantity);

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public payable onlyOwner {
        buy(tokenSeller, quantity, orderBook[tokenSeller].price);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }

    function buy(address tokenSeller, uint256 quantity, uint256 price) internal {
        // Implementation of the buy logic
    }

    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}",buy,"[{'function': 'buy', 'complexity': 1}, {'function': 'redeemVoucher', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeemVoucher"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""voucherCode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""voucherOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenSeller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""buy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenSeller""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenSeller""}}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""VoucherRedeemed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""voucherCode""}, {""type"": ""Identifier"", ""name"": ""voucherOwner""}, {""type"": ""Identifier"", ""name"": ""tokenSeller""}, {""type"": ""Identifier"", ""name"": ""quantity""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.660976960934119,0.0192781146449883,"pragma solidity ^0.8.0;

contract MyContract {

    // Assuming these are defined elsewhere in the contract
    mapping(address => uint256) public orderBook;
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    event VoucherRedeemed(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity);

    function buy(address _tokenSeller, uint256 _quantity, uint256 _price) internal {
        //Implementation for buy function.  This is a placeholder.  Replace with actual logic.
        require(orderBook[_tokenSeller] >= _price * _quantity, ""Insufficient funds"");
        //Transfer tokens and update orderbook
    }


    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public onlyOwner {
        buy(tokenSeller, quantity, orderBook[tokenSeller]);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }
}",42.45219969749451,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is a standard import for Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => uint256) public orderBook;

    event VoucherRedeemed(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with specific values as per the rules provided
        owner = msg.sender; // Address is set to deployer's address
        orderBook[address(0x111)] = 1; // uint256 set to 1
        orderBook[address(0x222)] = 1; // uint256 set to 1
        orderBook[address(0x333)] = 1; // uint256 set to 1
    }

    function buy(address _tokenSeller, uint256 _quantity, uint256 _price) internal {
        require(orderBook[_tokenSeller] >= _price * _quantity, ""Insufficient funds"");
        // Transfer tokens and update orderbook logic here
    }

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public onlyOwner {
        buy(tokenSeller, quantity, orderBook[tokenSeller]);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }
}"
6774,"Move to ceiling , used as a failsafe","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public currentIndex = 0;

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex.add(1);
    }
}",moveToNextCeiling,"[{'function': 'moveToNextCeiling', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""moveToNextCeiling"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentIndex""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentIndex""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    address public owner;
    uint256 public currentIndex;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex.add(1);
    }
}",41.50064849853516,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256 public currentIndex = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex.add(1);
    }
}"
1493,A function which allows only the owner to change the address of totlePrimary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    address public totlePrimary;

    function setTotle(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0x0));
        totlePrimary = _totlePrimary;
    }
}",setTotlePrimary,"[{'function': 'setTotlePrimary', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTotlePrimary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_totlePrimary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_totlePrimary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totlePrimary""}, ""right"": {""type"": ""Identifier"", ""name"": ""_totlePrimary""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.923211793727403,0.4855332614117322,"pragma solidity ^0.8.0;

contract MyContract {
    address public totlePrimary;

    function setTotlePrimary(address _totlePrimary) public {
        require(_totlePrimary != address(0), ""Address cannot be zero"");
        totlePrimary = _totlePrimary;
    }
}",41.3406720161438,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public totlePrimary;
    bool public initialized = true;
    bytes32 public initBytes;

    // Constructor
    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        totlePrimary = 0x1111111111111111111111111111111111111111; // Replace with actual primary address
        initialized = true;
        initBytes = bytes32('init');

        // Invoke parent contracts' constructors
        Ownable(msg.sender);
    }

    function setTotlePrimary(address _totlePrimary) public {
        require(_totlePrimary != address(0), ""Address cannot be zero"");
        totlePrimary = _totlePrimary;
    }
}"
6875,Allow the token holder to upgrade some of their tokens to the new contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IUpgradeAgent {
    function upgradeFrom(address _from, uint256 _value) external;
}

abstract contract UpgradeableToken is Ownable {
    using SafeMath for uint256;

    enum UpgradeState { Unknown, NotAllowedToUpgrade, ReadyToUpgrade, Upgrading }

    mapping(address => uint256) public balances;
    uint256 public totalSupply_;
    uint256 public totalUpgraded;
    IUpgradeAgent public upgradeAgent;

    event Upgrade(address indexed _from, IUpgradeAgent indexed _agent, uint256 _value);

    function getUpgradeState() public view returns (UpgradeState) {
        if (!isAllowedToUpgrade()) return UpgradeState.NotAllowedToUpgrade;
        if (totalUpgraded == 0 && totalSupply_ > 0) return UpgradeState.ReadyToUpgrade;
        if (totalUpgraded > 0 && totalUpgraded < totalSupply_) return UpgradeState.Upgrading;
        return UpgradeState.Unknown;
    }

    function isAllowedToUpgrade() internal view returns (bool) {
        // Implement your logic to check if the caller is allowed to upgrade
        return true;
    }

    function upgrade(uint256 _value) public {
        require(getUpgradeState() == UpgradeState.ReadyToUpgrade || getUpgradeState() == UpgradeState.Upgrading, ""State must be correct for upgrade"");
        require(_value > 0, ""Upgrade value must be greater than zero"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        upgradeAgent.upgradeFrom(msg.sender, _value);
        emit Upgrade(msg.sender, upgradeAgent, _value);
    }
}",upgrade,"[{'function': 'upgrade', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""upgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""UpgradeState""}, ""name"": ""state"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getUpgradeState""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""ReadyToUpgrade""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""Upgrading""}}}, {""type"": ""stringLiteral"", ""value"": ""Upgrade not allowed in current state""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Upgrade value must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalUpgraded""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalUpgraded""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}, ""memberName"": ""upgradeFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Upgrade""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""upgradeAgent""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",35.0,0.8355920216928274,0.4675962956155534,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract UpgradeableToken is EIP20Token, Burnable {
    using SafeMath for uint256;

    // ... other contract elements ...

    event Upgrade(address indexed _from, address indexed _upgradeAgent, uint256 _value);

    function upgrade(uint256 _value) public {
        UpgradeState state = getUpgradeState();
        require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading, ""Upgrade not allowed in current state"");
        require(_value > 0, ""Upgrade value must be greater than zero"");

        address sender = msg.sender;
        uint256 senderBalance = balanceOf(sender);
        require(senderBalance >= _value, ""Insufficient balance"");

        _transfer(sender, address(this), _value);
        totalSupply_ = totalSupply_.sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        upgradeAgent.upgradeFrom(sender, _value);

        emit Upgrade(sender, address(upgradeAgent), _value);
    }

    // ... other contract elements ...
}",42.69196629524231,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract UpgradeableToken is EIP20Token, Burnable, Ownable {
    using SafeMath for uint256;
    address public constant DEFAULT_UPGRADE_AGENT = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_INITIALIZED = true;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        _initialize();
    }

    function _initialize() internal {
        totalSupply_ = 1; // Set to a fixed value (never 0)
        balanceOf[msg.sender] = 1000; // Set to a fixed value
        totalUpgraded = 0;
        upgradeAgent = DEFAULT_UPGRADE_AGENT;
        state = UpgradeState.ReadyToUpgrade;
    }

    event Upgrade(address indexed _from, address indexed _upgradeAgent, uint256 _value);

    function upgrade(uint256 _value) public {
        UpgradeState state = getUpgradeState();
        require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading, ""Upgrade not allowed in current state"");
        require(_value > 0, ""Upgrade value must be greater than zero"");

        address sender = msg.sender;
        uint256 senderBalance = balanceOf(sender);
        require(senderBalance >= _value, ""Insufficient balance"");

        _transfer(sender, address(this), _value);
        totalSupply_ = totalSupply_.sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        upgradeAgent.upgradeFrom(sender, _value);

        emit Upgrade(sender, address(upgradeAgent), _value);
    }

    // ... other contract elements ...
}"
1111,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function invokeTop() public returns (uint) {
        return 0;
    }
}",top,"[{'function': 'top', 'complexity': 0}, {'function': 'invokeTop', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""top"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9299237055149296,0.0335730648409732,"pragma solidity ^0.8.0;

contract MyContract {

    function top() internal returns (uint256) {
        //Implementation of top function.  Replace this with your actual logic.
        return 10;
    }

    function invokeTop() external returns (uint256) {
        return top();
    }
}",41.41779708862305,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    uint256 public constant TOP = 1;
    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(OWNER) {}

    function top() internal returns (uint256) {
        return TOP;
    }

    function invokeTop() external returns (uint256) {
        return top();
    }
}"
312,Obtain the index of the next schedule entry that will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface VestingEntry {
    function getVestingTime(address account, uint index) external view returns (uint);
    function numVestingEntries(address account) external view returns (uint);
}

abstract contract VestingWrapper is Ownable, VestingEntry {
    using SafeMath for uint;

    function getNextVestingIndex(address account) public view override returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
}",nextVestingIndex,"[{'function': 'numVestingEntries', 'complexity': 0}, {'function': 'getVestingTime', 'complexity': 0}, {'function': 'nextVestingIndex', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""nextVestingIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalEntries"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""numVestingEntries""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalEntries""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getVestingTime""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""i""}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""totalEntries""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9237542865244888,0.6675721432878874,"pragma solidity ^0.8.0;

contract Vesting {

    function numVestingEntries(address account) public view virtual returns (uint256) {
        //Implementation for numVestingEntries
    }

    function getVestingTime(address account, uint256 index) public view virtual returns (uint256) {
        //Implementation for getVestingTime
    }


    function nextVestingIndex(address account) public view returns (uint256) {
        uint256 totalEntries = numVestingEntries(account);
        for (uint256 i = 0; i < totalEntries; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return totalEntries;
    }
}",42.01823997497559,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Vesting is Ownable {
    uint256 public numVestingEntries;
    uint256 public vestingTime;
    bool public initialized = true;
    bytes32 public initBytes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe values
        numVestingEntries = 1; // Never 0
        vestingTime = 1; // Never 0
        initBytes = bytes32('init');
    }

    function numVestingEntries(address account) public view virtual returns (uint256) {
        return numVestingEntries;
    }

    function getVestingTime(address account, uint256 index) public view virtual returns (uint256) {
        // Implementation for getVestingTime
    }

    function nextVestingIndex(address account) public view returns (uint256) {
        uint256 totalEntries = numVestingEntries;
        for (uint256 i = 0; i < totalEntries; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return totalEntries;
    }

    function initialize() public {
        // Initialize state variables to fixed, safe values
        numVestingEntries = 1; // Never 0
        vestingTime = 1; // Never 0
        initBytes = bytes32('initialized');
    }
}"
3060,Transfers tokens held by timelock to all beneficiaries .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

struct TokenTimeLockVault {
    uint releaseTime;
    uint amount;
    uint arrayIndex;
}

event UnlockEvent(address indexed beneficiary);

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address[] public lockIndexes;
    mapping(address => TokenTimeLockVault) public tokenLocks;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function releaseAll(uint from, uint to) external onlyOwner returns (bool) {
        require(from >= 0);
        require(to <= lockIndexes.length);
        for (uint i = from; i < to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary == address(0)) {
                continue;
            }
            TokenTimeLockVault memory lock = tokenLocks[beneficiary];
            if (!(block.timestamp >= lock.releaseTime && lock.amount > 0)) {
                continue;
            }
            delete tokenLocks[beneficiary];
            lockIndexes[lock.arrayIndex] = address(0);
            emit UnlockEvent(beneficiary);
            require(token.transfer(beneficiary, lock.amount));
        }
        return true;
    }
}",releaseAll,"[{'function': 'releaseAll', 'complexity': 10}, {'function': 'addLock', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""From index cannot be negative""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lockIndexes""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""To index exceeds array bounds""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""from""}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""to""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockIndexes""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenTimeLockVault""}, ""name"": ""vault"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenLocks""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""vault""}, ""memberName"": ""releaseTime""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""vault""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenLocks""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockIndexes""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UnlockEvent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""vault""}, ""memberName"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""FalseBody"": None}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",49.0,0.9281541316302911,0.5310164597867667,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 public token;
    mapping(address => TokenTimeLockVault) public tokenLocks;
    address[] public lockIndexes;

    struct TokenTimeLockVault {
        uint256 amount;
        uint256 releaseTime;
    }

    event UnlockEvent(address indexed beneficiary);

    constructor(address _token) {
        token = IERC20(_token);
    }

    function releaseAll(uint256 from, uint256 to) public returns (bool) {
        require(from >= 0, ""From index cannot be negative"");
        require(to <= lockIndexes.length, ""To index exceeds array bounds"");

        for (uint256 i = from; i <= to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary != address(0)) {
                TokenTimeLockVault storage vault = tokenLocks[beneficiary];
                if (block.timestamp >= vault.releaseTime && vault.amount > 0) {
                    delete tokenLocks[beneficiary];
                    lockIndexes[i] = address(0);
                    emit UnlockEvent(beneficiary);
                    require(token.transfer(beneficiary, vault.amount), ""Transfer failed"");
                }
            }
        }
        return true;
    }

    function addLock(address _beneficiary, uint256 _amount, uint256 _releaseTime) public {
        tokenLocks[_beneficiary] = TokenTimeLockVault(_amount, _releaseTime);
        lockIndexes.push(_beneficiary);
    }

}",43.47537422180176,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public token;
    mapping(address => TokenTimeLockVault) public tokenLocks;
    address[] public lockIndexes;

    struct TokenTimeLockVault {
        uint256 amount;
        uint256 releaseTime;
    }

    event UnlockEvent(address indexed beneficiary);

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function releaseAll(uint256 from, uint256 to) public returns (bool) {
        require(from >= 0, ""From index cannot be negative"");
        require(to <= lockIndexes.length, ""To index exceeds array bounds"");

        for (uint256 i = from; i <= to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary != address(0)) {
                TokenTimeLockVault storage vault = tokenLocks[beneficiary];
                if (block.timestamp >= vault.releaseTime && vault.amount > 0) {
                    delete tokenLocks[beneficiary];
                    lockIndexes[i] = address(0);
                    emit UnlockEvent(beneficiary);
                    require(token.transfer(beneficiary, vault.amount), ""Transfer failed"");
                }
            }
        }
        return true;
    }

    function addLock(address _beneficiary, uint256 _amount, uint256 _releaseTime) public {
        tokenLocks[_beneficiary] = TokenTimeLockVault(_amount, _releaseTime);
        lockIndexes.push(_beneficiary);
    }
}"
6528,Returns total amount of commission that has been already paid ( added to pending withdrawals ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasFeeHistory is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] commissionCumulative;
        uint32 paidCommissionIndex;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getCommissionWithdrawn(uint32 _canvasId) external view returns (uint) {
        require(_canvasId < canvases.length);
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint _index = _history.paidCommissionIndex;
        return _history.commissionCumulative[_index];
    }
}",getCommissionWithdrawn,"[{'function': 'getCommissionWithdrawn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCommissionWithdrawn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_canvasId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid canvas ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""FeeHistory""}, ""name"": ""feeHistory"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasToFeeHistory""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feeHistory""}, ""memberName"": ""commissionCumulative""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feeHistory""}, ""memberName"": ""lastPaidCommissionIndex""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.9276384648126452,0.4615567618865427,"pragma solidity ^0.8.0;

contract MyContract {
    struct FeeHistory {
        uint32 lastPaidCommissionIndex;
        uint256[] commissionCumulative;
    }

    uint32[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getCommissionWithdrawn(uint32 _canvasId) public view returns (uint256) {
        require(_canvasId < canvases.length, ""Invalid canvas ID"");
        FeeHistory storage feeHistory = canvasToFeeHistory[_canvasId];
        return feeHistory.commissionCumulative[feeHistory.lastPaidCommissionIndex];
    }
}",41.610995054245,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct FeeHistory {
        uint32 lastPaidCommissionIndex;
        uint256[] commissionCumulative;
    }

    uint32[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        canvases = [1, 2, 3]; // Example fixed values for demonstration
        uint32[] memory initialCanvases = new uint32[](3);
        FeeHistory[] memory feeHistories = new FeeHistory[](3);

        for (uint i = 0; i < 3; i++) {
            initialCanvases[i] = uint32(i + 1);
            feeHistories[i].lastPaidCommissionIndex = 0;
            feeHistories[i].commissionCumulative = new uint256[](1); // Assuming at least one element is needed
            feeHistories[i].commissionCumulative[0] = 1 ether; // Example fixed value for commission cumulative
        }

        canvases = initialCanvases;
        for (uint i = 0; i < 3; i++) {
            canvasToFeeHistory[uint32(i + 1)] = feeHistories[i];
        }
    }

    function getCommissionWithdrawn(uint32 _canvasId) public view returns (uint256) {
        require(_canvasId < canvases.length, ""Invalid canvas ID"");
        FeeHistory storage feeHistory = canvasToFeeHistory[_canvasId];
        return feeHistory.commissionCumulative[feeHistory.lastPaidCommissionIndex];
    }
}"
1094,finds total amount of neumarks issued for given amount of Euro,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CumulativeWrapper {
    using SafeMath for uint256;

    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 1e27; // Example value, replace with actual limit if known
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 0.8e27; // Example value, replace with actual limit if known
    uint256 constant NEUMARK_CAP = 1e24; // Example value, replace with actual cap if known
    uint256 constant TOT_LINEAR_NEUMARKS_ULPS = 0.1e27; // Example value, replace with actual total if known
    uint256 constant TOT_LINEAR_EUR_ULPS = 0.2e27; // Example value, replace with actual total if known
    uint256 constant NEUMARKS_AT_LINEAR_LIMIT_ULPS = 0.09e27; // Example value, replace with actual limit if known

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        }
        if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            return NEUMARKS_AT_LINEAR_LIMIT_ULPS.add((TOT_LINEAR_NEUMARKS_ULPS * (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS)) / TOT_LINEAR_EUR_ULPS);
        }
        uint256 d = 230769230769230769230769231;
        uint256 term = NEUMARK_CAP;
        uint256 sum = 0;
        uint256 denom = d;
        do {
            term = term.mul(euroUlps).div(denom);
            sum = sum.add(term);
            denom = denom.add(d);
            term = term.mul(euroUlps).div(denom);
            sum = sum.sub(term);
            denom = denom.add(d);
        } while (term != 0);
        return sum;
    }
}",cumulative,"[{'function': 'cumulative', 'complexity': 7}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""cumulative"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""euroUlps"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""neumarkUlps"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""euroUlps""}, ""right"": {""type"": ""Identifier"", ""name"": ""ISSUANCE_LIMIT_EUR_ULPS""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""NEUMARK_CAP""}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""euroUlps""}, ""right"": {""type"": ""Identifier"", ""name"": ""LINEAR_APPROX_LIMIT_EUR_ULPS""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""euroUlps""}, ""right"": {""type"": ""Identifier"", ""name"": ""LINEAR_APPROX_LIMIT_EUR_ULPS""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""K""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""LINEAR_APPROX_LIMIT_EUR_ULPS""}, ""right"": {""type"": ""Identifier"", ""name"": ""K""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""sum""}], ""expression"": {""type"": ""DecimalNumber"", ""value"": ""0""}}, {""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""term""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""euroUlps"", ""arguments"": []}}, {""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""i""}], ""expression"": {""type"": ""DecimalNumber"", ""value"": ""0""}}, {""type"": ""AssemblyFor"", ""pre"": {""type"": ""AssemblyBlock"", ""operations"": []}, ""condition"": {""type"": ""AssemblyExpression"", ""functionName"": ""lt"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""i"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""1000""}]}, ""post"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""i""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""i"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""1""}]}}]}, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""product""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mul"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""term"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""K"", ""arguments"": []}]}}, {""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""quotient""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""div"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""product"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""i"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""1""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""sum""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""sum"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""quotient"", ""arguments"": []}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""term""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""quotient"", ""arguments"": []}}, {""type"": ""AssemblyIf"", ""condition"": {""type"": ""AssemblyExpression"", ""functionName"": ""iszero"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""quotient"", ""arguments"": []}]}, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""Break""}]}}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""neumarkUlps""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""sum"", ""arguments"": []}}]}}]}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",77.0,0.7422990224413095,0.2726667321738205,"pragma solidity ^0.8.0;

contract NeumarkCalculator {

    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 1000000000000000000000; // Example value
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 50000000000000000000; // Example value
    uint256 constant NEUMARK_CAP = 100000000000000000000000000; // Example value
    uint256 constant K = 1000000000000000000; // Example value


    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        } else if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            return (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS) * K + (LINEAR_APPROX_LIMIT_EUR_ULPS * K) /2; //Example linear approximation
        } else {
            assembly {
                let sum := 0
                let term := euroUlps
                let i := 0

                for { } lt(i, 1000) { i := add(i, 1) } {
                    let product := mul(term, K)
                    let quotient := div(product, add(i,1))
                    sum := add(sum, quotient)
                    term := quotient
                    if iszero(quotient) { break }
                }
                neumarkUlps := sum
            }
        }
    }
}",43.73513293266296,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NeumarkCalculator is Ownable {
    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 1000000000000000000000; // Example value
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 50000000000000000000; // Example value
    uint256 constant NEUMARK_CAP = 100000000000000000000000000; // Example value
    uint256 constant K = 1000000000000000000; // Example value

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        ISSUANCE_LIMIT_EUR_ULPS = 1000000000000000000000;
        LINEAR_APPROX_LIMIT_EUR_ULPS = 50000000000000000000;
        NEUMARK_CAP = 100000000000000000000000000;
        K = 1000000000000000000;
    }

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        } else if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            return (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS) * K + (LINEAR_APPROX_LIMIT_EUR_ULPS * K) / 2; // Example linear approximation
        } else {
            assembly {
                let sum := 0
                let term := euroUlps
                let i := 0

                for { } lt(i, 1000) { i := add(i, 1) } {
                    let product := mul(term, K)
                    let quotient := div(product, add(i, 1))
                    sum := add(sum, quotient)
                    term := quotient
                    if iszero(quotient) { break }
                }
                neumarkUlps := sum
            }
        }
    }
}"
2019,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled = true;

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal returns (bool) {
        // Your transfer logic here
        require(balanceOf(from) >= amount, ""Insufficient balance"");
        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    mapping(address => uint256) public balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}",doTransfer,"[{'function': 'transfer', 'complexity': 1}, {'function': 'doTransfer', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transfersEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers are disabled""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.37326846182448,0.2544255508923299,"pragma solidity ^0.8.0;

contract Token {
    bool public transfersEnabled;

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        require(transfersEnabled, ""Transfers are disabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address _from, address _to, uint256 _amount) internal returns (bool) {
        //Implementation of the transfer logic.  This would typically involve updating balances.
        //Example implementation (replace with your actual logic):
        //require(balanceOf[_from] >= _amount, ""Insufficient balance"");
        //balanceOf[_from] -= _amount;
        //balanceOf[_to] += _amount;
        //emit Transfer(_from, _to, _amount);
        return true;
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);
    mapping(address => uint256) public balanceOf;
}",42.42130208015442,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    bool public transfersEnabled;
    mapping(address => uint256) public balanceOf;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        transfersEnabled = true;
        balanceOf[owner()] = 1; // Set initial balance to 1 for the owner
    }

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        require(transfersEnabled, ""Transfers are disabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address _from, address _to, uint256 _amount) internal returns (bool) {
        //Implementation of the transfer logic.  This would typically involve updating balances.
        //Example implementation (replace with your actual logic):
        //require(balanceOf[_from] >= _amount, ""Insufficient balance"");
        //balanceOf[_from] -= _amount;
        //balanceOf[_to] += _amount;
        //emit Transfer(_from, _to, _amount);
        return true;
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);
}"
5946,"Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function acceptOwnership() public override onlyNewOwnerCandidate {
        address oldOwner = owner();
        _transferOwnership(newOwnerCandidate);
        newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, owner());
    }
}",acceptOwnership,"[{'function': 'acceptOwnership', 'complexity': 1}, {'function': 'transferOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}}, {""type"": ""stringLiteral"", ""value"": ""Only the new owner candidate can accept ownership""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""previousOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""previousOwner""}, {""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8625407186316674,0.3462676686891204,"pragma solidity ^0.8.0;

contract Ownable {
    address public owner;
    address public newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
    }

    function acceptOwnership() public {
        require(msg.sender == newOwnerCandidate, ""Only the new owner candidate can accept ownership"");
        address previousOwner = owner;
        owner = newOwnerCandidate;
        newOwnerCandidate = address(0);
        emit OwnershipTransferred(previousOwner, owner);
    }

    function transferOwnership(address _newOwner) public {
        require(msg.sender == owner, ""Only the owner can transfer ownership"");
        newOwnerCandidate = _newOwner;
    }
}",42.084741830825806,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant SOME_CONSTANT = 1; // Example state variable with a fixed value

    constructor() Ownable(msg.sender) {
        // No need to initialize specific values for the base contract's state variables since they are already initialized in the parent constructor
    }
}"
4342,The owner will call this method to extract the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

interface Crowdsale {
    function finalizedTime() external view returns (uint256);
}

abstract contract TokenCollector is Ownable {
    using SafeMath for uint256;

    MiniMeToken public miniMeToken;
    Crowdsale public crowdsale;
    uint256 public collectedTokens;

    event TokensWithdrawn(address indexed to, uint256 amount);

    constructor(address _miniMeToken, address _crowdsale) {
        miniMeToken = MiniMeToken(_miniMeToken);
        crowdsale = Crowdsale(_crowdsale);
    }

    function collectTokens() public onlyOwner {
        uint256 balance = miniMeToken.balanceOf(address(this));
        uint256 total = collectedTokens.add(balance);
        uint256 finalizedTime = crowdsale.finalizedTime();
        require(finalizedTime > 0 && getTime() > finalizedTime.add(1 days));
        uint256 canExtract = 0;
        if (getTime() <= finalizedTime.add(months(3))) {
            require(collectedTokens < total.percent(40));
            canExtract = total.percent(40);
        } else if (getTime() > finalizedTime.add(months(3)) && getTime() <= finalizedTime.add(months(6))) {
            require(collectedTokens < total.percent(60));
            canExtract = total.percent(60);
        } else if (getTime() > finalizedTime.add(months(6)) && getTime() <= finalizedTime.add(months(9))) {
            require(collectedTokens < total.percent(80));
            canExtract = total.percent(80);
        } else {
            require(collectedTokens < total);
            canExtract = total;
        }
        canExtract = canExtract.sub(collectedTokens);
        if (canExtract > balance) {
            canExtract = balance;
        }
        collectedTokens = collectedTokens.add(canExtract);
        miniMeToken.transfer(owner, canExtract);
        emit TokensWithdrawn(owner, canExtract);
    }

    function getTime() internal view virtual returns (uint256) {
        // Implement your time retrieval logic here
        return block.timestamp;
    }

    function months(uint256 monthsToAdd) internal pure returns (uint256) {
        return monthsToAdd * 30 days;
    }
}",collectTokens,"[{'function': 'finalizeCrowdsale', 'complexity': 1}, {'function': 'collectTokens', 'complexity': 7}]",10.0,"{""type"": ""FunctionDefinition"", ""name"": ""collectTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only owner can collect tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isFinalized""}, {""type"": ""stringLiteral"", ""value"": ""Crowdsale not finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""finalizationTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}}, {""type"": ""stringLiteral"", ""value"": ""Not enough time has passed since finalization""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miniMeToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""availableTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeSinceFinalization"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""finalizationTime""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""monthsSinceFinalization"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSinceFinalization""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}], ""isArray"": False}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""withdrawableAmount"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""monthsSinceFinalization""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""availableTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""40"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""monthsSinceFinalization""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""6"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""availableTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""60"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""monthsSinceFinalization""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""9"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""availableTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""80"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""availableTokens""}}}]}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""availableTokens""}}, {""type"": ""stringLiteral"", ""value"": ""Withdrawable amount exceeds available tokens""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountToWithdraw"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}, ""right"": {""type"": ""Identifier"", ""name"": ""amountToWithdraw""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miniMeToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""amountToWithdraw""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensWithdrawn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""amountToWithdraw""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",86.0,0.589652324842844,0.1726313651987935,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract CrowdSale {

    IERC20 public miniMeToken;
    address public owner;
    uint256 public collectedTokens;
    uint256 public finalizationTime;
    bool public isFinalized;

    event TokensWithdrawn(address recipient, uint256 amount);

    constructor(address _miniMeToken) {
        owner = msg.sender;
        miniMeToken = IERC20(_miniMeToken);
    }

    function finalizeCrowdsale() public {
        require(msg.sender == owner, ""Only owner can finalize"");
        isFinalized = true;
        finalizationTime = block.timestamp;
    }

    function collectTokens() public {
        require(msg.sender == owner, ""Only owner can collect tokens"");
        require(isFinalized, ""Crowdsale not finalized"");
        require(block.timestamp >= finalizationTime + 1 days, ""Not enough time has passed since finalization"");

        uint256 balance = miniMeToken.balanceOf(address(this));
        uint256 availableTokens = balance + collectedTokens;
        uint256 timeSinceFinalization = block.timestamp - finalizationTime;
        uint256 monthsSinceFinalization = timeSinceFinalization / (30 days);

        uint256 withdrawableAmount;
        if (monthsSinceFinalization <= 3) {
            withdrawableAmount = availableTokens * 40 / 100;
        } else if (monthsSinceFinalization <= 6) {
            withdrawableAmount = availableTokens * 60 / 100;
        } else if (monthsSinceFinalization <= 9) {
            withdrawableAmount = availableTokens * 80 / 100;
        } else {
            withdrawableAmount = availableTokens;
        }

        require(withdrawableAmount <= availableTokens, ""Withdrawable amount exceeds available tokens"");

        uint256 amountToWithdraw = withdrawableAmount - collectedTokens;
        collectedTokens += amountToWithdraw;
        miniMeToken.transfer(owner, amountToWithdraw);

        emit TokensWithdrawn(owner, amountToWithdraw);
    }
}",44.26581907272339,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CrowdSale is Ownable {
    IERC20 public miniMeToken;
    address public owner = msg.sender;
    uint256 public collectedTokens = 1;
    uint256 public finalizationTime;
    bool public isFinalized;

    event TokensWithdrawn(address recipient, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor(address _miniMeToken) Ownable(msg.sender) {
        miniMeToken = IERC20(_miniMeToken);
    }

    function finalizeCrowdsale() public {
        require(msg.sender == owner, ""Only owner can finalize"");
        isFinalized = true;
        finalizationTime = block.timestamp;
    }

    function collectTokens() public {
        require(msg.sender == owner, ""Only owner can collect tokens"");
        require(isFinalized, ""Crowdsale not finalized"");
        require(block.timestamp >= finalizationTime + 1 days, ""Not enough time has passed since finalization"");

        uint256 balance = miniMeToken.balanceOf(address(this));
        uint256 availableTokens = balance + collectedTokens;
        uint256 timeSinceFinalization = block.timestamp - finalizationTime;
        uint256 monthsSinceFinalization = timeSinceFinalization / (30 days);

        uint256 withdrawableAmount;
        if (monthsSinceFinalization <= 3) {
            withdrawableAmount = availableTokens * 40 / 100;
        } else if (monthsSinceFinalization <= 6) {
            withdrawableAmount = availableTokens * 60 / 100;
        } else if (monthsSinceFinalization <= 9) {
            withdrawableAmount = availableTokens * 80 / 100;
        } else {
            withdrawableAmount = availableTokens;
        }

        require(withdrawableAmount <= availableTokens, ""Withdrawable amount exceeds available tokens"");

        uint256 amountToWithdraw = withdrawableAmount - collectedTokens;
        collectedTokens += amountToWithdraw;
        miniMeToken.transfer(owner, amountToWithdraw);

        emit TokensWithdrawn(owner, amountToWithdraw);
    }
}"
1358,Internal - Checks if the entered ticker is registered and has not expired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",_tickerAvailable,"[{'function': '_tickerAvailable', 'complexity': 4}, {'function': '_tickerOwner', 'complexity': 0}, {'function': '_tickerStatus', 'complexity': 0}, {'function': 'getUint', 'complexity': 0}, {'function': 'getKey', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""_tickerAvailable"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tickerOwner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_ticker""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expiryDate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getUint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Encoder""}, ""memberName"": ""getKey""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registeredTickers_expiryDate""}, {""type"": ""Identifier"", ""name"": ""_ticker""}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""Identifier"", ""name"": ""expiryDate""}}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tickerStatus""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_ticker""}], ""names"": []}, ""isPrefix"": True}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",32.0,0.5378051050847374,0.0256246632821332,"pragma solidity ^0.8.0;

contract MyContract {

    function _tickerAvailable(string memory _ticker) internal view returns (bool) {
        if (_tickerOwner(_ticker) == address(0)) {
            return true;
        }

        uint256 expiryDate = getUint(Encoder.getKey(""registeredTickers_expiryDate"", _ticker));
        if (now > expiryDate && !_tickerStatus(_ticker)) {
            return true;
        }

        return false;
    }

    function _tickerOwner(string memory _ticker) internal view virtual returns (address) {
        //Implementation to retrieve ticker owner.  Replace with actual implementation.
        return address(0);
    }

    function _tickerStatus(string memory _ticker) internal view virtual returns (bool) {
        //Implementation to retrieve ticker status. Replace with actual implementation.
        return false;
    }

    function getUint(bytes32 key) internal view virtual returns (uint256) {
        //Implementation to retrieve uint from storage. Replace with actual implementation.
        return 0;
    }

    library Encoder {
        function getKey(string memory keyPrefix, string memory keySuffix) internal pure returns (bytes32) {
            return keccak256(abi.encodePacked(keyPrefix, keySuffix));
        }
    }
}",42.87310194969177,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address private constant _ownerAddress = 0x1111111111111111111111111111111111111111; // Replace with actual owner address
    bool public constant _isInitialized = true;
    bytes32 public constant _initializedBytes = bytes32('init');

    constructor() Ownable(_ownerAddress) {}

    function _tickerAvailable(string memory _ticker) internal view returns (bool) {
        if (_tickerOwner(_ticker) == address(0)) {
            return true;
        }

        uint256 expiryDate = getUint(Encoder.getKey(""registeredTickers_expiryDate"", _ticker));
        if (now > expiryDate && !_tickerStatus(_ticker)) {
            return true;
        }

        return false;
    }

    function _tickerOwner(string memory _ticker) internal view virtual returns (address) {
        //Implementation to retrieve ticker owner.  Replace with actual implementation.
        return address(0);
    }

    function _tickerStatus(string memory _ticker) internal view virtual returns (bool) {
        //Implementation to retrieve ticker status. Replace with actual implementation.
        return false;
    }

    function getUint(bytes32 key) internal view virtual returns (uint256) {
        //Implementation to retrieve uint from storage. Replace with actual implementation.
        return 1; // Set to a fixed value
    }
}

library Encoder {
    function getKey(string memory keyPrefix, string memory keySuffix) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(keyPrefix, keySuffix));
    }
}"
5732,Withdraws deposited tokens on behalf of users Allowed only for oracle,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public token;
    mapping(bytes32 => uint) public user2lastPeriodParticipated;
    uint public periodsCount;
    struct Period {
        uint startDate;
    }
    mapping(uint => Period) public periods;
    event TreasuryWithdrawn(bytes32 indexed _userKey, uint _amount);
    uint constant OK = 0;

    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOwner returns (uint) {
        require(_userKey != bytes32(0));
        require(_value != 0);
        require(_feeAmount < _value);
        _makeWithdrawForPeriod(_userKey, _value);
        uint _periodsCount = periodsCount;
        user2lastPeriodParticipated[_userKey] = periodsCount;
        delete periods[periodsCount].startDate;
        IERC20 _token = IERC20(token);
        if (!(_feeAddress == address(0) || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {
            revert();
        }
        uint _withdrawnAmount = _value.sub(_feeAmount);
        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {
            revert();
        }
        emit TreasuryWithdrawn(_userKey, _withdrawnAmount);
        return OK;
    }

    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {
        // Implementation of the internal function
    }
}",withdraw,"[{'function': 'withdraw', 'complexity': 6}, {'function': '_makeWithdrawForPeriod', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_userKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_withdrawAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_feeAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_userKey""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""User key cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Fee amount cannot exceed value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_makeWithdrawForPeriod""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_userKey""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""user2lastPeriodParticipated""}, ""index"": {""type"": ""Identifier"", ""name"": ""_userKey""}}, ""right"": {""type"": ""Identifier"", ""name"": ""periodsCount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""periods""}, ""index"": {""type"": ""Identifier"", ""name"": ""periodsCount""}}, ""memberName"": ""startDate""}, ""isPrefix"": True}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_feeAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_feeAddress""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Fee transfer failed""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_withdrawnAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_withdrawAddress""}, {""type"": ""Identifier"", ""name"": ""_withdrawnAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Withdrawal transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TreasuryWithdrawn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_userKey""}, {""type"": ""Identifier"", ""name"": ""_withdrawnAmount""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""OK""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.851492289178158,0.4207459308806292,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    uint256 public constant OK = 1;
    IERC20 public token;
    // ... other state variables ...

    event TreasuryWithdrawn(uint256 _userKey, uint256 _withdrawnAmount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function withdraw(uint256 _userKey, uint256 _value, address _withdrawAddress, uint256 _feeAmount, address _feeAddress) public returns (uint256) {
        require(_userKey != 0, ""User key cannot be zero"");
        require(_value > 0, ""Value must be greater than zero"");
        require(_feeAmount < _value, ""Fee amount cannot exceed value"");

        _makeWithdrawForPeriod(_userKey, _value);
        user2lastPeriodParticipated[_userKey] = periodsCount;
        delete periods[periodsCount].startDate;

        if (_feeAddress != address(0) && _feeAmount > 0) {
            require(token.transfer(_feeAddress, _feeAmount), ""Fee transfer failed"");
        }

        uint256 _withdrawnAmount = _value - _feeAmount;
        require(token.transfer(_withdrawAddress, _withdrawnAmount), ""Withdrawal transfer failed"");

        emit TreasuryWithdrawn(_userKey, _withdrawnAmount);
        return OK;
    }

    // ... other functions and state variables ...
    mapping(uint256 => uint256) public user2lastPeriodParticipated;
    uint256 public periodsCount;
    struct Period {
        uint256 startDate;
        // ... other period data ...
    }
    Period[] public periods;

    function _makeWithdrawForPeriod(uint256 _userKey, uint256 _value) internal {
        //Implementation for _makeWithdrawForPeriod
    }
}",43.83645510673523,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant OK = 1;
    IERC20 public token;
    // ... other state variables ...

    event TreasuryWithdrawn(uint256 _userKey, uint256 _withdrawnAmount);

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        // Initialize other state variables to fixed, safe, non-corner-case values:
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function withdraw(uint256 _userKey, uint256 _value, address _withdrawAddress, uint256 _feeAmount, address _feeAddress) public returns (uint256) {
        require(_userKey != 0, ""User key cannot be zero"");
        require(_value > 0, ""Value must be greater than zero"");
        require(_feeAmount < _value, ""Fee amount cannot exceed value"");

        _makeWithdrawForPeriod(_userKey, _value);
        user2lastPeriodParticipated[_userKey] = periodsCount;
        delete periods[periodsCount].startDate;

        if (_feeAddress != address(0) && _feeAmount > 0) {
            require(token.transfer(_feeAddress, _feeAmount), ""Fee transfer failed"");
        }

        uint256 _withdrawnAmount = _value - _feeAmount;
        require(token.transfer(_withdrawAddress, _withdrawnAmount), ""Withdrawal transfer failed"");

        emit TreasuryWithdrawn(_userKey, _withdrawnAmount);
        return OK;
    }

    // ... other functions and state variables ...
    mapping(uint256 => uint256) public user2lastPeriodParticipated;
    uint256 public periodsCount = 0;
    struct Period {
        uint256 startDate;
        // ... other period data ...
    }
    Period[] public periods;

    function _makeWithdrawForPeriod(uint256 _userKey, uint256 _value) internal {
        //Implementation for _makeWithdrawForPeriod
    }
}"
5527,"Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint128 amount;
        uint128 totalClaimed;
        uint16 vestingCliff;
        uint16 vestingDuration;
        uint16 monthsClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    uint256 constant SECONDS_PER_MONTH = 2628000; // Approximately 30 days * 86400 seconds per day

    function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {
        Grant storage tokenGrant = tokenGrants[_recipient];

        if (block.timestamp < tokenGrant.startTime) {
            return (0, 0);
        }

        uint256 elapsedTime = block.timestamp.sub(tokenGrant.startTime);
        uint256 elapsedMonths = elapsedTime / SECONDS_PER_MONTH;

        if (elapsedMonths < tokenGrant.vestingCliff) {
            return (0, 0);
        }

        if (elapsedMonths >= tokenGrant.vestingDuration) {
            uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;
            return (uint16(tokenGrant.vestingDuration), remainingGrant);
        } else {
            uint16 monthsVested = uint16(elapsedMonths.sub(tokenGrant.monthsClaimed));
            uint256 amountVestedPerMonth = tokenGrant.amount / uint256(tokenGrant.vestingDuration);
            uint128 amountVested = uint128(monthsVested * amountVestedPerMonth);
            return (monthsVested, amountVested);
        }
    }
}",calculateGrantClaim,"[{'function': 'calculateGrantClaim', 'complexity': 3}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateGrantClaim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""grant"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenGrants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_recipient""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""nowTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""nowTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""startTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedMonths"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nowTime""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""startTime""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""cliff""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingDuration""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingDuration""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalAmount""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""claimedAmount""}], ""names"": []}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""monthsVested"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""cliff""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountPerMonth"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalAmount""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingDuration""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""claimableAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""monthsVested""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountPerMonth""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""monthsVested""}, {""type"": ""Identifier"", ""name"": ""claimableAmount""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",28.0,0.8864993773338151,0.3960222720284883,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract GrantCalculator {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint256 cliff;
        uint256 vestingDuration;
        uint256 totalAmount;
        uint256 claimedAmount;
    }

    mapping(address => Grant) public tokenGrants;

    function calculateGrantClaim(address _recipient) public view returns (uint256, uint256) {
        Grant memory grant = tokenGrants[_recipient];
        uint256 nowTime = block.timestamp;

        if (nowTime < grant.startTime) {
            return (0, 0);
        }

        uint256 elapsedMonths = nowTime.sub(grant.startTime).div(30 days); //Approximation

        if (elapsedMonths < grant.cliff) {
            return (0, 0);
        }

        if (elapsedMonths >= grant.vestingDuration) {
            return (grant.vestingDuration, grant.totalAmount.sub(grant.claimedAmount));
        }

        uint256 monthsVested = elapsedMonths.sub(grant.cliff);
        uint256 amountPerMonth = grant.totalAmount.div(grant.vestingDuration);
        uint256 claimableAmount = monthsVested.mul(amountPerMonth);

        return (monthsVested, claimableAmount);
    }
}",43.257593393325806,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract GrantCalculator is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint256 cliff;
        uint256 vestingDuration;
        uint256 totalAmount;
        uint256 claimedAmount;
    }

    mapping(address => Grant) public tokenGrants;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            tokenGrants[addr] = Grant({
                startTime: uint256(1),
                cliff: uint256(1),
                vestingDuration: uint256(1),
                totalAmount: uint256(1),
                claimedAmount: uint256(0)
            });
        }
    }

    function calculateGrantClaim(address _recipient) public view returns (uint256, uint256) {
        Grant memory grant = tokenGrants[_recipient];
        uint256 nowTime = block.timestamp;

        if (nowTime < grant.startTime) {
            return (0, 0);
        }

        uint256 elapsedMonths = nowTime.sub(grant.startTime).div(30 days); //Approximation

        if (elapsedMonths < grant.cliff) {
            return (0, 0);
        }

        if (elapsedMonths >= grant.vestingDuration) {
            return (grant.vestingDuration, grant.totalAmount.sub(grant.claimedAmount));
        }

        uint256 monthsVested = elapsedMonths.sub(grant.cliff);
        uint256 amountPerMonth = grant.totalAmount.div(grant.vestingDuration);
        uint256 claimableAmount = monthsVested.mul(amountPerMonth);

        return (monthsVested, claimableAmount);
    }
}"
1662,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
    AccountValueLocalVars memory localResults;
    localResults.sumSupplies = Exp({mantissa: 0});
    localResults.sumBorrows = Exp({mantissa: 0});
    Error err;
    localResults.collateralMarketsLength = collateralMarkets.length;
    for (uint i = 0; i < localResults.collateralMarketsLength; i++) {
        localResults.assetAddress = collateralMarkets[i];
        Market storage currentMarket = markets[localResults.assetAddress];
        Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];
        Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];
        if (supplyBalance.principal > 0) {
            (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
        if (borrowBalance.principal > 0) {
            (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
    }
    return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);
}

}",calculateAccountValuesInternal,"[{'function': 'calculateAccountValuesInternal', 'complexity': 17}]",8.0,{},102.0,0.7266894463581467,0.3591836790252344,"pragma solidity ^0.8.0;

// Assume necessary contracts and interfaces are defined elsewhere, including:
// - Error enum
// - Market struct
// - Balance struct
// - functions: calculateInterestIndex, calculateBalance, getPriceForAssetAmount, addExp


function calculateAccountValuesInternal(address userAddress) internal returns (Error, uint256, uint256) {
    LocalResults memory localResults;
    localResults.collateralMarketsLength = collateralMarkets.length;

    for (uint256 i = 0; i < localResults.collateralMarketsLength; i++) {
        address assetAddress = collateralMarkets[i];
        Market storage currentMarket = markets[assetAddress];
        Balance storage supplyBalance = supplyBalances[userAddress][assetAddress];
        Balance storage borrowBalance = borrowBalances[userAddress][assetAddress];

        if (supplyBalance.balance > 0) {
            Error err = calculateInterestIndex(currentMarket, MarketStorage.SupplyIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            uint256 supplyValue = calculateBalance(supplyBalance, currentMarket.supplyIndex);
            uint256 supplyValueUSD = getPriceForAssetAmount(assetAddress, supplyValue);
            (err, localResults.sumSupplies) = addExp(localResults.sumSupplies, supplyValueUSD);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }

        if (borrowBalance.balance > 0) {
            Error err = calculateInterestIndex(currentMarket, MarketStorage.BorrowIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            uint256 borrowValue = calculateBalance(borrowBalance, currentMarket.borrowIndex);
            uint256 borrowValueUSD = getPriceForAssetAmount(assetAddress, borrowValue);
            (Error err, uint256 newSumBorrows) = addExp(localResults.sumBorrows, borrowValueUSD);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            localResults.sumBorrows = newSumBorrows;
        }
    }

    return (Error.NO_ERROR, localResults.sumSupplies, localResults.sumBorrows);
}

struct LocalResults {
    uint256 sumSupplies;
    uint256 sumBorrows;
    uint256 collateralMarketsLength;
}",44.894317626953125,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    // Assume necessary contracts and interfaces are defined elsewhere, including:
    // - Error enum
    // - Market struct
    // - Balance struct
    // - functions: calculateInterestIndex, calculateBalance, getPriceForAssetAmount, addExp

    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';
    uint256 public constant DEFAULT_UINT256 = 1;

    Ownable public ownable = Ownable(DEFAULT_ADDRESS);

    struct LocalResults {
        uint256 sumSupplies;
        uint256 sumBorrows;
        uint256 collateralMarketsLength;
    }

    function calculateAccountValuesInternal(address userAddress) internal returns (Error, uint256, uint256) {
        LocalResults memory localResults;
        localResults.collateralMarketsLength = collateralMarkets.length;

        for (uint256 i = 0; i < localResults.collateralMarketsLength; i++) {
            address assetAddress = collateralMarkets[i];
            Market storage currentMarket = markets[assetAddress];
            Balance storage supplyBalance = supplyBalances[userAddress][assetAddress];
            Balance storage borrowBalance = borrowBalances[userAddress][assetAddress];

            if (supplyBalance.balance > 0) {
                Error err = calculateInterestIndex(currentMarket, MarketStorage.SupplyIndex);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
                uint256 supplyValue = calculateBalance(supplyBalance, currentMarket.supplyIndex);
                uint256 supplyValueUSD = getPriceForAssetAmount(assetAddress, supplyValue);
                (err, localResults.sumSupplies) = addExp(localResults.sumSupplies, supplyValueUSD);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
            }

            if (borrowBalance.balance > 0) {
                Error err = calculateInterestIndex(currentMarket, MarketStorage.BorrowIndex);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
                uint256 borrowValue = calculateBalance(borrowBalance, currentMarket.borrowIndex);
                uint256 borrowValueUSD = getPriceForAssetAmount(assetAddress, borrowValue);
                (Error err, uint256 newSumBorrows) = addExp(localResults.sumBorrows, borrowValueUSD);
                if (err != Error.NO_ERROR) {
                    return (err, 0, 0);
                }
                localResults.sumBorrows = newSumBorrows;
            }
        }

        return (Error.NO_ERROR, localResults.sumSupplies, localResults.sumBorrows);
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
6249,Set the threshold for a payment to be sent directly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public directPaymentThreshold;

    constructor(uint256 initialThreshold) {
        directPaymentThreshold = initialThreshold;
    }

    function setDirectPaymentThreshold(uint256 threshold) external onlyCFO {
        directPaymentThreshold = threshold;
    }
}",setDirectPaymentThreshold,"[{'function': 'setDirectPaymentThreshold', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setDirectPaymentThreshold"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""threshold"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""directPaymentThreshold""}, ""right"": {""type"": ""Identifier"", ""name"": ""threshold""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCFO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.964432564090096,0.7611606003349892,"pragma solidity ^0.8.0;

contract Contract {

    uint256 public directPaymentThreshold;
    address public cfo;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only CFO can call this function"");
        _;
    }

    constructor(address _cfo) {
        cfo = _cfo;
    }

    function setDirectPaymentThreshold(uint256 threshold) public onlyCFO {
        directPaymentThreshold = threshold;
    }
}",41.601757287979126,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Contract is Ownable {
    uint256 public directPaymentThreshold;
    address public cfo;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only CFO can call this function"");
        _;
    }

    constructor(address _cfo) Ownable(msg.sender) {
        cfo = _cfo;
        directPaymentThreshold = 1; // Set to a non-zero value for uint256
    }

    function setDirectPaymentThreshold(uint256 threshold) public onlyCFO {
        directPaymentThreshold = threshold;
    }
}"
153,A getter to find if a specified Project has been canceled,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PledgeAdminType {
    enum Type { Giver, Project }
}

struct PledgeAdmin {
    uint64 parentProject;
    bool canceled;
    PledgeAdminType.Type adminType;
}

abstract contract ProjectCancelChecker is Ownable {
    using SafeMath for uint256;

    mapping(uint64 => PledgeAdmin) public pledgeAdmins;

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin storage) {
        require(projectId != 0, ""Invalid project ID"");
        return pledgeAdmins[projectId];
    }

    function isProjectCanceled(uint64 projectId) public view returns (bool) {
        PledgeAdmin storage m = findAdmin(projectId);
        if (m.adminType == PledgeAdminType.Type.Giver) return false;
        require(m.adminType == PledgeAdminType.Type.Project, ""Invalid admin type"");
        if (m.canceled) return true;
        if (m.parentProject == 0) return false;
        return isProjectCanceled(m.parentProject);
    }
}",isProjectCanceled,"[{'function': 'findAdmin', 'complexity': 0}, {'function': 'isProjectCanceled', 'complexity': 4}]",5.0,{},43.0,0.88881334212172,0.39910168172601,"pragma solidity ^0.8.0;

enum PledgeAdminType { Giver, Project }

struct PledgeAdmin {
    PledgeAdminType adminType;
    uint64 parentProject;
    bool canceled;
    // ... other fields ...
}

function findAdmin(uint64 projectId) internal view returns (PledgeAdmin memory) {
    //Implementation to retrieve PledgeAdmin struct.  Replace with actual implementation.
    //This is a placeholder.
    PledgeAdmin memory admin;
    return admin;
}


function isProjectCanceled(uint64 projectId) internal view returns (bool) {
    PledgeAdmin memory admin = findAdmin(projectId);
    if (admin.adminType == PledgeAdminType.Giver) {
        return false;
    }
    assert(admin.adminType == PledgeAdminType.Project);
    if (admin.canceled) {
        return true;
    }
    if (admin.parentProject == 0) {
        return false;
    }
    return isProjectCanceled(admin.parentProject);
}",42.308236598968506,"pragma solidity ^0.8.0;

enum PledgeAdminType { Giver, Project }
import ""openzeppelin/SafeMath.sol"";
contract PledgeAdmin {
    // Fixed values for initialization
    address public constant DEFAULT_ADMIN = 0x1111111111111111111111111111111111111111; // Replace with actual admin address
    uint64 public constant DEFAULT_PARENT_PROJECT = 1;
    bool public constant DEFAULT_CANCELED = false;

    // Other fields ...
    PledgeAdminType public adminType;
    uint64 public parentProject;
    bool public canceled;
    // ... other fields ...

    // Constructor
    constructor() {
        // Initialize instance variables with fixed values
        adminType = PledgeAdminType.Giver; // Default to Giver type
        parentProject = DEFAULT_PARENT_PROJECT; // Set default parent project
        canceled = DEFAULT_CANCELED; // Set default canceled state

        // Invoke Ownable constructor
        Ownable(DEFAULT_ADMIN);
    }

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin memory) {
        // Implementation to retrieve PledgeAdmin struct. Replace with actual implementation.
        // This is a placeholder.
        PledgeAdmin memory admin;
        return admin;
    }

    function isProjectCanceled(uint64 projectId) internal view returns (bool) {
        PledgeAdmin memory admin = findAdmin(projectId);
        if (admin.adminType == PledgeAdminType.Giver) {
            return false;
        }
        assert(admin.adminType == PledgeAdminType.Project);
        if (admin.canceled) {
            return true;
        }
        if (admin.parentProject == 0) {
            return false;
        }
        return isProjectCanceled(admin.parentProject);
    }

    // Other functions ...
}"
223,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ICard {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
        uint256 price;
        uint256 nextprice;
        string imagepath;
        string category;
        uint256 IsWildCard;
        address owner;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    mapping(uint256 => uint256) public cardTokenToPrice;
    Card[] public cards;

    function getNextPrice(uint256 price) internal pure returns (uint256) {
        return price.mul(110).div(100); // Increase by 10%
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner) {
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
        price = getNextPrice(cardTokenToPrice[_tokenId]);
        nextprice = getNextPrice(price);
        imagepath = card.imagepath;
        category = card.category;
        wildcard = card.IsWildCard;
        _owner = card.owner;
    }
}",getCard,"[{'function': 'getNextPrice', 'complexity': 0}, {'function': 'getCard', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCard"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""nextprice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""imagepath"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""category"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""wildcard"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToPosition""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""name""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""token""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextPrice""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nextprice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextPrice""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""price""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""imagepath""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""imagepath""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""category""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""category""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""wildcard""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""wildcard""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.9474547998150016,0.883600754183584,"pragma solidity ^0.8.0;

contract CardContract {

    struct Card {
        string name;
        uint256 token;
        uint256 price;
        string imagepath;
        string category;
        bool wildcard;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    mapping(uint256 => uint256) public cardTokenToPrice;
    Card[] public cards;
    mapping(uint256 => address) public cardTokenToOwner;


    function getNextPrice(uint256 _price) public pure returns (uint256) {
        // Replace with your actual price calculation logic
        return _price * 2;
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, bool wildcard, address _owner) {
        uint256 index = cardTokenToPosition[_tokenId];
        Card memory card = cards[index];
        name = card.name;
        token = card.token;
        price = getNextPrice(cardTokenToPrice[_tokenId]);
        nextprice = getNextPrice(price);
        imagepath = card.imagepath;
        category = card.category;
        wildcard = card.wildcard;
        _owner = cardTokenToOwner[_tokenId];
    }
}",42.96691942214966,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CardContract is Ownable {
    struct Card {
        string name;
        uint256 token;
        uint256 price;
        string imagepath;
        string category;
        bool wildcard;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    mapping(uint256 => uint256) public cardTokenToPrice;
    Card[] public cards;
    mapping(uint256 => address) public cardTokenToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialPrice = 1 ether; // Set to a fixed value greater than zero
        bytes32 initBytes = bytes32('init'); // Set to 'init'
        string memory initializedString = 'initialized'; // Set to 'initialized'

        // Add some placeholder cards for demonstration
        addCard(""Card 1"", 1, initialPrice, ""imagepath1"", ""category1"", true);
        addCard(""Card 2"", 2, getNextPrice(initialPrice), ""imagepath2"", ""category2"", false);
    }

    function getNextPrice(uint256 _price) public pure returns (uint256) {
        // Replace with your actual price calculation logic
        return _price * 2;
    }

    function addCard(string memory name, uint256 token, uint256 price, string memory imagepath, string memory category, bool wildcard) internal {
        cards.push(Card({
            name: name,
            token: token,
            price: price,
            imagepath: imagepath,
            category: category,
            wildcard: wildcard
        }));
        cardTokenToPosition[token] = cards.length - 1;
        cardTokenToPrice[token] = price;
        cardTokenToOwner[token] = msg.sender; // Assuming the owner is the deployer for demonstration
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, bool wildcard, address _owner) {
        uint256 index = cardTokenToPosition[_tokenId];
        Card memory card = cards[index];
        name = card.name;
        token = card.token;
        price = getNextPrice(cardTokenToPrice[_tokenId]);
        nextprice = getNextPrice(price);
        imagepath = card.imagepath;
        category = card.category;
        wildcard = card.wildcard;
        _owner = cardTokenToOwner[_tokenId];
    }
}"
1195,"The owner can clawback any unspent Parsec credits after a date in the future , so no Parsec credits remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IParsecToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether;
    uint256 public constant OWNER_CLAWBACK_DATE = block.timestamp + 30 days; // Example date, adjust as needed

    bool public creditsClawbacked;
    IParsecToken public parsecToken;
    address public owner;
    uint256 public totalFunding;

    function ownerClawbackCredits() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        require(!creditsClawbacked);
        creditsClawbacked = true;
        parsecToken.transfer(owner, parsecToken.balanceOf(address(this)));
    }
}",ownerClawbackCredits,"[{'function': 'ownerClawbackCredits', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerClawbackCredits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""totalFunding""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRESALE_MINIMUM_FUNDING""}}, {""type"": ""stringLiteral"", ""value"": ""Funding above minimum threshold""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""OWNER_CLAWBACK_DATE""}}, {""type"": ""stringLiteral"", ""value"": ""Clawback date not reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""creditsClawbacked""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Credits already clawed back""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""creditsClawbacked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8348495926910222,0.3318506803494416,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public totalFunding;
    uint256 public constant PRESALE_MINIMUM_FUNDING = 1000 ether; // Example value
    uint256 public constant OWNER_CLAWBACK_DATE = 1678886400; // Example value - March 15, 2023
    bool public creditsClawbacked;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function ownerClawbackCredits() public {
        require(totalFunding < PRESALE_MINIMUM_FUNDING, ""Funding above minimum threshold"");
        require(block.timestamp >= OWNER_CLAWBACK_DATE, ""Clawback date not reached"");
        require(!creditsClawbacked, ""Credits already clawed back"");

        creditsClawbacked = true;
        // Assuming ERC20 token for credits. Replace with your actual token transfer logic.
        IERC20(address(this)).transfer(owner, IERC20(address(this)).balanceOf(address(this)));
    }

    //Example ERC20 interface.  Replace with your actual ERC20 token contract.
    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
        function balanceOf(address account) external view returns (uint256);
    }

}",43.15289878845215,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public totalFunding;
    uint256 public constant PRESALE_MINIMUM_FUNDING = 1000 ether; // Example value
    uint256 public constant OWNER_CLAWBACK_DATE = 1678886400; // Example value - March 15, 2023
    bool public creditsClawbacked;
    address public owner;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        totalFunding = 1;
        owner = msg.sender;
        creditsClawbacked = false;
    }

    function ownerClawbackCredits() public {
        require(totalFunding < PRESALE_MINIMUM_FUNDING, ""Funding above minimum threshold"");
        require(block.timestamp >= OWNER_CLAWBACK_DATE, ""Clawback date not reached"");
        require(!creditsClawbacked, ""Credits already clawed back"");

        creditsClawbacked = true;
        // Assuming ERC20 token for credits. Replace with your actual token transfer logic.
        IERC20(address(this)).transfer(owner, IERC20(address(this)).balanceOf(address(this)));
    }

    //Example ERC20 interface.  Replace with your actual ERC20 token contract.
    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
        function balanceOf(address account) external view returns (uint256);
    }
}"
3570,Pauses the whitelist if there is any issue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    using SafeMath for uint256;

    bool public paused = false;
    event Paused(address indexed account, uint256 timestamp);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Not the contract owner"");
        _;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}",pauseWhitelist,"[{'function': 'pauseWhitelist', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Paused""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {

    bool public paused;
    address public admin;

    event Paused(address indexed account, uint256 timestamp);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Caller is not the admin"");
        _;
    }

    constructor() {
        admin = msg.sender;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}",41.98543643951416,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for an Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool public paused;
    address public admin;

    event Paused(address indexed account, uint256 timestamp);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Caller is not the admin"");
        _;
    }

    constructor() Ownable(msg.sender) {
        paused = true; // Set to true instead of false as per initialization rules
        admin = msg.sender;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}"
5480,Allows transfer token ownership back to distribution contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token; // Address of the token contract

    constructor(address _token) {
        token = _token;
    }

    function reclaimTokenOwnership() public onlyOwner {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        IERC20(token).claimOwnership();
    }
}",reclaimTokenOwnership,"[{'function': 'reclaimTokenOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimTokenOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""claimOwnership""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.6690208607615388,0.1277045456416379,"pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    IERC20 public token; // Assuming an ERC20 token

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _tokenAddress) {
        owner = msg.sender;
        token = IERC20(_tokenAddress);
    }

    function reclaimTokenOwnership() public onlyOwner {
        token.claimOwnership();
    }

    interface IERC20 {
        function claimOwnership() external;
    }
}",41.883808612823486,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public owner;
    IERC20 public token; // Assuming an ERC20 token

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor(address _tokenAddress) {
        initialize(msg.sender, _tokenAddress);
    }

    function initialize(address _owner, address _tokenAddress) internal {
        owner = _owner;
        token = IERC20(_tokenAddress);
    }

    function reclaimTokenOwnership() public onlyOwner {
        token.claimOwnership();
    }

    interface IERC20 {
        function claimOwnership() external;
    }
}"
3477,"Returns the loan metadata , this field can be set by the creator of the loan with his own criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataWrapper {
    using SafeMath for uint256;

    struct Loan {
        string metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadata(uint256 index) public view returns (string memory) {
        return loans[index].metadata;
    }
}",tokenMetadata,"[{'function': 'tokenMetadata', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""metadata""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract LoanContract {
    struct Loan {
        string metadata;
        // Add other loan details as needed
    }

    Loan[] public loans;

    function tokenMetadata(uint256 index) public view returns (string memory) {
        return loans[index].metadata;
    }
}",41.34835958480835,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoanContract is Ownable {
    struct Loan {
        string metadata;
        // Add other loan details as needed
    }

    Loan[] public loans;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        loans = [Loan({metadata: ""initialized""})];
    }

    function tokenMetadata(uint256 index) public view returns (string memory) {
        return loans[index].metadata;
    }
}"
1259,Claims the ownership of a given token ID,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
}",_clearApprovalAndTransfer,"[{'function': 'takeOwnership', 'complexity': 1}, {'function': 'isSenderApprovedFor', 'complexity': 0}, {'function': '_clearApprovalAndTransfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isSenderApprovedFor""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""not approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_clearApprovalAndTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.5216879576495479,0.1013391827968127,"pragma solidity ^0.8.0;

contract MyContract {
    // ... other contract code ...

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");
        _clearApprovalAndTransfer(_tokenId, msg.sender);
    }

    function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {
        //Implementation for checking sender approval.  This would likely involve checking
        //approvedTransfers or operators mappings.  Replace with your actual implementation.
        //Example: return approvedTransfers[_tokenId] == msg.sender || operators[ownerOf(_tokenId)][msg.sender];

    }

    function _clearApprovalAndTransfer(uint256 _tokenId, address _to) internal {
        //Implementation for clearing approvals and transferring ownership.  This would likely involve
        //updating ownerByTokenId and approvedTransfers mappings and emitting a Transfer event.
        //Example:
        //address _from = ownerByTokenId[_tokenId];
        //ownerByTokenId[_tokenId] = _to;
        //approvedTransfers[_tokenId] = address(0);
        //emit Transfer(_from, _to, _tokenId);

    }

    // ... other contract code ...  (e.g., ownerOf, approvedTransfers, operators mappings)
}",42.70554804801941,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with your owner's address
    uint256 public constant TOKEN_ID = 1;
    bool public constant IS_INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() {
        // Initialize state variables to fixed, safe values
        OWNER = 0x1111111111111111111111111111111111111111; // Replace with your owner's address
        TOKEN_ID = 1;
        IS_INITIALIZED = true;
        INIT_BYTES32 = bytes32('init');
    }

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");
        _clearApprovalAndTransfer(_tokenId, msg.sender);
    }

    function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {
        //Implementation for checking sender approval.  This would likely involve checking
        //approvedTransfers or operators mappings.  Replace with your actual implementation.
        //Example: return approvedTransfers[_tokenId] == msg.sender || operators[ownerOf(_tokenId)][msg.sender];

    }

    function _clearApprovalAndTransfer(uint256 _tokenId, address _to) internal {
        //Implementation for clearing approvals and transferring ownership.  This would likely involve
        //updating ownerByTokenId and approvedTransfers mappings and emitting a Transfer event.
        //Example:
        //address _from = ownerByTokenId[_tokenId];
        //ownerByTokenId[_tokenId] = _to;
        //approvedTransfers[_tokenId] = address(0);
        //emit Transfer(_from, _to, _tokenId);

    }

    // ... other contract code ...
}"
6427,We do n't make this function constant to allow for state-updating access controls such as rate limiting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AccessControl {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => bool)) private roles;
    mapping(address => mapping(bytes4 => bool)) private permissions;

    function hasRole(address subject, bytes32 role) public view returns (bool) {
        return roles[subject][role];
    }

    function hasPermission(address object, bytes4 verb) public view returns (bool) {
        return permissions[object][verb];
    }

    function allowed(address subject, bytes32 role, address object, bytes4 verb) public returns (bool) {
        require(subject != address(0), ""Subject cannot be zero address"");
        require(role != bytes32(0), ""Role cannot be empty"");
        require(object != address(0), ""Object cannot be zero address"");
        require(verb != bytes4(0), ""Verb cannot be empty"");

        if (hasRole(subject, role)) {
            return true;
        }

        if (hasPermission(object, verb)) {
            return true;
        }

        return false;
    }
}",checkPermission,"[{'function': 'checkPermission', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkPermission"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""subject"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""object"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""verb"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accessControlList""}, ""index"": {""type"": ""Identifier"", ""name"": ""subject""}}, ""index"": {""type"": ""Identifier"", ""name"": ""role""}}, ""index"": {""type"": ""Identifier"", ""name"": ""object""}}, ""index"": {""type"": ""Identifier"", ""name"": ""verb""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",45.0,0.4369138481929238,0.0222340916439289,"pragma solidity ^0.8.0;

contract AccessControl {

    mapping(address => mapping(bytes32 => mapping(address => mapping(bytes4 => bool)))) public accessControlList;

    function checkPermission(address subject, bytes32 role, address object, bytes4 verb) public view returns (bool) {
        return accessControlList[subject][role][object][verb];
    }
}",41.5114016532898,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AccessControl is Ownable {
    mapping(address => mapping(bytes32 => mapping(address => mapping(bytes4 => bool))) public accessControlList;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function checkPermission(address subject, bytes32 role, address object, bytes4 verb) public view returns (bool) {
        return accessControlList[subject][role][object][verb];
    }
}"
5406,Returns all rewards charged for the given canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeeHistory {
    function rewardsCumulative(uint256 index) external view returns (uint256);
}

abstract contract CanvasRewards is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint256[] rewardsCumulative;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getTotalRewards(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Invalid canvas ID"");
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint256 _lastIndex = _history.rewardsCumulative.length - 1;
        if (_lastIndex < 0) {
            return 0;
        }
        return _history.rewardsCumulative[_lastIndex];
    }
}",getTotalRewards,"[{'function': 'getTotalRewards', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalRewards"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_canvasId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Canvas ID out of bounds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""FeeHistory""}, ""name"": ""feeHistory"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasToFeeHistory""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_lastIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feeHistory""}, ""memberName"": ""rewardsCumulative""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_lastIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": None}, {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feeHistory""}, ""memberName"": ""rewardsCumulative""}, ""index"": {""type"": ""Identifier"", ""name"": ""_lastIndex""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.9330791073776912,0.4888357758795306,"pragma solidity ^0.8.0;

contract CanvasRewards {

    struct FeeHistory {
        uint32[] rewardsCumulative;
    }

    mapping(uint32 => FeeHistory) public canvasToFeeHistory;
    uint32[] public canvases;

    function getTotalRewards(uint32 _canvasId) public view returns (uint32) {
        require(_canvasId < canvases.length, ""Canvas ID out of bounds"");
        FeeHistory storage feeHistory = canvasToFeeHistory[_canvasId];
        uint32 _lastIndex = uint32(feeHistory.rewardsCumulative.length -1);
        if (_lastIndex < 0) {
            return 0;
        }
        return feeHistory.rewardsCumulative[_lastIndex];
    }
}",41.87232327461243,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CanvasRewards is Ownable {
    struct FeeHistory {
        uint32[] rewardsCumulative;
    }

    mapping(uint32 => FeeHistory) public canvasToFeeHistory;
    uint32[] public canvases;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint32 i = 0; i < 3; i++) {
            FeeHistory storage feeHistory = canvasToFeeHistory[i];
            feeHistory.rewardsCumulative.push(1); // Never 0
        }
    }

    function getTotalRewards(uint32 _canvasId) public view returns (uint32) {
        require(_canvasId < canvases.length, ""Canvas ID out of bounds"");
        FeeHistory storage feeHistory = canvasToFeeHistory[_canvasId];
        uint32 _lastIndex = uint32(feeHistory.rewardsCumulative.length - 1);
        if (_lastIndex < 0) {
            return 0;
        }
        return feeHistory.rewardsCumulative[_lastIndex];
    }
}"
6503,The reward is calculated by the formula : ( numberOfBlocks ) ( effectiveBlockReward ) ( commitment.value ) / ( effectiveStake ) effectiveBlockReward is the average between the block reward during commit and the block reward during the call effectiveStake is the average between the stake during the commit and the stake during call ( liniar aproximation ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IMinerContract {
    function miners(address) external view returns (Miner memory);
    function totalStake() external view returns (uint256);
    function blockReward_() external view returns (int256);
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;

    struct Miner {
        uint256 value;
        int256 onBlockReward;
        uint256 atStake;
        uint256 onBlockNumber;
    }

    mapping(address => Miner) public miners;
    uint256 public totalStake_;
    int256 public blockReward_;

    IMinerContract public minerContract;

    constructor(address _minerContractAddress) {
        minerContract = IMinerContract(_minerContractAddress);
    }

    function getReward(address _miner) public view returns (uint256) {
        if (minerContract.miners(_miner).value == 0) {
            return 0;
        }
        Miner memory commitment = minerContract.miners(_miner);
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number.sub(commitment.onBlockNumber);
        uint256 miningReward = numberOfBlocks.mul(effectiveBlockReward).mul(commitment.value).div(effectiveStake);
        return miningReward;
    }

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return int256((uint256(a) + uint256(b)) / 2);
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}",getReward,"[{'function': 'signedAverage', 'complexity': 0}, {'function': 'average', 'complexity': 0}, {'function': 'getReward', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_miner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_miner""}}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Commitment""}, ""name"": ""commitment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_miner""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""int256""}, ""name"": ""averageBlockReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""signedAverage""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""onBlockReward""}, {""type"": ""Identifier"", ""name"": ""blockReward_""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""averageBlockReward""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveBlockReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""averageBlockReward""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveStake"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""average""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""atStake""}, {""type"": ""Identifier"", ""name"": ""totalStake_""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numberOfBlocks"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""onBlockNumber""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""miningReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""numberOfBlocks""}, ""right"": {""type"": ""Identifier"", ""name"": ""effectiveBlockReward""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""value""}}, ""right"": {""type"": ""Identifier"", ""name"": ""effectiveStake""}}}, {""type"": ""Identifier"", ""name"": ""miningReward""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",12.0,0.8078334274952343,0.6064815716243979,"pragma solidity ^0.8.0;

contract MiningRewardCalculator {
    struct Commitment {
        uint256 value;
        int256 onBlockReward;
        uint256 atStake;
        uint256 onBlockNumber;
    }

    mapping(address => Commitment) public miners;
    int256 public blockReward_;
    uint256 public totalStake_;

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return (a + b) / 2;
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a + b) / 2;
    }

    function getReward(address _miner) public view returns (uint256) {
        if (miners[_miner].value == 0) {
            return 0;
        }
        Commitment storage commitment = miners[_miner];
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number - commitment.onBlockNumber;
        uint256 miningReward = numberOfBlocks * effectiveBlockReward * commitment.value / effectiveStake;
        return miningReward;
    }
}",43.122034549713135,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MiningRewardCalculator is Ownable {
    struct Commitment {
        uint256 value;
        int256 onBlockReward;
        uint256 atStake;
        uint256 onBlockNumber;
    }

    mapping(address => Commitment) public miners;
    int256 public blockReward_;
    uint256 public totalStake_;

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return (a + b) / 2;
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a + b) / 2;
    }

    function getReward(address _miner) public view returns (uint256) {
        if (miners[_miner].value == 0) {
            return 0;
        }
        Commitment storage commitment = miners[_miner];
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number - commitment.onBlockNumber;
        uint256 miningReward = numberOfBlocks * effectiveBlockReward * commitment.value / effectiveStake;
        return miningReward;
    }

    constructor() Ownable(msg.sender) {
        blockReward_ = 1;
        totalStake_ = 1;
    }
}"
2533,Function to process cases when person send more than 10 ETH to smartcontract but never provided KYC data and wants/needs to be refunded .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RefundContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonWLBalanceOf;

    function refundNonWhitelistedPerson(address _address) public onlyOwner {
        require(_address != address(0), ""Invalid address"");
        uint256 refundAmount = nonWLBalanceOf[_address];
        require(refundAmount > 0, ""No balance to refund"");
        nonWLBalanceOf[_address] = nonWLBalanceOf[_address].sub(refundAmount);
        _address.transfer(refundAmount);
    }
}",refundNonWhitelisted,"[{'function': 'refundNonWhitelisted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""refundNonWhitelisted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonWLBalanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonWLBalanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.7224100441174568,0.1481208001626013,"pragma solidity ^0.8.0;

contract MyContract {

    address public owner;
    mapping(address => uint256) public nonWLBalanceOf;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function refundNonWhitelisted(address _address) public onlyOwner {
        uint256 balance = nonWLBalanceOf[_address];
        payable(_address).transfer(balance);
        nonWLBalanceOf[_address] = 0;
    }
}",41.80281090736389,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner = msg.sender;
    mapping(address => uint256) public nonWLBalanceOf;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are already initialized in the parent contract's constructor
    }

    function refundNonWhitelisted(address _address) public onlyOwner {
        uint256 balance = nonWLBalanceOf[_address];
        payable(_address).transfer(balance);
        nonWLBalanceOf[_address] = 0;
    }
}"
5759,Check ` _value ` tokens allowed to ` _spender ` by ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;
    mapping(address => mapping(address => uint256)) public approved;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return approved[_owner][_spender];
    }
}",allowance,"[{'function': 'allowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9834251147214492,0.8606031405392816,"pragma solidity ^0.8.0;

contract Token {

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public approved;

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return approved[_owner][_spender];
    }
}",41.60964584350586,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public approved;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        balanceOf[owner()] = 1;
        address _owner = owner();
        for (uint i = 0; i < 3; i++) {
            if (i == 0) approved[_owner][address(this)] = 1;
            else if (i == 1) approved[_owner][address(0x2222222222222222222222222222222222222222)] = 1;
            else if (i == 2) approved[_owner][address(0x3333333333333333333333333333333333333333)] = 1;
        }
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return approved[_owner][_spender];
    }
}"
4344,shuts the CDP and returns all the value in the form of Dai .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IFeed {
    function read() external view returns (bytes32);
}

interface ITub {
    function tab(bytes32 id) external view returns (uint256 debt);
    function ink(bytes32 id) external view returns (uint256 ink);
    function shut(bytes32 id) external;
    function bid(uint256 amount) external view returns (uint256 bought);
    function exit(uint256 amount) external;
}

interface IOTC {
    function sellAllAmount(address gem, uint256 amount, address pay, uint256 minPrice) external returns (uint256 bought);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public dai;
    ITub public tub;
    IFeed public feed;
    IOTC public otc;
    IERC20 public gem;
    uint256 public slippage;
    uint256 public WAD = 10**18;

    constructor(address _dai, address _tub, address _feed, address _otc, address _gem, uint256 _slippage) {
        dai = IERC20(_dai);
        tub = ITub(_tub);
        feed = IFeed(_feed);
        otc = IOTC(_otc);
        gem = IERC20(_gem);
        slippage = _slippage;
    }

    function shutForDai(uint _id) public onlyOwner {
        bytes32 id = bytes32(_id);
        uint debt = tub.tab(id);
        if (debt > 0) {
            require(dai.transferFrom(msg.sender, address(this), debt));
        }
        uint ink = tub.ink(id);
        tub.shut(id);
        uint gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint price = uint(feed.read());
        uint bought = otc.sellAllAmount(address(gem), min(gemBalance, gem.balanceOf(address(this))), address(dai), wmul(WAD - slippage, wmul(gemBalance, price)));
        require(dai.transfer(msg.sender, bought));
    }

    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = x * y / WAD;
    }
}",shutForDai,"[{'function': 'transfer', 'complexity': 0}, {'function': 'exit', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'sellAllAmount', 'complexity': 0}, {'function': 'read', 'complexity': 0}, {'function': 'shutForDai', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""shutForDai"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_id""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""debt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""tab""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""debt""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dai""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""debt""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Dai transfer failed""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ink"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""ink""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""shut""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""gemBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""bid""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ink""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""exit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ink""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feed""}, ""memberName"": ""read""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""bought"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""otc""}, ""memberName"": ""sellAllAmount""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gem""}], ""names"": []}, {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""gemBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""gem""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, ""TrueExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""gem""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""gemBalance""}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""dai""}], ""names"": []}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""slippage""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""gemBalance""}}, ""right"": {""type"": ""Identifier"", ""name"": ""price""}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""isArray"": False}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dai""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""bought""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.9202594988846056,0.6194315853354946,"pragma solidity ^0.8.0;

interface DaiInterface {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface TubInterface {
    function tab(bytes32 id) external view returns (uint256);
    function ink(bytes32 id) external view returns (uint256);
    function shut(bytes32 id) external;
    function bid(uint256 ink) external view returns (uint256);
    function exit(uint256 ink) external;
}

interface GemInterface {
    function balanceOf(address account) external view returns (uint256);
}

interface OtcInterface {
    function sellAllAmount(address gem, uint256 maxGem, address dai, uint256 minDai) external returns (uint256);
}

interface FeedInterface {
    function read() external view returns (uint256);
}

contract ShutForDai {
    TubInterface public tub;
    DaiInterface public dai;
    GemInterface public gem;
    OtcInterface public otc;
    FeedInterface public feed;
    uint256 public slippage;

    constructor(TubInterface _tub, DaiInterface _dai, GemInterface _gem, OtcInterface _otc, FeedInterface _feed, uint256 _slippage) {
        tub = _tub;
        dai = _dai;
        gem = _gem;
        otc = _otc;
        feed = _feed;
        slippage = _slippage;
    }

    function shutForDai(uint256 _id) external {
        bytes32 id = bytes32(_id);
        uint256 debt = tub.tab(id);
        if (debt > 0) {
            require(dai.transferFrom(msg.sender, address(this), debt), ""Dai transfer failed"");
        }
        uint256 ink = tub.ink(id);
        tub.shut(id);
        uint256 gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint256 price = feed.read();
        uint256 bought = otc.sellAllAmount(address(gem), gemBalance > gem.balanceOf(address(this)) ? gem.balanceOf(address(this)) : gemBalance, address(dai), (10**18 - slippage) * gemBalance * price / (10**18));
        dai.transfer(msg.sender, bought);
    }
}",44.70325183868408,"pragma solidity ^0.8.0;

interface DaiInterface {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface TubInterface {
    function tab(bytes32 id) external view returns (uint256);
    function ink(bytes32 id) external view returns (uint256);
    function shut(bytes32 id) external;
    function bid(uint256 ink) external view returns (uint256);
    function exit(uint256 ink) external;
}

interface GemInterface {
    function balanceOf(address account) external view returns (uint256);
}

interface OtcInterface {
    function sellAllAmount(address gem, uint256 maxGem, address dai, uint256 minDai) external returns (uint256);
}

interface FeedInterface {
    function read() external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract ShutForDai is Ownable {
    TubInterface public tub;
    DaiInterface public dai;
    GemInterface public gem;
    OtcInterface public otc;
    FeedInterface public feed;
    uint256 public slippage;

    mapping(address => uint256) public balanceOf;

 constructor(TubInterface _tub, DaiInterface _dai, GemInterface _gem, OtcInterface _otc, FeedInterface _feed, uint256 _slippage) Ownable() {
        tub = _tub;
        dai = _dai;
        gem = _gem;
        otc = _otc;
        feed = _feed;
        slippage = _slippage;
    }

    function shutForDai(uint256 _id) external {
        bytes32 id = bytes32(_id);
        uint256 debt = tub.tab(id);
        if (debt > 0) {
            require(dai.transferFrom(msg.sender, address(this), debt), ""Dai transfer failed"");
        }
        uint256 ink = tub.ink(id);
        tub.shut(id);
        uint256 gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint256 price = feed.read();
        uint256 bought = otc.sellAllAmount(address(gem), gemBalance > gem.balanceOf(address(this)) ? gem.balanceOf(address(this)) : gemBalance, address(dai), (10**18 - slippage) * gemBalance * price / (10**18));
        dai.transfer(msg.sender, bought);
    }
}"
6386,Internal - Removes the owner of a ticker,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TickerContract {
    using SafeMath for uint256;

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        uint256 index = uint256(getUint(Encoder.getKey(""tickerIndex"", _ticker)));
        bytes32 ownerKey = Encoder.getKey(""userToTickers"", _owner);
        bytes32[] memory tickers = getArrayBytes32(ownerKey);
        assert(index < tickers.length);
        assert(_tickerOwner(_ticker) == _owner);
        deleteArrayBytes32(ownerKey, index);
        if (getArrayBytes32(ownerKey).length > index) {
            bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];
            set(Encoder.getKey(""tickerIndex"", Util.bytes32ToString(switchedTicker)), index);
        }
    }
}",_deleteTickerOwnership,"[{'function': '_deleteTickerOwnership', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""_deleteTickerOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickerIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Ticker not found""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickerOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_owner""}}, {""type"": ""stringLiteral"", ""value"": ""Not the owner of this ticker""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""lastTicker"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickerIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}, ""isPrefix"": True}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""right"": {""type"": ""Identifier"", ""name"": ""lastTicker""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickerIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""lastTicker""}}, ""right"": {""type"": ""Identifier"", ""name"": ""index""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickerOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}, ""isPrefix"": True}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",51.0,0.5857465602070402,0.1709994462360033,"pragma solidity ^0.8.0;

contract TickerOwnership {

    mapping(address => mapping(string => uint256)) public tickerIndex;
    mapping(address => string[]) public userTickers;
    mapping(string => address) public tickerOwner;


    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        uint256 index = tickerIndex[_owner][_ticker];
        require(index < userTickers[_owner].length, ""Ticker not found"");
        require(tickerOwner[_ticker] == _owner, ""Not the owner of this ticker"");

        string memory lastTicker = userTickers[_owner][userTickers[_owner].length -1];

        delete tickerIndex[_owner][_ticker];

        if (index < userTickers[_owner].length -1) {
            userTickers[_owner][index] = lastTicker;
            tickerIndex[_owner][lastTicker] = index;
        }
        userTickers[_owner].pop();
        delete tickerOwner[_ticker];
    }
}",42.49843239784241,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TickerOwnership is Ownable {
    mapping(address => mapping(string => uint256)) public tickerIndex;
    mapping(address => string[]) public userTickers;
    mapping(string => address) public tickerOwner;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        uint256 index = tickerIndex[_owner][_ticker];
        require(index < userTickers[_owner].length, ""Ticker not found"");
        require(tickerOwner[_ticker] == _owner, ""Not the owner of this ticker"");

        string memory lastTicker = userTickers[_owner][userTickers[_owner].length - 1];

        delete tickerIndex[_owner][_ticker];

        if (index < userTickers[_owner].length - 1) {
            userTickers[_owner][index] = lastTicker;
            tickerIndex[_owner][lastTicker] = index;
        }
        userTickers[_owner].pop();
        delete tickerOwner[_ticker];
    }
}"
5781,Get the allowance of an specified address to use another address balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",allowance,"[{'function': 'allowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9835233089668656,0.8606031405392816,"pragma solidity ^0.8.0;

contract MyContract {
    mapping (address => mapping (address => uint256)) internal allowed;

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
}",41.18368649482727,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping (address => mapping (address => uint256)) internal allowed;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        allowed[address(0x111)][address(0x222)] = 1;
        allowed[address(0x222)][address(0x333)] = 1;
        allowed[address(0x333)][address(0x111)] = 1;
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }
}"
5300,Last callback used to accept the ERC721 parcel tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ERC721Receiver {
    using SafeMath for uint256;

    address public land;
    uint256 public flagReceiveLand;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4) {
        if (msg.sender == land && flagReceiveLand == _tokenId) {
            flagReceiveLand = 0;
            return bytes4(0x150b7a02);
        }
    }
}",onERC721Received,"[{'function': 'onERC721Received', 'complexity': 2}, {'function': 'setFlagReceiveLand', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""onERC721Received"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""landContractAddress""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""Identifier"", ""name"": ""flagReceiveLand""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""flagReceiveLand""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""this""}, ""memberName"": ""onERC721Received""}, ""memberName"": ""selector""}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Invalid token transfer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.894988063404364,0.5025376863938434,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public flagReceiveLand;
    address public landContractAddress;

    constructor(address _landContractAddress) {
        landContractAddress = _landContractAddress;
    }

    function onERC721Received(address, address, uint256 _tokenId, bytes memory) public returns (bytes4) {
        if (msg.sender == landContractAddress && _tokenId == flagReceiveLand) {
            flagReceiveLand = 0;
            return this.onERC721Received.selector;
        }
        revert(""Invalid token transfer"");
    }

    function setFlagReceiveLand(uint256 _tokenId) public {
        flagReceiveLand = _tokenId;
    }
}",43.10130500793457,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public flagReceiveLand;
    address public landContractAddress;

    constructor(address _landContractAddress) Ownable(msg.sender) {
        landContractAddress = _landContractAddress;
        flagReceiveLand = 1; // Set to a non-zero value
    }

    function onERC721Received(address, address, uint256 _tokenId, bytes memory) public returns (bytes4) {
        if (msg.sender == landContractAddress && _tokenId == flagReceiveLand) {
            flagReceiveLand = 0;
            return this.onERC721Received.selector;
        }
        revert(""Invalid token transfer"");
    }

    function setFlagReceiveLand(uint256 _tokenId) public {
        flagReceiveLand = _tokenId;
    }
}"
6110,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external;
}

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}",updatePrices,"[{'function': 'updatePrices', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newEthPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newHavvenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""ORACLE_FUTURE_LIMIT""}}}}, {""type"": ""stringLiteral"", ""value"": ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newEthPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newHavvenPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PricesUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOracle"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9472435952401742,0.8517763686737969,"pragma solidity ^0.8.0;

contract PriceOracle {

    uint256 public usdToEthPrice;
    uint256 public usdToHavPrice;
    uint256 public lastPriceUpdateTime;
    uint256 public constant ORACLE_FUTURE_LIMIT = 1 hours; //Example value, adjust as needed

    address public oracle;

    constructor(address _oracle) {
        oracle = _oracle;
    }

    modifier onlyOracle() {
        require(msg.sender == oracle, ""Only the oracle can call this function"");
        _;
    }

    event PricesUpdated(uint256 ethPrice, uint256 havvenPrice, uint256 timestamp);

    function updatePrices(uint256 newEthPrice, uint256 newHavvenPrice, uint256 timeSent)
        external
        onlyOracle
    {
        require(lastPriceUpdateTime < timeSent && timeSent < block.timestamp + ORACLE_FUTURE_LIMIT,
            ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");

        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;

        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}",43.20482563972473,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceOracle is Ownable {
    uint256 public usdToEthPrice;
    uint256 public usdToHavPrice;
    uint256 public lastPriceUpdateTime;
    uint256 public constant ORACLE_FUTURE_LIMIT = 1 hours; //Example value, adjust as needed

    address public oracle;

    constructor(address _oracle) Ownable(msg.sender) {
        oracle = _oracle;
        usdToEthPrice = 1;
        usdToHavPrice = 1;
        lastPriceUpdateTime = block.timestamp;
    }

    modifier onlyOracle() {
        require(msg.sender == oracle, ""Only the oracle can call this function"");
        _;
    }

    event PricesUpdated(uint256 ethPrice, uint256 havvenPrice, uint256 timestamp);

    function updatePrices(uint256 newEthPrice, uint256 newHavvenPrice, uint256 timeSent)
        external
        onlyOracle
    {
        require(lastPriceUpdateTime < timeSent && timeSent < block.timestamp + ORACLE_FUTURE_LIMIT,
            ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");

        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;

        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}"
1872,selfdestructs and sends the balance to ` escrowModerator ` or ` beneficiary `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Auction {
    function auctionState() external view returns (AuctionStates);
    function escrowModerator() external view returns (address);
    function beneficiary() external view returns (address);
}

abstract contract AuctionWrapper is Ownable, Auction {
    using SafeMath for uint256;

    enum AuctionStates { NotStarted, Active, Ended, Canceled }

    AuctionStates public auctionState;
    address public escrowModerator;
    address public beneficiary;

    function setAuctionState(AuctionStates state) external onlyOwner {
        auctionState = state;
    }

    function setEscrowModerator(address moderator) external onlyOwner {
        escrowModerator = moderator;
    }

    function setBeneficiary(address ben) external onlyOwner {
        beneficiary = ben;
    }

    function cleanUpAfterYourself() public {
        require(auctionState == AuctionStates.Ended, ""Auction is not ended."");
        if (escrowModerator != address(0)) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }
}",cleanup,"[{'function': 'cleanup', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cleanup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""auctionState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionState""}, ""memberName"": ""Ended""}}, {""type"": ""stringLiteral"", ""value"": ""Auction is not ended.""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""escrowModerator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""escrowModerator""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9669254034076687,0.8957706306804313,"pragma solidity ^0.8.0;

contract Auction {
    enum AuctionState {Created, Active, Ended}
    AuctionState public auctionState;
    address payable public beneficiary;
    address payable public escrowModerator;

    constructor(address payable _beneficiary, address payable _escrowModerator) {
        beneficiary = _beneficiary;
        escrowModerator = _escrowModerator;
        auctionState = AuctionState.Created;
    }

    function cleanup() public {
        require(auctionState == AuctionState.Ended, ""Auction is not ended."");
        if (escrowModerator != address(0)) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }

    // ... other functions ...
}",41.92703914642334,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    enum AuctionState {Created, Active, Ended}
    AuctionState public auctionState;
    address payable public beneficiary;
    address payable public escrowModerator;

    constructor(address payable _beneficiary, address payable _escrowModerator) Ownable(msg.sender) {
        require(_beneficiary != address(0), ""Beneficiary must be a valid address"");
        require(_escrowModerator != address(0), ""Escrow moderator must be a valid address"");

        beneficiary = _beneficiary;
        escrowModerator = _escrowModerator;
        auctionState = AuctionState.Created;
    }

    function cleanup() public {
        require(auctionState == AuctionState.Ended, ""Auction is not ended."");
        if (escrowModerator != address(0)) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }

    // ... other functions ...
}"
4928,Sets the contract which implements a specific interface for an address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC820ImplementerInterface {
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns (bytes4);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bytes4 constant private ERC820_ACCEPT_MAGIC = 0xffffffff;
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address implementer);

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == 0 ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, ""Not the manager"");
        require(!isERC165Interface(_interfaceHash), ""Must not be a ERC165 hash"");
        if (_implementer != 0 && _implementer != msg.sender) {
            require(ERC820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_interfaceHash, addr) == ERC820_ACCEPT_MAGIC, ""Does not implement the interface"");
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address addr) internal view returns (address) {
        // Implement logic to retrieve the manager for the address
        return owner();
    }

    function isERC165Interface(bytes32 interfaceHash) internal pure returns (bool) {
        // Implement logic to check if the interface hash is an ERC165 hash
        return false;
    }
}",setInterfaceImplementer,"[{'function': 'setInterfaceImplementer', 'complexity': 5}, {'function': 'getManager', 'complexity': 0}, {'function': 'canImplementInterfaceForAddress', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInterfaceImplementer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_interfaceHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_implementer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""_addr""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getManager""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Not the manager""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_interfaceHash""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x01ffc9a7"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Must not be a ERC165 hash""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_implementer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_implementer""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""canImplementInterfaceForAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_implementer""}, {""type"": ""Identifier"", ""name"": ""addr""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Does not implement the interface""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""interfaces""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_interfaceHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_implementer""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InterfaceImplementerSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}, {""type"": ""Identifier"", ""name"": ""_interfaceHash""}, {""type"": ""Identifier"", ""name"": ""_implementer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.9454650335551548,0.7709240651975264,"pragma solidity ^0.8.0;

contract InterfaceRegistry {

    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) public {
        address addr = _addr == address(0) ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, ""Not the manager"");
        require(_interfaceHash != 0x01ffc9a7, ""Must not be a ERC165 hash"");
        if (_implementer != address(0) && _implementer != msg.sender) {
            require(canImplementInterfaceForAddress(_implementer, addr), ""Does not implement the interface"");
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address _addr) internal pure returns (address) {
        // Replace with your actual logic to get the manager of an address.
        return _addr;
    }

    function canImplementInterfaceForAddress(address _implementer, address _addr) internal pure returns (bool) {
        // Replace with your actual logic to check if an address can implement an interface for another address.
        return true;
    }
}",42.66398787498474,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract InterfaceRegistry is Ownable {
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) public {
        address addr = _addr == address(0) ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, ""Not the manager"");
        require(_interfaceHash != 0x01ffc9a7, ""Must not be a ERC165 hash"");
        if (_implementer != address(0) && _implementer != msg.sender) {
            require(canImplementInterfaceForAddress(_implementer, addr), ""Does not implement the interface"");
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address _addr) internal pure returns (address) {
        // Replace with your actual logic to get the manager of an address.
        return _addr;
    }

    function canImplementInterfaceForAddress(address _implementer, address _addr) internal pure returns (bool) {
        // Replace with your actual logic to check if an address can implement an interface for another address.
        return true;
    }
}"
1268,"This creates a Pledge with an initial amount of 0 if one is not created already ; otherwise it finds the pledge with the specified attributes ; all pledges technically exist , if the pledge has n't been created in this system yet it simply is n't in the hash array hPledge2idx [ ] yet","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeManager is Ownable {
    using SafeMath for uint256;

    struct Pledge {
        uint256 amount;
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    enum PledgeState { Active, Canceled, Refunded }

    mapping(bytes32 => uint64) public hPledge2idx;
    Pledge[] public pledges;

    function findOrCreatePledge(uint64 owner, uint64[] memory delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint64) {
        bytes32 hPledge = keccak256(abi.encodePacked(owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        uint64 idx = hPledge2idx[hPledge];
        if (idx > 0) return idx;
        idx = uint64(pledges.length);
        hPledge2idx[hPledge] = idx;
        pledges.push(Pledge(0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        return idx;
    }
}",findOrCreatePledge,"[{'function': 'findOrCreatePledge', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""findOrCreatePledge"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""length"": None}, ""name"": ""delegationChain"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""intendedProject"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""commitTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""oldPledge"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeState""}, ""name"": ""state"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hPledge"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""delegationChain""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""intendedProject""}, {""type"": ""Identifier"", ""name"": ""commitTime""}, {""type"": ""Identifier"", ""name"": ""oldPledge""}, {""type"": ""Identifier"", ""name"": ""state""}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""hPledge""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""hPledge""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""idx"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""length""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""hPledge""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""idx""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Pledge""}, ""name"": ""newPledge"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Pledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""delegationChain""}, {""type"": ""Identifier"", ""name"": ""intendedProject""}, {""type"": ""Identifier"", ""name"": ""commitTime""}, {""type"": ""Identifier"", ""name"": ""oldPledge""}, {""type"": ""Identifier"", ""name"": ""state""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newPledge""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""idx""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.8921975961542736,0.6140175283208696,"pragma solidity ^0.8.0;

contract PledgeContract {

    enum PledgeState { Active, Inactive, Revoked }

    struct Pledge {
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    Pledge[] public pledges;
    mapping(bytes32 => uint256) public hPledge2idx;

    function findOrCreatePledge(uint64 owner, uint64[] memory delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint256) {
        bytes32 hPledge = keccak256(abi.encode(owner, keccak256(abi.encodePacked(delegationChain)), intendedProject, commitTime, oldPledge, state));
        if (hPledge2idx[hPledge] > 0) {
            return hPledge2idx[hPledge] -1;
        }
        uint256 idx = pledges.length;
        hPledge2idx[hPledge] = idx + 1;
        Pledge memory newPledge = Pledge(owner, delegationChain, intendedProject, commitTime, oldPledge, state);
        pledges.push(newPledge);
        return idx;
    }
}",43.01614260673523,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PledgeContract is Ownable {
    enum PledgeState { Active, Inactive, Revoked }

    struct Pledge {
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    Pledge[] public pledges;
    mapping(bytes32 => uint256) public hPledge2idx;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function findOrCreatePledge(uint64 owner, uint64[] memory delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint256) {
        bytes32 hPledge = keccak256(abi.encode(owner, keccak256(abi.encodePacked(delegationChain)), intendedProject, commitTime, oldPledge, state));
        if (hPledge2idx[hPledge] > 0) {
            return hPledge2idx[hPledge] - 1;
        }
        uint256 idx = pledges.length;
        hPledge2idx[hPledge] = idx + 1;
        Pledge memory newPledge = Pledge(owner, delegationChain, intendedProject, commitTime, oldPledge, state);
        pledges.push(newPledge);
        return idx;
    }
}"
6042,Returns all the relevant information about a specific library .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LibraryWrapper is Ownable {
    using SafeMath for uint256;

    struct Library {
        string name;
        string language;
        uint256 price;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    function getLibrary(uint256 _tokenId) public view returns (string memory language, string memory libraryName, uint256 tokenPrice, uint256 funds, address tokenOwner, address founder) {
        Library storage x = libraries[_tokenId];
        libraryName = x.name;
        language = x.language;
        founder = libraryIndexToFounder[_tokenId];
        funds = libraryIndexToFunds[_tokenId];
        tokenPrice = libraryIndexToPrice[_tokenId];
        tokenOwner = libraryIndexToOwner[_tokenId];
    }
}",getLibrary,"[{'function': 'getLibrary', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLibrary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""libraryName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""language"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""founder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""funds"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Library""}, ""name"": ""lib"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""libraryName""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lib""}, ""memberName"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""language""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lib""}, ""memberName"": ""language""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""founder""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToFounder""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""funds""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToFunds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenPrice""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9396928434614834,0.6966370661321631,"pragma solidity ^0.8.0;

contract LibraryContract {

    struct Library {
        string name;
        string language;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    function getLibrary(uint256 _tokenId) public view returns (string memory libraryName, string memory language, address founder, uint256 funds, uint256 tokenPrice, address tokenOwner) {
        Library memory lib = libraries[_tokenId];
        libraryName = lib.name;
        language = lib.language;
        founder = libraryIndexToFounder[_tokenId];
        funds = libraryIndexToFunds[_tokenId];
        tokenPrice = libraryIndexToPrice[_tokenId];
        tokenOwner = libraryIndexToOwner[_tokenId];
    }
}",42.34011340141296,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract LibraryContract is Ownable {
    struct Library {
        string name;
        string language;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        libraries[1].name = ""My Library"";
        libraries[2].language = ""English"";
        libraryIndexToFounder[1] = msg.sender;
        libraryIndexToFunds[1] = 1000;
        libraryIndexToPrice[1] = 10;
        libraryIndexToOwner[1] = msg.sender;

        // Initialize ERC20 contract (assuming it's a simple token)
        ERC20(""MyToken"", ""MYT"").initialize();
    }

    function getLibrary(uint256 _tokenId) public view returns (string memory libraryName, string memory language, address founder, uint256 funds, uint256 tokenPrice, address tokenOwner) {
        Library memory lib = libraries[_tokenId];
        libraryName = lib.name;
        language = lib.language;
        founder = libraryIndexToFounder[_tokenId];
        funds = libraryIndexToFunds[_tokenId];
        tokenPrice = libraryIndexToPrice[_tokenId];
        tokenOwner = libraryIndexToOwner[_tokenId];
    }
}
import ""openzeppelin/SafeMath.sol"";
contract ERC20 {
    string public name;
    string public symbol;

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function initialize() public {
        // Initialize contract logic
    }
}"
1213,Get the token balance for a specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint;

    mapping(address => uint) public balances;

 function balanceOf (address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; }


}",balanceOf,"[{'function': 'balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9817240321866956,0.8320381765431424,"pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => uint) public balances;

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }
}",41.44089889526367,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => uint) public balances;
    bytes32 public initialized;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000; // Set to a fixed, safe value (never 0)
        initialized = bytes32('initialized'); // Set to a fixed string value
    }

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }
}"
6726,transfers tokens in ERC20 compatible way using signature to recover token sender,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    function transferWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig) public returns (bool) {
        doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
        return true;
    }

    function doSendWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig, bool) internal {
        // Implementation of the original function logic would go here.
    }
}",transferWithSignature,"[{'function': 'transferWithSignature', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferWithSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_sig"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doSendWithSignature""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_data""}, {""type"": ""Identifier"", ""name"": ""_nonce""}, {""type"": ""Identifier"", ""name"": ""_sig""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.9636236610214216,0.8038822023014129,"pragma solidity ^0.8.0;

contract MyToken {

    // ... other contract code ...

    function transferWithSignature(
        address _to,
        uint256 _amount,
        uint256 _fee,
        bytes calldata _data,
        uint256 _nonce,
        bytes calldata _sig
    ) public returns (bool) {
        return doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
    }

    // ... other contract code, including doSendWithSignature function ...

}",41.58075928688049,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyToken {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function transferWithSignature(
        address _to,
        uint256 _amount,
        uint256 _fee,
        bytes calldata _data,
        uint256 _nonce,
        bytes calldata _sig
    ) public returns (bool) {
        return doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
    }

    // ... other contract code, including doSendWithSignature function ...
}"
6123,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract TokenRecipient is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        if (!approve(_spender, _amount)) throw;
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}",approve,"[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.6912650303129142,0.1218725610132649,"pragma solidity ^0.8.0;

interface ApproveAndCallReceiver {
    function receiveApproval(address sender, uint256 amount, address token, bytes memory data) external;
}

contract MyToken {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address spender, uint256 amount) internal returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }


    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount));
        ApproveAndCallReceiver(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}",42.57478094100952,"pragma solidity ^0.8.0;

interface ApproveAndCallReceiver {
    function receiveApproval(address sender, uint256 amount, address token, bytes memory data) external;
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _balances[owner()] = 1;
        for (uint i = 0; i < 3; i++) {
            address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
            _balances[addr] = 1;
        }
    }

    function approve(address spender, uint256 amount) internal returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount));
        ApproveAndCallReceiver(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}"
240,Used to check if an address is a delegate or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function checkDelegate(address _potentialDelegate) external view returns (bool) {
        // Implementation of the checkDelegate function
    }
}",addDelegate,"[{'function': 'addDelegate', 'complexity': 0}, {'function': 'removeDelegate', 'complexity': 0}, {'function': 'isDelegate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addDelegate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_delegate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isAuthorizedDelegate""}, ""index"": {""type"": ""Identifier"", ""name"": ""_delegate""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.6905764258713354,0.030081413820642,"pragma solidity ^0.8.0;

contract DelegateVerifier {

    mapping(address => bool) public isAuthorizedDelegate;

    function addDelegate(address _delegate) external {
        isAuthorizedDelegate[_delegate] = true;
    }

    function removeDelegate(address _delegate) external {
        isAuthorizedDelegate[_delegate] = false;
    }


    function isDelegate(address _potentialDelegate) external view returns (bool) {
        return isAuthorizedDelegate[_potentialDelegate];
    }
}",41.4660267829895,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract DelegateVerifier is Ownable {
    mapping(address => bool) public isAuthorizedDelegate;
    bytes32 public constant INIT = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        isAuthorizedDelegate[msg.sender] = true; // Set to 1 (never 0)
        isAuthorizedDelegate[address(0)] = false; // Address 0 should not be authorized
        isAuthorizedDelegate[0x1111111111111111111111111111111111111111]; // Use these fixed values in order
        isAuthorizedDelegate[0x2222222222222222222222222222222222222222];
        isAuthorizedDelegate[0x3333333333333333333333333333333333333333];

        // Initialize bool, string, and bytes32 variables to safe values
        bool initialized = true;
        string public constant NAME = 'MyContract';
        bytes32 public constant TOKEN_NAME = bytes32('TokenName');

        // Invoke ERC20 constructor with placeholder values
        ERC20 public constant MY_TOKEN = new ERC20(""MyToken"", ""TKN"");
    }

    function addDelegate(address _delegate) external {
        isAuthorizedDelegate[_delegate] = true;
    }

    function removeDelegate(address _delegate) external {
        isAuthorizedDelegate[_delegate] = false;
    }

    function isDelegate(address _potentialDelegate) external view returns (bool) {
        return isAuthorizedDelegate[_potentialDelegate];
    }
}"
3785,Clear collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract PixelConContract is Ownable {
    using SafeMath for uint256;

    struct PixelCon {
        uint256 tokenId;
        uint64 collectionIndex;
    }

    uint256 public totalCollections;
    mapping(uint256 => uint64[]) public collectionTokens;
    mapping(uint256 => string) public collectionNames;
    mapping(uint64 => PixelCon) public pixelcons;

    event ClearCollection(uint256 indexed _collectionIndex);

    modifier validIndex(uint256 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function clearCollection(uint256 _collectionIndex) public validIndex(_collectionIndex) returns (uint64) {
        uint64[] storage collection = collectionTokens[_collectionIndex];
        require(collection.length > 0, ""Collection is already cleared"");
        for (uint i = 0; i < collection.length; i++) {
            PixelCon storage pixelcon = pixelcons[collection[i]];
            require(isCreatorAndOwner(msg.sender, pixelcon.tokenId), ""Sender is not the creator and owner of the PixelCons"");
            pixelcon.collectionIndex = 0;
        }
        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];
        emit ClearCollection(_collectionIndex);
        return _collectionIndex;
    }

    function totalCollections() public view returns (uint256) {
        return totalCollections;
    }
}",clearCollection,"[{'function': 'clearCollection', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""clearCollection"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionNames""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid collection index""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""tokens"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pixelcons""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""memberName"": ""creator""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pixelcons""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""memberName"": ""owner""}}}, {""type"": ""stringLiteral"", ""value"": ""Unauthorized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pixelcons""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""memberName"": ""collectionIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionNames""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""isPrefix"": True}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClearCollection""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_collectionIndex""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",43.0,0.830213032520495,0.3182549833403822,"pragma solidity ^0.8.0;

contract PixelCons {

    struct PixelCon {
        uint256 collectionIndex;
        address creator;
        address owner;
        // ... other PixelCon properties
    }

    mapping(uint256 => PixelCon) public pixelcons;
    mapping(uint256 => string) public collectionNames;
    mapping(uint256 => uint256[]) public collectionTokens;

    event ClearCollection(uint256 _collectionIndex);

    function clearCollection(uint256 _collectionIndex) public {
        require(_collectionIndex > 0 && bytes(collectionNames[_collectionIndex]).length > 0, ""Invalid collection index"");

        uint256[] memory tokens = collectionTokens[_collectionIndex];
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 tokenId = tokens[i];
            require(msg.sender == pixelcons[tokenId].creator && msg.sender == pixelcons[tokenId].owner, ""Unauthorized"");
            pixelcons[tokenId].collectionIndex = 0;
        }

        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];

        emit ClearCollection(_collectionIndex);
    }
}",42.719643115997314,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PixelCons is Ownable {

    struct PixelCon {
        uint256 collectionIndex;
        address creator;
        address owner;
        // ... other PixelCon properties
    }

    mapping(uint256 => PixelCon) public pixelcons;
    mapping(uint256 => string) public collectionNames;
    mapping(uint256 => uint256[]) public collectionTokens;

    event ClearCollection(uint256 _collectionIndex);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            pixelcons[i] = PixelCon({
                collectionIndex: 1,
                creator: addr,
                owner: addr
            });
        }
        for (uint256 i = 1; i <= 3; i++) {
            collectionNames[i] = 'initialized';
        }
    }

    function clearCollection(uint256 _collectionIndex) public {
        require(_collectionIndex > 0 && bytes(collectionNames[_collectionIndex]).length > 0, ""Invalid collection index"");

        uint256[] memory tokens = collectionTokens[_collectionIndex];
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 tokenId = tokens[i];
            require(msg.sender == pixelcons[tokenId].creator && msg.sender == pixelcons[tokenId].owner, ""Unauthorized"");
            pixelcons[tokenId].collectionIndex = 0;
        }

        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];

        emit ClearCollection(_collectionIndex);
    }
}"
3163,` proxyPayment ( ) ` allows the caller to send ether to the Campaign but does not create tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyPayment is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable returns (bool) {
        doTakerPayment();
        return true;
    }

    function doTakerPayment() internal virtual;
}",doTakerPayment,"[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'doTakerPayment', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doTakerPayment""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",3.0,0.8767097977732814,0.0365638265951506,"pragma solidity ^0.8.0;

contract PaymentProxy {

    function proxyPayment(address _owner) public payable returns (bool) {
        doTakerPayment(_owner, msg.value);
        return true;
    }

    function doTakerPayment(address _owner, uint256 _amount) internal {
        //Implementation for actual payment logic
        //This is where you would interact with other contracts or perform necessary actions.
        //Example: Transferring funds to the owner.
        payable(_owner).transfer(_amount);
    }
}",41.56003761291504,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentProxy is Ownable {
    function proxyPayment(address _owner) public payable returns (bool) {
        doTakerPayment(_owner, msg.value);
        return true;
    }

    function doTakerPayment(address _owner, uint256 _amount) internal {
        //Implementation for actual payment logic
        //This is where you would interact with other contracts or perform necessary actions.
        //Example: Transferring funds to the owner.
        payable(_owner).transfer(_amount);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables according to the rules provided
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
4854,A constant getter that returns the total number of pledges,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledges {
    using SafeMath for uint256;

    mapping(uint => address) public pledges;

    function numberOfPledges() public view returns (uint) {
        return pledges.length.sub(1);
    }
}",numberOfPledges,"[{'function': 'numberOfPledges', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""numberOfPledges"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.8278837182266148,0.4786471554577889,"pragma solidity ^0.8.0;

contract PledgeContract {
    uint256[] public pledges;

    function numberOfPledges() public view returns (uint256) {
        return pledges.length - 1;
    }
}",41.24604177474976,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PledgeContract is Ownable {
    uint256[] public pledges;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        pledges = [uint256(1)]; // Start with at least one pledge
    }

    function numberOfPledges() public view returns (uint256) {
        return pledges.length - 1;
    }
}"
6206,Returns owner of a given Asset ( Token ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public assetIndexToOwner;

    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        return assetIndexToOwner[_tokenId];
    }
}",ownerOf,"[{'function': 'ownerOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9805593934503104,0.8320381765431424,"pragma solidity ^0.8.0;

contract MyContract {
    mapping(uint256 => address) public assetIndexToOwner;

    function ownerOf(uint256 _tokenId) public view returns (address) {
        return assetIndexToOwner[_tokenId];
    }
}",41.36830425262451,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(uint256 => address) public assetIndexToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            assetIndexToOwner[i] = address(uint160(i + 1e18));
        }
    }

    function ownerOf(uint256 _tokenId) public view returns (address) {
        return assetIndexToOwner[_tokenId];
    }
}"
780,Checks if two strings are equal or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EqualsWrapper {
    using SafeMath for uint256;

    function equals(string memory a, string memory b) internal pure returns (bool result) {
    if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
        return true;
    }
    return false;
}
}",equals,"[{'function': 'equals', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""equals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""a"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""b"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""aHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""a""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""aHash""}, ""right"": {""type"": ""Identifier"", ""name"": ""bHash""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",11.0,0.8143043225949651,0.545047542972306,"pragma solidity ^0.8.0;

contract StringComparator {

    function equals(string memory a, string memory b) public pure returns (bool) {
        bytes32 aHash = keccak256(abi.encodePacked(a));
        bytes32 bHash = keccak256(abi.encodePacked(b));
        return aHash == bHash;
    }
}",41.44740056991577,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract StringComparator is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function equals(string memory a, string memory b) public pure returns (bool) {
        bytes32 aHash = keccak256(abi.encodePacked(a));
        bytes32 bHash = keccak256(abi.encodePacked(b));
        return aHash == bHash;
    }
}"
6276,"The fallback function : If the contract 's controller has not been set to 0 , the ether is sent to the controller ( normally the token creation contract ) using the ` proxyPayment ` method .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function proxyPayment() external payable returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    address public controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    receive() external payable {
        if (controller == address(0)) revert();
        if (isContract(controller)) {
            TokenController tokenController = TokenController(controller);
            require(tokenController.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        } else {
            require(controller.send(msg.value), ""Send value failed"");
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",isContract,"[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'setController', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}]",1.0,{},0.0,1.0,1.0,"pragma solidity ^0.8.0;

interface TokenController {
    function proxyPayment(uint256 _amount, address _sender) external payable returns (bool);
}

contract FallbackReceiver {
    address payable public controller;

    function setController(address payable _controller) public {
        controller = _controller;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }

    fallback() external payable {
        require(controller != address(0), ""Controller not set"");
        if (isContract(controller)) {
            require(TokenController(controller).proxyPayment{value: msg.value}(msg.value, msg.sender), ""Proxy payment failed"");
        } else {
            require(controller.send(msg.value), ""Payment failed"");
        }
    }
}",42.2593035697937,"pragma solidity ^0.8.0;

interface TokenController {
    function proxyPayment(uint256 _amount, address _sender) external payable returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract FallbackReceiver is Ownable {
    address payable public controller;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setController(address payable _controller) public {
        controller = _controller;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }

    fallback() external payable {
        require(controller != address(0), ""Controller not set"");
        if (isContract(controller)) {
            require(TokenController(controller).proxyPayment{value: msg.value}(msg.value, msg.sender), ""Proxy payment failed"");
        } else {
            require(controller.send(msg.value), ""Payment failed"");
        }
    }
}"
321,Function used by the main partner to set the start time of the funding,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function setFundingStartTime(uint _startTime) external onlyOwner {
        // Assuming startTime is stored in a state variable named fundingStartTime
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        fundingStartTime = _startTime;
    }

    uint256 public fundingStartTime;
}",setFundingStartTime,"[{'function': 'setFundingStartTime', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setFundingStartTime"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""fundingStartTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.7490093336582906,0.0422932427105722,"pragma solidity ^0.8.0;

contract FundingContract {

    uint256 public fundingStartTime;

    function setFundingStartTime(uint256 _startTime) external {
        fundingStartTime = _startTime;
    }
}",41.263991355896,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FundingContract is Ownable {
    uint256 public fundingStartTime;

    constructor() Ownable(msg.sender) {
        fundingStartTime = 1; // Set to a non-zero value for safety
    }

    function setFundingStartTime(uint256 _startTime) external {
        fundingStartTime = _startTime;
    }
}"
2712,Only owner is allowed to perform this operation .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function burn(uint256 _value) external;
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;
    uint256 public tokenTotalSupply;

    event Burn(address indexed from, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function burn(uint256 _value) onlyOwner external {
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        tokenTotalSupply = tokenTotalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0x0), _value);
    }
}",burn,"[{'function': 'burn', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.9605723023057364,0.5703981873987225,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn(address indexed burner, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function burn(uint256 _value) public onlyOwner {
        require(_value > 0, ""Value must be greater than 0"");
        require(_value <= balances[msg.sender], ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);

        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0), _value);
    }
}",42.49051380157471,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public balances;
    uint256 public totalSupply = 1000000000000000000;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn(address indexed burner, uint256 value);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        balances[owner] = 1;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function burn(uint256 _value) public onlyOwner {
        require(_value > 0, ""Value must be greater than 0"");
        require(_value <= balances[owner], ""Insufficient balance"");

        balances[owner] = balances[owner].sub(_value);
        totalSupply = totalSupply.sub(_value);

        emit Burn(owner, _value);
        emit Transfer(owner, address(0), _value);
    }
}"
3285,Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC1155Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private _operatorApprovals;

    event ApprovalForAll(address indexed operator, address indexed owner, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != address(0), ""ERC1155: setting approval status for the zero address"");
        require(msg.sender == _operator || isApprovedForAll(msg.sender, _operator), ""ERC1155: must be approved to set approval for all"");

        _operatorApprovals[_operator] = _approved;
        emit ApprovalForAll(_operator, msg.sender, _approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[operator];
    }
}",setApprovalForAll,"[{'function': 'setApprovalForAll', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot approve yourself""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Operator address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operatorApprovals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8987038395096261,0.4457808474061393,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(address => mapping(address => bool)) public operatorApprovals;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != msg.sender, ""Cannot approve yourself"");
        require(_operator != address(0), ""Operator address cannot be zero"");
        operatorApprovals[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}",42.18739581108093,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => mapping(address => bool)) public operatorApprovals;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            if (i == 1) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                // Use fixed values as per the requirement
                operatorApprovals[msg.sender][addr] = true;
            } else {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                // Use fixed values as per the requirement
                operatorApprovals[msg.sender][addr] = false;
            }
        }
    }

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != msg.sender, ""Cannot approve yourself"");
        require(_operator != address(0), ""Operator address cannot be zero"");
        operatorApprovals[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}"
382,"Rent out an area of blocks at coordinates [ fromX , fromY , toX , toY ] at a price for each block in wei","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract RentalArea is Ownable {
    using SafeMath for uint256;

    struct Rental {
        address renter;
        uint rentPricePerPeriodWei;
        uint[] rentedBlocks;
    }

    mapping(uint => Rental) public rentals;
    uint public rentalCount;

    event LogRentsOut(uint id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei);

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (bool) {
        // Implement the logic to check if coordinates are legal
        return true;
    }

    function blocksList(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (uint[] memory) {
        // Implement the logic to generate a list of block IDs based on coordinates
        uint length = (toX - fromX + 1) * (toY - fromY + 1);
        uint[] memory blocks = new uint[](length);
        for (uint i = 0; i < length; i++) {
            blocks[i] = i;
        }
        return blocks;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY));
        uint id = rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, blocksList(fromX, fromY, toX, toY));
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }
}",rentOutArea,"[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'isLegalCoordinates', 'complexity': 0}, {'function': 'rentOutArea', 'complexity': 1}, {'function': 'rentOutBlocks', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""rentOutArea"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""fromX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""fromY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""toX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""toY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""rentPricePerPeriodWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isLegalCoordinates""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fromX""}, {""type"": ""Identifier"", ""name"": ""fromY""}, {""type"": ""Identifier"", ""name"": ""toX""}, {""type"": ""Identifier"", ""name"": ""toY""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Illegal coordinates""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""nextRentalId""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rentals""}, ""memberName"": ""rentOutBlocks""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""rentPricePerPeriodWei""}, {""type"": ""Identifier"", ""name"": ""fromX""}, {""type"": ""Identifier"", ""name"": ""fromY""}, {""type"": ""Identifier"", ""name"": ""toX""}, {""type"": ""Identifier"", ""name"": ""toY""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogRentsOut""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""Identifier"", ""name"": ""fromX""}, {""type"": ""Identifier"", ""name"": ""fromY""}, {""type"": ""Identifier"", ""name"": ""toX""}, {""type"": ""Identifier"", ""name"": ""toY""}, {""type"": ""Identifier"", ""name"": ""rentPricePerPeriodWei""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyWhenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",45.0,0.5785711152508155,0.1671434705753479,"pragma solidity ^0.8.0;

contract YourContract {
    uint256 public nextRentalId = 1;
    bool public paused = false;
    Rentals rentals;

    event LogRentsOut(uint256 id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint256 rentPricePerPeriodWei);

    constructor(address _rentalsAddress) {
        rentals = Rentals(_rentalsAddress);
    }

    modifier onlyWhenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() public {
        paused = true;
    }

    function unpause() public {
        paused = false;
    }


    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) public view virtual returns (bool) {
        // Add your logic to check coordinate validity here.  Example:
        return fromX <= toX && fromY <= toY && fromX >=0 && fromY >=0 && toX <=255 && toY <=255;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint256 rentPricePerPeriodWei) external onlyWhenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY), ""Illegal coordinates"");
        uint256 id = nextRentalId++;
        rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, fromX, fromY, toX, toY);
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }
}

contract Rentals {
    function rentOutBlocks(address renter, uint256 rentPricePerPeriodWei, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) public virtual {
        // Add your logic to rent out blocks here.  This is a placeholder.
    }
}",43.9158890247345,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Rentals {
    function rentOutBlocks(address renter, uint256 rentPricePerPeriodWei, uint8 fromX, uint8 toX, uint8 fromY, uint8 toY) public virtual {
        // Add your logic to rent out blocks here.  This is a placeholder.
    }
}
import ""openzeppelin/SafeMath.sol"";
contract YourContract is Ownable, Rentals {
    uint256 public nextRentalId = 1;
    bool public paused = false;
    Rentals rentals;

    event LogRentsOut(uint256 id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint256 rentPricePerPeriodWei);

    constructor(address _rentalsAddress) Ownable(msg.sender) {
        rentals = Rentals(_rentalsAddress);
    }

    modifier onlyWhenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() public {
        paused = true;
    }

    function unpause() public {
        paused = false;
    }

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) public view virtual returns (bool) {
        // Add your logic to check coordinate validity here.  Example:
        return fromX <= toX && fromY <= toY && fromX >=0 && fromY >=0 && toX <=255 && toY <=255;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint256 rentPricePerPeriodWei) external onlyWhenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY), ""Illegal coordinates"");
        uint256 id = nextRentalId++;
        rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, fromX, fromY, toX, toY);
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }
}"
1424,Allows the owner to revoke the vesting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Basic {
    function balanceOf(address account) external view returns (uint256);
    function safeTransfer(address to, uint256 value) external;
}

abstract contract RevocableToken is Ownable {
    using SafeMath for uint256;

    bool public revocable;
    mapping(ERC20Basic => bool) public revoked;

    event Revoked();

    function revoke(ERC20Basic _token) public onlyOwner {
        require(revocable, ""Revoke: Contract is not revocable"");
        require(!revoked[_token], ""Revoke: Token already revoked"");
        uint256 balance = _token.balanceOf(address(this));
        uint256 unreleased = releasableAmount(_token);
        uint256 refund = balance.sub(unreleased);
        revoked[_token] = true;
        _token.safeTransfer(owner(), refund);
        emit Revoked();
    }

    function releasableAmount(ERC20Basic token) internal view returns (uint256) {
        // Implement your logic to calculate the releasable amount here
        return 0; // Placeholder, replace with actual implementation
    }
}",revoke,"[{'function': 'revoke', 'complexity': 1}, {'function': 'releasableAmount', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""revoke"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20Basic""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""revoked""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""Token already revoked""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""releasable"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""releasableAmount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refundable"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""releasable""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""revoked""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""refundable""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Revoked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""refundable""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8642900664661408,0.450535436671119,"pragma solidity ^0.8.0;

import ""./IERC20Basic.sol""; // Assuming IERC20Basic is defined elsewhere

contract MyContract {
    mapping(address => bool) public revoked;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function revoke(IERC20Basic _token) public onlyOwner {
        require(revoked[_token] == false, ""Token already revoked"");
        uint256 balance = _token.balanceOf(address(this));
        uint256 releasable = releasableAmount(_token); // Assuming releasableAmount function exists
        uint256 refundable = balance - releasable;
        revoked[_token] = true;
        _token.safeTransfer(owner, refundable); // Assuming safeTransfer function exists in IERC20Basic
        emit Revoked(_token, refundable);
    }

    function releasableAmount(IERC20Basic _token) public view returns (uint256) {
        //Implementation for calculating releasable amount
        return 0; // Replace with actual logic
    }


    event Revoked(IERC20Basic indexed token, uint256 amount);
}",42.77574801445007,"pragma solidity ^0.8.0;

import ""./IERC20Basic.sol""; // Assuming IERC20Basic is defined elsewhere
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    mapping(address => bool) public revoked;
    address public owner;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function revoke(IERC20Basic _token) public onlyOwner {
        require(revoked[_token] == false, ""Token already revoked"");
        uint256 balance = _token.balanceOf(address(this));
        uint256 releasable = releasableAmount(_token); // Assuming releasableAmount function exists
        uint256 refundable = balance - releasable;
        revoked[_token] = true;
        _token.safeTransfer(owner, refundable); // Assuming safeTransfer function exists in IERC20Basic
        emit Revoked(_token, refundable);
    }

    function releasableAmount(IERC20Basic _token) public view returns (uint256) {
        //Implementation for calculating releasable amount
        return 0; // Replace with actual logic
    }

    event Revoked(IERC20Basic indexed token, uint256 amount);
}"
4864,Function to send multiple token transfers in one tx,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Multisender is Ownable {
    using SafeMath for uint256;

    uint256 public constant multiSendLimit = 100; // Example limit, adjust as needed

    function multisend(address[] memory _recipients, uint256[] memory _balances) public onlyOwner {
        require(_recipients.length == _balances.length, ""not equal length"");
        require(_recipients.length <= multiSendLimit, ""more than limit"");

        for (uint256 i = 0; i < _balances.length; i++) {
            require(address(this).balance >= _balances[i], ""insufficient balance"");
            payable(_recipients[i]).transfer(_balances[i]);
        }
    }
}",multisend,"[{'function': 'multisend', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""multisend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""length"": None}, ""name"": ""_recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_balances"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Recipients and balances arrays must have the same length.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""multiSendLimit""}}, {""type"": ""stringLiteral"", ""value"": ""Number of recipients exceeds the limit.""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Multisended""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipients""}, {""type"": ""Identifier"", ""name"": ""_balances""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",17.0,0.8893606216447396,0.4787601916354611,"pragma solidity ^0.8.0;

contract MultiSend {

    uint256 public multiSendLimit = 100;

    event Multisended(address[] recipients, uint256[] balances);

    function multisend(address payable[] memory _recipients, uint256[] memory _balances) public payable {
        require(_recipients.length == _balances.length, ""Recipients and balances arrays must have the same length."");
        require(_recipients.length <= multiSendLimit, ""Number of recipients exceeds the limit."");

        for (uint256 i = 0; i < _recipients.length; i++) {
            _recipients[i].transfer(_balances[i]);
        }

        emit Multisended(_recipients, _balances);
    }
}",41.95832848548889,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiSend is Ownable {
    uint256 public multiSendLimit = 100;

    event Multisended(address[] recipients, uint256[] balances);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        multiSendLimit = 100;
    }

    function multisend(address payable[] memory _recipients, uint256[] memory _balances) public payable {
        require(_recipients.length == _balances.length, ""Recipients and balances arrays must have the same length."");
        require(_recipients.length <= multiSendLimit, ""Number of recipients exceeds the limit."");

        for (uint256 i = 0; i < _recipients.length; i++) {
            _recipients[i].transfer(_balances[i]);
        }

        emit Multisended(_recipients, _balances);
    }
}"
5466,The user sends Ether to the pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function() public payable {
        deposit(msg.sender);
    }

    function deposit(address user) internal {
        // Your logic here
    }
}",deposit,"[{'function': 'deposit', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""fallback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposit""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": True, ""isReceive"": False, ""stateMutability"": ""payable""}",0.0,0.7383311701668671,0.0283392961760528,"pragma solidity ^0.8.0;

contract MyContract {

    function deposit(address _sender) internal {
        // Add your deposit logic here.  This is a placeholder.
    }

    fallback() payable external {
        deposit(msg.sender);
    }
}",41.60492396354675,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant _INITIAL_VALUE = 1;
    address public constant _DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant _DEFAULT_BOOL = true;
    string public constant _DEFAULT_STRING = 'initialized';
    bytes32 public constant _DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        uint256 _uintValue = _INITIAL_VALUE;
        address _addressValue = _DEFAULT_ADDRESS;
        bool _boolValue = _DEFAULT_BOOL;
        string _stringValue = _DEFAULT_STRING;
        bytes32 _bytes32Value = _DEFAULT_BYTES32;

        // Initialize state variables
        deposit(_addressValue);
    }

    function deposit(address _sender) internal {
        // Add your deposit logic here.  This is a placeholder.
    }

    fallback() payable external {
        deposit(msg.sender);
    }
}"
906,Create group Can be called only by contract owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GroupManager is Ownable {
    using SafeMath for uint256;

    event GroupCreated(bytes32 indexed groupName);

    struct Group {
        bytes32 name;
        uint priority;
        uint index;
    }

    mapping(bytes32 => uint) public groupName2index;
    mapping(uint => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;
    uint public groupsCount;

    function createGroup(bytes32 _groupName, uint _priority) external onlyOwner returns (uint) {
        require(_groupName != bytes32(0));
        if (isGroupExists(_groupName)) {
            return _emitError(USER_MANAGER_GROUP_ALREADY_EXIST);
        }
        uint _groupsCount = groupsCount.add(1);
        groupName2index[_groupName] = _groupsCount;
        index2groupName[_groupsCount] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, _groupsCount);
        groupsCount = _groupsCount;
        emit GroupCreated(_groupName);
        return OK;
    }

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }

    function _emitError(uint _errorCode) internal pure returns (uint) {
        revert(""Error: ""); // This should be replaced with the actual error handling logic.
    }
}",createGroup,"[{'function': 'isGroupExists', 'complexity': 0}, {'function': 'createGroup', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createGroup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_groupName"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_priority"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_groupName""}, ""right"": {""type"": ""stringLiteral"", ""value"": """"}}, ""TrueBody"": {""type"": ""RevertStatement"", ""functionCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""EmptyGroupName""}, ""arguments"": [], ""names"": []}}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isGroupExists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}], ""names"": []}, ""TrueBody"": {""type"": ""RevertStatement"", ""functionCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""GroupAlreadyExists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}], ""names"": []}}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""groupsCount""}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""groupName2index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_groupName""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""index2groupName""}, ""index"": {""type"": ""Identifier"", ""name"": ""newIndex""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_groupName""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""groupName2group""}, ""index"": {""type"": ""Identifier"", ""name"": ""_groupName""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Group""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}, {""type"": ""Identifier"", ""name"": ""_priority""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""GroupCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.8575906174893391,0.3764562138826912,"pragma solidity ^0.8.0;

contract GroupManager {
    uint256 public groupsCount;
    mapping(bytes32 => uint256) public groupName2index;
    mapping(uint256 => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;

    struct Group {
        bytes32 name;
        uint256 priority;
        uint256 memberCount;
    }

    event GroupCreated(bytes32 groupName);
    error GroupAlreadyExists(bytes32 groupName);
    error EmptyGroupName();


    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }

    function createGroup(bytes32 _groupName, uint256 _priority) public {
        if (_groupName == """") revert EmptyGroupName();
        if (isGroupExists(_groupName)) revert GroupAlreadyExists(_groupName);

        uint256 newIndex = ++groupsCount;
        groupName2index[_groupName] = newIndex;
        index2groupName[newIndex] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, 0);

        emit GroupCreated(_groupName);
    }
}",42.525639295578,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GroupManager is Ownable {
    uint256 public groupsCount = 1;
    mapping(bytes32 => uint256) public groupName2index;
    mapping(uint256 => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;

    struct Group {
        bytes32 name;
        uint256 priority;
        uint256 memberCount;
    }

    event GroupCreated(bytes32 groupName);
    error GroupAlreadyExists(bytes32 groupName);
    error EmptyGroupName();

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function createGroup(bytes32 _groupName, uint256 _priority) public {
        if (_groupName == """") revert EmptyGroupName();
        if (isGroupExists(_groupName)) revert GroupAlreadyExists(_groupName);

        uint256 newIndex = ++groupsCount;
        groupName2index[_groupName] = newIndex;
        index2groupName[newIndex] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, 0);

        emit GroupCreated(_groupName);
    }
}"
1722,Allow users to buy tokens for ` newTokenSaleHardCap ` XCR,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale {
    using SafeMath for uint256;

    uint256 public tokenSaleHardCap;
    address private authorizedAddress;

    constructor(uint256 initialTokenSaleHardCap) {
        tokenSaleHardCap = initialTokenSaleHardCap;
        authorizedAddress = msg.sender;
    }

    modifier onlyAuthorized() {
        require(msg.sender == authorizedAddress, ""Only authorized address can call this function"");
        _;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }
}",setTokenSaleHardCap,"[{'function': 'setTokenSaleHardCap', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTokenSaleHardCap"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newTokenSaleHardCap"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenSaleHardCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""newTokenSaleHardCap""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuthorized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract TokenSale {

    uint256 public tokenSaleHardCap;

    modifier onlyAuthorized() {
        // Add logic to check authorization here.  Example:
        // require(msg.sender == authorizedAddress, ""Not authorized"");
        _;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }
}",41.75160527229309,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for a typical ownership contract like OpenZeppelin's Ownable
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    uint256 public tokenSaleHardCap = 1;

    modifier onlyAuthorized() {
        require(msg.sender == owner(), ""Not authorized""); // Assuming the logic to check authorization here
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is already done in their declarations
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }
}"
3988,Pause sale just in case we have some troubles Note that time marks are not updated,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    enum CampaignState { Initial, Active, Paused }
    CampaignState public campaignState;
    bool public paused;

    event CampaignPaused(uint timestamp);

    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only controller can call this function"");
        _;
    }

    constructor() {
        campaignState = CampaignState.Active;
        paused = false;
        controller = msg.sender;
    }

    function pauseSale() public onlyController {
        require(campaignState == CampaignState.Active, ""Campaign must be active to pause"");
        paused = true;
        campaignState = CampaignState.Paused;
        emit CampaignPaused(block.timestamp);
    }
}",pauseSale,"[{'function': 'pauseSale', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect campaign state""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignPaused""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.7945970141089642,0.5604445590967513,"pragma solidity ^0.8.0;

contract Campaign {

    uint256 public campaignState;
    bool public paused;
    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Not authorized"");
        _;
    }

    event CampaignPaused(uint256 timestamp);

    constructor(address _controller) {
        controller = _controller;
    }

    function pauseSale() public onlyController {
        require(campaignState == 2, ""Incorrect campaign state"");
        paused = true;
        emit CampaignPaused(block.timestamp);
    }
}",41.95782232284546,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    uint256 public campaignState = 1;
    bool public paused = false;
    address public controller = address(uint160(uint256(keccak256('a'))));
    bytes32 private constant INITIALIZED_VALUE = keccak256(""init"");

    modifier onlyController() {
        require(msg.sender == controller, ""Not authorized"");
        _;
    }

    event CampaignPaused(uint256 timestamp);

    constructor(address _controller) Ownable(_controller) {
        if (_controller != address(0)) {
            controller = _controller;
        }
    }

    function pauseSale() public onlyOwner {
        require(campaignState == 2, ""Incorrect campaign state"");
        paused = true;
        emit CampaignPaused(block.timestamp);
    }
}"
4761,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
    }

    function updatePrice() public onlyOwner {
        sellPrice = initialSellPrice.mul(initialSupply).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).div(totalSupply);
    }
}",setInitialValues,"[{'function': 'updatePrice', 'complexity': 0}, {'function': 'setInitialValues', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInitialValues"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_initialSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_initialBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_initialSupply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_totalSupply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""initialSellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_initialSellPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""initialBuyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_initialBuyPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""initialSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_initialSupply""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.6103219356037057,0.0197464821950588,"pragma solidity ^0.8.0;

contract PriceUpdater {

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint256 public sellPrice;
    uint256 public buyPrice;

    function updatePrice() public {
        sellPrice = (initialSellPrice * initialSupply) / totalSupply;
        buyPrice = (initialBuyPrice * initialSupply) / totalSupply;
    }

    function setInitialValues(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint256 _totalSupply) public {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        totalSupply = _totalSupply;
    }
}",42.220738649368286,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceUpdater is Ownable {
    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint256 public sellPrice;
    uint256 public buyPrice;

    constructor() Ownable(msg.sender) {
        initialSellPrice = 1;
        initialBuyPrice = 1;
        initialSupply = 1;
        totalSupply = 1000000000000000000;
    }

    function updatePrice() public {
        sellPrice = (initialSellPrice * initialSupply) / totalSupply;
        buyPrice = (initialBuyPrice * initialSupply) / totalSupply;
    }

    function setInitialValues(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint256 _totalSupply) public {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        totalSupply = _totalSupply;
    }
}"
609,Checks that a given kitten is able to breed ( i.e .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DogBreeding {
    using SafeMath for uint256;

    struct Dog {
        // Define the structure of a dog here
    }

    mapping(uint256 => Dog) public dogs;

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1);
        Dog storage dog = dogs[_dogId];
        return _isReadyToBreed(dog);
    }

    function _isReadyToBreed(Dog storage dog) internal view returns (bool) {
        // Implement the logic to check if a dog is ready to breed here
        // This is just a placeholder for your actual implementation
        return true;
    }
}",_isReadyToBreed,"[{'function': 'isReadyToBreed', 'complexity': 1}, {'function': '_isReadyToBreed', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isReadyToBreed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_dogId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_dogId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid dog ID""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isReadyToBreed""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dogs""}, ""index"": {""type"": ""Identifier"", ""name"": ""_dogId""}}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.6467673937700158,0.1025267180172767,"pragma solidity ^0.8.0;

contract DogBreeding {

    struct Dog {
        // Add relevant dog properties here
    }

    mapping(uint256 => Dog) public dogs;

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1, ""Invalid dog ID"");
        return _isReadyToBreed(dogs[_dogId]);
    }

    function _isReadyToBreed(Dog memory _dog) internal pure returns (bool) {
        // Add your breeding readiness logic here based on _dog properties
        // Example: return _dog.age >= 2 && _dog.healthStatus == ""healthy"";
        return true; // Replace with actual logic
    }
}",41.84676265716553,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DogBreeding is Ownable {
    struct Dog {
        // Add relevant dog properties here
    }

    mapping(uint256 => Dog) public dogs;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        uint256 initialDogId = 1;
        dogs[initialDogId] = Dog({ /* initialize properties here */ });
    }

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1, ""Invalid dog ID"");
        return _isReadyToBreed(dogs[_dogId]);
    }

    function _isReadyToBreed(Dog memory _dog) internal pure returns (bool) {
        // Add your breeding readiness logic here based on _dog properties
        // Example: return _dog.age >= 2 && _dog.healthStatus == ""healthy"";
        return true; // Replace with actual logic
    }
}"
4790,Approve the passed address to spend the specified amount of tokens on behalf of msg.sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(0 == value || 0 == allowance(msg.sender, spender));
        allowance[msg.sender][spender] = value;
        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve from non-zero to non-zero allowance""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.8003570718709081,0.4072238199292497,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function approve(address spender, uint256 value) public virtual override returns (bool) {
        require(value == 0 || allowance(msg.sender, spender) == 0, ""ERC20: approve from non-zero to non-zero allowance"");
        return super.approve(spender, value);
    }
}",41.744351387023926,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1 * 10 ** uint256(decimals())); // Initialize total supply to 1 token
    }

    function approve(address spender, uint256 value) public virtual override returns (bool) {
        require(value == 0 || allowance(msg.sender, spender) == 0, ""ERC20: approve from non-zero to non-zero allowance"");
        return super.approve(spender, value);
    }
}"
4695,A participant 's contribution will be rejected if the Private Sale has been funded to the maximum amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PrivateSale {
    using SafeMath for uint256;

    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 1 ether;
    uint256 public constant PRIVATESALE_START_DATE = 1672502400; // Example start date, replace with actual value
    uint256 public constant PRIVATESALE_END_DATE = 1675180800;   // Example end date, replace with actual value

    mapping(address => uint256) private balances;

    function addBalance() public payable {
        require(now >= PRIVATESALE_START_DATE && now <= PRIVATESALE_END_DATE, ""Private sale period not active"");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Minimum participation amount not met"");
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
}",participate,"[{'function': 'addBalance', 'complexity': 0}, {'function': 'participate', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""participate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRIVATESALE_START_DATE""}}, {""type"": ""stringLiteral"", ""value"": ""Private sale has not started yet.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRIVATESALE_END_DATE""}}, {""type"": ""stringLiteral"", ""value"": ""Private sale has ended.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""MINIMUM_PARTICIPATION_AMOUNT""}}, {""type"": ""stringLiteral"", ""value"": ""Amount less than minimum participation amount.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addBalance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",14.0,0.7981603005194635,0.3652807917722636,"pragma solidity ^0.8.0;

contract PrivateSale {

    uint256 public PRIVATESALE_START_DATE;
    uint256 public PRIVATESALE_END_DATE;
    uint256 public MINIMUM_PARTICIPATION_AMOUNT;

    mapping(address => uint256) public balances;

    function addBalance(address _address, uint256 _amount) internal {
        balances[_address] += _amount;
    }

    function participate() public payable {
        require(block.timestamp >= PRIVATESALE_START_DATE, ""Private sale has not started yet."");
        require(block.timestamp <= PRIVATESALE_END_DATE, ""Private sale has ended."");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Amount less than minimum participation amount."");
        addBalance(msg.sender, msg.value);
    }
}",42.37213110923767,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PrivateSale is Ownable {
    uint256 public constant PRIVATESALE_START_DATE = 1; // Set to a fixed value never zero
    uint256 public constant PRIVATESALE_END_DATE = 2; // Set to a fixed value never zero
    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 0.1 ether; // Set to a fixed value not zero

    mapping(address => uint256) public balances;

    function addBalance(address _address, uint256 _amount) internal {
        balances[_address] += _amount;
    }

    function participate() public payable {
        require(block.timestamp >= PRIVATESALE_START_DATE, ""Private sale has not started yet."");
        require(block.timestamp <= PRIVATESALE_END_DATE, ""Private sale has ended."");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Amount less than minimum participation amount."");
        addBalance(msg.sender, msg.value);
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already initialized with fixed values
    }
}"
2989,Get a description of the validator at account ` validator ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorWrapper is Ownable {
    using SafeMath for uint256;

    function getValidatorInformation(address validator) external view returns (string memory description) {
        // Your formatting logic goes here
        return ""Your formatting logic should be placed here."";
    }
}",getValidatorDescription,"[{'function': 'getValidatorDescription', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValidatorDescription"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""description"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validatorDescriptions""}, ""index"": {""type"": ""Identifier"", ""name"": ""validator""}}}, {""type"": ""Identifier"", ""name"": ""description""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.7750007971851313,0.2384349468249443,"pragma solidity ^0.8.0;

contract ValidatorRegistry {

    mapping(address => string) public validatorDescriptions;

    function getValidatorDescription(address validator) public view returns (string memory) {
        string memory description = validatorDescriptions[validator];
        return description;
    }
}",41.46486687660217,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ValidatorRegistry is Ownable {
    mapping(address => string) public validatorDescriptions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            validatorDescriptions[addr] = ""initialized"";
        }
    }

    function getValidatorDescription(address validator) public view returns (string memory) {
        string memory description = validatorDescriptions[validator];
        return description;
    }
}"
4597,Returns how many pixels has been already set .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasStorage {
    using SafeMath for uint256;

    struct Canvas {
        uint32 paintedPixelsCount;
    }

    mapping(uint32 => Canvas) private canvases;

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas storage) {
        return canvases[_canvasId];
    }
}

abstract contract CanvasManager is Ownable, CanvasStorage {
    using SafeMath for uint256;

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
        return _getCanvas(_canvasId).paintedPixelsCount;
    }
}",_getCanvas,"[{'function': '_getCanvas', 'complexity': 1}, {'function': 'getCanvasPaintedPixelsCount', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""_getCanvas"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Canvas""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}, ""memberName"": ""paintedPixelsCount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Canvas not found""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",10.0,0.7352411908856313,0.3293801932218855,"pragma solidity ^0.8.0;

contract CanvasContract {

    struct Canvas {
        uint32 paintedPixelsCount;
        // other canvas properties...
    }

    mapping(uint32 => Canvas) private canvases;

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas memory) {
        require(canvases[_canvasId].paintedPixelsCount != 0, ""Canvas not found""); //Example check.  More robust checks may be needed.
        return canvases[_canvasId];
    }


    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
        Canvas memory canvas = _getCanvas(_canvasId);
        return canvas.paintedPixelsCount;
    }
}",41.87297320365906,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CanvasContract is Ownable {
    struct Canvas {
        uint32 paintedPixelsCount;
        // other canvas properties...
    }

    mapping(uint32 => Canvas) private canvases;

    constructor() Ownable(msg.sender) {
        for (uint32 i = 1; i <= 3; i++) {
            canvases[i] = Canvas({paintedPixelsCount: uint32(i)});
        }
    }

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas memory) {
        require(canvases[_canvasId].paintedPixelsCount != 0, ""Canvas not found""); //Example check.  More robust checks may be needed.
        return canvases[_canvasId];
    }

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
        Canvas memory canvas = _getCanvas(_canvasId);
        return canvas.paintedPixelsCount;
    }
}"
1962,Get value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract StorageWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint256) private uIntStorage;

    function getUint(bytes32 _key) public view returns (uint256 _value) {
        return uIntStorage[_key];
    }
}",getUint,"[{'function': 'getUint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getUint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""uIntStorage""}, ""index"": {""type"": ""Identifier"", ""name"": ""_key""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",3.0,0.9230805768423525,0.6268593335004975,"pragma solidity ^0.8.0;

contract UintStorage {

    mapping(bytes32 => uint) uIntStorage;

    function getUint(bytes32 _key) public view returns (uint _value) {
        _value = uIntStorage[_key];
    }
}",41.428812980651855,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract UintStorage is Ownable {
    mapping(bytes32 => uint) private uIntStorage;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uIntStorage['init'] = 1;
    }

    function getUint(bytes32 _key) public view returns (uint _value) {
        _value = uIntStorage[_key];
    }
}"
629,"Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGrant {
    function tokenGrants(uint256 _grantId) external view returns (Grant memory);
}

struct Grant {
    uint256 amount;
    uint256 startTime;
    uint256 vestingCliff;
    uint256 vestingDuration;
    uint256 totalClaimed;
    uint256 daysClaimed;
}

abstract contract GrantCalculator {
    using SafeMath for uint256;

    IGrant public grantContract;

    constructor(address _grantAddress) {
        grantContract = IGrant(_grantAddress);
    }

    function currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory tokenGrant = grantContract.tokenGrants(_grantId);
        if (currentTime() < tokenGrant.startTime) {
            return (0, 0);
        }
        uint256 elapsedTime = currentTime().sub(tokenGrant.startTime);
        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);
        if (elapsedDays < tokenGrant.vestingCliff) {
            return (elapsedDays, 0);
        }
        if (elapsedDays >= tokenGrant.vestingDuration) {
            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);
            return (tokenGrant.vestingDuration, remainingGrant);
        } else {
            uint256 daysVested = elapsedDays.sub(tokenGrant.daysClaimed);
            uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));
            uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));
            return (daysVested, amountVested);
        }
    }
}",calculateGrantClaim,"[{'function': 'calculateGrantClaim', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateGrantClaim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_grantId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""grant"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenGrants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_grantId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""currentTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""startTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedDays"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""currentTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""startTime""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""SECONDS_PER_DAY""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedDays""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingCliff""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""elapsedDays""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedDays""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingDuration""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainingGrant"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalClaimed""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingDuration""}, {""type"": ""Identifier"", ""name"": ""remainingGrant""}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""dailyVestedAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingDuration""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountVested"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""dailyVestedAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""elapsedDays""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""elapsedDays""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",35.0,0.7584213503641142,0.3946982367856791,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract GrantCalculator {
    uint256 public constant SECONDS_PER_DAY = 86400;

    struct Grant {
        uint256 startTime;
        uint256 vestingCliff;
        uint256 vestingDuration;
        uint256 amount;
        uint256 totalClaimed;
    }

    mapping(uint256 => Grant) public tokenGrants;

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory grant = tokenGrants[_grantId];
        uint256 currentTime = block.timestamp;

        if (currentTime < grant.startTime) {
            return (0, 0);
        }

        uint256 elapsedDays = (currentTime - grant.startTime) / SECONDS_PER_DAY;

        if (elapsedDays < grant.vestingCliff) {
            return (elapsedDays, 0);
        }

        if (elapsedDays >= grant.vestingDuration) {
            uint256 remainingGrant = grant.amount - grant.totalClaimed;
            return (grant.vestingDuration, remainingGrant);
        }

        uint256 dailyVestedAmount = grant.amount / grant.vestingDuration;
        uint256 amountVested = dailyVestedAmount * elapsedDays;
        return (elapsedDays, amountVested);
    }
}",43.41850709915161,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract GrantCalculator is Ownable {
    using SafeMath for uint256;

    uint256 public constant SECONDS_PER_DAY = 86400;

    struct Grant {
        uint256 startTime;
        uint256 vestingCliff;
        uint256 vestingDuration;
        uint256 amount;
        uint256 totalClaimed;
    }

    mapping(uint256 => Grant) public tokenGrants;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        SECONDS_PER_DAY = 86400;
    }

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory grant = tokenGrants[_grantId];
        uint256 currentTime = block.timestamp;

        if (currentTime < grant.startTime) {
            return (0, 0);
        }

        uint256 elapsedDays = (currentTime - grant.startTime) / SECONDS_PER_DAY;

        if (elapsedDays < grant.vestingCliff) {
            return (elapsedDays, 0);
        }

        if (elapsedDays >= grant.vestingDuration) {
            uint256 remainingGrant = grant.amount - grant.totalClaimed;
            return (grant.vestingDuration, remainingGrant);
        }

        uint256 dailyVestedAmount = grant.amount / grant.vestingDuration;
        uint256 amountVested = dailyVestedAmount * elapsedDays;
        return (elapsedDays, amountVested);
    }
}"
4567,Called by the ModuleFactory owner to register new modules for SecurityTokens to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeatureRegistry {
    function getFeatureStatus(string memory feature) external view returns (bool);
}

interface IOwnable {
    function owner() external view returns (address);
}

interface IModuleFactory {
    function getTypes() external pure returns (uint8[] memory);
}

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => mapping(address => uint256)) private registry;
    mapping(uint256 => address[]) private moduleList;

    event ModuleRegistered(address indexed moduleFactory, address owner);

    function getAddress(bytes32 key) internal pure returns (address addr) {
        assembly {
            addr := shr(96, calldataload(add(key, 0x20)))
        }
    }

    function getUint(bytes32 key) internal pure returns (uint256 value) {
        assembly {
            value := calldataload(add(key, 0x20))
        }
    }

    function set(bytes32 key, uint256 value) internal {
        bytes memory data = abi.encodePacked(value);
        for (uint256 i = 0; i < data.length; i++) {
            assembly {
                mstore8(add(key, add(0x20, i)), data[i])
            }
        }
    }

    function getArrayAddress(bytes32 key) internal pure returns (address[] memory array) {
        assembly {
            array := calldataload(add(key, 0x20))
        }
    }

    function pushArray(bytes32 key, address value) internal {
        uint256 length;
        assembly {
            length := sload(key)
            sstore(add(key, 0x20), add(length, 1))
            mstore(0, value)
            sstore(add(key, mul(length, 32)), value)
        }
    }

    function registerModule(address _moduleFactory) external whenNotPausedOrOwner {
        if (IFeatureRegistry(getAddress(Encoder.getKey(""featureRegistry""))).getFeatureStatus(""customModulesAllowed"")) {
            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(), ""msg.sender must be the Module Factory owner or registry curator"");
        } else {
            require(msg.sender == owner(), ""Only owner allowed to register modules"");
        }
        require(getUint(Encoder.getKey(""registry"", _moduleFactory)) == 0, ""Module factory should not be pre-registered"");
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint256 i;
        uint256 j;
        uint8[] memory moduleTypes = moduleFactory.getTypes();
        for (i = 1; i < moduleTypes.length; i++) {
            for (j = 0; j < i; j++) {
                require(moduleTypes[i] != moduleTypes[j], ""Type mismatch"");
            }
        }
        require(moduleTypes.length != 0, ""Factory must have type"");
        uint8 moduleType = moduleFactory.getTypes()[0];
        set(Encoder.getKey(""registry"", _moduleFactory), uint256(moduleType));
        set(Encoder.getKey(""moduleListIndex"", _moduleFactory), uint256(getArrayAddress(Encoder.getKey(""moduleList"", uint256(moduleType))).length));
        pushArray(Encoder.getKey(""moduleList"", uint256(moduleType)), _moduleFactory);
        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}",registerModuleFactory,"[{'function': 'owner', 'complexity': 0}, {'function': 'isFeatureEnabled', 'complexity': 0}, {'function': 'getSupportedModuleTypes', 'complexity': 0}, {'function': 'registerModuleFactory', 'complexity': 7}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModuleFactory"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleFactory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Module factory cannot be zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""customModulesAllowed"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""featureRegistry""}, ""memberName"": ""isFeatureEnabled""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""customModulesAllowed""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""customModulesAllowed""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IOwnable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}, ""memberName"": ""owner""}, ""arguments"": [], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""curator""}}}, {""type"": ""stringLiteral"", ""value"": ""Unauthorized""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Unauthorized""}], ""names"": []}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""moduleFactoryRegistry""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Module factory already registered""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IModuleFactory""}, ""name"": ""moduleFactory"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IModuleFactory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": ""supportedTypes"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""moduleFactory""}, ""memberName"": ""getSupportedModuleTypes""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""supportedTypes""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Module factory must support at least one module type""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""primaryType"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""supportedTypes""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""moduleFactoryRegistry""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}}, ""right"": {""type"": ""Identifier"", ""name"": ""primaryType""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""moduleList""}, ""index"": {""type"": ""Identifier"", ""name"": ""primaryType""}}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""moduleListIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""primaryType""}}}, ""right"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""moduleListIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""primaryType""}}, ""isPrefix"": False}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModuleRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IOwnable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}, ""memberName"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",84.0,0.7065414406994635,0.2249544353106373,"pragma solidity ^0.8.0;

interface IOwnable {
    function owner() external view returns (address);
}

interface IFeatureRegistry {
    function isFeatureEnabled(bytes32 featureId) external view returns (bool);
}

interface IModuleFactory {
    function getSupportedModuleTypes() external view returns (bytes32[] memory);
}


contract ModuleRegistry {
    IFeatureRegistry public featureRegistry;
    address public owner;
    address public curator;

    mapping(bytes32 => mapping(uint256 => address)) public moduleList;
    mapping(bytes32 => uint256) public moduleListIndex;
    mapping(address => bytes32) public moduleFactoryRegistry;


    event ModuleRegistered(address indexed moduleFactory, address indexed owner);

    constructor(address _featureRegistry, address _owner, address _curator) {
        featureRegistry = IFeatureRegistry(_featureRegistry);
        owner = _owner;
        curator = _curator;
    }

    function registerModuleFactory(address _moduleFactory) public {
        require(_moduleFactory != address(0), ""Module factory cannot be zero address"");

        bool customModulesAllowed = featureRegistry.isFeatureEnabled(""customModulesAllowed"");
        if (customModulesAllowed) {
            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == curator, ""Unauthorized"");
        } else {
            require(msg.sender == owner, ""Unauthorized"");
        }

        require(moduleFactoryRegistry[_moduleFactory] == bytes32(0), ""Module factory already registered"");

        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        bytes32[] memory supportedTypes = moduleFactory.getSupportedModuleTypes();
        require(supportedTypes.length > 0, ""Module factory must support at least one module type"");

        bytes32 primaryType = supportedTypes[0];
        moduleFactoryRegistry[_moduleFactory] = primaryType;
        moduleList[primaryType][moduleListIndex[primaryType]] = _moduleFactory;
        moduleListIndex[primaryType]++;

        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}",44.23612189292908,"pragma solidity ^0.8.0;

interface IOwnable {
    function owner() external view returns (address);
}

interface IFeatureRegistry {
    function isFeatureEnabled(bytes32 featureId) external view returns (bool);
}

interface IModuleFactory {
    function getSupportedModuleTypes() external view returns (bytes32[] memory);
}
import ""openzeppelin/SafeMath.sol"";
contract ModuleRegistry {
    IFeatureRegistry public featureRegistry;
    address public owner;
    address public curator;

    mapping(bytes32 => mapping(uint256 => address)) public moduleList;
    mapping(bytes32 => uint256) public moduleListIndex;
    mapping(address => bytes32) public moduleFactoryRegistry;

    event ModuleRegistered(address indexed moduleFactory, address indexed owner);

    constructor(address _featureRegistry, address _owner, address _curator) {
        require(_featureRegistry != address(0), ""Invalid feature registry address"");
        require(_owner != address(0), ""Invalid owner address"");
        require(_curator != address(0), ""Invalid curator address"");

        featureRegistry = IFeatureRegistry(_featureRegistry);
        owner = _owner;
        curator = _curator;
    }

    function registerModuleFactory(address _moduleFactory) public {
        require(_moduleFactory != address(0), ""Module factory cannot be zero address"");

        bool customModulesAllowed = featureRegistry.isFeatureEnabled(""customModulesAllowed"");
        if (customModulesAllowed) {
            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == curator, ""Unauthorized"");
        } else {
            require(msg.sender == owner, ""Unauthorized"");
        }

        require(moduleFactoryRegistry[_moduleFactory] == bytes32(0), ""Module factory already registered"");

        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        bytes32[] memory supportedTypes = moduleFactory.getSupportedModuleTypes();
        require(supportedTypes.length > 0, ""Module factory must support at least one module type"");

        bytes32 primaryType = supportedTypes[0];
        moduleFactoryRegistry[_moduleFactory] = primaryType;
        moduleList[primaryType][moduleListIndex[primaryType]] = _moduleFactory;
        moduleListIndex[primaryType]++;

        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}"
2433,Total hash rate of a miner in a halving,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Miner {
    using SafeMath for uint256;
    mapping(uint256 => MinerHashRate) public hashRate;
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;
    struct MinerHashRate {
        uint256 rate;
        bool carried;
    }

    mapping(address => Miner) public miners;

    function getMinerHalving() public pure returns (uint256) {
        // This should be implemented in the actual contract.
        return 0; // Placeholder for actual implementation.
    }

    function getMinerHalvingHashRateOf(address _miner) public view returns (uint256) {
        require(block.number >= block.timestamp, ""Not before genesis"");
        Miner miner = miners[_miner];
        uint256 halving = getMinerHalving();
        MinerHashRate memory hashRate = miner.hashRate[halving];
        if (halving == 0) {
            return hashRate.rate;
        } else {
            if (!hashRate.carried) {
                return hashRate.rate.add(miner.hashRate[halving - 1].rate);
            } else {
                return hashRate.rate;
            }
        }
    }
}",getMinHashRate,"[{'function': 'getMinHashRate', 'complexity': 5}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMinHashRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_miner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""halving"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getMinerHalving""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_miner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Miner""}, ""name"": ""miner"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_miner""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentHashRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""Identifier"", ""name"": ""halving""}}, ""memberName"": ""rate""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""halving""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""currentHashRate""}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""Identifier"", ""name"": ""halving""}}, ""memberName"": ""carried""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""currentHashRate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""halving""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""memberName"": ""rate""}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""currentHashRate""}]}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""notBeforeGenesis"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""isMiner"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_miner""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",22.0,0.9084250855938816,0.4151072493081303,"pragma solidity ^0.8.0;

contract MiningContract {

    // Define necessary structs and modifiers here...  (This part is omitted as it's not provided in the context)

    function getMinHashRate(address _miner) public view notBeforeGenesis isMiner(_miner) returns (uint256) {
        uint256 halving = getMinerHalving(_miner);
        Miner storage miner = miners[_miner];
        uint256 currentHashRate = miner.hashRate[halving].rate;

        if (halving == 0) {
            return currentHashRate;
        } else {
            if (!miner.hashRate[halving].carried) {
                return currentHashRate + miner.hashRate[halving - 1].rate;
            } else {
                return currentHashRate;
            }
        }
    }

    // ... other functions and structs ...
}",42.099411725997925,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MiningContract is Ownable {
    // Define necessary structs and modifiers here...

    uint256 public constant MIN_HRS = 1;
    address public constant DEFAULT_MINER = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_INIT = true;
    bytes32 public constant DEFAULT_INIT_BYTES = bytes32('init');
    string public constant DEFAULT_TOKEN_NAME = 'MyToken';
    uint256 public constant DEFAULT_TOKEN_SYMBOL = 'TKN';

    constructor() Ownable(msg.sender) {
        miners[msg.sender] = Miner(
            halving[0].rate: MIN_HRS,
            halving[1].rate: 0, // Initialize with default value
            carried: false,
            previousRate: 0 // Initialize with default value
        );
    }

    struct Halving {
        uint256 rate;
        bool carried;
        uint256 previousRate;
    };

    mapping(address => Miner) public miners;

    function getMinHashRate(address _miner) public view notBeforeGenesis isMiner(_miner) returns (uint256) {
        uint256 halving = getMinerHalving(_miner);
        Miner storage miner = miners[_miner];
        uint256 currentHashRate = miner.hashRate[halving].rate;

        if (halving == 0) {
            return currentHashRate;
        } else {
            if (!miner.hashRate[halving].carried) {
                return currentHashRate + miner.hashRate[halving - 1].rate;
            } else {
                return currentHashRate;
            }
        }
    }

    // ... other functions and structs ...
}"
915,"Get the budget avaliable of a campaign Based on the Campaign id , return the total value avaliable to pay for proofs of attention .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Campaign {
    function getBudget() external view returns (uint);
}

abstract contract CampaignRegistry is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => address) public campaigns;

    function setCampaign(bytes32 bidId, address campaignAddress) public onlyOwner {
        campaigns[bidId] = campaignAddress;
    }

    function getCampaignBudgetById(bytes32 bidId) public view returns (uint budget) {
        return Campaign(campaigns[bidId]).getBudget();
    }
}",getCampaignBudget,"[{'function': 'getCampaignBudget', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCampaignBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}, ""memberName"": ""budget""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.7547164179053073,0.0860958371038403,"pragma solidity ^0.8.0;

contract CampaignContract {

    mapping(bytes32 => Campaign) public campaigns;

    struct Campaign {
        uint256 budget;
        // other campaign details...
    }

    function getCampaignBudget(bytes32 bidId) public view returns (uint256) {
        return campaigns[bidId].budget;
    }
}",42.348074197769165,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CampaignContract is Ownable {
    mapping(bytes32 => Campaign) public campaigns;

    struct Campaign {
        uint256 budget;
        // other campaign details...
    }

    constructor() Ownable(msg.sender) {
        for (uint256 i = 1; i <= 3; i++) {
            bytes32 bidId = keccak256(abi.encodePacked(""campaign"", i));
            campaigns[bidId] = Campaign({budget: uint256(i)});
        }
    }

    function getCampaignBudget(bytes32 bidId) public view returns (uint256) {
        return campaigns[bidId].budget;
    }
}"
2907,Sets the ICO Contract Address variable to be used with the ` onlyIcoContract ` modifier .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public freezeBypassing;
    address public icoContractAddress;

    function setIcoContractAddress(address contractAddress) public onlyOwner {
    freezeBypassing[contractAddress] = true;
    icoContractAddress = contractAddress;
}
}",setIcoContractAddress,"[{'function': 'setIcoContractAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcoContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""freezeBypassing""}, ""index"": {""type"": ""Identifier"", ""name"": ""contractAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoContractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""contractAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract MyContract {
    address public icoContractAddress;
    mapping(address => bool) public freezeBypassing;
    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setIcoContractAddress(address contractAddress) public onlyOwner {
        freezeBypassing[contractAddress] = true;
        icoContractAddress = contractAddress;
    }
}",41.77972626686096,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public icoContractAddress;
    mapping(address => bool) public freezeBypassing;

    constructor() Ownable(msg.sender) {
        icoContractAddress = msg.sender; // Initialize to owner's address
        freezeBypassing[msg.sender] = true; // Freeze the owner by default
    }

    function setIcoContractAddress(address contractAddress) public onlyOwner {
        require(contractAddress != address(0), ""Invalid contract address"");
        freezeBypassing[contractAddress] = true;
        icoContractAddress = contractAddress;
    }
}"
5542,Enables the owner of a parcel to update the data field,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LandInterface {
    function decodeTokenId(uint256 tokenId) external pure returns (int256 x, int256 y);
    function updateLandData(int256 x, int256 y, string memory data) external;
}

abstract contract LandWrapper is Ownable {
    using SafeMath for uint256;

    struct Mortgage {
        uint256 landId;
    }

    mapping(uint256 => Mortgage) public mortgages;
    LandInterface public land;

    event UpdatedLandData(address indexed sender, uint256 id, string data);

    constructor(address _landAddress) {
        land = LandInterface(_landAddress);
    }

    function updateLandData(uint256 id, string memory data) external onlyOwner returns (bool) {
        require(_isAuthorized(msg.sender, id), ""Sender not authorized"");
        (int256 x, int256 y) = land.decodeTokenId(mortgages[id].landId);
        land.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
        return true;
    }

    function _isAuthorized(address sender, uint256 id) internal view returns (bool) {
        // Implement your authorization logic here
        return owner() == sender || mortgages[id].landId != 0;
    }
}",updateLandData,"[{'function': 'decodeTokenId', 'complexity': 0}, {'function': 'updateLandData', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateLandData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""x"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112feb8c0>}, {""type"": ""VariableDeclaration"", ""name"": ""y"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112fe9e10>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""landContract""}, ""memberName"": ""decodeTokenId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""landContract""}, ""memberName"": ""updateLandData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""x""}, {""type"": ""Identifier"", ""name"": ""y""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpdatedLandData""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuthorized"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.8013398427821774,0.3985873403109365,"pragma solidity ^0.8.0;

interface Land {
    function updateLandData(uint256 x, uint256 y, string calldata data) external;
    function decodeTokenId(uint256 tokenId) external view returns (uint256 x, uint256 y);
}

contract Mortgage {
    event UpdatedLandData(address indexed sender, uint256 indexed id, string data);

    Land public landContract;

    constructor(address _landContractAddress) {
        landContract = Land(_landContractAddress);
    }


    modifier onlyAuthorized(uint256 id) {
        // Replace this with your actual authorization logic.  This is a placeholder.
        require(msg.sender == address(0x123), ""Sender not authorized"");
        _;
    }

    function updateLandData(uint256 id, string calldata data) public onlyAuthorized(id) {
        (uint256 x, uint256 y) = landContract.decodeTokenId(id);
        landContract.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
    }
}",42.49727129936218,"pragma solidity ^0.8.0;

interface Land {
    function updateLandData(uint256 x, uint256 y, string calldata data) external;
    function decodeTokenId(uint256 tokenId) external view returns (uint256 x, uint256 y);
}
import ""openzeppelin/SafeMath.sol"";
contract Mortgage {
    event UpdatedLandData(address indexed sender, uint256 indexed id, string data);

    Land public landContract;

    constructor(address _landContractAddress) {
        require(_landContractAddress != address(0), ""Invalid contract address"");
        landContract = Land(_landContractAddress);
    }

    modifier onlyAuthorized(uint256 id) {
        // Replace this with your actual authorization logic.  This is a placeholder.
        require(msg.sender == address(0x123), ""Sender not authorized"");
        _;
    }

    function updateLandData(uint256 id, string calldata data) public onlyAuthorized(id) {
        (uint256 x, uint256 y) = landContract.decodeTokenId(id);
        landContract.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
    }
}"
6660,"Set the `` approved taker '' for your deed , or revoke approval by setting the zero address .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function approve(address _to, uint256 _deedId) external payable {
        // Function body
    }
}",approve,"[{'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_deedId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""owners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}}, {""type"": ""stringLiteral"", ""value"": ""Not the owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_deedId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",30.0,0.4006624806791733,0.3001800600660342,"pragma solidity ^0.8.0;

contract DeedApprovals {

    mapping(uint256 => address) public owners;
    mapping(uint256 => address) public approvals;

    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);

    function approve(address _to, uint256 _deedId) external payable {
        require(msg.sender == owners[_deedId], ""Not the owner"");
        approvals[_deedId] = _to;
        emit Approval(msg.sender, _to, _deedId);
    }
}",41.85754370689392,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract DeedApprovals is Ownable {

    mapping(uint256 => address) public owners;
    mapping(uint256 => address) public approvals;

    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            owners[i] = address(uint160(uint256(keccak256(abi.encodePacked('owner', i)))));
            approvals[i] = address(uint160(uint256(keccak256(abi.encodePacked('approval', i)))));
        }
    }

    function approve(address _to, uint256 _deedId) external payable {
        require(msg.sender == owners[_deedId], ""Not the owner"");
        approvals[_deedId] = _to;
        emit Approval(msg.sender, _to, _deedId);
    }
}"
2749,"Set budget for ` _token.symbol ( ) : string ` to ` @ tokenAmount ( _token , _amount , false ) ` , effective immediately","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BudgetSetter is Ownable {
    using SafeMath for uint256;

    struct Settings {
        mapping(address => uint256) budgets;
        mapping(address => bool) hasBudget;
    }

    Settings private settings;

    event SetBudget(address indexed token, uint256 amount, bool indexed success);

    modifier authP(bytes32 role, bytes memory data) {
        require(hasRole(role, msg.sender), ""Unauthorized"");
        _;
    }

    function setBudget(address _token, uint256 _amount) external authP(keccak256(""CHANGE_BUDGETS_ROLE""), abi.encodePacked(_token, _amount, settings.budgets[_token], settings.hasBudget[_token] ? 1 : 0)) {
        require(_amount > 0, ""Amount must be greater than zero"");

        if (!settings.hasBudget[_token]) {
            settings.hasBudget[_token] = true;
        }

        settings.budgets[_token] = _amount;
        emit SetBudget(_token, _amount, true);
    }
}",setBudget,"[{'function': 'setBudget', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""budgetCreated"", ""storageLocation"": None}], ""initialValue"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""hasBudget""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""isPrefix"": True}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""budgetCreated""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""hasBudget""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""budgets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetBudget""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""budgetCreated""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""authP"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.7501944486791654,0.3550863980598321,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract BudgetSetter is AccessControl {
    bytes32 public constant CHANGE_BUDGETS_ROLE = keccak256(""CHANGE_BUDGETS_ROLE"");

    struct BudgetSettings {
        mapping(address => bool) hasBudget;
        mapping(address => uint256) budgets;
    }

    BudgetSettings public settings;

    modifier authP(address _token, uint256 _amount) {
        //  Add your authP logic here.  This is placeholder logic.  Replace with your actual logic.
        require(hasRole(CHANGE_BUDGETS_ROLE, msg.sender), ""Unauthorized"");
        _;
    }


    event SetBudget(address indexed token, uint256 amount, bool budgetCreated);

    function setBudget(address _token, uint256 _amount) public authP(_token, _amount) {
        bool budgetCreated = !settings.hasBudget[_token];
        if (budgetCreated) {
            settings.hasBudget[_token] = true;
        }
        settings.budgets[_token] = _amount;
        emit SetBudget(_token, _amount, budgetCreated);
    }
}",42.70338106155396,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BudgetSetter is AccessControl, Ownable {
    bytes32 public constant CHANGE_BUDGETS_ROLE = keccak256(""CHANGE_BUDGETS_ROLE"");

    struct BudgetSettings {
        mapping(address => bool) hasBudget;
        mapping(address => uint256) budgets;
    }

    BudgetSettings public settings;

    modifier authP(address _token, uint256 _amount) {
        require(hasRole(CHANGE_BUDGETS_ROLE, msg.sender), ""Unauthorized"");
        _;
    }

    event SetBudget(address indexed token, uint256 amount, bool budgetCreated);

    constructor() Ownable(msg.sender) {
        // Initialize roles and settings with safe non-corner-case values
        bytes32 role = keccak256(""CHANGE_BUDGETS_ROLE"");
        _setupRole(role, msg.sender);

        // Initialize the rest of the state variables
        settings.hasBudget[_msgSender()] = true; // Use owner as an initial token with budget
        settings.budgets[_msgSender()] = 1; // Initial budget amount
    }

    function setBudget(address _token, uint256 _amount) public authP(_token, _amount) {
        bool budgetCreated = !settings.hasBudget[_token];
        if (budgetCreated) {
            settings.hasBudget[_token] = true;
        }
        settings.budgets[_token] = _amount;
        emit SetBudget(_token, _amount, budgetCreated);
    }
}"
5294,"Only to be used when this contract is significantly broken , and an upgrade is required .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public upgradedContractAddress;

    event ContractUpgrade(address indexed newContractAddress);

    function setUpgradedContractAddress(address _upgradedContractAddress) external onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }
}",setUpgradedContractAddress,"[{'function': 'setUpgradedContractAddress', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUpgradedContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_upgradedContractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradedContractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_upgradedContractAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ContractUpgrade""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradedContractAddress""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.982094490101554,0.8578928092681435,"pragma solidity ^0.8.0;

contract MyContract {

    address public upgradedContractAddress;
    address public owner;
    bool public paused;

    event ContractUpgrade(address newUpgradedContractAddress);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setUpgradedContractAddress(address _upgradedContractAddress) public onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}",42.13424038887024,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public upgradedContractAddress;
    bool public paused;

    event ContractUpgrade(address newUpgradedContractAddress);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    constructor() Ownable(msg.sender) {
        paused = false;
    }

    function setUpgradedContractAddress(address _upgradedContractAddress) public onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}"
598,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public onlyOwner {
        require(now > 1508840297);
        _transfer(msg.sender, _to, _value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        // Implementation of the transfer logic
    }
}",transfer,"[{'function': 'transfer', 'complexity': 1}, {'function': '_transfer', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1508840297"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Too early""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.912862102172076,0.7071011629185621,"pragma solidity ^0.8.0;

contract MyToken {

    function transfer(address _to, uint256 _value) public {
        require(block.timestamp > 1508840297, ""Too early"");
        _transfer(msg.sender, _to, _value);
    }

    function _transfer(address _from, address _to, uint256 _value) internal virtual {
        //Implementation of the _transfer function would go here.  This is a placeholder.
    }
}",41.762032985687256,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    uint256 public constant INITIAL_SUPPLY = 1; // Set to 1 (never 0)
    string public name = ""MyToken""; // Set to 'initialized'
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    mapping(address => uint256) balances;
    address[] internal stakeholders;

    constructor() Ownable(msg.sender) {
        balances[owner()] = INITIAL_SUPPLY; // Initialize the owner's balance to 1
        totalSupply = INITIAL_SUPPLY;
        emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);
    }

    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _value) public {
        require(block.timestamp > 1508840297, ""Too early"");
        require(_to != address(0), ""Invalid recipient"");
        require(balances[msg.sender] >= _value, ""Insufficient balance"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
    }

    function _transfer(address _from, address _to, uint256 _value) internal override {
        require(_to != address(0), ""Invalid recipient"");
        require(balances[_from] >= _value, ""Insufficient balance"");

        balances[_from] -= _value;
        balances[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}"
2600,This function will set the conversion rate .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public rateMe;

    function setRate(uint _rateMe) public onlyOwner {
        rateMe = _rateMe;
    }
}",setRate,"[{'function': 'setRate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_rateMe"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""rateMe""}, ""right"": {""type"": ""Identifier"", ""name"": ""_rateMe""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""ownerOnly"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.971871952544524,0.4758733096412523,"pragma solidity ^0.8.0;

contract MyContract {

    address public owner;
    uint256 public rateMe;

    constructor() {
        owner = msg.sender;
    }

    modifier ownerOnly() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setRate(uint256 _rateMe) public ownerOnly {
        rateMe = _rateMe;
    }
}",41.557090520858765,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public rateMe;

    constructor() Ownable(msg.sender) {
        rateMe = 1;
    }

    modifier ownerOnly() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    function setRate(uint256 _rateMe) public ownerOnly {
        rateMe = _rateMe;
    }
}"
2777,Calls approve on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CompatibleERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract SafeApproveWrapper is Ownable {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 amount) internal {
        CompatibleERC20(token).approve(spender, amount);
        require(previousReturnValue(), ""approve failed"");
    }

    function previousReturnValue() private pure returns (bool) {
        // This is a placeholder for the actual logic to check if the approve call succeeded.
        // In practice, this would involve checking the return value of the approve function.
        // For simplicity, we assume it always succeeds in this example.
        return true;
    }
}",safeApprove,"[{'function': 'safeApprove', 'complexity': 1}]",2.0,{},23.0,0.7301179699509782,0.0046265827277891,"pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

function safeApprove(address token, address spender, uint256 amount) public {
    require(IERC20(token).approve(spender, amount), ""approve failed"");
}",41.40869331359863,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public owner;

    constructor() {
        owner = msg.sender;
    }
}"
2639,"The total SNX owned by this account , both escrowed and unescrowed , against which synths can be issued .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollateralWrapper {
    using SafeMath for uint256;

    address public tokenState;
    address public escrow;

    constructor(address _tokenState, address _escrow) {
        tokenState = _tokenState;
        escrow = _escrow;
    }

    function collateral(address account) public view returns (uint256) {
        uint256 balance = ITokenState(tokenState).balanceOf(account);
        if (escrow != address(0)) {
            balance = balance.add(IEscrow(escrow).balanceOf(account));
        }
        return balance;
    }
}",calculateTotalCollateral,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'calculateTotalCollateral', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateTotalCollateral"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""tokenStateContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenState""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenStateContract""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""escrowContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""escrow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrowContract""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""Identifier"", ""name"": ""balance""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",8.0,0.9043006928810576,0.5644435724075126,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract CollateralCalculator {
    address public tokenState;
    address public escrow;

    constructor(address _tokenState, address _escrow) {
        tokenState = _tokenState;
        escrow = _escrow;
    }

    function calculateTotalCollateral(address account) public view returns (uint256) {
        IERC20 tokenStateContract = IERC20(tokenState);
        uint256 balance = tokenStateContract.balanceOf(account);

        if (escrow != address(0)) {
            IERC20 escrowContract = IERC20(escrow);
            balance += escrowContract.balanceOf(account);
        }

        return balance;
    }
}",42.01902484893799,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract CollateralCalculator is Ownable {
    address public tokenState;
    address public escrow;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenState, address _escrow) Ownable(msg.sender) {
        require(_tokenState != address(0), ""Invalid token state address"");
        require(_escrow != address(0), ""Invalid escrow address"");

        tokenState = _tokenState;
        escrow = _escrow;
    }

    function calculateTotalCollateral(address account) public view returns (uint256) {
        IERC20 tokenStateContract = IERC20(tokenState);
        uint256 balance = tokenStateContract.balanceOf(account);

        if (escrow != address(0)) {
            IERC20 escrowContract = IERC20(escrow);
            balance += escrowContract.balanceOf(account);
        }

        return balance;
    }
}"
4569,Returns all the relevant information about a specific whale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhaleMarketplace is Ownable {
    using SafeMath for uint256;

    struct Whale {
        string name;
    }

    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Whale storage whale = whales[_tokenId];
        Id = _tokenId;
        whaleName = whale.name;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}",getWhale,"[{'function': 'getWhale', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getWhale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""Id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""whaleName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""Id""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""whaleName""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whales""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""memberName"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whaleIndexToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whaleIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",8.0,0.9524498358311296,0.7711238309082911,"pragma solidity ^0.8.0;

struct Whale {
    string name;
    // Add other relevant whale attributes here if needed
}

contract WhaleNFT {
    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Id = _tokenId;
        whaleName = whales[_tokenId].name;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}",42.33470010757446,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

struct Whale {
    string name;
    // Add other relevant whale attributes here if needed
}
import ""openzeppelin/SafeMath.sol"";
contract WhaleNFT is Ownable {
    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        whales[1] = Whale({name: ""Whale 1""});
        whales[2] = Whale({name: ""Whale 2""});
        whales[3] = Whale({name: ""Whale 3""});

        whaleIndexToPrice[1] = 1 ether;
        whaleIndexToPrice[2] = 2 ether;
        whaleIndexToPrice[3] = 3 ether;

        whaleIndexToOwner[1] = address(0x111);
        whaleIndexToOwner[2] = address(0x222);
        whaleIndexToOwner[3] = address(0x333);
    }

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Id = _tokenId;
        whaleName = whales[_tokenId].name;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}"
3314,deliberately authorized the sender of the message via some mechanism,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SCComplianceService {
    function validate(address _from, address _to, uint256 _amount) external view returns (bool);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    bool public stopInEmergency = false;

    SCComplianceService public complianceService;

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
    }

    function setComplianceService(address _complianceService) public onlyOwner {
        complianceService = SCComplianceService(_complianceService);
    }

    function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {
        if (balances[_from] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the token balance of the source');
        }

        if (allowed[_from][msg.sender] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');
        }

        if (!complianceService.validate(_from, _to, _amount)) {
            revert('transferFrom: not allowed by the compliance service');
        }

        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        emit Transfer(_from, _to, _amount);

        return true;
    }

    function setStopInEmergency(bool _stop) public onlyOwner {
        stopInEmergency = _stop;
    }
}",transferFrom,"[{'function': 'transferFrom', 'complexity': 3}]",4.0,{},83.0,0.7989949553029996,0.2803701747062011,"pragma solidity ^0.8.0;

import ""./SCComplianceService.sol""; // Assuming this contract exists and has a validate function

contract YourToken {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {
        require(balances[_from] >= _amount, ""Insufficient balance"");
        require(allowed[_from][msg.sender] >= _amount, ""Insufficient allowance"");
        require(SCComplianceService(0x...).validate(_from, _to, _amount), ""Transfer not compliant""); // Replace 0x... with the actual address of SCComplianceService

        balances[_from] -= _amount;
        balances[_to] += _amount;
        allowed[_from][msg.sender] -= _amount;
        emit Transfer(_from, _to, _amount);
        return true;
    }
}",42.32884383201599,"pragma solidity ^0.8.0;

import ""./SCComplianceService.sol""; // Assuming this contract exists and has a validate function
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract YourToken is Ownable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Initial balance for the owner
        allowed[msg.sender][address(0x1111111111111111111111111111111111111111)] = 1; // Example fixed address
        allowed[msg.sender][address(0x2222222222222222222222222222222222222222)] = 1; // Next fixed address
        allowed[msg.sender][address(0x3333333333333333333333333333333333333333)] = 1; // Next fixed address
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {
        require(balances[_from] >= _amount, ""Insufficient balance"");
        require(allowed[_from][msg.sender] >= _amount, ""Insufficient allowance"");
        require(SCComplianceService(0x...).validate(_from, _to, _amount), ""Transfer not compliant""); // Replace 0x... with the actual address of SCComplianceService

        balances[_from] -= _amount;
        balances[_to] += _amount;
        allowed[_from][msg.sender] -= _amount;
        emit Transfer(_from, _to, _amount);
        return true;
    }
}"
3619,Get the tags related to the module factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TagProvider {
    using SafeMath for uint256;

    function getTags() public view returns (bytes32[] memory) {
        bytes32[] memory availableTags = new bytes32[](2);
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
        return availableTags;
    }
}",getTags,"[{'function': 'getTags', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTags"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, ""name"": ""availableTags"", ""storageLocation"": ""memory""}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""availableTags""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""stringLiteral"", ""value"": ""Count""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""availableTags""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""right"": {""type"": ""stringLiteral"", ""value"": ""Transfer Restriction""}}}, {""type"": ""Identifier"", ""name"": ""availableTags""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.8800264480904705,0.5260948203898325,"pragma solidity ^0.8.0;

contract TagContract {

    function getTags() public view returns (bytes32[2] memory) {
        bytes32[2] memory availableTags;
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
        return availableTags;
    }
}",41.70264220237732,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TagContract {
    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');
    string public constant INIT_STRING = 'initialized';

    constructor() Ownable(OWNER) {}

    function getTags() public view returns (bytes32[2] memory) {
        bytes32[2] memory availableTags;
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
        return availableTags;
    }
}"
3235,Invoke ` onERC721Received ` on a target address ( not executed if the target address is not a contract ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721Wrapper is Ownable {
    using SafeMath for uint256;

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal returns (bool) {
        if (!_to.isContract()) return true;
        bytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
        return (retval == 0x150b7a02); // ERC721_RECEIVED is the keccak-256 hash of ""onERC721Received(address,address,uint256,bytes)""
    }
}",checkAndCallSafeTransfer,"[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}, {'function': 'checkAndCallSafeTransfer', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",24.0,0.8482356070761613,0.4028318346518287,"pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721SafeTransfer {

    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes calldata _data) public returns (bool) {
        if (!isContract(_to)) {
            return true;
        }
        try IERC721Receiver(_to).onERC721Received(_from, _from, _tokenId, _data) returns (bytes4 retval) {
            return retval == ERC721_RECEIVED;
        } catch {
            return false;
        }
    }
}",42.52528953552246,"pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}
import ""openzeppelin/SafeMath.sol"";
contract ERC721SafeTransfer is ERC721SafeTransfer {
    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes calldata _data) public returns (bool) {
        if (!isContract(_to)) {
            return true;
        }
        try IERC721Receiver(_to).onERC721Received(_from, _from, _tokenId, _data) returns (bytes4 retval) {
            return retval == ERC721_RECEIVED;
        } catch {
            return false;
        }
    }
}"
4896,Set whether prices can be changed manually .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public allowChangePrice;

    function setAllowChangePrice(bool _allowChangePrice) external onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}",setAllowChangePrice,"[{'function': 'setAllowChangePrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAllowChangePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_allowChangePrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""allowChangePrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_allowChangePrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCFO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.97198691224417,0.7611606003349892,"pragma solidity ^0.8.0;

contract MyContract {
    address public cfo;
    bool public allowChangePrice;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only CFO can call this function"");
        _;
    }

    constructor(address _cfo) {
        cfo = _cfo;
    }

    function setAllowChangePrice(bool _allowChangePrice) public onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}",41.94055199623108,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public cfo;
    bool public allowChangePrice;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only CFO can call this function"");
        _;
    }

    constructor(address _cfo) Ownable(msg.sender) {
        cfo = _cfo;
        allowChangePrice = false; // Set to safe non-corner-case value
    }

    function setAllowChangePrice(bool _allowChangePrice) public onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}"
5609,Updates registration status for multiple addresses for participation,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function changeRegistrationStatus(address target, bool isRegistered) public onlyOwner {
        // Implementation of changing registration status
    }

    function changeRegistrationStatuses(address[] memory targets, bool isRegistered) public onlyOwner {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}",updateMultipleRegistrationStatus,"[{'function': 'changeRegistrationStatus', 'complexity': 0}, {'function': 'updateMultipleRegistrationStatus', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeRegistrationStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_status"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isRegistered""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_status""}}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.9195606220910114,0.7182509383665651,"pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    mapping(address => bool) public isRegistered;

    modifier onlyBy(address _account) {
        require(msg.sender == _account, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function changeRegistrationStatus(address _addr, bool _status) internal {
        isRegistered[_addr] = _status;
    }

    function updateMultipleRegistrationStatus(address[] memory targets, bool isRegistered) public onlyBy(owner) {
        for (uint256 i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}",41.85394239425659,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner = msg.sender;
    mapping(address => bool) public isRegistered;

    modifier onlyBy(address _account) {
        require(msg.sender == _account, ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are already initialized in the parent contract's constructor
    }

    function changeRegistrationStatus(address _addr, bool _status) internal {
        isRegistered[_addr] = _status;
    }

    function updateMultipleRegistrationStatus(address[] memory targets, bool isRegistered) public onlyBy(owner) {
        for (uint256 i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}"
3896,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract BeneficiaryManager is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    IERC20 public token;
    mapping(address => Beneficiary) public beneficiaries;
    address[] public addresses;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _token, address[] memory initialBeneficiaries) {
        token = IERC20(_token);
        for (uint i = 0; i < initialBeneficiaries.length; i++) {
            beneficiaries[initialBeneficiaries[i]] = Beneficiary({isBeneficiary: true, vested: 0, released: 0});
        }
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary].isBeneficiary, ""Beneficiary does not exist"");
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        token.transfer(owner(), balance);
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        for (uint i = 0; i < addresses.length - 1; i++) {
            if (addresses[i] == _beneficiary) {
                addresses[i] = addresses[addresses.length - 1];
                break;
            }
        }
        addresses.pop();
        emit BeneficiaryDestroyed(_beneficiary);
    }
}",destroyBeneficiary,"[{'function': 'destroyBeneficiary', 'complexity': 7}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Beneficiary""}, ""name"": ""beneficiary"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainingBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""vested""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""remainingBalance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalReleased""}, ""right"": {""type"": ""Identifier"", ""name"": ""remainingBalance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""isBeneficiary""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}, ""right"": {""type"": ""Identifier"", ""name"": ""remainingBalance""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastBeneficiaryIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""lastBeneficiaryIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""lastBeneficiary"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""lastBeneficiaryIndex""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""beneficiaryIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiaryIndex""}, ""right"": {""type"": ""Identifier"", ""name"": ""i""}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiaryIndex""}}, ""right"": {""type"": ""Identifier"", ""name"": ""lastBeneficiary""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BeneficiaryDestroyed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.8715142863151047,0.4411490647371855,"pragma solidity ^0.8.0;

// Assume necessary imports and contracts are defined here, including IERC20 and onlyOwner modifier

contract MyContract {
    // Assume necessary state variables are defined here, including token, beneficiaries, addresses, totalReleased

    event BeneficiaryDestroyed(address beneficiary);

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 remainingBalance = beneficiary.vested - beneficiary.released;

        token.transfer(msg.sender, remainingBalance);
        totalReleased += remainingBalance;
        beneficiary.isBeneficiary = false;
        beneficiary.released += remainingBalance;

        uint256 lastBeneficiaryIndex = addresses.length - 1;
        if (lastBeneficiaryIndex > 0) {
            address lastBeneficiary = addresses[lastBeneficiaryIndex];
            uint256 beneficiaryIndex = 0;
            for (uint256 i = 0; i < addresses.length; i++) {
                if (addresses[i] == _beneficiary) {
                    beneficiaryIndex = i;
                    break;
                }
            }
            addresses[beneficiaryIndex] = lastBeneficiary;
        }
        addresses.pop();

        emit BeneficiaryDestroyed(_beneficiary);
    }

    struct Beneficiary {
        uint256 vested;
        uint256 released;
        bool isBeneficiary;
    }
}",43.015567779541016,"pragma solidity ^0.8.0;

// Assume necessary imports and contracts are defined here, including IERC20 and onlyOwner modifier
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    // Assume necessary state variables are defined here, including token, beneficiaries, addresses, totalReleased

    event BeneficiaryDestroyed(address beneficiary);

    constructor() Ownable(msg.sender) {
        // Initialize all instance (state) variables to fixed, safe, non-corner-case values
        for (uint256 i = 0; i < addresses.length; i++) {
            beneficiaries[addresses[i]] = Beneficiary({
                vested: 1,
                released: 0,
                isBeneficiary: true
            });
        }
        totalReleased = 0;
    }

    struct Beneficiary {
        uint256 vested;
        uint256 released;
        bool isBeneficiary;
    }
}"
2053,Create ` msg.value ` ETH worth of GMT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint256 public tokenExchangeRate = 1000; // Example rate, adjust as needed
    uint256 public totalSupply = 1000000 * (10 ** 18); // Example total supply, adjust as needed
    uint256 public assignedSupply;
    uint256 public gmtFund;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return assignedSupply.add(tokens) <= totalSupply;
    }

    function claimTokens() public payable {
        require(msg.value > 0, ""Value must be greater than zero"");
        uint256 tokens = msg.value.mul(tokenExchangeRate);
        require(isWithinCap(tokens), ""Claim exceeds the token cap"");
        uint256 checkedSupply = assignedSupply.add(tokens);
        require(checkedSupply.add(gmtFund) <= totalSupply, ""Total supply would be exceeded"");
        balances[msg.sender] = balances[msg.sender].add(tokens);
        purchases[msg.sender] = purchases[msg.sender].add(tokens);
        assignedSupply = checkedSupply;
        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }
}",claimTokens,"[{'function': 'registerUser', 'complexity': 0}, {'function': 'isWithinCap', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredUsers""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""User not registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}}, {""type"": ""stringLiteral"", ""value"": ""Claim period expired""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Ether amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""exchangeRate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isWithinCap""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token purchase exceeds cap limit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""assignedSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, {""type"": ""stringLiteral"", ""value"": ""Token assignment exceeds total supply""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""purchases""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""purchases""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""assignedSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""assignedSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimGMT""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",28.0,0.908017715392058,0.6042597302688196,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    uint256 public totalSupply;
    uint256 public assignedSupply;
    uint256 public exchangeRate; // Tokens per Ether
    uint256 public capLimit; // Token purchase cap per address
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;
    mapping(address => bool) public registeredUsers;
    uint256 public startTime;
    uint256 public endTime;

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 _totalSupply, uint256 _exchangeRate, uint256 _capLimit, uint256 _startTime, uint256 _endTime) {
        totalSupply = _totalSupply;
        exchangeRate = _exchangeRate;
        capLimit = _capLimit;
        startTime = _startTime;
        endTime = _endTime;
    }

    function registerUser() public {
        registeredUsers[msg.sender] = true;
    }

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return purchases[msg.sender].add(tokens) <= capLimit;
    }

    function claimTokens() public payable {
        require(registeredUsers[msg.sender], ""User not registered"");
        require(block.timestamp >= startTime && block.timestamp <= endTime, ""Claim period expired"");
        require(msg.value > 0, ""Ether amount must be greater than zero"");

        uint256 tokens = msg.value.mul(exchangeRate);
        require(isWithinCap(tokens), ""Token purchase exceeds cap limit"");
        require(assignedSupply.add(tokens) <= totalSupply, ""Token assignment exceeds total supply"");

        balances[msg.sender] = balances[msg.sender].add(tokens);
        purchases[msg.sender] = purchases[msg.sender].add(tokens);
        assignedSupply = assignedSupply.add(tokens);

        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }
}",44.3762366771698,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {;
    using SafeMath for uint256;

    uint256 public totalSupply = 1000000000000000000; // Set to 1 (never 0)
    uint256 public assignedSupply; // Initialize in uint256 public totalSupply;

 constructor
    uint256 public exchangeRate = 1; // Tokens per Ether
    uint256 public capLimit = 1; // Token purchase cap per address
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;
    mapping(address => bool) public registeredUsers;
    uint256 public startTime = block.timestamp + 1 days; // Placeholder value for initialization
    uint256 public endTime = block.timestamp + 2 days; // Placeholder value for initialization

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    uint256 public totalSupply;

 constructor(uint256 _totalSupply, uint256 _exchangeRate, uint256 _capLimit, uint256 _startTime, uint256 _endTime) Ownable(_startTime) {
        totalSupply = _totalSupply;
        exchangeRate = _exchangeRate;
        capLimit = _capLimit;
        startTime = _startTime;
        endTime = _endTime;
    }

    function registerUser() public {
        registeredUsers[msg.sender] = true;
    }

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return purchases[msg.sender].add(tokens) <= capLimit;
    }

    function claimTokens() public payable {
        require(registeredUsers[msg.sender], ""User not registered"");
        require(block.timestamp >= startTime && block.timestamp <= endTime, ""Claim period expired"");
        require(msg.value > 0, ""Ether amount must be greater than zero"");

        uint256 tokens = msg.value.mul(exchangeRate);
        require(isWithinCap(tokens), ""Token purchase exceeds cap limit"");
        require(assignedSupply.add(tokens) <= totalSupply, ""Token assignment exceeds total supply"");

        balances[msg.sender] = balances[msg.sender].add(tokens);
        purchases[msg.sender] = purchases[msg.sender].add(tokens);
        assignedSupply = assignedSupply.add(tokens);

        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }
}"
306,How many HEAL tokens do this contract have,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EthealToken {
    function balanceOf(address account) external view returns (uint256);
}

interface EthealController {
    function ethealToken() external view returns (EthealToken);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    EthealController public ethealController;

    constructor(address _ethealController) {
        require(_ethealController != address(0), ""Invalid controller address"");
        ethealController = EthealController(_ethealController);
    }

    function getHealBalance() view public returns (uint256) {
        return ethealController.ethealToken().balanceOf(address(this));
    }
}",getEtherTokenAddress,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getHealBalance', 'complexity': 0}, {'function': 'getEtherTokenAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getHealBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""ethealToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getEtherTokenAddress""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ethealToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.7148789475241123,0.0187555258432192,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract MyContract {
    address public ethealController;

    constructor(address _ethealController) {
        ethealController = _ethealController;
    }

    function getHealBalance() public view returns (uint256) {
        IERC20 ethealToken = IERC20(getEtherTokenAddress());
        return ethealToken.balanceOf(address(this));
    }

    function getEtherTokenAddress() internal view returns (address) {
        //Implementation to get Ether token address from ethealController
        //This is a placeholder and needs to be replaced with actual logic based on ethealController contract
        //Example:  return IController(ethealController).ethealToken();
        return address(0); //Replace with actual address retrieval
    }
}",42.29706335067749,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public ethealController;

    mapping(address => uint256) public balanceOf;

 constructor(address _ethealController) Ownable(msg.sender) {
        require(_ethealController != address(0), ""Invalid controller address"");
        ethealController = _ethealController;
    }

    function getHealBalance() public view returns (uint256) {
        IERC20 ethealToken = IERC20(getEtherTokenAddress());
        return ethealToken.balanceOf(address(this));
    }

    function getEtherTokenAddress() internal view returns (address) {
        //Implementation to get Ether token address from ethealController
        //This is a placeholder and needs to be replaced with actual logic based on ethealController contract
        //Example:  return IController(ethealController).ethealToken();
        return address(0); //Replace with actual address retrieval
    }
}"
3644,"Pledges fees to the token holders , later to be claimed by burning","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeFeesWrapper {
    using SafeMath for uint256;

    uint public totalPledgedFees;
    mapping(uint => uint) public totalPledgedFeesHistory;
    address private controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor() {
        controller = msg.sender;
    }

    function pledgeFees(uint _value) public onlyController returns (bool) {
        uint curTotalFees = totalPledgedFees();
        require(curTotalFees + _value >= curTotalFees, ""SafeMath: addition overflow"");
        updateValueAtNow(totalPledgedFeesHistory, curTotalFees.add(_value));
        return true;
    }

    function totalPledgedFees() public view returns (uint) {
        return totalPledgedFees;
    }

    function updateValueAtNow(mapping(uint => uint) storage _map, uint _value) internal {
        totalPledgedFees = _value;
    }
}",pledgeFees,"[{'function': 'pledgeFees', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pledgeFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""curTotalFees"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalPledgedFees""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""right"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}}, {""type"": ""stringLiteral"", ""value"": ""Overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateValueAtNow""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.8956472649198043,0.6343909892400624,"pragma solidity ^0.8.0;

// Assume necessary contracts and interfaces are defined elsewhere, including updateValueAtNow and totalPledgedFees

contract YourContract {

    // ... other contract code ...

    function pledgeFees(uint _value) external returns (bool) {
        uint curTotalFees = totalPledgedFees();
        require(curTotalFees + _value >= curTotalFees, ""Overflow"");
        updateValueAtNow(curTotalFees + _value);
        return true;
    }

    // ... other contract code ...
}",41.52286648750305,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract YourContract {
    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner address
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');
    uint256 public constant DEFAULT_VALUE = 1;

    constructor() Ownable(OWNER) {
        // Initialize instance variables to fixed, safe values
        initialized = true;
        INIT_BYTES32 = INIT_BYTES32;
        DEFAULT_VALUE = DEFAULT_VALUE;
    }

    function pledgeFees(uint _value) external returns (bool) {
        uint curTotalFees = totalPledgedFees();
        require(curTotalFees + _value >= curTotalFees, ""Overflow"");
        updateValueAtNow(curTotalFees + _value);
        return true;
    }

    // ... other contract code ...
}"
6330,Helper function that calculates the valuation of the asset in terms of an ART token quantity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public oracle_price_decimals_factor = 10**18; // Example factor, adjust as needed
    uint256 public decimal_precission_difference_factor = 10**18; // Example factor, adjust as needed

    function convert_valuation_to_art(uint256 _valuation, uint256 _art_price) public view returns (uint256 amount) {
        amount = ((_valuation.mul(oracle_price_decimals_factor)).div(_art_price)).mul(decimal_precission_difference_factor);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}",convertValuationToArt,"[{'function': 'convertValuationToArt', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""convertValuationToArt"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_valuation"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_art_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""adjustedValuation"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_valuation""}, ""right"": {""type"": ""Identifier"", ""name"": ""oracle_price_decimals_factor""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""artUnits"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""adjustedValuation""}, ""right"": {""type"": ""Identifier"", ""name"": ""_art_price""}}}, {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""artUnits""}, ""right"": {""type"": ""Identifier"", ""name"": ""decimal_precission_difference_factor""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",25.0,0.5133130821184643,0.0141126805486826,"pragma solidity ^0.8.0;

contract ArtValuationConverter {

    uint256 public constant oracle_price_decimals_factor = 10**18; // Example factor, adjust as needed
    uint256 public constant decimal_precission_difference_factor = 10**18; //Example factor, adjust as needed


    function convertValuationToArt(uint256 _valuation, uint256 _art_price) public view returns (uint256) {
        uint256 adjustedValuation = _valuation * oracle_price_decimals_factor;
        uint256 artUnits = adjustedValuation / _art_price;
        return artUnits * decimal_precission_difference_factor;
    }
}",41.94714426994324,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ArtValuationConverter is Ownable {
    uint256 public constant oracle_price_decimals_factor = 10**18; // Example factor, adjust as needed
    uint256 public constant decimal_precission_difference_factor = 10**18; //Example factor, adjust as needed

    constructor() Ownable(msg.sender) {
        // Initialization of state variables are not required as they are already set to safe non-corner-case values
    }

    function convertValuationToArt(uint256 _valuation, uint256 _art_price) public view returns (uint256) {
        uint256 adjustedValuation = _valuation * oracle_price_decimals_factor;
        uint256 artUnits = adjustedValuation / _art_price;
        return artUnits * decimal_precission_difference_factor;
    }
}"
5296,"Remove a node from the list , and fix the previous and next pointers that are pointing to the removed node .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address previous;
        address next;
        bool inList;
    }

    mapping(address => Node) public list;

    function isInList(List storage self, address node) internal view returns (bool) {
        return self.list[node].inList;
    }

    function remove(List storage self, address node) internal {
        require(isInList(self, node), ""not in list"");
        if (node == address(0)) {
            return;
        }
        address p = self.list[node].previous;
        address n = self.list[node].next;
        self.list[p].next = n;
        self.list[n].previous = p;
        self.list[node].inList = false;
        delete self.list[node];
    }
}",remove,"[{'function': 'isInList', 'complexity': 0}, {'function': 'remove', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""remove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""List""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""node"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isInList""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""self""}, {""type"": ""Identifier"", ""name"": ""node""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""not in list""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""p"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""memberName"": ""previous""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""n"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""memberName"": ""next""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""p""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""p""}}, ""memberName"": ""next""}, ""right"": {""type"": ""Identifier"", ""name"": ""n""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""head""}, ""right"": {""type"": ""Identifier"", ""name"": ""n""}}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""n""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""n""}}, ""memberName"": ""previous""}, ""right"": {""type"": ""Identifier"", ""name"": ""p""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""tail""}, ""right"": {""type"": ""Identifier"", ""name"": ""p""}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""memberName"": ""inList""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""isPrefix"": True}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.8640170011729483,0.4488211670467937,"pragma solidity ^0.8.0;

contract DoublyLinkedList {

    struct List {
        mapping(address => Node) nodes;
        address head;
        address tail;
    }

    struct Node {
        address previous;
        address next;
        bool inList;
        // Add other node data as needed
    }


    function isInList(List storage self, address node) internal view returns (bool) {
        return self.nodes[node].inList;
    }

    function remove(List storage self, address node) internal {
        require(isInList(self, node), ""not in list"");
        address p = self.nodes[node].previous;
        address n = self.nodes[node].next;

        if (p != address(0)) {
            self.nodes[p].next = n;
        } else {
            self.head = n;
        }

        if (n != address(0)) {
            self.nodes[n].previous = p;
        } else {
            self.tail = p;
        }

        self.nodes[node].inList = false;
        delete self.nodes[node];
    }
}",42.63046193122864,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DoublyLinkedList is Ownable {
    struct List {
        mapping(address => Node) nodes;
        address head;
        address tail;
    }

    struct Node {
        address previous;
        address next;
        bool inList;
        // Add other node data as needed
    }

    function isInList(List storage self, address node) internal view returns (bool) {
        return self.nodes[node].inList;
    }

    function remove(List storage self, address node) internal {
        require(isInList(self, node), ""not in list"");
        address p = self.nodes[node].previous;
        address n = self.nodes[node].next;

        if (p != address(0)) {
            self.nodes[p].next = n;
        } else {
            self.head = n;
        }

        if (n != address(0)) {
            self.nodes[n].previous = p;
        } else {
            self.tail = p;
        }

        self.nodes[node].inList = false;
        delete self.nodes[node];
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
1009,Function that registers new synth as they are isseud .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SynthetixState {
    function incrementTotalIssuerCount() external;
    function setCurrentIssuanceData(address issuer, uint debtPercentage) external;
    function appendDebtLedgerValue(uint value) external;
    function lastDebtLedgerEntry() external view returns (uint);
    function hasIssued(address account) external view returns (bool);
    function debtLedgerLength() external view returns (int);
}

interface Synth {
    function effectiveValue(bytes4 currencyKey, uint amount, bytes32 destinationCurrencyKey) external pure returns (uint);
    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);
}

interface DebtCache {
    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);
}

abstract contract DebtRegisterWrapper is Ownable {
    using SafeMath for uint;
    using SafeDecimalMath for uint;

    SynthetixState public synthetixState;
    Synth public synth;
    DebtCache public debtCache;

    constructor(address _synthetixState, address _synth, address _debtCache) {
        synthetixState = SynthetixState(_synthetixState);
        synth = Synth(_synth);
        debtCache = DebtCache(_debtCache);
    }

    function _addToDebtRegister(bytes4 currencyKey, uint amount) external optionalProxy {
        require(msg.sender == address(this), ""Only callable by this contract"");

        uint xdrValue = synth.effectiveValue(currencyKey, amount, ""XDR"");
        uint totalDebtIssued = synth.totalIssuedSynths(""XDR"");
        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);
        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);
        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);
        uint existingDebt = debtCache.debtBalanceOf(msg.sender, ""XDR"");

        if (existingDebt > 0) {
            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);
        }

        if (!synthetixState.hasIssued(msg.sender)) {
            synthetixState.incrementTotalIssuerCount();
        }

        synthetixState.setCurrentIssuanceData(msg.sender, debtPercentage);

        if (synthetixState.debtLedgerLength() > 0) {
            synthetixState.appendDebtLedgerValue(synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));
        } else {
            synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());
        }
    }
}",_addToDebtRegister,"[{'function': '_addToDebtRegister', 'complexity': 4}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""_addToDebtRegister"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""currencyKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""xdrValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""effectiveValue""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currencyKey""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""totalDebtIssued"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalIssuedSynths""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newTotalDebtIssued"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""totalDebtIssued""}, ""right"": {""type"": ""Identifier"", ""name"": ""xdrValue""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""debtPercentage"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeDecimalMath""}, ""memberName"": ""preciseDiv""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""xdrValue""}, {""type"": ""Identifier"", ""name"": ""newTotalDebtIssued""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""delta"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeDecimalMath""}, ""memberName"": ""preciseUnit""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""debtPercentage""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""existingDebt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""debtBalanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""existingDebt""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newTotalDebtIssued""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""totalDebtIssued""}, ""right"": {""type"": ""Identifier"", ""name"": ""existingDebt""}}, ""right"": {""type"": ""Identifier"", ""name"": ""xdrValue""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""debtPercentage""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeDecimalMath""}, ""memberName"": ""preciseDiv""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""existingDebt""}, ""right"": {""type"": ""Identifier"", ""name"": ""xdrValue""}}, {""type"": ""Identifier"", ""name"": ""newTotalDebtIssued""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""delta""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeDecimalMath""}, ""memberName"": ""preciseUnit""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""debtPercentage""}}}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""hasIssued""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""incrementTotalIssuerCount""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synthetixState""}, ""memberName"": ""setCurrentIssuanceData""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""debtPercentage""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""debtLedger""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastDebtLedgerEntry"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""debtLedger""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""debtLedger""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""debtLedger""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeDecimalMath""}, ""memberName"": ""preciseMul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lastDebtLedgerEntry""}, {""type"": ""Identifier"", ""name"": ""delta""}], ""names"": []}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""debtLedger""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeDecimalMath""}, ""memberName"": ""preciseUnit""}, ""arguments"": [], ""names"": []}], ""names"": []}}]}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.8588081352779148,0.4945570897698761,"pragma solidity ^0.8.0;

import ""./SafeDecimalMath.sol"";

contract Synthetix {
    // ... other contract elements ...

    function _addToDebtRegister(bytes4 currencyKey, uint amount) internal {
        uint xdrValue = effectiveValue(currencyKey, amount);
        uint totalDebtIssued = totalIssuedSynths();
        uint newTotalDebtIssued = totalDebtIssued + xdrValue;
        uint debtPercentage = SafeDecimalMath.preciseDiv(xdrValue, newTotalDebtIssued);
        uint delta = SafeDecimalMath.preciseUnit() - debtPercentage;
        uint existingDebt = debtBalanceOf(msg.sender);

        if (existingDebt > 0) {
            newTotalDebtIssued = totalDebtIssued + existingDebt + xdrValue;
            debtPercentage = SafeDecimalMath.preciseDiv(existingDebt + xdrValue, newTotalDebtIssued);
            delta = SafeDecimalMath.preciseUnit() - debtPercentage;
        }

        if (!synthetixState.hasIssued(msg.sender)) {
            synthetixState.incrementTotalIssuerCount();
        }

        synthetixState.setCurrentIssuanceData(msg.sender, debtPercentage);

        if (debtLedger.length > 0) {
            uint lastDebtLedgerEntry = debtLedger[debtLedger.length - 1];
            debtLedger.push(SafeDecimalMath.preciseMul(lastDebtLedgerEntry, delta));
        } else {
            debtLedger.push(SafeDecimalMath.preciseUnit());
        }
    }

    // ... other contract elements ...

    uint[] public debtLedger;
    // ... other state variables ...

    // ... other functions ...
}",43.40712952613831,"pragma solidity ^0.8.0;

import ""./SafeDecimalMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from in OpenZeppelin
import ""openzeppelin/SafeMath.sol"";
contract Synthetix is Ownable {
    using SafeDecimalMath for uint256;

    struct SynthetixState {
        bool initialized;
        bytes32 initBytes32;
        address[] debtLedger;
        // other state variables...
    }

    SynthetixState public synthetixState;

    constructor() Ownable(msg.sender) {
        synthetixState = SynthetixState({
            initialized: true,
            initBytes32: bytes32('init'),
            debtLedger: [1] // Fixed value for address array initialization
        });
    }

    function _addToDebtRegister(bytes4 currencyKey, uint amount) internal {
        require(synthetixState.initialized, ""Synthetix not initialized"");
        uint xdrValue = effectiveValue(currencyKey, amount);
        uint totalDebtIssued = totalIssuedSynths();
        uint newTotalDebtIssued = totalDebtIssued + xdrValue;
        uint debtPercentage = SafeDecimalMath.preciseDiv(xdrValue, newTotalDebtIssued);
        uint delta = SafeDecimalMath.preciseUnit() - debtPercentage;
        uint existingDebt = debtBalanceOf(msg.sender);

        if (existingDebt > 0) {
            newTotalDebtIssued = totalDebtIssued + existingDebt + xdrValue;
            debtPercentage = SafeDecimalMath.preciseDiv(existingDebt + xdrValue, newTotalDebtIssued);
            delta = SafeDecimalMath.preciseUnit() - debtPercentage;
        }

        if (!synthetixState.initialized) {
            synthetixState.debtLedger.push(1); // Fixed value for address array initialization
        }

        synthetixState.debtLedger.push(SafeDecimalMath.preciseMul(synthetixState.debtLedger[synthetixState.debtLedger.length - 1], delta));
    }

    function totalIssuedSynths() public view returns (uint) {
        // Implementation of the function...
        return 0; // Placeholder for implementation details
    }

    function debtBalanceOf(address issuer) public view returns (uint) {
        // Implementation of the function...
        return 0; // Placeholder for implementation details
    }

    function effectiveValue(bytes4 currencyKey, uint amount) internal pure returns (uint) {
        // Implementation of the function...
        return 0; // Placeholder for implementation details
    }
}"
5740,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    constructor() {}

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) onlyOwner public {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }
}",setPrices,"[{'function': 'setPrices', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellMultiplier"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyMultiplier"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellMultiplier""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellMultiplier""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyMultiplier""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyMultiplier""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,0.8934877060849065,"pragma solidity ^0.8.0;

contract MyContract {

    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) public onlyOwner {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }

    function owner() public view returns (address) {
        return owner;
    }
}",42.10131549835205,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and you have a corresponding file for Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        sellPrice = 1;
        sellMultiplier = 1;
        buyPrice = 1;
        buyMultiplier = 1;
    }

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) public onlyOwner {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }

    function owner() public view returns (address) {
        return super.owner();
    }
}"
4219,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AIX {
    function totalSupply() external view returns (uint256);
    function generateTokens(address to, uint256 value) external;
}

abstract contract Finalizable is Ownable {
    using SafeMath for uint256;

    AIX public aix;
    address public remainderHolder;
    address public devHolder;
    address public communityHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public constant TOKEN_CAP_MULTIPLIER = 100;
    uint256 public constant TOKEN_DISTRIBUTION_RATIO = 51;

    event Finalized(uint256 indexed blockNumber);

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == controller || getBlockTimestamp() > endTime || weiToCollect() == 0);

        aix.generateTokens(remainderHolder, weiToCollect().mul(2000));
        uint256 tokenCap = aix.totalSupply().mul(TOKEN_CAP_MULTIPLIER).div(TOKEN_DISTRIBUTION_RATIO);
        aix.generateTokens(devHolder, tokenCap.mul(20).div(100));
        aix.generateTokens(communityHolder, tokenCap.mul(29).div(100));

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}",finalize,"[{'function': 'finalize', 'complexity': 5}, {'function': 'weiToCollect', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Already finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}, {""type"": ""stringLiteral"", ""value"": ""Not yet started""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiToCollect""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Not allowed to finalize""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""weiCollected"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainderTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""weiCollected""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2000"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""10000000000000000000000"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenCap"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""51"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""devTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenCap""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""20"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""communityTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenCap""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""29"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Finalized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalizedBlock""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",58.0,0.6232477668751252,0.2624644347353568,"pragma solidity ^0.8.0;

contract TokenGenerator {

    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public startTime;
    uint256 public endTime;
    address public controller;
    address public remainderHolder;
    address public devHolder;
    address public communityHolder;

    event Finalized(uint256 finalizedBlock);

    constructor(uint256 _startTime, uint256 _endTime, address _controller, address _remainderHolder, address _devHolder, address _communityHolder) {
        startTime = _startTime;
        endTime = _endTime;
        controller = _controller;
        remainderHolder = _remainderHolder;
        devHolder = _devHolder;
        communityHolder = _communityHolder;
    }


    function finalize() public {
        require(finalizedBlock == 0 && finalizedTime == 0, ""Already finalized"");
        require(block.timestamp >= startTime, ""Not yet started"");
        require(msg.sender == controller || block.timestamp >= endTime || weiToCollect() == 0, ""Not allowed to finalize"");

        uint256 weiCollected = address(this).balance;
        uint256 remainderTokens = weiCollected * 2000;
        uint256 totalSupply = 10000000000000000000000; //Example total supply.  Should be set elsewhere.
        uint256 tokenCap = totalSupply / 51;
        uint256 devTokens = tokenCap * 20 / 100;
        uint256 communityTokens = tokenCap * 29 / 100;

        //Token generation logic would go here.  This is placeholder.  Replace with actual token generation.
        //Example:  IERC20(tokenAddress).mint(remainderHolder, remainderTokens);

        finalizedBlock = block.number;
        finalizedTime = block.timestamp;

        emit Finalized(finalizedBlock);
    }

    function weiToCollect() public view returns (uint256) {
        //Logic to calculate wei to collect.  This is a placeholder.
        return 0;
    }
}",44.06293082237244,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenGenerator is Ownable {
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public startTime;
    uint256 public endTime;
    address public controller;
    address public remainderHolder;
    address public devHolder;
    address public communityHolder;

    event Finalized(uint256 finalizedBlock);

    uint256 public totalSupply;

 constructor(uint256 _startTime, uint256 _endTime, address _controller, address _remainderHolder, address _devHolder, address _communityHolder) Ownable(msg.sender) {
        startTime = _startTime;
        endTime = _endTime;
        controller = _controller;
        remainderHolder = _remainderHolder;
        devHolder = _devHolder;
        communityHolder = _communityHolder;
    }

    function finalize() public {
        require(finalizedBlock == 0 && finalizedTime == 0, ""Already finalized"");
        require(block.timestamp >= startTime, ""Not yet started"");
        require(msg.sender == controller || block.timestamp >= endTime || weiToCollect() == 0, ""Not allowed to finalize"");

        uint256 weiCollected = address(this).balance;
        uint256 remainderTokens = weiCollected * 2000;
        uint256 totalSupply = 10000000000000000000000; //Example total supply.  Should be set elsewhere.
        uint256 tokenCap = totalSupply / 51;
        uint256 devTokens = tokenCap * 20 / 100;
        uint256 communityTokens = tokenCap * 29 / 100;

        //Token generation logic would go here.  This is placeholder.  Replace with actual token generation.
        //Example:  IERC20(tokenAddress).mint(remainderHolder, remainderTokens);

        finalizedBlock = block.number;
        finalizedTime = block.timestamp;

        emit Finalized(finalizedBlock);
    }

    function weiToCollect() public view returns (uint256) {
        //Logic to calculate wei to collect.  This is a placeholder.
        return 0;
    }
}"
6178,Checks whether the contract operations is paused or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Encoder {
    function getKey(string memory key) external pure returns (bytes32);
}

abstract contract Pausable is Ownable {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private pausedMap;
    Encoder public encoder;

    constructor(address _encoderAddress) {
        encoder = Encoder(_encoderAddress);
    }

    function getBool(bytes32 key) internal view returns (bool) {
        return pausedMap[key];
    }

    function isPaused() public view returns (bool) {
        return getBool(encoder.getKey(""paused""));
    }
}",getBool,"[{'function': 'isPaused', 'complexity': 0}, {'function': 'getBool', 'complexity': 0}, {'function': 'getKey', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isPaused"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBool""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Encoder""}, ""memberName"": ""getKey""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""paused""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",6.0,0.9412419688922716,0.3542938205971965,"pragma solidity ^0.8.0;

contract MyContract {

    function isPaused() public view returns (bool) {
        return getBool(Encoder.getKey(""paused""));
    }

    function getBool(bytes32 key) internal view returns (bool) {
        //Implementation for getBool,  replace with your actual implementation.  Example below.
        //This example assumes a mapping called _boolStorage exists.
        return _boolStorage[key];
    }

    mapping(bytes32 => bool) internal _boolStorage;

    library Encoder {
        function getKey(string memory key) internal pure returns (bytes32) {
            return keccak256(abi.encodePacked(key));
        }
    }
}",41.72186803817749,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(bytes32 => bool) internal _boolStorage;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        uint256 fixedUint = 1;
        address fixedAddress = address(uint160(uint256(keccak256('a'))));
        bool fixedBool = true;
        string memory initializedString = 'initialized';
        bytes32 fixedBytes32 = bytes32('init');
    }

    function isPaused() public view returns (bool) {
        return getBool(Encoder.getKey(""paused""));
    }

    function getBool(bytes32 key) internal view returns (bool) {
        //Implementation for getBool, replace with your actual implementation. Example below.
        //This example assumes a mapping called _boolStorage exists.
        return _boolStorage[key];
    }

    library Encoder {
        function getKey(string memory key) internal pure returns (bytes32) {
            return keccak256(abi.encodePacked(key));
        }
    }
}"
1600,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ConverterRamp {
    // Define the interface of the ConverterRamp contract here if necessary
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    ConverterRamp public converterRamp;

    event SetConverterRamp(ConverterRamp indexed oldConverterRamp, ConverterRamp indexed newConverterRamp);

    function setConverterRamp(ConverterRamp _converterRamp) external onlyOwner returns (bool) {
        require(_isContract(_converterRamp), ""Should be a contract"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",_isContract,"[{'function': '_isContract', 'complexity': 0}, {'function': 'setConverterRamp', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",18.0,0.7233662092563047,0.1139035430351085,"pragma solidity ^0.8.0;

contract MyContract {

    address public converterRamp;
    address private owner;

    event SetConverterRamp(address indexed oldConverterRamp, address indexed newConverterRamp);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }

    function setConverterRamp(address _converterRamp) public onlyOwner {
        require(_isContract(_converterRamp), ""Address is not a contract"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
    }
}",42.16275382041931,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public converterRamp;

    event SetConverterRamp(address indexed oldConverterRamp, address indexed newConverterRamp);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        converterRamp = msg.sender;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size > 0;
    }

    function setConverterRamp(address _converterRamp) public onlyOwner {
        require(_isContract(_converterRamp), ""Address is not a contract"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
    }
}"
4079,Get the token spender allowance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

abstract contract TokenAllowanceWrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) Storage;
    }

    function getTokenAllowance(Data storage self, string memory currency, address account, address spender) internal view returns (uint256 allowance) {
        bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, _getForwardedAccount(self, account), _getForwardedAccount(self, spender)));
        return self.Storage[id];
    }

    function _getForwardedAccount(Data storage self, address account) private view returns (address) {
        // Implement any forwarding logic here if necessary
        return account;
    }
}",getTokenAllowance,"[{'function': 'getTokenAllowance', 'complexity': 0}, {'function': 'getForwardedAccount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""token.allowance""}, {""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.7995821822995199,0.3819557750067076,"pragma solidity ^0.8.0;

contract TokenAllowance {

    function getTokenAllowance(string memory currency, address account, address spender) public view returns (uint256) {
        bytes32 id = keccak256(abi.encodePacked(""token.allowance"", currency, account, spender));
        return uint256(id); // Replace this with actual storage retrieval.  This example returns the hash as a placeholder.  A real implementation would use a mapping to store allowances.
    }

    // Placeholder for getForwardedAccount -  Replace with actual implementation if needed.
    function getForwardedAccount(address addr) internal pure returns (address) {
        return addr;
    }
}",41.94095540046692,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenAllowance is Ownable {
    // Initialize state variables to fixed, safe values
    uint256 public constant TOKEN_ALLOWANCE_ID = 1;
    address public constant DEFAULT_SPENDER = 0x1111111111111111111111111111111111111111; // Replace with actual default spender value
    bool public constant DEFAULT_ISInitialized = true;
    bytes32 public constant DEFAULT_INIT_ID = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize state variables in the constructor
        tokenAllowanceId = TOKEN_ALLOWANCE_ID;
        defaultSpender = DEFAULT_SPENDER;
        isInitialized = DEFAULT_ISInitialized;
        initId = DEFAULT_INIT_ID;
    }

    uint256 public tokenAllowanceId;
    address public constant defaultSpender;
    bool public constant isInitialized;
    bytes32 public constant initId;

    // Placeholder for getForwardedAccount -  Replace with actual implementation if needed.
    function getForwardedAccount(address addr) internal pure returns (address) {
        return addr;
    }

    function getTokenAllowance(string memory currency, address account, address spender) public view returns (uint256) {
        bytes32 id = keccak256(abi.encodePacked(""token.allowance"", currency, account, spender));
        return uint256(id); // Replace this with actual storage retrieval.  This example returns the hash as a placeholder.  A real implementation would use a mapping to store allowances.
    }
}"
5836,amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint public tokenMinted;

    function getTokenMinted() public constant returns (uint) {
        return tokenMinted;
    }
}",getTokenMinted,"[{'function': 'getTokenMinted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenMinted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""totalMinted""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9371073459532704,0.4001601601922499,"pragma solidity ^0.8.0;

contract TokenContract {
    uint256 public totalMinted;

    function getTokenMinted() public view returns (uint256) {
        return totalMinted;
    }
}",41.63525152206421,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is Ownable {
    uint256 public totalMinted = 1;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables are already done in the declaration and initialization above.
    }

    function getTokenMinted() public view returns (uint256) {
        return totalMinted;
    }
}"
6399,Sets an external ` manager ` that will be able to call ` setInterfaceImplementer ( ) ` on behalf of the address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ManagerChange {
    using SafeMath for uint256;

    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Only the current manager can change the manager."");
        _;
    }

    function changeManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}",changeManager,"[{'function': 'changeManager', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newManager""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ManagerChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}, {""type"": ""Identifier"", ""name"": ""newManager""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canManage"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract ManagerContract {

    mapping(address => address) public managers;

    event ManagerChanged(address addr, address newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Not authorized"");
        _;
    }

    function changeManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}",41.36868953704834,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ManagerContract is Ownable {
    mapping(address => address) public managers;
    event ManagerChanged(address addr, address newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Not authorized"");
        _;
    }

    function changeManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= type(uint256).max; i++) {
            if (i == 0 || i == 1) continue; // Skip default or zero values
            managers[address(uint160(i))] = address(uint160(i + 1));
        }
    }
}"
5804,Returns current sell offer for the canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasMarketplace is Ownable {
    using SafeMath for uint256;

    struct SellOffer {
        bool isForSale;
        address seller;
        uint minPrice;
        address onlySellTo;
    }

    mapping(uint32 => SellOffer) public canvasForSale;

    function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint minPrice, address onlySellTo) {
        SellOffer storage offer = canvasForSale[_canvasId];
        return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
    }
}",getCurrentSellOffer,"[{'function': 'getCurrentSellOffer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentSellOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""SellOffer""}, ""name"": ""offer"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasForSale""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""isForSale""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""seller""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""minPrice""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""onlySellTo""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.8991375853040612,0.5940370375427819,"pragma solidity ^0.8.0;

struct SellOffer {
    bool isForSale;
    address seller;
    uint256 minPrice;
    address onlySellTo;
}

contract CanvasMarket {
    mapping(uint32 => SellOffer) public canvasForSale;

    function getCurrentSellOffer(uint32 _canvasId) public view returns (bool, address, uint256, address) {
        SellOffer memory offer = canvasForSale[_canvasId];
        return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
    }
}",41.87427258491516,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

struct SellOffer {
    bool isForSale;
    address seller;
    uint256 minPrice;
    address onlySellTo;
}
import ""openzeppelin/SafeMath.sol"";
contract CanvasMarket is Ownable {
    mapping(uint32 => SellOffer) public canvasForSale;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint32 i = 0; i < 10; i++) {
            canvasForSale[i] = SellOffer({
                isForSale: true,
                seller: address(uint160(i + 1)),
                minPrice: uint256(i + 1) * 1 ether,
                onlySellTo: address(uint160(i + 2))
            });
        }
    }

    function getCurrentSellOffer(uint32 _canvasId) public view returns (bool, address, uint256, address) {
        SellOffer memory offer = canvasForSale[_canvasId];
        return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
    }
}"
1832,Generates ` amount ` tokens that are assigned to ` owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function mGenerateTokens(address owner, uint256 amount) internal {
        // logic goes here
    }
}",mGenerateTokens,"[{'function': 'mGenerateTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mGenerateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.3433486098562609,0.1872507591997036,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    uint256 public totalSupply;
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function mGenerateTokens(address owner, uint256 amount) internal {
        require(amount > 0, ""Amount must be greater than zero."");
        totalSupply = totalSupply.add(amount);
        balances[owner] = balances[owner].add(amount);
        emit Transfer(address(0), owner, amount);
    }
}",41.88121223449707,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply = 1000000000000000000;
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        totalSupply = 1000000000000000000;
        for (uint256 i = 0; i < 3; i++) {
            balances[address(uint160(uint256(keccak256(abi.encodePacked(""owner"", i)))))] = 1;
        }
    }

    function mGenerateTokens(address owner, uint256 amount) internal {
        require(amount > 0, ""Amount must be greater than zero."");
        totalSupply = totalSupply.add(amount);
        balances[owner] = balances[owner].add(amount);
        emit Transfer(address(0), owner, amount);
    }
}"
107,Allows the owner to register and the details for a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRegistry is Ownable {
    using SafeMath for uint256;

    struct TokenInfo {
        address tokenAddress;
        uint8 tokenDecimals;
    }

    mapping(uint32 => TokenInfo) public tokenInfos;

    event RegisteredToken(uint32 indexed tokenCode, address indexed tokenAddress, uint8 tokenDecimals);

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(_tokenCode > 0, ""Invalid token code"");
        require(_tokenAddress != address(0), ""Invalid token address"");
        require(_tokenDecimals > 0, ""Invalid token decimals"");

        uint32 tokenCode = _tokenCode;
        address tokenAddress = _tokenAddress;
        uint8 tokenDecimals = _tokenDecimals;

        TokenInfo storage tokenInfo = tokenInfos[tokenCode];
        require(tokenInfo.tokenAddress == address(0), ""Token already registered"");

        tokenInfo.tokenAddress = tokenAddress;
        tokenInfo.tokenDecimals = tokenDecimals;

        emit RegisteredToken(_tokenCode, tokenAddress, tokenDecimals);
    }
}",registerToken,"[{'function': 'registerToken', 'complexity': 1}, {'function': 'owner', 'complexity': 0}]",2.0,{},86.0,0.636227353134645,0.1507883702687569,"pragma solidity ^0.8.0;

contract TokenRegistry {

    struct Token {
        address address;
        uint8 decimals;
    }

    mapping(uint32 => Token) public tokens;

    event TokenRegistered(uint32 indexed tokenCode, address indexed tokenAddress, uint8 tokenDecimals);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(tokens[_tokenCode].address == address(0), ""Token code already registered"");
        tokens[_tokenCode] = Token(_tokenAddress, _tokenDecimals);
        emit TokenRegistered(_tokenCode, _tokenAddress, _tokenDecimals);
    }

    function owner() public view returns (address) {
        return owner;
    }
}",42.29522967338562,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRegistry is Ownable {

    struct Token {
        address address;
        uint8 decimals;
    }

    mapping(uint32 => Token) public tokens;

    event TokenRegistered(uint32 indexed tokenCode, address indexed tokenAddress, uint8 tokenDecimals);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint32 i = 1; i <= 3; i++) {
            tokens[i] = Token(address(uint160(uint256(keccak256(abi.encodePacked(""token"", i)))), 18));
        }
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only owner can call this function"");
        _;
    }

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(tokens[_tokenCode].address == address(0), ""Token code already registered"");
        tokens[_tokenCode] = Token(_tokenAddress, _tokenDecimals);
        emit TokenRegistered(_tokenCode, _tokenAddress, _tokenDecimals);
    }
}"
2044,Mint ` _amount ` tokens that are assigned to ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function updateValueAtNow(mapping(address => uint256) storage data, uint value) external;
}

abstract contract Token is Ownable, IToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint256 => uint256) public totalSupplyHistory;
    bool public finalized;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyController() {
        require(isController[msg.sender], ""Only controller can call this function"");
        _;
    }

    modifier notFinalized() {
        require(!finalized, ""Contract is finalized and cannot be modified"");
        _;
    }

    function mintTokens(address _owner, uint256 _amount) public onlyController notFinalized returns (bool) {
        uint256 curTotalSupply = totalSupply();
        require(curTotalSupply.add(_amount) >= curTotalSupply, ""SafeMath: addition overflow"");
        uint256 previousBalanceTo = balanceOf(_owner);
        require(previousBalanceTo.add(_amount) >= previousBalanceTo, ""SafeMath: addition overflow"");
        updateValueAtNow(balances[_owner], previousBalanceTo.add(_amount));
        updateValueAtNow(totalSupplyHistory, curTotalSupply.add(_amount));
        emit Transfer(address(0), _owner, _amount);
        return true;
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupplyHistory[block.number];
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function updateValueAtNow(mapping(address => uint256) storage data, uint value) internal {
        data[block.number] = value;
    }
}",mintTokens,"[{'function': 'mintTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Mint to the zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""curTotalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""previousBalanceTo"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""curTotalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""curTotalSupply""}}, {""type"": ""stringLiteral"", ""value"": ""Total supply overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousBalanceTo""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""previousBalanceTo""}}, {""type"": ""stringLiteral"", ""value"": ""Balance overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupplyHistory""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""curTotalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceHistory""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousBalanceTo""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""curTotalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousBalanceTo""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.8408715267591377,0.5559709365014088,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    uint256[] public totalSupplyHistory;
    mapping(address => uint256[]) public balanceHistory;
    uint256 public totalSupply;
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function mintTokens(address _owner, uint256 _amount) public returns (bool) {
        require(_owner != address(0), ""Mint to the zero address"");
        uint256 curTotalSupply = totalSupply;
        uint256 previousBalanceTo = balances[_owner];

        require(curTotalSupply.add(_amount) >= curTotalSupply, ""Total supply overflow"");
        require(previousBalanceTo.add(_amount) >= previousBalanceTo, ""Balance overflow"");

        totalSupplyHistory.push(curTotalSupply.add(_amount));
        balanceHistory[_owner].push(previousBalanceTo.add(_amount));

        totalSupply = curTotalSupply.add(_amount);
        balances[_owner] = previousBalanceTo.add(_amount);

        emit Transfer(address(0), _owner, _amount);
        return true;
    }
}",42.856423139572144,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    uint256[] public totalSupplyHistory;
    mapping(address => uint256[]) public balanceHistory;
    uint256 public totalSupply;
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        totalSupply = 1000000000000000000;
        balances[owner()] = 1;
        balanceHistory[owner()] = [1];
        totalSupplyHistory.push(totalSupply);
    }

    function mintTokens(address _owner, uint256 _amount) public returns (bool) {
        require(_owner != address(0), ""Mint to the zero address"");
        uint256 curTotalSupply = totalSupply;
        uint256 previousBalanceTo = balances[_owner];

        require(curTotalSupply.add(_amount) >= curTotalSupply, ""Total supply overflow"");
        require(previousBalanceTo.add(_amount) >= previousBalanceTo, ""Balance overflow"");

        totalSupplyHistory.push(curTotalSupply.add(_amount));
        balanceHistory[_owner].push(previousBalanceTo.add(_amount));

        totalSupply = curTotalSupply.add(_amount);
        balances[_owner] = previousBalanceTo.add(_amount);

        emit Transfer(address(0), _owner, _amount);
        return true;
    }
}"
2892,Makes an offer which can be filled by other users .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Coordinator {
    function onlyCoordinator() external view;
    function onlyActiveState() external view;
}

abstract contract OfferManager is Ownable, SafeMath {
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        uint256 availableAmount;
        uint64 nonce;
    }

    mapping(bytes32 => Offer) public offers;
    address public coordinator;

    event Make(address indexed maker, bytes32 indexed offerHash);

    function makeOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint64 _nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external onlyOwner {
        require(_offerAmount > 0 && _wantAmount > 0, ""Invalid amounts"");
        require(_offerAsset != _wantAsset, ""Invalid assets"");

        bytes32 offerHash = keccak256(abi.encodePacked(""makeOffer"", _maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _feeAsset, _feeAmount, _nonce));

        require(_recoverAddress(offerHash, v, r, s) == _maker, ""Invalid signature"");

        _validateAndAddHash(offerHash);

        _decreaseBalanceAndPayFees(_maker, _offerAsset, _offerAmount, _feeAsset, _feeAmount, ReasonMakerGive, ReasonMakerFeeGive, ReasonMakerFeeReceive);

        Offer storage offer = offers[offerHash];
        offer.maker = _maker;
        offer.offerAsset = _offerAsset;
        offer.wantAsset = _wantAsset;
        offer.offerAmount = _offerAmount;
        offer.wantAmount = _wantAmount;
        offer.availableAmount = _offerAmount;
        offer.nonce = _nonce;

        emit Make(_maker, offerHash);
    }

    function setCoordinator(address _coordinator) external onlyOwner {
        coordinator = _coordinator;
    }

    modifier onlyCoordinator() {
        require(msg.sender == coordinator, ""Only coordinator can call this function"");
        _;
    }

    modifier onlyActiveState() {
        // Assuming there's a way to check if the state is active
        require(isStateActive(), ""Contract state is not active"");
        _;
    }

    function isStateActive() internal view returns (bool) {
        // Implement logic to check if the state is active
        return true; // Placeholder
    }

    function _validateAndAddHash(bytes32 hash) internal {
        // Implement validation and adding of hash logic
    }

    function _decreaseBalanceAndPayFees(
        address account,
        address token,
        uint256 amount,
        address feeToken,
        uint256 feeAmount,
        Reason reasonMakerGive,
        Reason reasonMakerFeeGive,
        Reason reasonMakerFeeReceive
    ) internal {
        // Implement logic to decrease balance and pay fees
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }
}",createOffer,"[{'function': 'createOffer', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""createOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_maker"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_offerAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_wantAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_offerAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_wantAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_feeAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_signature"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_offerAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_wantAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Amounts must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_offerAsset""}, ""right"": {""type"": ""Identifier"", ""name"": ""_wantAsset""}}, {""type"": ""stringLiteral"", ""value"": ""Offer and want assets must be different""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""offerHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""_offerAsset""}, {""type"": ""Identifier"", ""name"": ""_wantAsset""}, {""type"": ""Identifier"", ""name"": ""_offerAmount""}, {""type"": ""Identifier"", ""name"": ""_wantAmount""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""offerHash""}}, ""memberName"": ""maker""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Offer already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ecrecover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""offerHash""}, {""type"": ""NumberLiteral"", ""number"": ""27"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_signature""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_maker""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonces""}, ""index"": {""type"": ""Identifier"", ""name"": ""_maker""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_nonce""}}, {""type"": ""stringLiteral"", ""value"": ""Nonce already used""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_maker""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_offerAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""offerHash""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Offer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""_offerAsset""}, {""type"": ""Identifier"", ""name"": ""_wantAsset""}, {""type"": ""Identifier"", ""name"": ""_offerAmount""}, {""type"": ""Identifier"", ""name"": ""_wantAmount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonces""}, ""index"": {""type"": ""Identifier"", ""name"": ""_maker""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_nonce""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Make""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""offerHash""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",54.0,0.8259005868793177,0.4825143551372653,"pragma solidity ^0.8.0;

contract OfferContract {

    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        uint256 nonce;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(address => uint256) public nonces;
    mapping(address => uint256) public balances;


    event Make(address maker, bytes32 offerHash);

    function createOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint256 _nonce,
        bytes calldata _signature
    ) public {
        require(_offerAmount > 0 && _wantAmount > 0, ""Amounts must be greater than zero"");
        require(_offerAsset != _wantAsset, ""Offer and want assets must be different"");

        bytes32 offerHash = keccak256(
            abi.encodePacked(
                _maker,
                _offerAsset,
                _wantAsset,
                _offerAmount,
                _wantAmount,
                _feeAsset,
                _feeAmount,
                _nonce
            )
        );

        require(offers[offerHash].maker == address(0), ""Offer already exists"");
        require(ecrecover(offerHash, 27, _signature) == _maker, ""Invalid signature"");
        require(nonces[_maker] < _nonce, ""Nonce already used"");

        balances[_maker] -= _offerAmount;
        // Assuming fee payment logic is handled elsewhere, e.g., a separate function.
        // ... fee payment logic ...

        offers[offerHash] = Offer(_maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _nonce);
        nonces[_maker] = _nonce;

        emit Make(_maker, offerHash);
    }
}",44.02646493911743,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OfferContract is Ownable {
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        uint256 nonce;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(address => uint256) public nonces;
    mapping(address => uint256) public balances;

    event Make(address maker, bytes32 offerHash);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 10; i++) {
            balances[address(uint160(i + 1))] = 1 ether; // Set balance to 1 ether for addresses 0x1 to 0xA
        }
    }

    function createOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint256 _nonce,
        bytes calldata _signature
    ) public {
        require(_offerAmount > 0 && _wantAmount > 0, ""Amounts must be greater than zero"");
        require(_offerAsset != _wantAsset, ""Offer and want assets must be different"");

        bytes32 offerHash = keccak256(
            abi.encodePacked(
                _maker,
                _offerAsset,
                _wantAsset,
                _offerAmount,
                _wantAmount,
                _feeAsset,
                _feeAmount,
                _nonce
            )
        );

        require(offers[offerHash].maker == address(0), ""Offer already exists"");
        require(ecrecover(offerHash, 27, _signature) == _maker, ""Invalid signature"");
        require(nonces[_maker] < _nonce, ""Nonce already used"");

        balances[_maker] -= _offerAmount;
        // Assuming fee payment logic is handled elsewhere, e.g., a separate function.
        // ... fee payment logic ...

        offers[offerHash] = Offer(_maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _nonce);
        nonces[_maker] = _nonce;

        emit Make(_maker, offerHash);
    }
}"
5927,A getter to find the level of authority a specific Project has using a self-referential loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminWrapper {
    using SafeMath for uint256;

    struct PledgeAdmin {
        uint adminType;
        uint parentProject;
        // Add other necessary state variables here
    }

    enum PledgeAdminType { Project, Other }

    function getProjectLevel(PledgeAdmin storage m) internal returns (uint) {
        require(m.adminType == uint(PledgeAdminType.Project), ""Invalid admin type"");
        if (m.parentProject == 0) return 1;
        PledgeAdmin storage parentNM = findAdmin(m.parentProject);
        return getProjectLevel(parentNM).add(1);
    }

    function findAdmin(uint projectId) internal view returns (PledgeAdmin storage) {
        // Implement the logic to retrieve the PledgeAdmin struct by projectId
        // This is a placeholder for where you would have your actual implementation
        revert(""Not implemented"");
    }
}",getProjectLevel,"[{'function': 'findAdmin', 'complexity': 0}, {'function': 'getProjectLevel', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getProjectLevel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": ""m"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""assert""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""adminType""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AdminType""}, ""memberName"": ""Project""}}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""parentProject""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": ""parentNM"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""findAdmin""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""parentProject""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getProjectLevel""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""parentNM""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}]}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",8.0,0.8914525119878896,0.4805158075239497,"pragma solidity ^0.8.0;

contract PledgeSystem {
    enum AdminType {Project, Other}
    struct PledgeAdmin {
        uint256 id;
        AdminType adminType;
        uint256 parentProject;
        // ... other fields ...
    }
    mapping(uint256 => PledgeAdmin) public admins;

    function findAdmin(uint256 projectId) internal view returns (PledgeAdmin storage) {
        return admins[projectId];
    }

    function getProjectLevel(PledgeAdmin memory m) internal view returns (uint256) {
        assert(m.adminType == AdminType.Project);
        if (m.parentProject == 0) {
            return 1;
        } else {
            PledgeAdmin storage parentNM = findAdmin(m.parentProject);
            return getProjectLevel(parentNM) + 1;
        }
    }
}",41.968682289123535,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PledgeSystem is Ownable {
    enum AdminType { Project, Other }
    struct PledgeAdmin {
        uint256 id;
        AdminType adminType;
        uint256 parentProject;
        // ... other fields ...
    }
    mapping(uint256 => PledgeAdmin) public admins;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            admins[i] = PledgeAdmin({
                id: i,
                adminType: AdminType.Project,
                parentProject: i == 1 ? 0 : i - 1 // Set parent project for each level
            });
        }
    }

    function findAdmin(uint256 projectId) internal view returns (PledgeAdmin storage) {
        return admins[projectId];
    }

    function getProjectLevel(PledgeAdmin memory m) internal view returns (uint256) {
        assert(m.adminType == AdminType.Project);
        if (m.parentProject == 0) {
            return 1;
        } else {
            PledgeAdmin storage parentNM = findAdmin(m.parentProject);
            return getProjectLevel(parentNM) + 1;
        }
    }
}"
3990,Notifies the controller about a token transfer allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onTransfer(address _from, address _to, uint256 _amount) public returns (bool) {
        return false;
    }
}",onTransfer,"[{'function': 'onTransfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""onTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.9749735406913808,0.8656030552541708,"pragma solidity ^0.8.0;

contract MyContract {

    function onTransfer(address _from, address _to, uint256 _amount) internal returns (bool) {
        return false;
    }
}",41.13596367835999,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant _INITIAL_VALUE = 1;
    address public constant _DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant _DEFAULT_BOOL = true;
    string public constant _DEFAULT_STRING = 'initialized';
    bytes32 public constant _DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        uint256 value = _INITIAL_VALUE;
        address address = _DEFAULT_ADDRESS;
        bool boolValue = _DEFAULT_BOOL;
        string stringValue = _DEFAULT_STRING;
        bytes32 bytes32Value = _DEFAULT_BYTES32;

        // Initialize state variables
        onTransfer(address(0), address(0), value);
        onTransfer(address(0), address(0), address);
        onTransfer(address(0), address(0), boolValue);
        onTransfer(address(0), address(0), stringValue);
        onTransfer(address(0), address(0), bytes32Value);
    }

    function onTransfer(address _from, address _to, uint256 _amount) internal returns (bool) {
        return false;
    }
}"
5074,` onlyOwner ` Cancel a payment all together,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint indexed idPayment);

    function cancelPayment(uint _idPayment) public onlyOwner {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if (p.canceled) revert();
        if (p.paid) revert();
        p.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}",cancelPayment,"[{'function': 'cancelPayment', 'complexity': 5}]",4.0,{},32.0,0.8155329422049676,0.3130616486940437,"pragma solidity ^0.8.0;

contract PaymentContract {

    struct Payment {
        bool canceled;
        bool paid;
        // Add other payment details as needed
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint256 indexed _idPayment);

    modifier onlyOwner() {
        // Add owner logic here.  Replace with your actual owner logic.
        require(msg.sender == 0x..., ""Only owner can call this function"");
        _;
    }

    function cancelPayment(uint256 _idPayment) public onlyOwner {
        require(_idPayment < authorizedPayments.length, ""Payment ID out of bounds"");
        Payment storage payment = authorizedPayments[_idPayment];
        require(!payment.canceled, ""Payment already canceled"");
        require(!payment.paid, ""Payment already paid"");
        payment.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}",42.16635608673096,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentContract is Ownable {

    struct Payment {
        bool canceled;
        bool paid;
        // Add other payment details as needed
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint256 indexed _idPayment);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        authorizedPayments = [Payment({canceled: false, paid: false})];
    }

    modifier onlyOwner() {
        require(msg.sender == 0x1111111111111111111111111111111111111111, ""Only owner can call this function"");
        _;
    }

    function cancelPayment(uint256 _idPayment) public onlyOwner {
        require(_idPayment < authorizedPayments.length, ""Payment ID out of bounds"");
        Payment storage payment = authorizedPayments[_idPayment];
        require(!payment.canceled, ""Payment already canceled"");
        require(!payment.paid, ""Payment already paid"");
        payment.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}"
1247,Helper function that checks for IEIP777TokensOperator on the recipient and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function callOperator(address _operator, address _from, address _to, uint256 _value, bytes memory _userData, bytes memory _operatorData, bool _preventLocking) public onlyOwner {
        address recipientImplementation = interfaceAddr(_to, ""ERC777TokensOperator"");
        if (recipientImplementation != 0) {
            ERC777TokensOperator(recipientImplementation).madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking) {
            require(isRegularAddress(_to), ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"");
        }
    }
}",callOperator,"[{'function': 'madeOperatorForTokens', 'complexity': 0}, {'function': 'interfaceAddr', 'complexity': 2}, {'function': 'isRegularAddress', 'complexity': 0}, {'function': 'callOperator', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""interfaceAddr"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_interfaceName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""success"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x11374ae40>}, {""type"": ""VariableDeclaration"", ""name"": ""data"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113749be0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addr""}, ""memberName"": ""staticcall""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""supportsInterface(bytes4)""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_interfaceName""}], ""names"": []}], ""names"": []}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""decode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""data""}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""ElementaryTypeName"", ""name"": ""address""}], ""isArray"": False}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",,0.9251673408677824,0.5358829616510433,"pragma solidity ^0.8.0;

interface IERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData) external;
}

contract MyContract {
    function interfaceAddr(address _addr, string memory _interfaceName) internal view returns (address) {
        (bool success, bytes memory data) = _addr.staticcall(abi.encodeWithSignature(""supportsInterface(bytes4)"", bytes4(keccak256(bytes(_interfaceName)))));
        if (success && data.length >= 32) {
            return abi.decode(data, (address));
        }
        return address(0);
    }

    function isRegularAddress(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }


    function callOperator(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData, bool _preventLocking) external {
        address recipientInterface = interfaceAddr(_to, ""ERC777TokensOperator"");
        if (recipientInterface != address(0)) {
            IERC777TokensOperator(_to).madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking && !isRegularAddress(_to)) {
            revert(""Recipient is not a regular address and preventLocking is true"");
        }
    }
}",43.500521659851074,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    function interfaceAddr(address _addr, string memory _interfaceName) internal view returns (address) {
        (bool success, bytes memory data) = _addr.staticcall(abi.encodeWithSignature(""supportsInterface(bytes4)"", bytes4(keccak256(bytes(_interfaceName)))));
        if (success && data.length >= 32) {
            return abi.decode(data, (address));
        }
        return address(0);
    }

    function isRegularAddress(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }

    function callOperator(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData, bool _preventLocking) external {
        address recipientInterface = interfaceAddr(_to, ""ERC777TokensOperator"");
        if (recipientInterface != address(0)) {
            IERC777TokensOperator(_to).madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking && !isRegularAddress(_to)) {
            revert(""Recipient is not a regular address and preventLocking is true"");
        }
    }
}"
5500,Approves another address to claim for the ownership of any tokens owned by this account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveAllWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function approveAll(address _to) public onlyOwner {
        require(_to != msg.sender, ""cant approve yourself"");
        require(_to != address(0), ""invalid owner"");
        operatorApprovals[msg.sender][_to] = true;
        emit ApprovalForAll(msg.sender, _to, true);
    }
}",approveAll,"[{'function': 'approveAll', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot approve yourself""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot approve the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operatorApprovals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9738722348249184,0.7522029164456493,"pragma solidity ^0.8.0;

contract ApprovalContract {

    mapping(address => mapping(address => bool)) public operatorApprovals;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function approveAll(address _to) external {
        require(_to != msg.sender, ""Cannot approve yourself"");
        require(_to != address(0), ""Cannot approve the zero address"");

        operatorApprovals[msg.sender][_to] = true;

        emit ApprovalForAll(msg.sender, _to, true);
    }
}",41.483604192733765,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ApprovalContract is Ownable {
    mapping(address => mapping(address => bool)) public operatorApprovals;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveAll(address _to) external {
        require(_to != msg.sender, ""Cannot approve yourself"");
        require(_to != address(0), ""Cannot approve the zero address"");

        operatorApprovals[msg.sender][_to] = true;

        emit ApprovalForAll(msg.sender, _to, true);
    }
}"
4001,Function calls other functions to calculate tokenamount to send to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    Token public token;
    address payable public wallet;
    uint256 public rate;
    uint256 public weiRaised;
    uint256 public tokensSold;

    constructor(uint256 _rate, address payable _wallet, Token _token) {
        require(_rate > 0, ""Crowdsale: rate is 0"");
        require(_wallet != address(0), ""Crowdsale: wallet is the zero address"");
        require(address(_token) != address(0), ""Crowdsale: token is the zero address"");

        rate = _rate;
        wallet = _wallet;
        token = _token;
    }

    function buyTokens(address _beneficiary) public payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        uint256 tokens = _getTokenAmount(weiAmount);
        require(token.balanceOf(address(this)) >= tokens, ""Crowdsale: token contract has insufficient balance"");

        weiRaised = weiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokens);
        _deliverTokens(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
        _processBonus(msg.sender, tokens);
        _forwardFunds();
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure {
        require(_beneficiary != address(0), ""Crowdsale: beneficiary is the zero address"");
        require(_weiAmount > 0, ""Crowdsale: wei amount is 0"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(rate);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(token.transfer(_beneficiary, _tokenAmount), ""Crowdsale: token transfer failed"");
    }

    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function _processBonus(address _investor, uint256 _tokens) internal virtual {
        // Implement bonus logic here
    }
}",buyTokens,"[{'function': 'buyTokens', 'complexity': 1}, {'function': '_preValidatePurchase', 'complexity': 2}, {'function': '_getTokenAmount', 'complexity': 0}, {'function': '_deliverTokens', 'complexity': 0}, {'function': '_processBonus', 'complexity': 0}, {'function': '_forwardFunds', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""weiAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_preValidatePurchase""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getTokenAmount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalWeiRaised""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalWeiRaised""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensSold""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokensSold""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_deliverTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenPurchase""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""weiAmount""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_processBonus""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""weiAmount""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_forwardFunds""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""wallet""}, {""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",8.0,0.9536461124607708,0.7629956199995972,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    uint256 public totalWeiRaised;
    uint256 public tokensSold;
    address payable public wallet;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    function buyTokens(address _beneficiary) public payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        uint256 tokens = _getTokenAmount(weiAmount);
        require(tokens <= address(this).balance, ""Insufficient token balance"");
        totalWeiRaised = totalWeiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokens);
        _deliverTokens(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
        _processBonus(msg.sender, _beneficiary, weiAmount, tokens);
        _forwardFunds(wallet, weiAmount);
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal virtual {
        require(_beneficiary != address(0), ""Beneficiary address cannot be zero"");
        require(_weiAmount > 0, ""Amount must be greater than zero"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal virtual view returns (uint256) {
        // Implement token calculation logic here
        return _weiAmount; // Placeholder: Replace with actual calculation
    }

    function _deliverTokens(address _beneficiary, uint256 _amount) internal virtual {
        // Implement token delivery logic here
    }

    function _processBonus(address _purchaser, address _beneficiary, uint256 _weiAmount, uint256 _tokens) internal virtual {
        // Implement bonus processing logic here
    }

    function _forwardFunds(address payable _beneficiary, uint256 _amount) internal virtual {
        _beneficiary.transfer(_amount);
    }
}",44.23541975021362,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract {
    using SafeMath for uint256;

    uint256 public totalWeiRaised;
    uint256 public tokensSold;
    address payable public wallet;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    constructor() Ownable(msg.sender) {
        totalWeiRaised = 1; // Set to a fixed value
        tokensSold = 0; // Set to zero
        wallet = address(0x1111111111111111111111111111111111111111); // Use a fixed address
    }

    function buyTokens(address _beneficiary) public payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        uint256 tokens = _getTokenAmount(weiAmount);
        require(tokens <= address(this).balance, ""Insufficient token balance"");
        totalWeiRaised = totalWeiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokens);
        _deliverTokens(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
        _processBonus(msg.sender, _beneficiary, weiAmount, tokens);
        _forwardFunds(wallet, weiAmount);
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal virtual {
        require(_beneficiary != address(0), ""Beneficiary address cannot be zero"");
        require(_weiAmount > 0, ""Amount must be greater than zero"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal virtual view returns (uint256) {
        // Implement token calculation logic here
        return _weiAmount; // Placeholder: Replace with actual calculation
    }

    function _deliverTokens(address _beneficiary, uint256 _amount) internal virtual {
        // Implement token delivery logic here
    }

    function _processBonus(address _purchaser, address _beneficiary, uint256 _weiAmount, uint256 _tokens) internal virtual {
        // Implement bonus processing logic here
    }

    function _forwardFunds(address payable _beneficiary, uint256 _amount) internal virtual {
        _beneficiary.transfer(_amount);
    }
}"
267,Redeem required amount of tokens for the real asset,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function redeem(uint256 _tokens) public onlyOwner {
        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address account, uint256 tokens) internal {
        // Implementation of the redeem logic
    }
}",redeem,"[{'function': 'redeem', 'complexity': 0}, {'function': '__redeem_impl', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeem"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""__redeem_impl""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9201880959228298,0.8320381765431424,"pragma solidity ^0.8.0;

contract TokenRedemption {

    function redeem(uint256 _tokens) public {
        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address _redeemer, uint256 _tokens) internal virtual {
        //Implementation for token redemption logic.  This is where checks and state modifications would occur.
    }
}",42.088295459747314,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenRedemption {
    address public constant REDEEMER = 0x1111111111111111111111111111111111111111; // Replace with actual address
    uint256 public constant TOKENS = 1;
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(REDDEMER) {
        __ Redeem_impl(REDDEMER, TOKENS);
    }

    function redeem(uint256 _tokens) public {
        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address _redeemer, uint256 _tokens) internal virtual {
        //Implementation for token redemption logic.  This is where checks and state modifications would occur.
    }
}"
1315,Burns ` _amount ` tokens from ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function balanceOf(address owner) external view returns (uint256);
    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) external;
    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) external view returns (uint256);
}

abstract contract TokenWrapper is Ownable, TokenInterface {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint => uint256) public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function balanceOf(address _owner) public override view returns (uint256 balance) {
        return balances[_owner];
    }

    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) public override view returns (uint256) {
        require(blockNumber <= getBlockNumber(), ""Block number must be in the past"");
        return data[blockNumber];
    }

    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) public override {
        data[getBlockNumber()] = value;
    }

    function getBlockNumber() internal view virtual returns (uint256) {
        return block.number;
    }

    function destroyTokens(address _owner, uint256 _amount) public onlyController returns (bool) {
        uint256 curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());
        require(curTotalSupply >= _amount, ""Insufficient balance"");
        updateValueAtNow(totalSupplyHistory, curTotalSupply.sub(_amount));
        uint256 previousBalanceFrom = balanceOf(_owner);
        require(previousBalanceFrom >= _amount, ""Insufficient balance"");
        updateValueAtNow(balances[_owner], previousBalanceFrom.sub(_amount));
        emit Transfer(_owner, address(0), _amount);
        return true;
    }
}",destroyTokens,"[{'function': 'destroyTokens', 'complexity': 2}, {'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'getValueAt', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTotalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentTotalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient total supply""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ownerBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""ownerBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.7982166219717985,0.4647101273005355,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => uint256) public balanceOfHistory;
    uint256 public totalSupply;
    uint256 public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function destroyTokens(address _owner, uint256 _amount) public returns (bool) {
        uint256 currentTotalSupply = totalSupply;
        require(currentTotalSupply >= _amount, ""Insufficient total supply"");

        uint256 ownerBalance = balances[_owner];
        require(ownerBalance >= _amount, ""Insufficient balance"");

        totalSupply = totalSupply.sub(_amount);
        balances[_owner] = ownerBalance.sub(_amount);

        emit Transfer(_owner, address(0), _amount);
        return true;
    }

    function updateValueAtNow(uint256 _newValue) internal {
        totalSupplyHistory = _newValue;
    }

    function getValueAt(uint256 _blockNumber) public view returns (uint256) {
        return totalSupplyHistory;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}",43.06230354309082,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => uint256) public balanceOfHistory;
    uint256 public totalSupply;
    uint256 public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        balances[owner()] = 1; // Use the owner's address as an example
        totalSupply = 1000000000000000000;
        totalSupplyHistory = 1;
    }

    function destroyTokens(address _owner, uint256 _amount) public returns (bool) {
        uint256 currentTotalSupply = totalSupply;
        require(currentTotalSupply >= _amount, ""Insufficient total supply"");

        uint256 ownerBalance = balances[_owner];
        require(ownerBalance >= _amount, ""Insufficient balance"");

        totalSupply = totalSupply.sub(_amount);
        balances[_owner] = ownerBalance.sub(_amount);

        emit Transfer(_owner, address(0), _amount);
        return true;
    }

    function updateValueAtNow(uint256 _newValue) internal {
        totalSupplyHistory = _newValue;
    }

    function getValueAt(uint256 _blockNumber) public view returns (uint256) {
        return totalSupplyHistory;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}"
4051,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}",isOperatorApproved,"[{'function': 'isOperatorApproved', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isOperatorApproved"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operatorApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.9447175991289714,0.744373319312051,"pragma solidity ^0.8.0;

contract OperatorApprovalChecker {

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function isOperatorApproved(address _owner, address _operator) public view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}",41.23524737358093,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OperatorApprovalChecker is Ownable {
    mapping(address => mapping(address => bool)) public operatorApprovals;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isOperatorApproved(address _owner, address _operator) public view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}"
5314,Modifies the list of overrides for non-accredited limits in USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    event SetNonAccreditedLimit(address indexed investor, uint256 limit);

    function changeNonAccreditedLimit(address[] memory _investors, uint256[] memory _nonAccreditedLimit) public onlyOwner {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");

        for (uint256 i = 0; i < _investors.length; i++) {
            require(_nonAccreditedLimit[i] > 0, ""Limit can not be 0"");

            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];
            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);
        }
    }
}",setNonAccreditedLimits,"[{'function': 'setNonAccreditedLimits', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNonAccreditedLimits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_investors"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_nonAccreditedLimit"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Array length mismatch""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Limit can not be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonAccreditedLimitUSDOverride""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetNonAccreditedLimit""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9773453661764828,0.9303555602149248,"pragma solidity ^0.8.0;

contract InvestmentContract {

    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    event SetNonAccreditedLimit(address indexed investor, uint256 limit);

    function setNonAccreditedLimits(address[] memory _investors, uint256[] memory _nonAccreditedLimit) public {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");
        for (uint256 i = 0; i < _investors.length; i++) {
            require(_nonAccreditedLimit[i] > 0, ""Limit can not be 0"");
            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];
            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);
        }
    }
}",42.1418764591217,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract InvestmentContract is Ownable {
    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    event SetNonAccreditedLimit(address indexed investor, uint256 limit);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        bytes32 initBytes = bytes32('init');
        string memory initializedString = 'initialized';

        for (uint256 i = 0; i < 3; i++) {
            address fixedAddress = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
            nonAccreditedLimitUSDOverride[fixedAddress] = 1; // uint256 set to 1 (never 0)
        }
    }

    function setNonAccreditedLimits(address[] memory _investors, uint256[] memory _nonAccreditedLimit) public {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");
        for (uint256 i = 0; i < _investors.length; i++) {
            require(_nonAccreditedLimit[i] > 0, ""Limit can not be 0"");
            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];
            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);
        }
    }
}"
2308,Return the boolean ( true/false ) registration status for an issuer firm,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Data {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private storageMap;

    function getBool(bytes32 key) public view returns (bool) {
        return storageMap[key];
    }
}

abstract contract RegisteredFirm is Ownable {
    Data private dataStorage;

    constructor() {
        dataStorage = new Data();
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool registered) {
        bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));
        return dataStorage.getBool(id);
    }
}",isRegisteredFirm,"[{'function': 'isRegisteredFirm', 'complexity': 0}]",1.0,{},22.0,0.9529107222653036,0.6719447105931873,"pragma solidity ^0.8.0;

interface IStorage {
    function get(bytes32 key) external view returns (bool);
}

function isRegisteredFirm(IStorage self, string memory issuerFirm) public view returns (bool) {
    bytes32 id = keccak256(abi.encodePacked(""registered.firm"", issuerFirm));
    return self.get(id);
}",43.96637797355652,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IStorage {
    function get(bytes32 key) external view returns (bool);
}

function isRegisteredFirm(IStorage self, string memory issuerFirm) public view returns (bool) {
    bytes32 id = keccak256(abi.encodePacked(""registered.firm"", issuerFirm));
    return self.get(id);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IStorage private _storage;

    constructor(IStorage storageContract, address owner) Ownable(owner) {
        _storage = storageContract;
    }
}"
1642,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool);
}

abstract contract ERC20Token is Ownable {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    bool public transfersEnabled;
    address public controller;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply.mul(10 ** uint256(decimals));
        balances[msg.sender] = totalSupply;
        transfersEnabled = true;
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0), ""Allowance already granted"");
        if (isContract(_spender)) {
            bool onApprove = TokenController(controller).onApprove(msg.sender, _spender, _amount);
            require(onApprove, ""Approval rejected by controller"");
        }
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",approve,"[{'function': 'isContract', 'complexity': 0}, {'function': 'approve', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transfersEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers are disabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Approval already exists. Set to 0 to overwrite.""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IController""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}, ""memberName"": ""onApprove""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Controller rejected approval""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.954568272047584,0.7064126637884753,"pragma solidity ^0.8.0;

contract MyContract {
    mapping (address => mapping (address => uint256)) allowed;
    address public controller;
    bool public transfersEnabled = true;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

    function approve(address _spender, uint256 _amount) public returns (bool) {
        require(transfersEnabled, ""Transfers are disabled"");
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0), ""Approval already exists. Set to 0 to overwrite."");

        if (isContract(controller)) {
            require(IController(controller).onApprove(msg.sender, _spender, _amount), ""Controller rejected approval"");
        }

        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    interface IController {
        function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool);
    }
}",42.6703941822052,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    mapping (address => mapping (address => uint256)) allowed;
    address public controller = 0x1111111111111111111111111111111111111111; // fixed value for address
    bool public transfersEnabled = true;
    bytes32 public initialized = bytes32('init'); // fixed value for bytes32

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        // Initialize Ownable contract
        _Ownable_init();
    }

    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

    function approve(address _spender, uint256 _amount) public returns (bool) {
        require(transfersEnabled, ""Transfers are disabled"");
        require((_amount == 1) || (allowed[msg.sender][_spender] == 1), ""Approval already exists. Set to 1 to overwrite."");

        if (isContract(controller)) {
            require(IController(controller).onApprove(msg.sender, _spender, _amount), ""Controller rejected approval"");
        }

        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    interface IController {
        function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool);
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;

    constructor(address _owner) public {
        require(_owner != address(0), ""Owner cannot be the zero address"");
        owner = _owner;
    }

    function _Ownable_init() internal {
        // Initialize instance variables
        allowed[msg.sender][owner] = 1; // initialize approval for owner
        transfersEnabled = true; // set default value for transfersEnabled
        initialized = bytes32('initialized'); // set default value for initialized
    }
}"
3698,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    address public snt = 0x0;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        require(_token != snt, ""Cannot withdraw SNT tokens"");
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}",claimTokens,"[{'function': 'claimTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot claim Ether using this function""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.8887614006897644,0.6390659897417598,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    event ClaimedTokens(address _token, address owner, uint256 balance);

    function claimTokens(address _token) public onlyOwner {
        require(_token != address(0), ""Cannot claim Ether using this function"");

        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            emit ClaimedTokens(address(0), owner(), address(this).balance);
        } else {
            IERC20 token = IERC20(_token);
            uint256 balance = token.balanceOf(address(this));
            token.transfer(owner(), balance);
            emit ClaimedTokens(_token, owner(), balance);
        }
    }
}",42.312313079833984,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {

    event ClaimedTokens(address _token, address owner, uint256 balance);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function claimTokens(address _token) public onlyOwner {
        require(_token != address(0), ""Cannot claim Ether using this function"");

        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            emit ClaimedTokens(address(0), owner(), address(this).balance);
        } else {
            IERC20 token = IERC20(_token);
            uint256 balance = token.balanceOf(address(this));
            token.transfer(owner(), balance);
            emit ClaimedTokens(_token, owner(), balance);
        }
    }
}"
6060,Set current ICO prices in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public currentTokenPrice;
    bool public preIcoIsRunning;
    uint256 public preICOprice;
    uint256 public ICOprice;

    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function updatePrices() external onlyOwner {
        uint256 oldPrice = currentTokenPrice;
        if (preIcoIsRunning) {
            checkPreIcoStatus();
        }
        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }
        if (oldPrice != currentTokenPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price updated!"");
        }
    }

    function checkPreIcoStatus() internal view {
        // Implement the logic to check pre-ICO status
    }
}",updatePrices,"[{'function': 'checkPreIcoStatus', 'complexity': 0}, {'function': 'updatePrices', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""preIcoIsRunning""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""checkPreIcoStatus""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""preIcoIsRunning""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""preICOprice""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""ICOprice""}}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""oldPrice""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""priceUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldPrice""}, {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, {""type"": ""stringLiteral"", ""value"": ""MetaDollar price updated""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9725592705871544,0.7862454513659143,"pragma solidity ^0.8.0;

contract MetaDollar {

    uint256 public currentTokenPrice;
    uint256 public preICOprice;
    uint256 public ICOprice;
    bool public preIcoIsRunning;

    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function checkPreIcoStatus() internal {
        //Implementation to check preICO status.  Replace this with your actual logic.
        //This example just toggles the status for demonstration.
        preIcoIsRunning = !preIcoIsRunning;
    }


    function updatePrices() public {
        uint256 oldPrice = currentTokenPrice;

        if (preIcoIsRunning) {
            checkPreIcoStatus();
        }

        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }

        if (currentTokenPrice != oldPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""MetaDollar price updated"");
        }
    }
}",42.441810846328735,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MetaDollar is Ownable {
    uint256 public currentTokenPrice = 1;
    uint256 public preICOprice = 1;
    uint256 public ICOprice = 1;
    bool public preIcoIsRunning = true;

    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function checkPreIcoStatus() internal {
        //Implementation to check preICO status. Replace this with your actual logic.
        //This example just toggles the status for demonstration.
        preIcoIsRunning = !preIcoIsRunning;
    }

    function updatePrices() public {
        uint256 oldPrice = currentTokenPrice;

        if (preIcoIsRunning) {
            checkPreIcoStatus();
        }

        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }

        if (currentTokenPrice != oldPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""MetaDollar price updated"");
        }
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
6552,upper bound of series of snapshotIds for which there 's a value in series,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract SnapshotHolder is Ownable {
    using SafeMath for uint256;

    uint256 private _currentSnapshotId;

    function currentSnapshotId() public view onlyOwner returns (uint256) {
        return _currentSnapshotId;
    }
}",getCurrentSnapshotId,"[{'function': 'getCurrentSnapshotId', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentSnapshotId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""snapshotId""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.9077752723064012,0.5181294220614273,"pragma solidity ^0.8.0;

contract SnapshotContract {

    uint256 public snapshotId;

    function getCurrentSnapshotId() public view returns (uint256) {
        return snapshotId;
    }
}",41.25325870513916,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SnapshotContract is Ownable {
    uint256 public snapshotId;

    constructor() Ownable(msg.sender) {
        snapshotId = 1;
    }

    function getCurrentSnapshotId() public view returns (uint256) {
        return snapshotId;
    }
}"
2199,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function mintToken(address target, uint256 mintedAmount) public onlyOwner {
        token.mint(target, mintedAmount);
    }
}",pose,"[{'function': 'pose', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.921528036223293,0.7590994812356263,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./IERC20.sol""; // Assuming you have an IERC20 interface defined

contract MyContract is Ownable {

    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function pose(address target, uint256 mintedAmount) public onlyOwner {
        token.transfer(target, mintedAmount);
    }
}",41.55468225479126,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""./IERC20.sol""; // Assuming you have an IERC20 interface defined
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function pose(address target, uint256 mintedAmount) public onlyOwner {
        token.transfer(target, mintedAmount);
    }
}"
1644,Trim the realitio question content to the part before the initial delimiter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;
    string constant REALITIO_DELIMITER = ""|"";

    function _trimQuestion(string memory q) public pure returns (string memory) {
        return abi.decode(bytes(q).length > 0 ? bytes.concat(bytes(q), bytes(REALITIO_DELIMITER)) : bytes(""""), (string));
    }
}",find,"[{'function': 'toSlice', 'complexity': 0}, {'function': 'toString', 'complexity': 1}, {'function': 'split', 'complexity': 1}, {'function': 'find', 'complexity': 9}, {'function': '_trimQuestion', 'complexity': 0}]",5.0,{},23.0,0.5463489263326816,0.0299896201346837,"pragma solidity ^0.8.0;

library StringUtil {
    function toSlice(string memory self) internal pure returns (Slice memory) {
        return Slice(bytes(self), 0);
    }

    function toString(Slice memory self) internal pure returns (string memory) {
        uint256 len = self._len;
        uint256 ptr = self._ptr;
        bytes memory result = new bytes(len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = bytes(self._buf)[ptr + i];
        }
        return string(result);
    }
}


library Slice {
    struct Slice {
        bytes _buf;
        uint256 _ptr;
        uint256 _len;
    }

    function split(Slice memory self, Slice memory sep) internal pure returns (Slice[] memory) {
        uint256 pos = find(self, sep);
        if (pos == -1) {
            Slice[] memory result = new Slice[](1);
            result[0] = self;
            return result;
        }
        Slice[] memory result = new Slice[](2);
        result[0] = new Slice(self._buf, self._ptr, pos);
        result[1] = new Slice(self._buf, self._ptr + pos + sep._len, self._len - pos - sep._len);
        return result;
    }

    function find(Slice memory self, Slice memory sep) internal pure returns (int256) {
        uint256 len = self._len;
        uint256 sepLen = sep._len;
        uint256 ptr = self._ptr;
        uint256 sepPtr = sep._ptr;
        for (uint256 i = 0; i < len - sepLen + 1; i++) {
            bool match = true;
            for (uint256 j = 0; j < sepLen; j++) {
                if (bytes(self._buf)[ptr + i + j] != bytes(sep._buf)[sepPtr + j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                return int256(i);
            }
        }
        return -1;
    }
}


contract MyContract {
    string constant REALITIO_DELIMITER = ""?"";

    function _trimQuestion(string memory q) public pure returns (string memory) {
        Slice memory qSlice = StringUtil.toSlice(q);
        Slice memory delimiterSlice = StringUtil.toSlice(REALITIO_DELIMITER);
        Slice[] memory parts = Slice.split(qSlice, delimiterSlice);
        return StringUtil.toString(parts[0]);
    }
}",45.23849678039551,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    string constant REALITIO_DELIMITER = ""?"";

    constructor() Ownable(msg.sender) {
        // Initialization of state variables can be done here if needed, but based on the requirements, no changes are necessary for uint/uint256, address, bool, string, bytes32.
    }

    function _trimQuestion(string memory q) public pure returns (string memory) {
        Slice memory qSlice = StringUtil.toSlice(q);
        Slice memory delimiterSlice = StringUtil.toSlice(REALITIO_DELIMITER);
        Slice[] memory parts = Slice.split(qSlice, delimiterSlice);
        return StringUtil.toString(parts[0]);
    }
}

library StringUtil {
    function toSlice(string memory self) internal pure returns (Slice memory) {
        return Slice(bytes(self), 0);
    }

    function toString(Slice memory self) internal pure returns (string memory) {
        uint256 len = self._len;
        uint256 ptr = self._ptr;
        bytes memory result = new bytes(len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = bytes(self._buf)[ptr + i];
        }
        return string(result);
    }
}

library Slice {
    struct Slice {
        bytes _buf;
        uint256 _ptr;
        uint256 _len;
    }

    function split(Slice memory self, Slice memory sep) internal pure returns (Slice[] memory) {
        uint256 pos = find(self, sep);
        if (pos == -1) {
            Slice[] memory result = new Slice[](1);
            result[0] = self;
            return result;
        }
        Slice[] memory result = new Slice[](2);
        result[0] = new Slice(self._buf, self._ptr, pos);
        result[1] = new Slice(self._buf, self._ptr + pos + sep._len, self._len - pos - sep._len);
        return result;
    }

    function find(Slice memory self, Slice memory sep) internal pure returns (int256) {
        uint256 len = self._len;
        uint256 sepLen = sep._len;
        uint256 ptr = self._ptr;
        uint256 sepPtr = sep._ptr;
        for (uint256 i = 0; i < len - sepLen + 1; i++) {
            bool match = true;
            for (uint256 j = 0; j < sepLen; j++) {
                if (bytes(self._buf)[ptr + i + j] != bytes(sep._buf)[sepPtr + j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                return int256(i);
            }
        }
        return -1;
    }
}"
2321,Function to send tokens or refund after the closing time of the funding proposals,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(uint => uint) public pendingAmounts;

    event SentPendingAmount(address indexed buyer, uint indexed id, uint amount);

    function sendPendingAmounts(uint _from, uint _to, address _buyer) public onlyOwner returns (bool) {
        require(_from <= _to);
        for (uint i = _from; i <= _to; i++) {
            if (pendingAmounts[i] > 0) {
                pendingAmounts[i].transfer(address(this));
                emit SentPendingAmount(_buyer, i, pendingAmounts[i]);
                pendingAmounts[i] = 0;
            }
        }
    }
}",sendPendingAmounts,"[{'function': 'sendPendingAmounts', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendPendingAmounts"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_buyer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Buyer address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}, {""type"": ""stringLiteral"", ""value"": ""_from must be less than or equal to _to""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""_to is out of bounds""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyer""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.9072736448768036,0.2649586844486258,"pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    uint256[] public pendingAmounts;

    constructor() {
        owner = msg.sender;
    }

    function sendPendingAmounts(uint256 _from, uint256 _to, address _buyer) public returns (bool) {
        require(msg.sender == owner, ""Only the owner can call this function"");
        require(_buyer != address(0), ""Buyer address cannot be zero"");
        require(_from <= _to, ""_from must be less than or equal to _to"");
        require(_to < pendingAmounts.length, ""_to is out of bounds"");

        for (uint256 i = _from; i <= _to; i++) {
            uint256 amount = pendingAmounts[i];
            pendingAmounts[i] = 0;
            payable(_buyer).transfer(amount);
        }

        return true;
    }
}",42.216912031173706,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner = msg.sender;
    uint256[] public pendingAmounts;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        pendingAmounts = [1]; // Example initialization for uint256 array
    }

    function sendPendingAmounts(uint256 _from, uint256 _to, address _buyer) public returns (bool) {
        require(msg.sender == owner, ""Only the owner can call this function"");
        require(_buyer != address(0), ""Buyer address cannot be zero"");
        require(_from <= _to, ""_from must be less than or equal to _to"");
        require(_to < pendingAmounts.length, ""_to is out of bounds"");

        for (uint256 i = _from; i <= _to; i++) {
            uint256 amount = pendingAmounts[i];
            pendingAmounts[i] = 0;
            payable(_buyer).transfer(amount);
        }

        return true;
    }
}"
5497,Returns asset balance for a particular holder id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IAsset {
    function balanceOf(uint _holderId, bytes32 _symbol) external view returns (uint);
}

abstract contract AssetWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => Asset) public assets;

    struct Asset {
        mapping(uint => Wallet) wallets;
    }

    struct Wallet {
        uint balance;
    }

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol].wallets[_holderId].balance;
    }
}",_balanceOf,"[{'function': '_balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_holderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_symbol"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_symbol""}}, ""memberName"": ""wallets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderId""}}, ""memberName"": ""balance""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract AssetManager {
    struct Asset {
        mapping(uint => Wallet) wallets;
    }

    struct Wallet {
        uint balance;
    }

    mapping(bytes32 => Asset) public assets;

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol].wallets[_holderId].balance;
    }
}",41.48426294326782,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetManager is Ownable {
    struct Asset {
        mapping(uint => Wallet) wallets;
    }

    struct Wallet {
        uint balance;
    }

    mapping(bytes32 => Asset) public assets;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize all state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol].wallets[_holderId].balance;
    }
}"
124,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender; // Simplified ownership check for demonstration purposes
    }
}",approve,"[{'function': 'ownerOf', 'complexity': 0}, {'function': 'approve', 'complexity': 1}, {'function': 'isSpecificallyApprovedFor', 'complexity': 0}, {'function': 'isApprovedForAll', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""ERC721: approve caller is not owner nor approved for all""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allStarIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.9587706176708454,0.6032620004841758,"pragma solidity ^0.8.0;

contract MyContract {

    mapping(uint256 => address) public allStarIndexToApproved;
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function ownerOf(uint256 _tokenId) internal view virtual returns (address) {
        //Implementation for ownerOf function.  Replace with your actual implementation.
        return address(0);
    }

    function approve(address _to, uint256 _tokenId) public {
        require(ownerOf(_tokenId) == msg.sender, ""ERC721: approve caller is not owner nor approved for all"");
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function isSpecificallyApprovedFor(address _to, uint256 _tokenId) internal view returns (bool) {
        return allStarIndexToApproved[_tokenId] == _to;
    }

    function isApprovedForAll(address _owner, address _operator) internal view virtual returns (bool) {
        //Implementation for isApprovedForAll function. Replace with your actual implementation.
        return false;
    }
}",42.73961138725281,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(uint256 => address) public allStarIndexToApproved;
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            allStarIndexToApproved[i] = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
        }
    }

    function ownerOf(uint256 _tokenId) internal view virtual returns (address) {
        //Implementation for ownerOf function. Replace with your actual implementation.
        return address(0);
    }

    function approve(address _to, uint256 _tokenId) public {
        require(ownerOf(_tokenId) == msg.sender, ""ERC721: approve caller is not owner nor approved for all"");
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function isSpecificallyApprovedFor(address _to, uint256 _tokenId) internal view returns (bool) {
        return allStarIndexToApproved[_tokenId] == _to;
    }

    function isApprovedForAll(address _owner, address _operator) internal view virtual returns (bool) {
        //Implementation for isApprovedForAll function. Replace with your actual implementation.
        return false;
    }
}"
467,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    mapping(address => Beneficiary) public beneficiaries;
    IERC20 public token;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        require(token.transfer(owner, balance), ""Token transfer failed"");
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        emit BeneficiaryDestroyed(_beneficiary);
    }
}",destroyBeneficiary,"[{'function': 'destroyBeneficiary', 'complexity': 1}, {'function': 'addBeneficiary', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isBeneficiary""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainingBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestedAmount""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""releasedAmount""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""remainingBalance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalReleased""}, ""right"": {""type"": ""Identifier"", ""name"": ""remainingBalance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isBeneficiary""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""releasedAmount""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""Identifier"", ""name"": ""remainingBalance""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BeneficiaryDestroyed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.7609238435184329,0.2822817360989945,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract VestingSchedule is Ownable {

    IERC20 public token;
    mapping(address => uint256) public vestedAmount;
    mapping(address => uint256) public releasedAmount;
    mapping(address => bool) public isBeneficiary;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address beneficiary);

    constructor(address _token) {
        token = IERC20(_token);
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(isBeneficiary[_beneficiary], ""Beneficiary does not exist"");
        uint256 remainingBalance = vestedAmount[_beneficiary] - releasedAmount[_beneficiary];
        token.transfer(_beneficiary, remainingBalance);
        totalReleased += remainingBalance;
        isBeneficiary[_beneficiary] = false;
        releasedAmount[_beneficiary] += remainingBalance;
        emit BeneficiaryDestroyed(_beneficiary);
    }

    function addBeneficiary(address _beneficiary, uint256 _vestedAmount) public onlyOwner {
        require(!isBeneficiary[_beneficiary], ""Beneficiary already exists"");
        vestedAmount[_beneficiary] = _vestedAmount;
        isBeneficiary[_beneficiary] = true;
    }


}",42.94209218025208,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VestingSchedule is Ownable {

    IERC20 public token;
    mapping(address => uint256) public vestedAmount;
    mapping(address => uint256) public releasedAmount;
    mapping(address => bool) public isBeneficiary;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address beneficiary);

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
        // Initialize state variables with safe, non-corner-case values
        vestedAmount[address(0x111)] = 1;
        vestedAmount[address(0x222)] = 1;
        vestedAmount[address(0x333)] = 1;
        releasedAmount[address(0x111)] = 0;
        releasedAmount[address(0x222)] = 0;
        releasedAmount[address(0x333)] = 0;
        isBeneficiary[address(0x111)] = true;
        isBeneficiary[address(0x222)] = true;
        isBeneficiary[address(0x333)] = true;
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(isBeneficiary[_beneficiary], ""Beneficiary does not exist"");
        uint256 remainingBalance = vestedAmount[_beneficiary] - releasedAmount[_beneficiary];
        token.transfer(_beneficiary, remainingBalance);
        totalReleased += remainingBalance;
        isBeneficiary[_beneficiary] = false;
        releasedAmount[_beneficiary] += remainingBalance;
        emit BeneficiaryDestroyed(_beneficiary);
    }

    function addBeneficiary(address _beneficiary, uint256 _vestedAmount) public onlyOwner {
        require(!isBeneficiary[_beneficiary], ""Beneficiary already exists"");
        vestedAmount[_beneficiary] = _vestedAmount;
        isBeneficiary[_beneficiary] = true;
    }
}"
3604,Adds a co-owner for an asset with provided symbol .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetWrapper {
    using SafeMath for uint256;

    struct Asset {
        mapping(uint => bool) partowners;
    }

    bytes32[] public symbols;
    mapping(bytes32 => Asset) public assets;
    address public eventsHistory;
    uint constant OK = 1;

    modifier onlyOneOfOwners(bytes32 _symbol) {
        require(_isPartowner(_symbol, msg.sender), ""Not a part owner"");
        _;
    }

    function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {
        uint holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);
        return OK;
    }

    function _isPartowner(bytes32 _symbol, address _partowner) internal view returns (bool) {
        for (uint i = 0; ; ++i) {
            if (!assets[_symbol].partowners[i]) {
                return false;
            }
            if (_partowner == address(0)) {
                break;
            }
        }
        return true;
    }

    function _createHolderId(address _partowner) internal pure returns (uint holderId) {
        holderId = uint256(_partowner);
    }
}",addPartOwner,"[{'function': 'addPartOwner', 'complexity': 1}, {'function': '_createHolderId', 'complexity': 0}, {'function': 'onlyOneOfOwners', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addPartOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_symbol"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_partowner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""onlyOneOfOwners""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_symbol""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an owner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""holderId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createHolderId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_partowner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_symbol""}}, ""memberName"": ""partowners""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipChange""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_partowner""}, {""type"": ""Identifier"", ""name"": ""_symbol""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.7593144821404008,0.1934529902282619,"pragma solidity ^0.8.0;

contract MyContract {
    // Define necessary structs and events here...  (Example below)
    struct Asset {
        mapping(uint256 => bool) partowners;
    }

    mapping(bytes32 => Asset) public assets;
    // ... other state variables ...

    event OwnershipChange(address indexed previousOwner, address indexed newOwner, bytes32 indexed assetSymbol);

    // ... other functions ...

    function addPartOwner(bytes32 _symbol, address _partowner) public {
        require(onlyOneOfOwners(_symbol), ""Caller is not an owner"");
        uint256 holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        emit OwnershipChange(address(0), _partowner, _symbol);
    }


    function _createHolderId(address _partowner) internal pure returns (uint256) {
        return uint256(uint160(_partowner));
    }

    function onlyOneOfOwners(bytes32 _symbol) internal view returns (bool) {
        // Implement your logic to check if the caller is an owner of the asset.
        // This will depend on your contract's ownership structure.  Example below:
        //  return assets[_symbol].owners[msg.sender];
    }

    // ... other functions ...
}",42.98313641548157,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Asset {
        mapping(uint256 => bool) partowners;
    }

    mapping(bytes32 => Asset) public assets;

    event OwnershipChange(address indexed previousOwner, address indexed newOwner, bytes32 indexed assetSymbol);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            assets[bytes32(i)] = Asset({partowners: new mapping(uint256 => bool)(0)});
        }
    }

    function addPartOwner(bytes32 _symbol, address _partowner) public {
        require(onlyOneOfOwners(_symbol), ""Caller is not an owner"");
        uint256 holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        emit OwnershipChange(address(0), _partowner, _symbol);
    }

    function _createHolderId(address _partowner) internal pure returns (uint256) {
        return uint256(uint160(_partowner));
    }

    function onlyOneOfOwners(bytes32 _symbol) internal view returns (bool) {
        // Implement your logic to check if the caller is an owner of the asset.
        // This will depend on your contract's ownership structure.  Example below:
        //  return assets[_symbol].owners[msg.sender];
    }
}"
5691,allows participants in the Atonomi network to claim their rewards,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWithdrawal is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public rewards;
    IERC20 public token;
    bool public paused = false;

    event TokensWithdrawn(address indexed user, uint256 amount);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function withdrawTokens() public whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");
        rewards[msg.sender] = rewards[msg.sender].sub(amount);
        emit TokensWithdrawn(msg.sender, amount);
        require(token.transfer(msg.sender, amount), ""token transfer failed"");
        return true;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}",withdrawRewards,"[{'function': 'withdrawRewards', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawRewards"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""amount is zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensWithdrawn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8698705290111114,0.8524063963237851,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract RewardContract is Pausable {

    IERC20 public token;
    mapping(address => uint256) public rewards;

    event TokensWithdrawn(address indexed user, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function withdrawRewards() public whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");
        rewards[msg.sender] = 0;
        emit TokensWithdrawn(msg.sender, amount);
        require(token.transfer(msg.sender, amount), ""token transfer failed"");
        return true;
    }
}",42.39939546585083,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RewardContract is Pausable, Ownable {
    IERC20 public token;
    mapping(address => uint256) public rewards;

    event TokensWithdrawn(address indexed user, uint256 amount);

    constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC20(_tokenAddress);
        _transferOwnership(msg.sender); // Initialize Ownable with the deployer
    }

    function withdrawRewards() public whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");
        rewards[msg.sender] = 0;
        emit TokensWithdrawn(msg.sender, amount);
        require(token.transfer(msg.sender, amount), ""token transfer failed"");
        return true;
    }
}"
2271,Deposit Ether where the contribution is credited to the address specified in the parameter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public isOpen = true;
    address[] public swimmersList;
    mapping(address => bool) public invested;
    mapping(address => uint256) public swimmers;
    uint256 public weiRaised;

    event Deposit(address indexed user, uint256 amount);

    modifier depositIsConfigCompliant() {
        require(isOpen, ""Deposit is not open"");
        _;
    }

    modifier canDeposit(address _user) {
        // Assuming some logic for checking if the user can deposit
        require(/* some condition */, ""User cannot deposit at this time"");
        _;
    }

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            swimmersList.push(_user);
            invested[_user] = true;
        }
        weiRaised = weiRaised.add(msg.value);
        swimmers[_user] = swimmers[_user].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }
}",deposit,"[{'function': 'deposit', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""invested""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swimmersList""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_user""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""invested""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""weiRaised""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""swimmers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Deposit""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isOpen"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""depositIsConfigCompliant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""canDeposit"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_user""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",8.0,0.8638233717151514,0.7095936526189391,"pragma solidity ^0.8.0;

contract MyContract {

    address[] public swimmersList;
    mapping(address => uint256) public swimmers;
    mapping(address => bool) public invested;
    uint256 public weiRaised;

    modifier isOpen() {
        // Add your isOpen logic here
        _;
    }

    modifier depositIsConfigCompliant() {
        // Add your depositIsConfigCompliant logic here
        _;
    }

    modifier canDeposit(address _user) {
        // Add your canDeposit logic here
        _;
    }

    event Deposit(address indexed sender, uint256 amount);

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            swimmersList.push(_user);
            invested[_user] = true;
        }
        weiRaised += msg.value;
        swimmers[_user] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
}",42.48556280136109,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address[] public swimmersList;
    mapping(address => uint256) public swimmers;
    mapping(address => bool) public invested;
    uint256 public weiRaised;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        swimmersList = new address[](1);
        swimmersList[0] = msg.sender;
        swimmers[msg.sender] = 0; // Set initial value for demonstration purposes
        invested[msg.sender] = true;
        weiRaised = 0;
    }

    modifier isOpen() {
        _;
    }

    modifier depositIsConfigCompliant() {
        _;
    }

    modifier canDeposit(address _user) {
        _;
    }

    event Deposit(address indexed sender, uint256 amount);

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            swimmersList.push(_user);
            invested[_user] = true;
        }
        weiRaised += msg.value;
        swimmers[_user] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
}"
2948,The auction contract variable ( saleAuction ) is defined in MasterpieceBase to allow us to refer to them in MasterpieceOwnership to prevent accidental transfers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    SaleClockAuction public saleAuction;

    function setSaleAuctionAddress(address _address) external onlyCEO {
        SaleClockAuction candidateContract = SaleClockAuction(_address);
        require(candidateContract.isSaleClockAuction());
        saleAuction = candidateContract;
    }
}",setSaleAuctionAddress,"[{'function': 'setSaleAuctionAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setSaleAuctionAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ISaleClockAuction""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}, ""memberName"": ""isSaleClockAuction""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid SaleClockAuction address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""saleAuction""}, ""right"": {""type"": ""Identifier"", ""name"": ""_address""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCEO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.8775223357357042,0.3531598970614652,"pragma solidity ^0.8.0;

contract ExampleContract {
    address payable public ceoAddress;
    address public saleAuction;

    constructor(address payable _ceoAddress) {
        ceoAddress = _ceoAddress;
    }

    modifier onlyCEO() {
        require(msg.sender == ceoAddress, ""Only CEO can call this function"");
        _;
    }

    function setSaleAuctionAddress(address _address) public onlyCEO {
        require(ISaleClockAuction(_address).isSaleClockAuction(), ""Invalid SaleClockAuction address"");
        saleAuction = _address;
    }
}

interface ISaleClockAuction {
    function isSaleClockAuction() external view returns (bool);
}",41.82160687446594,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ExampleContract {
    address payable public ceoAddress;
    address public saleAuction;

    constructor(address payable _ceoAddress) {
        ceoAddress = _ceoAddress;
    }

    modifier onlyCEO() {
        require(msg.sender == ceoAddress, ""Only CEO can call this function"");
        _;
    }

    function setSaleAuctionAddress(address _address) public onlyCEO {
        require(ISaleClockAuction(_address).isSaleClockAuction(), ""Invalid SaleClockAuction address"");
        saleAuction = _address;
    }
}

interface ISaleClockAuction {
    function isSaleClockAuction() external view returns (bool);
}"
4839,"Returns the loan metadata , hashed with keccak256 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataHashWrapper is Ownable {
    using SafeMath for uint256;

    struct Loan {
        bytes32 metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadataHash(uint2atural index) public view returns (bytes32) {
        require(index < totalLoans(), ""Index out of bounds"");
        return keccak256(abi.encodePacked(loans[index].metadata));
    }

    function setLoanMetadata(uint256 index, bytes32 metadata) public onlyOwner {
        require(index < totalLoans(), ""Index out of bounds"");
        loans[index].metadata = metadata;
    }

    function totalLoans() internal view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(loans)));
    }
}",tokenMetadataHash,"[{'function': 'tokenMetadataHash', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenMetadataHash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""metadata""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",12.0,0.7446653695008632,0.275472223445892,"pragma solidity ^0.8.0;

contract LoanContract {
    struct Loan {
        bytes metadata;
        // other loan details...
    }

    Loan[] public loans;

    function tokenMetadataHash(uint256 index) public view returns (bytes32) {
        return keccak256(loans[index].metadata);
    }
}",41.370934009552,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoanContract is Ownable {
    struct Loan {
        bytes metadata;
        // other loan details...
    }

    Loan[] public loans;

    function tokenMetadataHash(uint256 index) public view returns (bytes32) {
        return keccak256(loans[index].metadata);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        loans = [Loan({metadata: ""init"".getBytes32()})];
    }
}"
1398,Performs transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transferWithReference(address _to, uint _value, string memory _reference, address _sender) public onlyProxy returns (bool) {
        require(_checkTransferAllowance(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        require(_isValidCountryLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        if (!super.transferWithReference(_to, _value, _reference, _sender)) {
            return false;
        }
        _updateTransferLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender);
        _contractFallbackERC223(_sender, _to, _value);
        return true;
    }

    function _checkTransferAllowance(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for checking transfer allowance
        require(false, ""Not implemented"");
        return false;
    }

    function _isValidCountryLimits(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for validating country limits
        require(false, ""Not implemented"");
        return false;
    }

    function _updateTransferLimits(address _to, uint8 _role, uint _value, address _sender) internal {
        // Implement the logic to update transfer limits
        require(false, ""Not implemented"");
    }

    function _contractFallbackERC223(address _from, address _to, uint _value) internal {
        // Implement the fallback logic for ERC223 contract
        require(false, ""Not implemented"");
    }

    function _getParticipantRoles(address _sender, address _to) internal pure returns (uint8[2] memory roles) {
        // Implement the logic to get participant roles
        require(false, ""Not implemented"");
        return [uint8(0), uint8(0)];
    }
}",transferWithReference,"[{'function': 'transferWithReference', 'complexity': 6}, {'function': '_getParticipantRoles', 'complexity': 0}, {'function': '_checkTransferAllowance', 'complexity': 0}, {'function': '_isValidCountryLimits', 'complexity': 0}, {'function': '__transferWithReference', 'complexity': 0}, {'function': '_updateTransferLimits', 'complexity': 0}, {'function': '_contractFallbackERC223', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferWithReference"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_reference"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""senderRole"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x11380d710>}, {""type"": ""VariableDeclaration"", ""name"": ""recipientRole"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x11380d8d0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getParticipantRoles""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_checkTransferAllowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""senderRole""}, {""type"": ""Identifier"", ""name"": ""recipientRole""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isValidCountryLimits""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""__transferWithReference""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_reference""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_updateTransferLimits""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_contractFallbackERC223""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_reference""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.8651256637016127,0.4865227969957524,"pragma solidity ^0.8.0;

// Assume necessary contracts and interfaces are imported and defined

contract MyContract {

    function transferWithReference(address _to, uint256 _value, string memory _reference, address _sender) public returns (bool) {
        (bytes32 senderRole, bytes32 recipientRole) = _getParticipantRoles(_sender, _to);
        if (!_checkTransferAllowance(senderRole, recipientRole, _value)) {
            return false;
        }
        if (!_isValidCountryLimits(_sender, _to, _value)) {
            return false;
        }
        if (!super.__transferWithReference(_to, _value, _reference)) {
            return false;
        }
        _updateTransferLimits(_to, _value);
        _contractFallbackERC223(_to, _value, _reference);
        return true;
    }

    // Assume _getParticipantRoles, _checkTransferAllowance, _isValidCountryLimits, __transferWithReference, _updateTransferLimits, and _contractFallbackERC223 are defined elsewhere
    function _getParticipantRoles(address _sender, address _recipient) internal view virtual returns (bytes32, bytes32) {
        //Implementation to retrieve roles
        return ("""", """");
    }

    function _checkTransferAllowance(bytes32 _senderRole, bytes32 _recipientRole, uint256 _value) internal view virtual returns (bool) {
        //Implementation to check allowance
        return true;
    }

    function _isValidCountryLimits(address _sender, address _recipient, uint256 _value) internal view virtual returns (bool) {
        //Implementation to check country limits
        return true;
    }

    function __transferWithReference(address _to, uint256 _value, string memory _reference) internal virtual returns (bool) {
        //Implementation to transfer tokens
        return true;
    }

    function _updateTransferLimits(address _recipient, uint256 _value) internal virtual {
        //Implementation to update transfer limits
    }

    function _contractFallbackERC223(address _to, uint256 _value, string memory _reference) internal virtual {
        //Implementation to trigger fallback
    }
}",44.07930946350098,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant INITIAL_VALUE = 1;
    bytes32 public constant INITIALIZED_BYTES = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        senderRole = ""INIT_ROLE"";
        recipientRole = ""INIT_ROLE"";
        allowance = true;
        reference = 'initialized';
        value = INITIAL_VALUE;
        bytes32Value = INITIALIZED_BYTES;
    }

    // State variables with fixed, safe initial values
    bytes32 public senderRole;
    bytes32 public recipientRole;
    bool public allowance;
    string public reference;
    uint256 public value;
    bytes32 public bytes32Value;

    function transferWithReference(address _to, uint256 _value, string memory _reference, address _sender) public returns (bool) {
        (bytes32 senderRole, bytes32 recipientRole) = _getParticipantRoles(_sender, _to);
        if (!_checkTransferAllowance(senderRole, recipientRole, _value)) {
            return false;
        }
        if (!_isValidCountryLimits(_sender, _to, _value)) {
            return false;
        }
        if (!super.__transferWithReference(_to, _value, _reference)) {
            return false;
        }
        _updateTransferLimits(_to, _value);
        _contractFallbackERC223(_to, _value, _reference);
        return true;
    }

    function _getParticipantRoles(address _sender, address _recipient) internal view virtual returns (bytes32, bytes32) {
        //Implementation to retrieve roles
        return (""INIT_ROLE"", ""INIT_ROLE"");
    }

    function _checkTransferAllowance(bytes32 _senderRole, bytes32 _recipientRole, uint256 _value) internal view virtual returns (bool) {
        //Implementation to check allowance
        return true;
    }

    function _isValidCountryLimits(address _sender, address _recipient, uint256 _value) internal view virtual returns (bool) {
        //Implementation to check country limits
        return true;
    }

    function __transferWithReference(address _to, uint256 _value, string memory _reference) internal virtual returns (bool) {
        //Implementation to transfer tokens
        return true;
    }

    function _updateTransferLimits(address _recipient, uint256 _value) internal virtual {
        //Implementation to update transfer limits
    }

    function _contractFallbackERC223(address _to, uint256 _value, string memory _reference) internal virtual {
        //Implementation to trigger fallback
    }
}"
883,Buy from multiple sellers at once to fill a single large order .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITrade {
    function execute(address seller, uint256 quantity, uint256 price) external returns (uint256);
    function isAllowedTrade(address user) external view returns (bool);
}

abstract contract TradeWrapper is Ownable {
    using SafeMath for uint256;

    bool public enforceKyc = false;
    mapping(address => TradeOrder) public orderBook;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
    }

    function setEnforceKyc(bool _enforceKyc) external onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setTradeOrder(address seller, uint256 quantity, uint256 price) external onlyOwner {
        orderBook[seller] = TradeOrder({quantity: quantity, price: price});
    }

    function multiExecute(address[] memory sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {
        require(!enforceKyc || ITrade(this).isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        totalVouchers = 0;
        for (uint i = 0; i < sellers.length; i++) {
            TradeOrder memory to = orderBook[sellers[i]];
            if (i == sellers.length - 1) {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), lastQuantity, to.price);
                totalVouchers += voucherCount;
            } else {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), to.quantity, to.price);
                totalVouchers += voucherCount;
            }
        }
        return totalVouchers;
    }
}",multiExecute,"[{'function': 'isAllowedTrade', 'complexity': 0}, {'function': 'multiExecute', 'complexity': 7}, {'function': 'execute', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiExecute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""sellers"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""enforceKyc"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""enforceKyc""}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isAllowedTrade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""isPrefix"": True}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""You are unknown and not allowed to trade.""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVouchers""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TradeOrder""}, ""name"": ""order"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantityToExecute"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""TrueExpression"": {""type"": ""Identifier"", ""name"": ""lastQuantity""}, ""FalseExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""order""}, ""memberName"": ""quantity""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""execute""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""Identifier"", ""name"": ""quantityToExecute""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""order""}, ""memberName"": ""price""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVouchers""}, ""right"": {""type"": ""Identifier"", ""name"": ""quantityToExecute""}}}]}}, {""type"": ""Identifier"", ""name"": ""totalVouchers""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.7909161901889147,0.3684735990583687,"pragma solidity ^0.8.0;

contract TradeExecutor {

    uint256 public totalVouchers;
    mapping(address => TradeOrder) public orderBook; // Assuming TradeOrder struct is defined elsewhere

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        // Add other relevant fields as needed
    }

    function isAllowedTrade(address _trader) public view virtual returns (bool) {
        //Implementation for KYC check
        return true; //Replace with actual KYC check logic
    }


    function multiExecute(address[] memory sellers, uint256 lastQuantity) public returns (uint256) {
        bool enforceKyc = true; // Replace with actual state variable

        if (enforceKyc && !isAllowedTrade(msg.sender)) {
            revert(""You are unknown and not allowed to trade."");
        }

        totalVouchers = 0;
        for (uint256 i = 0; i < sellers.length; i++) {
            TradeOrder memory order = orderBook[sellers[i]];
            uint256 quantityToExecute = i == sellers.length - 1 ? lastQuantity : order.quantity;
            execute(sellers[i], quantityToExecute, order.price);
            totalVouchers += quantityToExecute;
        }
        return totalVouchers;
    }

    function execute(address seller, uint256 quantity, uint256 price) internal virtual {
        //Implementation for trade execution.  This function should handle updating the orderbook and transferring funds/tokens.
    }
}",43.29497623443604,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TradeExecutor is Ownable {
    uint256 public totalVouchers = 1;
    mapping(address => TradeOrder) public orderBook; // Assuming TradeOrder struct is defined elsewhere

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        // Add other relevant fields as needed
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isAllowedTrade(address _trader) public view virtual returns (bool) {
        //Implementation for KYC check
        return true; //Replace with actual KYC check logic
    }

    function multiExecute(address[] memory sellers, uint256 lastQuantity) public returns (uint256) {
        bool enforceKyc = true; // Replace with actual state variable

        if (enforceKyc && !isAllowedTrade(msg.sender)) {
            revert(""You are unknown and not allowed to trade."");
        }

        totalVouchers = 0;
        for (uint256 i = 0; i < sellers.length; i++) {
            TradeOrder memory order = orderBook[sellers[i]];
            uint256 quantityToExecute = i == sellers.length - 1 ? lastQuantity : order.quantity;
            execute(sellers[i], quantityToExecute, order.price);
            totalVouchers += quantityToExecute;
        }
        return totalVouchers;
    }

    function execute(address seller, uint256 quantity, uint256 price) internal virtual {
        //Implementation for trade execution.  This function should handle updating the orderbook and transferring funds/tokens.
    }
}"
2617,Set current mtdAmount price in wei for one token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MTDContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdAmount;

    function setMtdAmount(uint256 mtdAmountInWei) public onlyOwner {
        require(mtdAmountInWei > 0, ""MTD amount must be greater than zero"");
        require(mtdAmount != mtdAmountInWei, ""MTD amount has not changed"");
        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices function
    }
}",setMtdAmount,"[{'function': 'setMtdAmount', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMtdAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mtdAmountInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmountInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmountInWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""mtdAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be different from current amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""mtdAmountInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.954665199714504,0.630005037806172,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public mtdAmount;

    function setMtdAmount(uint256 mtdAmountInWei) public {
        require(mtdAmountInWei > 0, ""Amount must be greater than zero"");
        require(mtdAmountInWei != mtdAmount, ""Amount must be different from current amount"");
        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal virtual {
        //Implementation for updating prices
    }
}",41.35593819618225,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public mtdAmount;

    constructor() Ownable(msg.sender) {
        mtdAmount = 1; // Set to 1 (never 0)
    }

    function setMtdAmount(uint256 mtdAmountInWei) public {
        require(mtdAmountInWei > 0, ""Amount must be greater than zero"");
        require(mtdAmountInWei != mtdAmount, ""Amount must be different from current amount"");
        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal virtual {
        //Implementation for updating prices
    }
}"
191,"Change period duration to ` @ transformTime ( _periodDuration ) ` , effective for next accounting period","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISettings {
    function periodDuration() external view returns (uint64);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Settings {
        uint64 periodDuration;
    }

    Settings public settings;

    event ChangePeriodDuration(uint64 indexed periodDuration);

    error ERROR_SET_PERIOD_TOO_SHORT();

    function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE, arr(uint256(_periodDuration), uint256(settings.periodDuration))) transitionsPeriod {
        require(_periodDuration >= 1 days, ERROR_SET_PERIOD_TOO_SHORT);
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }
}",setPeriodDuration,"[{'function': 'setPeriodDuration', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPeriodDuration"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}, {""type"": ""stringLiteral"", ""value"": ""ERROR_SET_PERIOD_TOO_SHORT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ChangePeriodDuration""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_periodDuration""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""authP"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""CHANGE_PERIOD_ROLE""}]}, {""type"": ""ModifierInvocation"", ""name"": ""transitionsPeriod"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.7876806265776457,0.5847091207724948,"pragma solidity ^0.8.0;

contract MyContract {
    // Define necessary structs, enums, and state variables here...
    struct Settings {
        uint64 periodDuration;
        // ... other settings
    }
    Settings public settings;
    // ... other state variables, roles, and modifiers ...

    event ChangePeriodDuration(uint64 newPeriodDuration);

    modifier authP(bytes32 role) {
        // ... implementation of authP modifier ...
        _;
    }

    modifier transitionsPeriod() {
        // ... implementation of transitionsPeriod modifier ...
        _;
    }

    error SetPeriodTooShort();

    function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE) transitionsPeriod {
        require(_periodDuration >= 1 days, ""ERROR_SET_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }

    // ... rest of the contract ...
}",42.40007781982422,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Settings {
        uint64 periodDuration;
        // ... other settings
    }
    Settings public settings;
    // ... other state variables, roles, and modifiers ...

    event ChangePeriodDuration(uint64 newPeriodDuration);

    modifier authP(bytes32 role) {
        // ... implementation of authP modifier ...
        _;
    }

    modifier transitionsPeriod() {
        // ... implementation of transitionsPeriod modifier ...
        _;
    }

    error SetPeriodTooShort();

    constructor() Ownable(msg.sender) {
        settings = Settings({periodDuration: 1 days, /* other initializations */});
    }

    function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE) transitionsPeriod {
        require(_periodDuration >= 1 days, ""ERROR_SET_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }

    // ... rest of the contract ...
}"
243,Allows resetting the entire bid decryption/appending process in case a mistake was made and it is not possible to continue appending further bids .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum state { active, ended }

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
    }

    mapping(uint => Bid) public bids;
    uint[] public bids_decrypted;
    uint public bids_reset_count;
    uint public bids_decrypted_count;
    uint public bids_sorted_count;
    uint public bids_ignored_count;
    uint public bids_burned_count;
    state public status;

    function resetAppendDecryptedBids(uint _count) public onlyOwner {
        require(status == state.ended);
        require(bids_decrypted_count > 0);
        require(_count > 0);

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted_count;
        }

        uint count = _count;
        if (bids_reset_count < count) {
            count = bids_reset_count;
        }

        do {
            bids_reset_count--;
            bids[bids_decrypted[bids_reset_count]].is_decrypted = false;
            bids[bids_decrypted[bids_reset_count]].is_burned = false;
            bids[bids_decrypted[bids_reset_count]].will_compute = false;
            count--;
        } while (count > 0);

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}",resetAndAppendDecryptedBids,"[{'function': 'resetAndAppendDecryptedBids', 'complexity': 8}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""resetAndAppendDecryptedBids"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_count"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""contract_status""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Contract must be in the ""ended"" state""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids_decrypted""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""There must be at least one decrypted bid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""The provided count must be greater than zero""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids_decrypted""}, ""memberName"": ""length""}}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""count"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_count""}, ""right"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}}, ""TrueExpression"": {""type"": ""Identifier"", ""name"": ""_count""}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""count""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids_decrypted""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""is_decrypted""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""is_burned""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""will_compute""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""Identifier"", ""name"": ""count""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_sorted_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_ignored_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_decrypted_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_burned_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",46.0,0.9083704929769671,0.3130030000707151,"pragma solidity ^0.8.0;

contract MyContract {
    // ... other contract code ...

    uint256 public bids_reset_count;
    uint256 public bids_sorted_count;
    uint256 public bids_ignored_count;
    uint256 public bids_decrypted_count;
    uint256 public bids_burned_count;
    uint256 public contract_status; // 0: not started, 1: active, 2: ended

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
        // ... other bid fields ...
    }

    Bid[] public bids;
    uint256[] public bids_decrypted;

    // ... other contract code ...

    function resetAndAppendDecryptedBids(uint256 _count) public {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        require(contract_status == 2, ""Contract must be in the 'ended' state"");
        require(bids_decrypted.length > 0, ""There must be at least one decrypted bid"");
        require(_count > 0, ""The provided count must be greater than zero"");

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted.length;
        }

        uint256 count = _count < bids_reset_count ? _count : bids_reset_count;

        for (uint256 i = 0; i < count; i++) {
            uint256 index = bids_decrypted[bids_reset_count - 1 - i];
            bids[index].is_decrypted = false;
            bids[index].is_burned = false;
            bids[index].will_compute = false;
        }

        bids_reset_count -= count;

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }

    // ... other contract code ...

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }
}",44.49936842918396,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public bids_reset_count;
    uint256 public bids_sorted_count;
    uint256 public bids_ignored_count;
    uint256 public bids_decrypted_count;
    uint256 public bids_burned_count;
    uint256 public contract_status; // 0: not started, 1: active, 2: ended

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
        // ... other bid fields ...
    }

    Bid[] public bids;
    uint256[] public bids_decrypted;

    address public owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        contract_status = 0; // Initialize to not started
        bids_reset_count = 0;
        bids_sorted_count = 0;
        bids_ignored_count = 0;
        bids_decrypted_count = 0;
        bids_burned_count = 0;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    function resetAndAppendDecryptedBids(uint256 _count) public {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        require(contract_status == 2, ""Contract must be in the 'ended' state"");
        require(bids_decrypted.length > 0, ""There must be at least one decrypted bid"");
        require(_count > 0, ""The provided count must be greater than zero"");

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted.length;
        }

        uint256 count = _count < bids_reset_count ? _count : bids_reset_count;

        for (uint256 i = 0; i < count; i++) {
            uint256 index = bids_decrypted[bids_reset_count - 1 - i];
            bids[index].is_decrypted = false;
            bids[index].is_burned = false;
            bids[index].will_compute = false;
        }

        bids_reset_count -= count;

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}"
6808,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public buyPrice;
    uint256 public sellPrice;

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}",setPrices,"[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,1.0,1.0,"pragma solidity ^0.8.0;

contract PriceSetter {

    uint256 public buyPrice;
    uint256 public sellPrice;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}",41.69272708892822,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceSetter is Ownable {
    uint256 public buyPrice;
    uint256 public sellPrice;

    constructor() Ownable(msg.sender) {
        buyPrice = 1;
        sellPrice = 1;
    }

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        require(newBuyPrice != 0, ""Invalid buy price"");
        require(newSellPrice != 0, ""Invalid sell price"");
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}"
4005,Buy quantity of tokens depending on the amount of sent ethers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event SoldToken(address indexed buyer, uint256 value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function BuyToken(address _buyer, uint256 _value, string memory note) public onlyOwner {
        require(balances[msg.sender] >= _value && balances[_buyer].add(_value) > balances[_buyer], ""Insufficient balance or overflow"");
        SoldToken(_buyer, _value, note);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_buyer] = balances[_buyer].add(_value);
        Transfer(msg.sender, _buyer, _value);
    }
}",BuyToken,"[{'function': 'BuyToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""BuyToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""note"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}}, {""type"": ""stringLiteral"", ""value"": ""Overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SoldToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""note""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.8875263705680553,0.5647181710910268,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event SoldToken(address indexed _buyer, uint256 _value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function BuyToken(address _buyer, uint256 _value, string memory note) public {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        require(balanceOf[_buyer].add(_value) >= balanceOf[_buyer], ""Overflow"");

        SoldToken(_buyer, _value, note);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_buyer] = balanceOf[_buyer].add(_value);
        emit Transfer(msg.sender, _buyer, _value);
    }
}",42.13824534416199,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event SoldToken(address indexed _buyer, uint256 _value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set initial balance for the owner
    }

    function BuyToken(address _buyer, uint256 _value, string memory note) public {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        require(balanceOf[_buyer].add(_value) >= balanceOf[_buyer], ""Overflow"");

        SoldToken(_buyer, _value, note);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_buyer] = balanceOf[_buyer].add(_value);
        emit Transfer(msg.sender, _buyer, _value);
    }
}"
5639,Transfers asset balance from the caller to specified receiver .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return _transferWithReference(_to, _value, """");
        }
    }
}",transfer,"[{'function': 'transfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Transfer to the zero address""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transferWithReference""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""stringLiteral"", ""value"": """"}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.9229385942217806,0.6374393444596219,"pragma solidity ^0.8.0;

contract Token {

    function transfer(address _to, uint256 _value) internal returns (bool) {
        require(_to != address(0), ""Transfer to the zero address"");
        return _transferWithReference(_to, _value, """");
    }

    function _transferWithReference(address _to, uint256 _value, string memory _reference) internal virtual returns (bool);
}",41.83790183067322,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    function transfer(address _to, uint256 _value) internal returns (bool) {
        require(_to != address(0), ""Transfer to the zero address"");
        return _transferWithReference(_to, _value, """");
    }

    function _transferWithReference(address _to, uint256 _value, string memory _reference) internal virtual returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Token {
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name;
    string public symbol;
    uint8 public decimals;

    address public owner;

    constructor() {
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
        balanceOf[msg.sender] = totalSupply;
        owner = msg.sender; // Use the sender's address as the initial owner
        name = 'initialized'; // Set to 'initialized'
        symbol = 'TKN'; // Placeholder value for ERC20 constructor argument
        decimals = 18; // Default decimal places
    }
}"
971,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",approve,"[{'function': 'approve', 'complexity': 0}, {'function': 'approve', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.963602946669526,0.3679437324761364,"pragma solidity ^0.8.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract MyToken is IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // ... other functions ...
}",42.10745191574097,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyToken is IERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // ... other functions ...
}"
2396,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract OfferWrapper is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    bool public enforceKyc = false;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed user, uint256 quantity, uint256 price, uint256 expiry);

    function offer(uint256 quantity, uint256 price, uint256 expiry) public {
        require(enforceKyc == false || isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = ERC20Interface(_tokenContract);
    }

    function setEnforceKyc(bool _enforceKyc) public onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setSellFloor(uint256 _sellFloor) public onlyOwner {
        sellFloor = _sellFloor;
    }

    function setSellCeiling(uint256 _sellCeiling) public onlyOwner {
        sellCeiling = _sellCeiling;
    }

    function isAllowedTrade(address user) internal view returns (bool) {
        // Implement your KYC logic here
        return true; // Placeholder for actual implementation
    }
}",offer,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'isAllowedTrade', 'complexity': 0}, {'function': 'offer', 'complexity': 10}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""offer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Conditional"", ""condition"": {""type"": ""Identifier"", ""name"": ""enforceKyc""}, ""TrueExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isAllowedTrade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""FalseExpression"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""stringLiteral"", ""value"": ""KYC check failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Quantity must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""expiry""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Expiry must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellFloor""}}, {""type"": ""stringLiteral"", ""value"": ""Price below minimum allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}}}, {""type"": ""stringLiteral"", ""value"": ""Price exceeds maximum allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TradeOrder""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensOffered""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.9217002911884912,0.4564408185497685,"pragma solidity ^0.8.0;

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

contract TradeContract {
    struct TradeOrder {
        address trader;
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;
    bool public enforceKyc;
    uint256 public sellFloor;
    uint256 public sellCeiling;
    ERC20Interface public token;

    event TokensOffered(address indexed trader, uint256 quantity, uint256 price, uint256 expiry);

    constructor(address _tokenAddress) {
        token = ERC20Interface(_tokenAddress);
    }

    function isAllowedTrade(address _trader) internal view returns (bool) {
        // Add your KYC logic here.  Return true if allowed, false otherwise.
        return true;
    }


    function offer(uint256 quantity, uint256 price, uint256 expiry) public {
        require(enforceKyc ? isAllowedTrade(msg.sender) : true, ""KYC check failed"");
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(price > 0, ""Price must be greater than zero"");
        require(expiry > block.timestamp, ""Expiry must be in the future"");
        require(price >= sellFloor, ""Price below minimum allowed"");
        require(sellCeiling == 0 || price <= sellCeiling, ""Price exceeds maximum allowed"");
        require(token.allowance(msg.sender, address(this)) >= quantity, ""Insufficient allowance"");
        require(token.balanceOf(msg.sender) >= quantity, ""Insufficient balance"");

        orderBook[msg.sender] = TradeOrder(msg.sender, quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}",44.31731772422791,"pragma solidity ^0.8.0;

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract TradeContract is Ownable {
    struct TradeOrder {
        address trader;
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;
    bool public enforceKyc;
    uint256 public sellFloor;
    uint256 public sellCeiling;
    ERC20Interface public token;

    event TokensOffered(address indexed trader, uint256 quantity, uint256 price, uint256 expiry);

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = ERC20Interface(_tokenAddress);
        sellFloor = 1; // Set to 1 (never 0)
        enforceKyc = true; // Default value for bool, set to true
        sellCeiling = 0; // Set to 0 for uint256
    }

    function isAllowedTrade(address _trader) internal view returns (bool) {
        // Add your KYC logic here. Return true if allowed, false otherwise.
        return true;
    }

    function offer(uint256 quantity, uint256 price, uint256 expiry) public {
        require(enforceKyc ? isAllowedTrade(msg.sender) : true, ""KYC check failed"");
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(price > 0, ""Price must be greater than zero"");
        require(expiry > block.timestamp, ""Expiry must be in the future"");
        require(price >= sellFloor, ""Price below minimum allowed"");
        require(sellCeiling == 0 || price <= sellCeiling, ""Price exceeds maximum allowed"");
        require(token.allowance(msg.sender, address(this)) >= quantity, ""Insufficient allowance"");
        require(token.balanceOf(msg.sender) >= quantity, ""Insufficient balance"");

        orderBook[msg.sender] = TradeOrder(msg.sender, quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}"
2112,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed receiver, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}",claimTokens,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""controller""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8861391655123692,0.4180377679643338,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract MyContract {
    address public controller;

    event ClaimedTokens(address indexed token, address indexed recipient, uint256 amount);

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor(address _controller) {
        controller = _controller;
    }

    function claimTokens(address _token) external onlyController {
        uint256 amount;
        if (_token == address(0)) {
            amount = address(this).balance;
            payable(controller).transfer(amount);
        } else {
            IERC20 token = IERC20(_token);
            amount = token.balanceOf(address(this));
            token.transfer(controller, amount);
        }
        emit ClaimedTokens(_token, controller, amount);
    }
}",42.45833086967468,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public controller;

    event ClaimedTokens(address indexed token, address indexed recipient, uint256 amount);

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _controller) Ownable(_controller) {
        controller = _controller;
    }

    function claimTokens(address _token) external onlyController {
        uint256 amount;
        if (_token == address(0)) {
            amount = address(this).balance;
            payable(controller).transfer(amount);
        } else {
            IERC20 token = IERC20(_token);
            amount = token.balanceOf(address(this));
            token.transfer(controller, amount);
        }
        emit ClaimedTokens(_token, controller, amount);
    }
}"
5098,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public withdrawalRequests;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        if (withdrawalRequests[_from] > 0) revert();
        if (withdrawalRequests[_to] > 0) revert();
        if (balanceOf[_from].sub(balanceOf[_from]) != balanceOf[_from]) revert();
        if (balanceOf[_to].add(_value) < balanceOf[_to]) revert();
        if (_value.add(allowance[_from][msg.sender]) != allowance[_from][msg.sender]) revert();
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}",transferFrom,"[{'function': 'transferFrom', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""stringLiteral"", ""value"": ""Overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",58.0,0.5856238593576749,0.2157682420601597,"pragma solidity ^0.8.0;

contract ERC20 {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(allowances[_from][msg.sender] >= _value, ""Insufficient allowance"");
        require(balances[_to] + _value >= balances[_to], ""Overflow"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }


}",42.45034718513489,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ERC20 {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() ERC20(""MyToken"", ""TKN"") {
        balances[msg.sender] = 1000; // Initialize with a non-zero value
        allowances[msg.sender][address(0)] = 1; // Allow transfer to anyone
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(allowances[_from][msg.sender] >= _value, ""Insufficient allowance"");
        require(balances[_to] + _value >= balances[_to], ""Overflow"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public {
        require(newOwner != address(0), ""Cannot set zero address"");
        require(newOwner != owner, ""New owner cannot be current owner"");

        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract ModifiedContract is ERC20, Ownable {
    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {}
}"
3297,Used by a staker to withdraw their initial stake,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    enum StakeStateEnum { staked, released }

    struct Stake {
        uint256 initialStake;
        StakeStateEnum state;
    }

    mapping(address => mapping(uint256 => Stake)) public stakes;
    uint256 public activeStakes;
    mapping(address => uint256) public internalRTCBalances;
    IERC20 public RTI;

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staked, ""Invalid stake state"");
        _;
    }

    function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {
        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.released;
        activeStakes = activeStakes.sub(1);
        internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
        require(RTI.transfer(msg.sender, initialStake), ""Unable to transfer tokens likely due to incorrect balance"");
        return true;
    }
}",withdrawInitialStake,"[{'function': 'withdrawInitialStake', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawInitialStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_stakeNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""initialStake"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_stakeNumber""}}, ""memberName"": ""initialStake""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_stakeNumber""}}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""StakeStateEnum""}, ""memberName"": ""staked""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""activeStakes""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""internalRTCBalances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""initialStake""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InitialStakeWithdrawn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_stakeNumber""}, {""type"": ""Identifier"", ""name"": ""initialStake""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RTI""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""initialStake""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validInitialStakeRelease"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_stakeNumber""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8593402305302715,0.4246801106857918,"pragma solidity ^0.8.0;

enum StakeStateEnum {
    pending,
    staked,
    released
}

contract MyContract {
    // ... other contract elements ...

    mapping(address => mapping(uint256 => Stake)) public stakes;
    uint256 public activeStakes;
    mapping(address => uint256) public internalRTCBalances;

    struct Stake {
        uint256 initialStake;
        StakeStateEnum state;
        // ... other stake properties ...
    }

    // ... other contract elements ...

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.pending, ""Stake is not pending"");
        _;
    }

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    function withdrawInitialStake(uint256 _stakeNumber) external validInitialStakeRelease(_stakeNumber) {
        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.staked;
        activeStakes--;
        internalRTCBalances[msg.sender] -= initialStake;
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
        require(RTI.transfer(msg.sender, initialStake), ""Transfer failed"");
    }

    // ... other contract elements ...
    IERC20 public RTI; // Assuming RTI is an ERC20 token

    constructor(address _rtiAddress) {
        RTI = IERC20(_rtiAddress);
    }

    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }
    // ... other contract elements ...
}",43.39769387245178,"pragma solidity ^0.8.0;

enum StakeStateEnum {
    pending,
    staked,
    released
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => mapping(uint256 => Stake)) public stakes;
    uint256 public activeStakes;
    mapping(address => uint256) public internalRTCBalances;

    struct Stake {
        uint256 initialStake;
        StakeStateEnum state;
        // ... other stake properties ...
    }

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.pending, ""Stake is not pending"");
        _;
    }

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    function withdrawInitialStake(uint256 _stakeNumber) external validInitialStakeRelease(_stakeNumber) {
        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.staked;
        activeStakes--;
        internalRTCBalances[msg.sender] -= initialStake;
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
        require(RTI.transfer(msg.sender, initialStake), ""Transfer failed"");
    }

    IERC20 public RTI; // Assuming RTI is an ERC20 token

    constructor(address _rtiAddress) Ownable(_rtiAddress) {
        RTI = IERC20(_rtiAddress);
    }

    interface IERC20 {
        function transfer(address recipient, uint256 amount) external returns (bool);
    }
}"
1877,A function which allows the caller to approve the max amount of any given token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeERC20 {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 value) internal returns (bool) {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(ERC20.approve.selector, spender, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""SafeERC20: approve failed"");
        return true;
    }
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function approveAddress(address addressToApprove, address token) public onlyOwner {
        if (ERC20(token).allowance(address(this), addressToApprove) == 0) {
            require(SafeERC20.safeApprove(token, addressToApprove, uint256(-1)));
        }
    }
}",approveAddress,"[{'function': 'approveAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addressToApprove"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""safeApprove""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addressToApprove""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.6153096367712192,0.0082188641310323,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract MyContract {
    using SafeERC20 for IERC20;

    function approveAddress(address addressToApprove, address token) public {
        IERC20(token).safeApprove(addressToApprove, type(uint256).max);
    }
}",41.387351989746094,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeERC20 for IERC20;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        uint256 _uintValue = 1;
        address _addressValue = 0x1111111111111111111111111111111111111111; // Replace with actual address
        bool _boolValue = true;
        string _stringValue = 'initialized';
        bytes32 _bytes32Value = bytes32('init');
    }

    function approveAddress(address addressToApprove, address token) public {
        IERC20(token).safeApprove(addressToApprove, type(uint256).max);
    }
}"
