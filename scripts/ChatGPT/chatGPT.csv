ID,Comment,Contract,ChatGPTGenerated,Time,target_function,GPTCognitiveComplexity,GPTCyclomaticComplexity,ast,TED,SemanticSimilarity,BLEU,contract_with_constructor
3024,Announce that a particular future Ethereum fork will the one taken by the contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""Caller is not a role"");
        _;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ForkAnnouncement is Ownable {
    string private _forkDetails;

    function announceFork(string memory newFork) public onlyOwner {
        _forkDetails = newFork;
    }

    function getForkDetails() public view returns (string memory) {
        require(bytes(_forkDetails).length > 0, ""Fork details not set yet"");
        return _forkDetails;
    }
}",5.533228874206543,getForkDetails,"[{'function': 'announceFork', 'complexity': 0}, {'function': 'getForkDetails', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getForkDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_forkDetails""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Fork details not set yet""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""_forkDetails""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",32.0,0.6114027290072553,0.0809791369899854,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ForkAnnouncement is Ownable {
    string private _forkDetails;

    constructor() Ownable(msg.sender) {
        _forkDetails = 'initialized';
    }

    function announceFork(string memory newFork) public onlyOwner {
        _forkDetails = newFork;
    }

    function getForkDetails() public view returns (string memory) {
        require(bytes(_forkDetails).length > 0, ""Fork details not set yet"");
        return _forkDetails;
    }
}"
2295,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    constructor(address _tokenContract, uint256 _sellFloor, uint256 _sellCeiling) {
        tokenContract = ERC20Interface(_tokenContract);
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function sell(uint256 quantity, uint256 price, uint256 expiry) public {
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is ReentrancyGuard, Ownable {
    IERC20 public token;

    uint256 public price;

    constructor(IERC20 _token, uint256 _price) {
        require(address(_token) != address(0));
        require(_price > 0);

        token = _token;
        price = _price;
    }

    function offerTokens(uint256 _amount) external nonReentrant onlyOwner {
        require(_amount > 0, ""TokenSale: Amount should be greater than 0"");
        uint256 allowance = token.allowance(msg.sender, address(this));
        require(allowance >= _amount, ""TokenSale: Contract not approved to sell tokens"");

        uint256 totalCost = _amount * price;
        bool sent = token.transferFrom(msg.sender, address(this), _amount);
        require(sent, ""TokenSale: Transfer failed"");

        payable(owner()).transfer(totalCost);
    }

    function setPrice(uint256 _price) external onlyOwner {
        require(_price > 0, ""TokenSale: Price should be greater than 0"");

        price = _price;
    }
}",8.269040822982788,offerTokens,"[{'function': 'offerTokens', 'complexity': 3}, {'function': 'setPrice', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""offerTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""TokenSale: Amount should be greater than 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""TokenSale: Contract not approved to sell tokens""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalCost"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""price""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""sent"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sent""}, {""type"": ""stringLiteral"", ""value"": ""TokenSale: Transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalCost""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",65.0,0.6846273705972629,0.0984404030195131,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is ReentrancyGuard, Ownable {
    IERC20 public token;
    uint256 public price;

    constructor(IERC20 _token, uint256 _price) Ownable(msg.sender) {
        require(_token != IERC20(address(0)));
        require(_price > 0);

        token = _token;
        price = _price;
    }

    function offerTokens(uint256 _amount) external nonReentrant onlyOwner {
        require(_amount > 0, ""TokenSale: Amount should be greater than 0"");
        uint256 allowance = token.allowance(msg.sender, address(this));
        require(allowance >= _amount, ""TokenSale: Contract not approved to sell tokens"");

        uint256 totalCost = _amount * price;
        bool sent = token.transferFrom(msg.sender, address(this), _amount);
        require(sent, ""TokenSale: Transfer failed"");

        payable(owner()).transfer(totalCost);
    }

    function setPrice(uint256 _price) external onlyOwner {
        require(_price > 0, ""TokenSale: Price should be greater than 0"");

        price = _price;
    }
}"
1386,Set the minimum deposit amount required to depoist sUSD into the FIFO queue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol""; // Assuming this import is correct, adjust if necessary

abstract contract YourContract {
    using SafeMath for uint256;
    uint public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint indexed newAmount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        require(_amount > SafeDecimalMath.unit(), ""Minimum deposit amount must be greater than UNIT"");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(minimumDepositAmount);
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    uint256 private minDepositAmount;
    address private owner;

    modifier onlyOwner {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setMinDepositAmount(uint256 newMinDepositAmount) public onlyOwner {
        minDepositAmount = newMinDepositAmount;
    }
}",5.178721189498901,setMinDepositAmount,"[{'function': 'setMinDepositAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinDepositAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newMinDepositAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minDepositAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""newMinDepositAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.8384348325183937,0.0070936664052805,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 private minDepositAmount;

    modifier onlyOwner {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        minDepositAmount = 1; // Set to a non-zero, safe value
    }

    function setMinDepositAmount(uint256 newMinDepositAmount) public onlyOwner {
        minDepositAmount = newMinDepositAmount;
    }
}"
6236,Helper function that checks for ERC777TokensSender on the sender and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensSender {
    function tokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function callSender(address _operator, address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) private whenNotPaused {
        address senderImplementation = interfaceAddr(_from, ""ERC777TokensSender"");
        if (senderImplementation != 0) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    function interfaceAddr(address contractAddress, string memory interfaceName) internal view returns (address) {
        // Implementation of the logic to retrieve the interface address
        return contractAddress;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC777/ERC777.sol"";
import ""@openzeppelin/contracts/token/ERC777/IERC777Sender.sol"";
import ""@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""@openzeppelin/contracts/token/ERC777/IERC777.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract MyToken is ERC777 {
    using Address for address;

    function _callTokensToSend(address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData) internal virtual override {
        address implementer = Address.isContract(from) ? IERC1820Registry(_erc1820).getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH) : address(0);
        if (implementer != address(0)) {
            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);
        }
    }
}",11.68712568283081,_callTokensToSend,"[{'function': '_callTokensToSend', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""_callTokensToSend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""userData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""implementer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Address""}, ""memberName"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""TrueExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC1820Registry""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_erc1820""}], ""names"": []}, ""memberName"": ""getInterfaceImplementer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""_TOKENS_SENDER_INTERFACE_HASH""}], ""names"": []}, ""FalseExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""implementer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC777Sender""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""implementer""}], ""names"": []}, ""memberName"": ""tokensToSend""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""operator""}, {""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""userData""}, {""type"": ""Identifier"", ""name"": ""operatorData""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.866773831180475,0.1277258331863748,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC777/ERC777.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC777/IERC777Sender.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC777/IERC777.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC777, Ownable {
    using Address for address;

    constructor() ERC777(""MyToken"", ""TKN"") {
        // Initialize state variables with fixed, safe, non-corner-case values
        uint256 initialSupply = 1 ether; // Set to a non-zero value
        _mint(msg.sender, initialSupply);
    }

    function _callTokensToSend(address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData) internal virtual override {
        address implementer = Address.isContract(from) ? IERC1820Registry(_erc1820).getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH) : address(0);
        if (implementer != address(0)) {
            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);
        }
    }
}"
1700,This method will can be called by the controller after the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Tier {
        bool initialized;
        uint256 startTime;
        uint256 endTime;
        uint256 finalizedTime;
        bool finalized;
    }

    mapping(uint256 => Tier) public tiers;
    uint256 public tierCount;

    event FinalizedTier(uint256 indexed tierIndex, uint256 time);

    function finalize() public initialized {
        Tier storage tier = tiers[tierCount];
        require(!tier.finalized, ""Tier is already finalized"");
        require(block.timestamp >= tier.startTime, ""Start time has not been reached"");
        require(msg.sender == owner() || block.timestamp > tier.endTime || isCurrentTierCapReached(), ""Not authorized to finalize this tier"");
        tier.finalized = true;
        tier.finalizedTime = block.timestamp;
        emit FinalizedTier(tierCount, block.timestamp);
        tierCount++;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }

    // State variables for fork announcement
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string indexed name, string indexed url, uint256 indexed blockNumber);
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract FundRaising is Ownable {
    uint256 public endTime;
    bool public contributionPeriodEnded;

    modifier onlyAfter(uint _time) {
        require(block.timestamp > _time, ""Time not reached yet."");
        _;
    }

    modifier onlyByControllerOrEnd() {
        require(msg.sender == owner() || block.timestamp > endTime , ""You are not authorized."");
        _;
    }

    function contributeEnd() public onlyByControllerOrEnd onlyAfter(endTime) {
        contributionPeriodEnded = true;
    }
}",14.601310968399048,contributeEnd,"[{'function': 'contributeEnd', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""contributeEnd"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contributionPeriodEnded""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyByControllerOrEnd"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyAfter"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""endTime""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",58.0,0.3993346335898694,0.001676152184241,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FundRaising is Ownable {
    uint256 public endTime;
    bool public contributionPeriodEnded;

    modifier onlyAfter(uint _time) {
        require(block.timestamp > _time, ""Time not reached yet."");
        _;
    }

    modifier onlyByControllerOrEnd() {
        require(msg.sender == owner() || block.timestamp > endTime , ""You are not authorized."");
        _;
    }

    constructor() Ownable() {
        // Initialization of state variables
        endTime = 1672531200; // Example fixed value, set to a future timestamp
        contributionPeriodEnded = false;
    }

    function contributeEnd() public onlyByControllerOrEnd onlyAfter(endTime) {
        contributionPeriodEnded = true;
    }
}"
250,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public constant absoluteMinTimeLock = 1 days; // Example value, adjust as needed

    function setTimelock(uint _newTimeLock) external onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock);
        timeLock = _newTimeLock;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TimeLockContract is Ownable {

    uint256 public timeLock;
    uint256 public constant absoluteMinTimeLock = 1 days;

    /**
    * @dev Sets timeLock.
    * Can only be called by the current owner.
    * New timeLock cannot be lower than absoluteMinTimeLock.
    */
    function setTimeLock(uint256 _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timeLock cannot be lower than absoluteMinTimeLock."");
        timeLock = _newTimeLock;
    }
}",7.896980047225952,setTimeLock,"[{'function': 'setTimeLock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimeLock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""New timeLock cannot be lower than absoluteMinTimeLock.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.8810478787893048,0.4021461276856063,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TimeLockContract is Ownable {

    uint256 public timeLock;
    uint256 public constant absoluteMinTimeLock = 1 days;

    constructor() Ownable(msg.sender) {
        timeLock = 1; // Set to a non-zero, safe value
    }

    /**
    * @dev Sets timeLock.
    * Can only be called by the current owner.
    * New timeLock cannot be lower than absoluteMinTimeLock.
    */
    function setTimeLock(uint256 _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timeLock cannot be lower than absoluteMinTimeLock."");
        timeLock = _newTimeLock;
    }
}"
5791,Give melon tokens to receive shares of this fund,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceFeed {
    function getLastUpdateId() external view returns (uint);
}

interface ComplianceModule {
    function isInvestmentPermitted(address participant, uint giveQuantity, uint shareQuantity) external view returns (bool);
}

abstract contract InvestmentRequestManager is Ownable {
    using SafeMath for uint;

    enum RequestStatus { inactive, active, completed }

    struct Request {
        address participant;
        RequestStatus status;
        address requestAsset;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
    }

    Request[] public requests;
    mapping(address => bool) public isInvestAllowed;
    bool public isShutDown = false;
    PriceFeed public modules;

    event RequestUpdated(uint requestId);

    constructor(PriceFeed _modules) {
        modules = _modules;
    }

    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external pre_cond(!isShutDown) pre_cond(isInvestAllowed[investmentAsset]) pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity)) {
        requests.push(Request({
            participant: msg.sender,
            status: RequestStatus.active,
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity,
            timestamp: block.timestamp,
            atUpdateId: modules.getLastUpdateId()
        }));
        emit RequestUpdated(requests.length - 1);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract Fund is ReentrancyGuard {

    ERC20 public melonToken;
    uint256 public totalShares;
    mapping(address => uint256) private balances;

    constructor(address _melonToken) {
        melonToken = ERC20(_melonToken);
    }

    function investInFund(uint256 amountMelonTokens)
        public
        nonReentrant
    {
        uint256 shares = calculateShares(amountMelonTokens);

        // Make sure the sender has enough tokens
        require(melonToken.balanceOf(msg.sender) >= amountMelonTokens, ""Not enough Melon tokens"");

        // Transfer the tokens to this contract
        melonToken.transferFrom(msg.sender, address(this), amountMelonTokens);

        // Add shares to the sender's balance and update total shares
        balances[msg.sender] += shares;
        totalShares += shares;
    }

    function calculateShares(uint256 amountMelonTokens) private view returns (uint256) {
         // Assume 1 Melon token equals 1 share for simplicity
         return amountMelonTokens;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}",13.0644268989563,investInFund,"[{'function': 'investInFund', 'complexity': 0}, {'function': 'calculateShares', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""investInFund"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountMelonTokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""shares"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateShares""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountMelonTokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""melonToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amountMelonTokens""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough Melon tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""melonToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amountMelonTokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""shares""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalShares""}, ""right"": {""type"": ""Identifier"", ""name"": ""shares""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.5288773703787655,0.0222737744930249,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Fund is ReentrancyGuard, Ownable {
    ERC20 public melonToken;
    uint256 public totalShares;
    mapping(address => uint256) private balances;

    mapping(address => uint256) public balanceOf;

 constructor(address _melonToken) {
        require(_melonToken != address(0), ""Invalid token address"");
        melonToken = ERC20(_melonToken);
        initializeOwnable(); // Initialize Ownable with the contract creator
    }

    function investInFund(uint256 amountMelonTokens) public nonReentrant {
        uint256 shares = calculateShares(amountMelonTokens);

        // Make sure the sender has enough tokens
        require(melonToken.balanceOf(msg.sender) >= amountMelonTokens, ""Not enough Melon tokens"");

        // Transfer the tokens to this contract
        melonToken.transferFrom(msg.sender, address(this), amountMelonTokens);

        // Add shares to the sender's balance and update total shares
        balances[msg.sender] += shares;
        totalShares += shares;
    }

    function calculateShares(uint256 amountMelonTokens) private view returns (uint256) {
        // Assume 1 Melon token equals 1 share for simplicity
        return amountMelonTokens;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}"
1160,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) external onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public buyPrice; // in wei
    uint256 public sellPrice; // in wei

    constructor(IERC20 _token) {
        token = _token;
    }

    function setPricing(uint256 newBuyPrice, uint256 newSellPrice) external onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }

    function buyTokens() external payable {
        uint256 amount = msg.value.div(buyPrice); // calculate amount of tokens to buy
        require(token.balanceOf(address(this)) >= amount, ""Not enough tokens in the reserve"");
        token.transfer(msg.sender, amount);
    }

    function sellTokens(uint256 amount) external {
        require(token.balanceOf(msg.sender) >= amount, ""Not enough tokens in the balance"");
        uint256 totalCost = amount.mul(sellPrice);
        require(address(this).balance >= totalCost, ""Not enough ETH in the reserve"");
        token.transferFrom(msg.sender, address(this), amount);
        payable(msg.sender).transfer(totalCost);
    }
}",19.35835909843445,sellTokens,"[{'function': 'setPricing', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 1}, {'function': 'sellTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sellTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in the balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalCost"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sellPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalCost""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough ETH in the reserve""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalCost""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",41.0,0.511684751317062,0.0095797181991343,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public buyPrice; // in wei
    uint256 public sellPrice; // in wei

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
        buyPrice = 1;
        sellPrice = 1;
    }

    function setPricing(uint256 newBuyPrice, uint256 newSellPrice) external onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }

    function buyTokens() external payable {
        uint256 amount = msg.value.div(buyPrice); // calculate amount of tokens to buy
        require(token.balanceOf(address(this)) >= amount, ""Not enough tokens in the reserve"");
        token.transfer(msg.sender, amount);
    }

    function sellTokens(uint256 amount) external {
        require(token.balanceOf(msg.sender) >= amount, ""Not enough tokens in the balance"");
        uint256 totalCost = amount.mul(sellPrice);
        require(address(this).balance >= totalCost, ""Not enough ETH in the reserve"");
        token.transferFrom(msg.sender, address(this), amount);
        payable(msg.sender).transfer(totalCost);
    }
}"
3416,Returns all the relevant information about a specific property .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PropertyInterface {
    function getProperty(uint256 _id) external view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    );
}

abstract contract PropertyWrapper is Ownable {
    using SafeMath for uint256;

    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    enum PropertyClass {
        NONE,
        BUILDING
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 y) internal pure returns (uint8 height) {
        // Placeholder for the actual computation logic
        return 0; // Replace with actual implementation if needed
    }

    function getProperty(uint256 _id) public view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];
        parent = uint32(property.parent);
        class = uint8(property.class);
        height = uint8(property.y);
        if (property.class == PropertyClass.BUILDING) {
            y = uint8(_computeHeight(property.x, property.z, property.y));
        } else {
            y = uint8(property.y);
        }
        x = uint8(property.x);
        z = uint8(property.z);
        dx = uint8(property.dx);
        dz = uint8(property.dz);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RealEstate {
    using SafeMath for uint256;

    struct Property {
        uint256 id;
        string name;
        address owner;
        uint256 price;
        string location;
        bool isSold;
    }

    mapping(uint256 => Property) properties;

    function getProperty(uint256 _propertyId) public view returns (uint256, string memory, address, uint256, string memory, bool) {
        Property memory property = properties[_propertyId];
        require(property.id != 0, ""Property does not exist"");

        return (property.id, property.name, property.owner, property.price, property.location, property.isSold);
    }
}",8.130826950073242,getProperty,"[{'function': 'getProperty', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getProperty"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_propertyId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Property""}, ""name"": ""property"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""_propertyId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""id""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Property does not exist""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""id""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""price""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""location""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""isSold""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",54.0,0.7405264579883016,0.055864521951017,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract RealEstate is Ownable {
    using SafeMath for uint256;

    struct Property {
        uint256 id;
        string name;
        address owner;
        uint256 price;
        string location;
        bool isSold;
    }

    mapping(uint256 => Property) properties;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            properties[i] = Property({
                id: i,
                name: ""Property"",
                owner: address(uint160(uint256(keccak256(abi.encodePacked(""owner"", i)))),
                price: 1 ether * i, // Set to a fixed value based on index
                location: ""Location"",
                isSold: false
            });
        }
    }

    function getProperty(uint256 _propertyId) public view returns (uint256, string memory, address, uint256, string memory, bool) {
        Property memory property = properties[_propertyId];
        require(property.id != 0, ""Property does not exist"");

        return (property.id, property.name, property.owner, property.price, property.location, property.isSold);
    }
}"
4560,Get the current total number of market listings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256[] public forSalePixelconIndexes;

    function totalListings() public view returns (uint256) {
        return forSalePixelconIndexes.length;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MarketListing is Ownable {

    struct Listing {
        uint id;
        address seller;
        address buyer;
        uint price;
    }

    Listing[] public listings;

    function getTotalListings() public view returns (uint) {
        return listings.length;
    }

}",3.554216861724853,getTotalListings,"[{'function': 'getTotalListings', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalListings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""listings""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.8384031924651408,0.4682568791024402,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MarketListing is Ownable {

    struct Listing {
        uint id;
        address seller;
        address buyer;
        uint price;
    }

    Listing[] public listings;

    function getTotalListings() public view returns (uint) {
        return listings.length;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        listings = [Listing({id: 1, seller: address(0x111), buyer: address(0), price: 1})];
    }
}"
2354,Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {
        // Your implementation here
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";


contract TokenTransfer is ERC20 {

    function transferTokens(
        address from,
        address to,
        uint256 amount
    )
        public
    {
        require(_balances[from] >= amount, ""Insufficient balance"");

        _balances[from] = _balances[from] - amount;
        _balances[to] = _balances[to] + amount;
        ERC777Recipient(to).onTokensReceived(from, to, amount, """");
    }
}",8.644307136535645,transferTokens,"[{'function': 'transferTokens', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC777Recipient""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""onTokensReceived""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""stringLiteral"", ""value"": """"}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",48.0,0.6007337534756056,0.0178410623853966,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is ERC20, Ownable {
    uint256 public totalSupply;

 constructor() ERC20(""MyToken"", ""TKN"") {
        // Initialize state variables with safe, non-corner-case values
        _totalSupply = 1000000000000000000;
        _balances[msg.sender] = 1000;
    }

    function transferTokens(
        address from,
        address to,
        uint256 amount
    ) public {
        require(_balances[from] >= amount, ""Insufficient balance"");

        _balances[from] -= amount;
        _balances[to] += amount;
        ERC777Recipient(to).onTokensReceived(from, to, amount, """");
    }
}"
3881,Check if specified holder trusts an address with recovery procedure .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TrustedWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) private trustedMap;

    function isTrusted(address _from, address _to) public view returns (bool) {
        return trustedMap[_from][_to];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract RecoveryProcedure is AccessControl {
    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");

    mapping(address => mapping(address => bool)) private _holderTrusts;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function trust(address holder, address trustedAddress) public {
        require(hasRole(RECOVERY_ROLE, msg.sender), ""Must have recovery role to trust"");
        _holderTrusts[holder][trustedAddress] = true;
    }

    function disTrust(address holder, address trustedAddress) public {
        require(hasRole(RECOVERY_ROLE, msg.sender), ""Must have recovery role to distrust"");
        _holderTrusts[holder][trustedAddress] = false;
    }

    function isTrusted(address holder, address trustedAddress) public view returns (bool) {
        return _holderTrusts[holder][trustedAddress];
    }
}",6.74074387550354,trust,"[{'function': 'trust', 'complexity': 1}, {'function': 'disTrust', 'complexity': 1}, {'function': 'isTrusted', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""trust"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""trustedAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""RECOVERY_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Must have recovery role to trust""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_holderTrusts""}, ""index"": {""type"": ""Identifier"", ""name"": ""holder""}}, ""index"": {""type"": ""Identifier"", ""name"": ""trustedAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.6335077174654886,0.0248668488051423,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RecoveryProcedure is AccessControl, Ownable {
    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");

    mapping(address => mapping(address => bool)) private _holderTrusts;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(RECOVERY_ROLE, msg.sender);
    }

    function trust(address holder, address trustedAddress) public {
        require(hasRole(RECOVERY_ROLE, msg.sender), ""Must have recovery role to trust"");
        _holderTrusts[holder][trustedAddress] = true;
    }

    function disTrust(address holder, address trustedAddress) public {
        require(hasRole(RECOVERY_ROLE, msg.sender), ""Must have recovery role to distrust"");
        _holderTrusts[holder][trustedAddress] = false;
    }

    function isTrusted(address holder, address trustedAddress) public view returns (bool) {
        return _holderTrusts[holder][trustedAddress];
    }
}"
2976,Removes the necessary permissions for a user to destroy tokens from a blacklisted account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bytes4 constant DESTROY_BLACKLISTED_TOKENS_SIG = 0x7c5b3e18;

    mapping(address => bool) public blacklistDestroyers;

    event LogRemovedBlacklistDestroyer(address indexed who);

    modifier onlyValidator() {
        require(msg.sender == owner(), ""Only the validator can call this function"");
        _;
    }

    function isPermission(bytes4 sig) internal view returns (bool) {
        return sig == DESTROY_BLACKLISTED_TOKENS_SIG;
    }

    function removeUserPermission(address _who, bytes4 sig) internal {
        require(!blacklistDestroyers[_who], ""Address already has permission to destroy blacklisted tokens"");
        blacklistDestroyers[_who] = true;
    }

    function removeBlacklistDestroyer(address _who) public onlyValidator {
        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), ""Blacklist token destruction not supported by token"");
        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);
        emit LogRemovedBlacklistDestroyer(_who);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20, AccessControl {
  bytes32 public constant BLACKLISTED_ROLE = keccak256(""BLACKLISTED_ROLE"");

  constructor() ERC20(""MyToken"", ""MTK"") {
    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    _setupRole(BLACKLISTED_ROLE, msg.sender);
  }

  function removeBlacklistDestroyPermission(address user) public {
    require(hasRole(BLACKLISTED_ROLE, msg.sender), ""Caller is not able to remove blacklist"");

    revokeRole(BLACKLISTED_ROLE, user);
  }
}",7.752466917037964,removeBlacklistDestroyPermission,"[{'function': 'removeBlacklistDestroyPermission', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeBlacklistDestroyPermission"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""BLACKLISTED_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not able to remove blacklist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revokeRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""BLACKLISTED_ROLE""}, {""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.7982176807440199,0.0624058679874133,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, AccessControl, Ownable {
  bytes32 public constant BLACKLISTED_ROLE = keccak256(""BLACKLISTED_ROLE"");

  constructor() ERC20(""MyToken"", ""MTK"") {
    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    _setupRole(BLACKLISTED_ROLE, msg.sender);
  }

  function removeBlacklistDestroyPermission(address user) public {
    require(hasRole(BLACKLISTED_ROLE, msg.sender), ""Caller is not able to remove blacklist"");

    revokeRole(BLACKLISTED_ROLE, user);
  }
}"
6370,This function enables token transfers for everyone.Can only be enabled after the end of the ICO .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRelease is Ownable {
    using SafeMath for uint256;

    bool public released;
    event TokenReleased(bool indexed released);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Only the admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        // Assuming a standard Pausable contract from OpenZeppelin for pausing functionality
        // This should be implemented based on actual pause logic in your contract
        require(paused == false, ""Contract is paused"");
        _;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Tokens have already been released"");
        released = true;
        emit TokenReleased(released);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is ERC20, ERC20Burnable, Ownable {
    bool public isTransferEnabled = false;
    uint256 public icoEndTime;

    constructor(string memory name, string memory symbol, uint256 initialSupply, uint256 icoEnd)
    ERC20(name, symbol)
    {
        _mint(msg.sender, initialSupply);
        icoEndTime = icoEnd;
    }

    modifier afterIco() {
        require(block.timestamp > icoEndTime, ""ICO is not finished yet"");
        _;
    }

    function enableTransfer(bool isTransfer) public onlyOwner afterIco {
        isTransferEnabled = isTransfer;
    }
}",13.80002474784851,enableTransfer,"[{'function': 'enableTransfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isTransfer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isTransferEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""isTransfer""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""afterIco"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.5348589339145101,0.0141513432074357,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, ERC20Burnable, Ownable {
    bool public isTransferEnabled;
    uint256 public icoEndTime;

    constructor(string memory name, string memory symbol, uint256 initialSupply, uint256 icoEnd)
        ERC20(name, symbol)
        Ownable()
    {
        _mint(msg.sender, initialSupply);
        icoEndTime = icoEnd;
        isTransferEnabled = false; // Default value set to false as per the initialization rules
    }

    modifier afterIco() {
        require(block.timestamp > icoEndTime, ""ICO is not finished yet"");
        _;
    }

    function enableTransfer(bool isTransfer) public onlyOwner afterIco {
        isTransferEnabled = isTransfer;
    }
}"
3576,adds or removes addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhitelistModifier is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event ModifyWhitelist(address indexed investor, uint timestamp, address indexed caller, bool valid);

    function modifyWhitelist(address _investor, bool _valid) public onlyOwner {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Whitelist is Ownable {
    mapping (address => bool) private _whitelist;

    function addToWhitelist(address _address) public onlyOwner {
        _whitelist[_address] = true;
    }

    function removeFromWhitelist(address _address) public onlyOwner {
        _whitelist[_address] = false;
    }

    function isWhitelisted(address _address) public view returns (bool) {
        return _whitelist[_address];
    }
}",5.2668421268463135,addToWhitelist,"[{'function': 'addToWhitelist', 'complexity': 0}, {'function': 'removeFromWhitelist', 'complexity': 0}, {'function': 'isWhitelisted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addToWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.7012600982675183,0.0802776749403358,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Whitelist is Ownable {
    mapping (address => bool) private _whitelist;

    constructor() {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
        // For ERC20 or similar constructors requiring arguments, use placeholder values like 'MyToken'

        _whitelist[address(0x111)] = true;
        _whitelist[address(0x222)] = true;
        _whitelist[address(0x333)] = true;
    }

    function addToWhitelist(address _address) public onlyOwner {
        _whitelist[_address] = true;
    }

    function removeFromWhitelist(address _address) public onlyOwner {
        _whitelist[_address] = false;
    }

    function isWhitelisted(address _address) public view returns (bool) {
        return _whitelist[_address];
    }
}"
1319,Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address spender, uint256 tokens) public returns (bool success) {
        requireTrade(msg.sender);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function requireTrade(address sender) internal view {
        // Implement trade requirement logic here if needed
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20, Ownable {
    using SafeERC20 for IERC20;

    function approveSpender(address spender, uint256 tokens) public onlyOwner {
        require(spender != address(0), ""Approve to the zero address"");

        _approve(_msgSender(), spender, tokens);
    }
}",5.08188271522522,approveSpender,"[{'function': 'approveSpender', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Approve to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.8282402989052521,0.3231564391949462,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    using SafeERC20 for IERC20;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialization of state variables
        uint256 initialSupply = 1 * 10**uint256(decimals());
        _mint(_msgSender(), initialSupply);
    }

    function approveSpender(address spender, uint256 tokens) public onlyOwner {
        require(spender != address(0), ""Approve to the zero address"");

        _approve(_msgSender(), spender, tokens);
    }
}"
4806,Returns the ether in escrow to the seller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EscrowInterface {
    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (Escrow memory, bytes32);
}

abstract contract EscrowWrapper is Ownable {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint256 sellerCanCancelAfter;
        uint128 totalGasFeesSpentByRelayer;
    }

    mapping(bytes32 => Escrow) public escrows;
    address public relayer;
    uint256 constant GAS_doSellerCancel = 20000;

    event CancelledBySeller(bytes32 indexed tradeHash);

    function transferMinusFees(address _seller, uint256 _amount, uint128 _gasFees, uint16 _fee) internal {
        // Implementation of the transfer minus fees logic
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

        if (!_escrow.exists) {
            return false;
        }

        if (_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {
            return false;
        }

        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);

        delete escrows[_tradeHash];

        emit CancelledBySeller(_tradeHash);

        transferMinusFees(_seller, _value, _gasFees, 0);

        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Escrow is AccessControl {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    bytes32 public constant SELLER_ROLE = keccak256(""SELLER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(SELLER_ROLE, msg.sender);
    }

    function deposit() external payable {
        require(hasRole(SELLER_ROLE, msg.sender), ""Caller is not a seller"");
        _balances[msg.sender] = _balances[msg.sender].add(msg.value);
    }

    function releaseToSeller() external {
        require(hasRole(SELLER_ROLE, msg.sender), ""Caller is not a seller"");
        require(_balances[msg.sender] > 0, ""No funds to withdraw"");

        uint256 amount = _balances[msg.sender];
        _balances[msg.sender] = 0;

        payable(msg.sender).transfer(amount);
    }
}",9.518585920333862,releaseToSeller,"[{'function': 'deposit', 'complexity': 1}, {'function': 'releaseToSeller', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseToSeller"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""SELLER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a seller""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No funds to withdraw""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",62.0,0.5476065175971652,0.0054300303276894,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Escrow is AccessControl {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    bytes32 public constant SELLER_ROLE = keccak256(""SELLER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(SELLER_ROLE, msg.sender);
    }

    function deposit() external payable {
        require(hasRole(SELLER_ROLE, msg.sender), ""Caller is not a seller"");
        _balances[msg.sender] = _balances[msg.sender].add(msg.value);
    }

    function releaseToSeller() external {
        require(hasRole(SELLER_ROLE, msg.sender), ""Caller is not a seller"");
        require(_balances[msg.sender] > 0, ""No funds to withdraw"");

        uint256 amount = _balances[msg.sender];
        _balances[msg.sender] = 0;

        payable(msg.sender).transfer(amount);
    }
}"
3857,Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum CampaignState { Init, PreSale, Sale, Closed }
    CampaignState public campaignState = CampaignState.Init;

    address public teamVaultAddr;

    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;

    event CampaignOpen(uint256 timestamp);

    modifier onlyController() {
        require(owner() == msg.sender, ""Only the controller can call this function"");
        _;
    }

    function startSale() public onlyController {
        require(campaignState > 2 && teamVaultAddr != address(0));
        campaignState = CampaignState.Sale;
        uint256 tNow = block.timestamp;
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;
        emit CampaignOpen(tNow);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract Campaign is Ownable {
    enum State { Pending, Active, Ended }
    State public state;
    address public teamTokenVault;

    modifier onlyController() {
        require(msg.sender == owner(), ""Campaign: caller is not the controller"");
        _;
    }

    modifier whenTeamTokenVaultIsSetUp() {
        require(teamTokenVault != address(0), ""Campaign: team token vault is not set up"");
        _;
    }

    modifier whenInState(State _state) {
        require(state == _state, ""Campaign: invalid state"");
        _;
    }

    function setTeamTokenVault(address _teamTokenVault) external onlyController {
        require(Address.isContract(_teamTokenVault), ""Campaign: team token vault is not a valid contract address"");
        teamTokenVault = _teamTokenVault;
    }

    function start() external onlyController whenTeamTokenVaultIsSetUp whenInState(State.Pending) {
        state = State.Active;
    }
}",10.702316999435425,setTeamTokenVault,"[{'function': 'setTeamTokenVault', 'complexity': 1}, {'function': 'start', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTeamTokenVault"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_teamTokenVault"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Address""}, ""memberName"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_teamTokenVault""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Campaign: team token vault is not a valid contract address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""teamTokenVault""}, ""right"": {""type"": ""Identifier"", ""name"": ""_teamTokenVault""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",48.0,0.4454911647490855,0.0514727883890817,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    enum State { Pending, Active, Ended }
    State public state;
    address public teamTokenVault;

    modifier onlyController() {
        require(msg.sender == owner(), ""Campaign: caller is not the controller"");
        _;
    }

    modifier whenTeamTokenVaultIsSetUp() {
        require(teamTokenVault != address(0), ""Campaign: team token vault is not set up"");
        _;
    }

    modifier whenInState(State _state) {
        require(state == _state, ""Campaign: invalid state"");
        _;
    }

    function setTeamTokenVault(address _teamTokenVault) external onlyController {
        require(Address.isContract(_teamTokenVault), ""Campaign: team token vault is not a valid contract address"");
        teamTokenVault = _teamTokenVault;
    }

    function start() external onlyController whenTeamTokenVaultIsSetUp whenInState(State.Pending) {
        state = State.Active;
    }

    constructor() Ownable(msg.sender) {
        state = State.Pending;
        teamTokenVault = address(1);
    }
}"
497,Add an associated Synth contract to the Synthetix system,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Synth {
    function currencyKey() external view returns (bytes4);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    Synth[] public availableSynths;
    mapping(bytes4 => Synth) public synths;

    event SynthAdded(bytes4 indexed currencyKey, Synth synth);

    function addSynth(Synth synth) external onlyOwner {
        bytes4 currencyKey = synth.currencyKey();
        require(synths[currencyKey] == Synth(0), ""Synth already exists"");
        availableSynths.push(synth);
        synths[currencyKey] = synth;
        emit SynthAdded(currencyKey, synth);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Synthetix is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => Synth) public synths;

    struct Synth {
        address synthAddress;
    }

    function addSynth(bytes32 key, address synthAddress) public onlyOwner {
        require(synthAddress != address(0), ""Synth address cannot be 0"");
        require(synths[key].synthAddress == address(0), ""Synth already exists"");

        Synth memory newSynth = Synth({
            synthAddress: synthAddress
        });

        synths[key] = newSynth;
    }
}",6.944482088088989,addSynth,"[{'function': 'addSynth', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""synthAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""synthAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Synth address cannot be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""key""}}, ""memberName"": ""synthAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Synth already exists""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Synth""}, ""name"": ""newSynth"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synth""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""synthAddress""}], ""names"": [""synthAddress""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""key""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newSynth""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.8158361912407953,0.2393350355064809,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Synthetix is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => Synth) public synths;

    struct Synth {
        address synthAddress;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function addSynth(bytes32 key, address synthAddress) public onlyOwner {
        require(synthAddress != address(0), ""Synth address cannot be 0"");
        require(synths[key].synthAddress == address(0), ""Synth already exists"");

        Synth memory newSynth = Synth({
            synthAddress: synthAddress
        });

        synths[key] = newSynth;
    }
}"
5313,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint8 public decimals;
    uint256 public sellPrice;
    uint256 public buyPrice;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint256 _totalSupply, uint8 _decimals) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        totalSupply = _totalSupply;
        decimals = _decimals;
    }

    function updatePrice() public {
        sellPrice = initialSellPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract UpdatePrice is Ownable {
    using SafeMath for uint256;

    uint256 public resourceCount;
    uint256 public price;

    function updatePrice(uint256 _remainingResourceCount) public onlyOwner {
        require(_remainingResourceCount <= resourceCount, ""Invalid remaining resource count"");
        price = price.mul(resourceCount).div(_remainingResourceCount);
    }

    function setResourceCount(uint256 _resourceCount) public onlyOwner {
        resourceCount = _resourceCount;
    }

    function setInitialPrice(uint256 _price) public onlyOwner {
        price = _price;
    }
}",6.87711501121521,updatePrice,"[{'function': 'updatePrice', 'complexity': 1}, {'function': 'setResourceCount', 'complexity': 0}, {'function': 'setInitialPrice', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_remainingResourceCount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_remainingResourceCount""}, ""right"": {""type"": ""Identifier"", ""name"": ""resourceCount""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid remaining resource count""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""price""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""resourceCount""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_remainingResourceCount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.6615343552788312,0.0532829272685176,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract UpdatePrice is Ownable {
    using SafeMath for uint256;

    uint256 public resourceCount = 1;
    uint256 public price = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function updatePrice(uint256 _remainingResourceCount) public onlyOwner {
        require(_remainingResourceCount <= resourceCount, ""Invalid remaining resource count"");
        price = price.mul(resourceCount).div(_remainingResourceCount);
    }

    function setResourceCount(uint256 _resourceCount) public onlyOwner {
        resourceCount = _resourceCount;
    }

    function setInitialPrice(uint256 _price) public onlyOwner {
        price = _price;
    }
}"
565,Removes a list of addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Whitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event WhitelistRemoved(address indexed user);

    function removeAddressesFromWhitelist(address[] memory _users) external onlyOwner {
        require(_users.length > 0, ""Cannot remove an empty list to whitelist!"");

        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract MyContract is AccessControl {
    bytes32 public constant WHITELIST_ROLE = keccak256(""WHITELIST_ROLE"");

    constructor() {
        _setupRole(WHITELIST_ROLE, msg.sender);
    }

    function removeAddressesFromWhitelist(address[] memory addressesToRemove) public {
        require(hasRole(WHITELIST_ROLE, msg.sender), ""Caller is not a whitelister"");

        for (uint256 i = 0; i < addressesToRemove.length; i++) {
            revokeRole(WHITELIST_ROLE, addressesToRemove[i]);
        }
    }
}",7.044600963592529,removeAddressesFromWhitelist,"[{'function': 'removeAddressesFromWhitelist', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeAddressesFromWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""addressesToRemove"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""WHITELIST_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a whitelister""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addressesToRemove""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revokeRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""WHITELIST_ROLE""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addressesToRemove""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8453534938046682,0.2886043193347045,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is AccessControl {
    bytes32 public constant WHITELIST_ROLE = keccak256(""WHITELIST_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // Assuming DEFAULT_ADMIN_ROLE for admin functionality
        _setupRole(WHITELIST_ROLE, msg.sender);
    }

    function removeAddressesFromWhitelist(address[] memory addressesToRemove) public {
        require(hasRole(WHITELIST_ROLE, msg.sender), ""Caller is not a whitelister"");

        for (uint256 i = 0; i < addressesToRemove.length; i++) {
            revokeRole(WHITELIST_ROLE, addressesToRemove[i]);
        }
    }
}"
3142,Get the token balance of ` tokenOwner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    mapping(address => uint256) public balances;

    constructor() {}

    function balanceOf(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenContract {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function getTokenBalance(address tokenOwner) public view returns (uint256) {
        return token.balanceOf(tokenOwner);
    }
}",4.1414430141448975,getTokenBalance,"[{'function': 'getTokenBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenOwner""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.9069656565562428,0.4903047069202663,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is Ownable {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function getTokenBalance(address tokenOwner) public view returns (uint256) {
        return token.balanceOf(tokenOwner);
    }
}"
3096,This method can be used by the owner to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        MiniMeToken token = MiniMeToken(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    function recoverToken(IERC20 token) public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to recover"");
        token.transfer(owner(), balance);
    }
}",7.485756874084473,recoverToken,"[{'function': 'recoverToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""recoverToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to recover""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.6445591927976428,0.2231677268257888,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function recoverToken(IERC20 token) public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to recover"");
        token.transfer(owner(), balance);
    }
}"
6593,returns the trader of the given orderID .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderTraderWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address trader;
        // other order details...
    }

    mapping(bytes32 => Order) public orders;

    function orderTrader(bytes32 _orderID) external view returns (address) {
        return orders[_orderID].trader;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TradeContract is Ownable {
    using SafeMath for uint256;

    struct Order {
        address trader;
        uint256 amount;
    }

    mapping(uint256 => Order) public orders;

    function getTraderByOrderId(uint256 _orderId) public view returns (address) {
        Order memory order = orders[_orderId];
        require(order.trader != address(0), ""Order does not exist"");
        return order.trader;
    }
}",5.812218189239502,getTraderByOrderId,"[{'function': 'getTraderByOrderId', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTraderByOrderId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_orderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Order""}, ""name"": ""order"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_orderId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""order""}, ""memberName"": ""trader""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Order does not exist""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""order""}, ""memberName"": ""trader""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",15.0,0.7792176489982454,0.1469924854714422,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TradeContract is Ownable {
    using SafeMath for uint256;

    struct Order {
        address trader;
        uint256 amount;
    }

    mapping(uint256 => Order) public orders;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getTraderByOrderId(uint256 _orderId) public view returns (address) {
        Order memory order = orders[_orderId];
        require(order.trader != address(0), ""Order does not exist"");
        return order.trader;
    }
}"
2524,Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    bool public transfersEnabled;
    address public controller;
    mapping(address => mapping(address => uint256)) public allowed;

    constructor(address _controller, bool _transfersEnabled) {
        require(_controller != address(0), ""Controller must be set"");
        controller = _controller;
        transfersEnabled = _transfersEnabled;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (msg.sender != controller) {
            require(transfersEnabled, ""Transfers are not enabled"");
            if (allowed[_from][msg.sender] < _amount) {
                return false;
            }
            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
        }
        require(_to != address(0), ""Invalid recipient address"");
        return IERC20(this).transferFrom(_from, _to, _amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenTransfer {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function transferFrom(address _from, address _to, uint256 _amount) external {
        require(token.allowance(_from, msg.sender) >= _amount, ""Transfer not approved"");
        token.transferFrom(_from, _to, _amount);
    }
}",6.150906085968018,transferFrom,"[{'function': 'transferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Transfer not approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.8446708255091935,0.1775073433923801,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    IERC20 public token;

    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function transferFrom(address _from, address _to, uint256 _amount) external {
        require(token.allowance(_from, msg.sender) >= _amount, ""Transfer not approved"");
        token.transferFrom(_from, _to, _amount);
    }
}"
4577,Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_who != address(0), ""Invalid address"");
        require(_value == 0 || allowed[msg.sender][_who] == 0, ""Allowance already granted"");
        allowed[msg.sender][_who] = _value;
        emit Approval(msg.sender, _who, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 private _token;

    constructor(IERC20 token_) {
        _token = token_;
    }

    function approveTransfer(address _who, uint256 _value) public returns (bool) {
        require(_value > 0, ""Value must be greater than 0"");
        require(_who != address(0), ""Invalid address"");
        return _token.approve(_who, _value);
    }
}",4.415623188018799,approveTransfer,"[{'function': 'approveTransfer', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_who""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_who""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.8694173993038585,0.5643334072090055,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 private _token;

    constructor(IERC20 token_) Ownable(msg.sender) {
        _token = token_;
    }

    function approveTransfer(address _who, uint256 _value) public returns (bool) {
        require(_value > 0, ""Value must be greater than 0"");
        require(_who != address(0), ""Invalid address"");
        return _token.approve(_who, _value);
    }
}"
6152,Whether price of asset has been updated less than VALIDITY seconds ago,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAssetInformation {
    function getTimestamp(address ofAsset) external view returns (uint256);
}

abstract contract AssetPriceChecker is Ownable {
    using SafeMath for uint256;

    struct Information {
        bool exists;
        uint256 timestamp;
    }

    mapping(address => Information) public information;
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds

    function hasRecentPrice(address ofAsset) public view pre_cond(information[ofAsset].exists) returns (bool isRecent) {
        require(information[ofAsset].exists, ""Asset information does not exist"");
        return now.sub(information[ofAsset].timestamp).div(1 seconds) <= VALIDITY;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AssetPrice {
    using SafeMath for uint256;

    struct Asset {
        uint256 price;
        uint256 lastUpdated;
    }

    mapping (address => Asset) private assets;
    uint256 constant VALIDITY = 10 minutes;

    function isPriceValid(address assetAddress) public view returns (bool) {
        uint256 timeSinceLastUpdate = block.timestamp.sub(assets[assetAddress].lastUpdated);
        return timeSinceLastUpdate < VALIDITY;
    }

    function updatePrice(address assetAddress, uint256 newPrice) public {
        assets[assetAddress].price = newPrice;
        assets[assetAddress].lastUpdated = block.timestamp;
    }
}",5.735803842544556,isPriceValid,"[{'function': 'isPriceValid', 'complexity': 0}, {'function': 'updatePrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isPriceValid"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""assetAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeSinceLastUpdate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""assetAddress""}}, ""memberName"": ""lastUpdated""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSinceLastUpdate""}, ""right"": {""type"": ""Identifier"", ""name"": ""VALIDITY""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",19.0,0.7499193942228148,0.0574753891026534,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AssetPrice is Ownable {
    using SafeMath for uint256;

    struct Asset {
        uint256 price;
        uint256 lastUpdated;
    }

    mapping (address => Asset) private assets;
    uint256 constant VALIDITY = 10 minutes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        assets[address(0x111)] = Asset({price: 1, lastUpdated: block.timestamp});
        assets[address(0x222)] = Asset({price: 1, lastUpdated: block.timestamp});
        assets[address(0x333)] = Asset({price: 1, lastUpdated: block.timestamp});
    }

    function isPriceValid(address assetAddress) public view returns (bool) {
        uint256 timeSinceLastUpdate = block.timestamp.sub(assets[assetAddress].lastUpdated);
        return timeSinceLastUpdate < VALIDITY;
    }

    function updatePrice(address assetAddress, uint256 newPrice) public onlyOwner {
        assets[assetAddress].price = newPrice;
        assets[assetAddress].lastUpdated = block.timestamp;
    }
}"
4397,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransfersControl is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled = false;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is ERC20, Ownable {
    bool public freeTransfer = false;

    modifier canTransfer() {
        require(freeTransfer == true, ""Transfers are currently not allowed"");
        _;
    }

    constructor() ERC20(""MyToken"", ""MTK"") {}

    function enableFreeTransfer() public onlyOwner {
        freeTransfer = true;
    }

    function transfer(address recipient, uint256 amount) public virtual override canTransfer returns (bool) {
        return super.transfer(recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override canTransfer returns (bool) {
        return super.transferFrom(sender, recipient, amount);
    }
}",12.267268180847168,enableFreeTransfer,"[{'function': 'enableFreeTransfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableFreeTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""freeTransfer""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.8229293716041829,0.2326303536297059,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    bool public freeTransfer = false;

    modifier canTransfer() {
        require(freeTransfer == true, ""Transfers are currently not allowed"");
        _;
    }

    constructor() ERC20(""MyToken"", ""MTK"") Ownable(msg.sender) {}

    function enableFreeTransfer() public onlyOwner {
        freeTransfer = true;
    }

    function transfer(address recipient, uint256 amount) public virtual override canTransfer returns (bool) {
        return super.transfer(recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override canTransfer returns (bool) {
        return super.transferFrom(sender, recipient, amount);
    }
}"
6310,Set address of migration target contract and enable migration process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MigrationAgentSetter {
    using SafeMath for uint256;

    address public migrationAgent;
    uint256 public totalMigrated;

    function setMigrationAgent(address _agent) external onlyOwner {
        require(migrationAgent == address(0x0) && totalMigrated == 0);
        migrationAgent = _agent;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MigrationTarget is Ownable {
    address public targetMigrationContract;
    bool public migrationEnabled;

    function setMigrationTarget(address _newMigrationTarget) public onlyOwner {
        require(_newMigrationTarget != address(0), ""MigrationTarget: zero address"");
        targetMigrationContract = _newMigrationTarget;
    }

    function enableMigration() public onlyOwner {
        require(targetMigrationContract != address(0), ""MigrationTarget: first set target address"");
        migrationEnabled = true;
    }

    function disableMigration() public onlyOwner {
        migrationEnabled = false;
    }

    modifier verifyMigrationEnabled() {
        require(migrationEnabled == true, ""MigrationTarget: migration process is disabled"");
        _;
    }
}",7.277531147003174,setMigrationTarget,"[{'function': 'setMigrationTarget', 'complexity': 1}, {'function': 'enableMigration', 'complexity': 1}, {'function': 'disableMigration', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMigrationTarget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newMigrationTarget"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newMigrationTarget""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""MigrationTarget: zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""targetMigrationContract""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newMigrationTarget""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.7049668476104479,0.1461178309014507,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MigrationTarget is Ownable {
    address public targetMigrationContract;
    bool public migrationEnabled;

    // Constructor with fixed, safe initialization of instance variables
    constructor() Ownable(msg.sender) {
        targetMigrationContract = 0x1111111111111111111111111111111111111111; // Replace with actual value
        migrationEnabled = true;
    }

    function setMigrationTarget(address _newMigrationTarget) public onlyOwner {
        require(_newMigrationTarget != address(0), ""MigrationTarget: zero address"");
        targetMigrationContract = _newMigrationTarget;
    }

    function enableMigration() public onlyOwner {
        require(targetMigrationContract != address(0), ""MigrationTarget: first set target address"");
        migrationEnabled = true;
    }

    function disableMigration() public onlyOwner {
        migrationEnabled = false;
    }

    modifier verifyMigrationEnabled() {
        require(migrationEnabled == true, ""MigrationTarget: migration process is disabled"");
        _;
    }
}
```

Note that I've replaced the actual values with `0x1111111111111111111111111111111111111111` placeholders. You should replace these with the actual fixed, safe values for your contract.

Also, as a side note, it's worth mentioning that using `address(0)` in the `require` statements is not necessary, since `address(0)` is already considered ""zero"" and will always fail the condition. Instead, you can simply use `address(0)` directly in the `require` statement without wrapping it in parentheses:

```solidity
require(_newMigrationTarget != address(0), ""MigrationTarget: zero address"");"
4553,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public blacklistedUsers;
    bool public paused = false;

    modifier userNotBlacklisted(address _user) {
        require(!blacklistedUsers[_user], ""User is blacklisted"");
        _;
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have permission"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused {
        _mint(_to, _amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

contract MyNFT is ERC721, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    constructor() ERC721(""MyNFT"", ""MNFT"") {
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function mint(address to, uint256 tokenId) external {
        require(hasRole(MINTER_ROLE, msg.sender), ""Must have minter role to mint"");

        _mint(to, tokenId);
    }
}",5.464838266372681,mint,"[{'function': 'mint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Must have minter role to mint""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.6654746497082916,0.1241635064559202,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyNFT is ERC721, AccessControl, Ownable {
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    constructor() ERC721(""MyNFT"", ""MNFT"") {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // Assuming DEFAULT_ADMIN_ROLE is used for Ownable initialization
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function mint(address to, uint256 tokenId) external {
        require(hasRole(MINTER_ROLE, msg.sender), ""Must have minter role to mint"");
        _mint(to, tokenId);
    }
}"
4912,Used only if there are some leftover funds ( because of topUpBalance ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
        wallet.transfer(address(this).balance);
    }
}","ty
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LeftoverFundsHandler is Initializable, ReentrancyGuard {
    using SafeMath for uint256;

    address payable private _owner;
    uint256 private topUpBalance;

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Caller is not the owner"");
        _;
    }

    function initialize() public initializer {
        __ReentrancyGuard_init();
        _owner = payable(msg.sender);
    }

    function handleLeftoverFunds(uint256 amount) external onlyOwner nonReentrant {
        require(amount <= topUpBalance, ""Amount exceeds the top up balance"");
        _owner.transfer(amount);
        topUpBalance = topUpBalance.sub(amount);
    }
}",13.282647132873535,handleLeftoverFunds,"[{'function': 'initialize', 'complexity': 0}, {'function': 'handleLeftoverFunds', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""handleLeftoverFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""topUpBalance""}}, {""type"": ""stringLiteral"", ""value"": ""Amount exceeds the top up balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""topUpBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""topUpBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.4781650983733329,0.0350784192085697,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

contract LeftoverFundsHandler is Initializable, ReentrancyGuard {
    using SafeMath for uint256;

    address payable private _owner;
    uint256 private topUpBalance;

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Caller is not the owner"");
        _;
    }

    constructor() {
        initialize();
    }

    function initialize() public initializer {
        __ReentrancyGuard_init();
        _owner = payable(msg.sender);
        topUpBalance = 1; // Set to a non-zero, safe value
    }

    function handleLeftoverFunds(uint256 amount) external onlyOwner nonReentrant {
        require(amount <= topUpBalance, ""Amount exceeds the top up balance"");
        _owner.transfer(amount);
        topUpBalance = topUpBalance.sub(amount);
    }
}"
4727,This method MUST NEVER be called by smart contract code .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IGiftToken {
    function GiftsOfOwner(address _owner) external view returns (uint256[] memory);
}

abstract contract GiftWrapper is Ownable {
    using SafeMath for uint256;

    address public giftContractAddress;

    constructor(address _giftContractAddress) {
        giftContractAddress = _giftContractAddress;
    }

    function giftOwnerByIndex(uint256 _index) external view returns (uint256 GiftId) {
        IGiftToken giftToken = IGiftToken(giftContractAddress);
        uint256[] memory ownerGifts = giftToken.GiftsOfOwner(owner());
        require(_index < ownerGifts.length, ""Index out of bounds"");
        return ownerGifts[_index];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol"";

contract SampleContract is ReentrancyGuard {
    function safeMethod(address payable recipient, uint256 amount) external nonReentrant {
        require(!isContract(msg.sender), ""Cannot be called by contract"");
        recipient.transfer(amount);
    }

    function isContract(address _addr) private view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }
        return (size > 0);
    }
}",9.223160982131958,isContract,"[{'function': 'safeMethod', 'complexity': 2}, {'function': 'isContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_addr"", ""arguments"": []}]}}]}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}]}, ""visibility"": ""private"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",22.0,0.3322089861938077,0.0320702019043646,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SampleContract is ReentrancyGuard, Ownable {
    constructor() ReentrancyGuard() Ownable(msg.sender) {}

    function safeMethod(address payable recipient, uint256 amount) external nonReentrant {
        require(!isContract(msg.sender), ""Cannot be called by contract"");
        recipient.transfer(amount);
    }

    function isContract(address _addr) private view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }
        return (size > 0);
    }
}"
5921,Hash ( keccak256 ) of the payload used by approvePreSigned,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovePreSignedHashingWrapper {
    using SafeMath for uint256;

    function approvePreSignedHashing(address _token, address _spender, uint256 _value, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(
            bytes4(0xf7ac9c2e),
            _token,
            _spender,
            _value,
            _fee,
            _nonce
        );
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PreSignedTransfer {
    using SafeMath for uint256;

    mapping(bytes => bool) public preSignedHashes;

    function approvePreSigned(bytes memory _signature, address _to, uint256 _value, uint256 _fee, uint256 _nonce) public {
        bytes32 hashedTx = keccak256(abi.encodePacked(this, _to, _value, _fee, _nonce));

        require(_signature.length == 65, ""Invalid signature length."");
        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            v := byte(0, mload(add(_signature, 96)))
        }

        require(ecrecover(hashedTx, v, r, s) != address(0), ""Invalid signature."");

        require(!preSignedHashes[hashedTx], ""Transaction already occurred."");

        preSignedHashes[hashedTx] = true;
    }
}",14.382699012756348,approvePreSigned,"[{'function': 'approvePreSigned', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approvePreSigned"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hashedTx"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_signature""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""65"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature length.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""r"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""s"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""v"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""r""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_signature"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""32""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""s""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_signature"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""64""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""v""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""byte"", ""arguments"": [{""type"": ""DecimalNumber"", ""value"": ""0""}, {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_signature"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""96""}]}]}]}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ecrecover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hashedTx""}, {""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""preSignedHashes""}, ""index"": {""type"": ""Identifier"", ""name"": ""hashedTx""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Transaction already occurred.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""preSignedHashes""}, ""index"": {""type"": ""Identifier"", ""name"": ""hashedTx""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",73.0,0.7848563078044593,0.13768751169579,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PreSignedTransfer is Ownable {
    using SafeMath for uint256;

    mapping(bytes => bool) public preSignedHashes;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approvePreSigned(bytes memory _signature, address _to, uint256 _value, uint256 _fee, uint256 _nonce) public {
        bytes32 hashedTx = keccak256(abi.encodePacked(this, _to, _value, _fee, _nonce));

        require(_signature.length == 65, ""Invalid signature length."");
        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(_signature, 32))
            s := mload(add(_signature, 64))
            v := byte(0, mload(add(_signature, 96)))
        }

        require(ecrecover(hashedTx, v, r, s) != address(0), ""Invalid signature."");

        require(!preSignedHashes[hashedTx], ""Transaction already occurred."");

        preSignedHashes[hashedTx] = true;
    }
}"
5070,Withdraw ether and delete the htlc swap .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MultisigWallet is Ownable {
    using SafeMath for uint256;

    struct Multisig {
        uint unlockTime;
        address[] owners;
        mapping(address => bool) ownerMap;
        uint deposit;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;

    function spendFromMultisig(bytes32 msigId, uint amount, address owner) internal {
        // Implementation of spending from multisig logic
    }

    function timeoutResolve(bytes32 msigId, uint amount) public onlyOwner {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time has not been reached"");
        spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity >=0.5.16 <0.9.0;

import '@openzeppelin/contracts/utils/math/SafeMath.sol';

contract MyContract {
    using SafeMath for uint256;

    struct Swap {
        uint256 amount;
        address payable participant;
    }

    mapping(bytes32 => Swap) public swaps;

    function withdraw(bytes32 _swapId) external {
        Swap storage swap = swaps[_swapId];
        uint256 amount = swap.amount;
        address payable participant = swap.participant;

        require(amount > 0, 'No funds to withdraw');
        require(msg.sender == participant, 'Access denied');

        delete swaps[_swapId];

        (bool success, ) = participant.call{value: amount}("""");
        require(success, 'Transfer failed');
    }
}",8.619746685028076,withdraw,"[{'function': 'withdraw', 'complexity': 3}]",4.0,{},38.0,0.4868004967623766,0.0704980367519285,"// SPDX-License-Identifier: MIT
pragma solidity >=0.5.16 <0.9.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Swap {
        uint256 amount;
        address payable participant;
    }

    mapping(bytes32 => Swap) public swaps;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function withdraw(bytes32 _swapId) external {
        Swap storage swap = swaps[_swapId];
        uint256 amount = swap.amount;
        address payable participant = swap.participant;

        require(amount > 0, 'No funds to withdraw');
        require(msg.sender == participant, 'Access denied');

        delete swaps[_swapId];

        (bool success, ) = participant.call{value: amount}("""");
        require(success, 'Transfer failed');
    }
}"
4823,Send tokens to multiple recipients on behalf of the address ` from ` The transaction will revert if any of the recipients is frozen .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    mapping(address => bool) public frozenAccounts;

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        require(!paused, ""Contract is already paused."");
        paused = false;
    }

    function freezeAccount(address account) external onlyOwner {
        frozenAccounts[account] = true;
    }

    function unfreezeAccount(address account) external onlyOwner {
        require(frozenAccounts[account], ""Account is not frozen."");
        delete frozenAccounts[account];
    }

    function operatorBatchSend(address _from, address[] memory _recipients, uint256[] memory _amounts, bytes memory _userData, bytes memory _operatorData) external whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
        require(_recipients.length == _amounts.length, ""The lengths of _recipients and _amounts should be the same."");
        require(isOperatorFor(msg.sender, _from), ""Only operators can call this function"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            doSend(msg.sender, _from, _recipients[i], _amounts[i].mul(_amounts[i]), _userData, _operatorData, true);
        }
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused."");
        _;
    }

    modifier whenAccountNotFrozen(address account) {
        require(!frozenAccounts[account], ""Account is frozen."");
        _;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MultiSend is Ownable {
    mapping (address => bool) private _frozenAccounts;

    function multiSendTokensFrom(
        address from,
        address tokenAddress,
        address[] calldata recipients,
        uint256[] calldata amounts
    )
        public
        onlyOwner
    {
        require(recipients.length == amounts.length, ""Mismatched recipient and amount arrays."");
        IERC20 token = IERC20(tokenAddress);

        for (uint256 i = 0; i < recipients.length; i++) {
            require(!_frozenAccounts[recipients[i]], ""Recipient account is frozen."");
            uint256 oldSenderBalance = token.balanceOf(from);
            require(token.transferFrom(from, recipients[i], amounts[i]), ""Transfer failed."");
            require(token.balanceOf(from) == oldSenderBalance - amounts[i], ""Transfer did not properly take funds from the sender."");
        }
    }

    function freezeAccount(address account, bool isFrozen) public onlyOwner {
        _frozenAccounts[account] = isFrozen;
    }
}",9.343886137008669,multiSendTokensFrom,"[{'function': 'multiSendTokensFrom', 'complexity': 0}, {'function': 'freezeAccount', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiSendTokensFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""recipients"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""amounts"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Mismatched recipient and amount arrays.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_frozenAccounts""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Recipient account is frozen.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldSenderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""oldSenderBalance""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""stringLiteral"", ""value"": ""Transfer did not properly take funds from the sender.""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",51.0,0.6075916832398349,0.188773330779197,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiSend is Ownable {
    mapping (address => bool) private _frozenAccounts;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
            _frozenAccounts[addr] = false;
        }
    }

    function multiSendTokensFrom(
        address from,
        address tokenAddress,
        address[] calldata recipients,
        uint256[] calldata amounts
    )
        public
        onlyOwner
    {
        require(recipients.length == amounts.length, ""Mismatched recipient and amount arrays."");
        IERC20 token = IERC20(tokenAddress);

        for (uint256 i = 0; i < recipients.length; i++) {
            require(!_frozenAccounts[recipients[i]], ""Recipient account is frozen."");
            uint256 oldSenderBalance = token.balanceOf(from);
            require(token.transferFrom(from, recipients[i], amounts[i]), ""Transfer failed."");
            require(token.balanceOf(from) == oldSenderBalance - amounts[i], ""Transfer did not properly take funds from the sender."");
        }
    }

    function freezeAccount(address account, bool isFrozen) public onlyOwner {
        _frozenAccounts[account] = isFrozen;
    }
}"
4675,Used to launch the Module with the help of factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPolyToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract GeneralPermissionManager {
    constructor(address owner, address polyTokenAddress) {
        // Constructor implementation
    }
}

abstract contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    IPolyToken public polyToken;
    uint256 public setupCost;

    event GenerateModuleFromFactory(address indexed moduleAddress, string name, address factoryAddress, address sender, uint256 cost, uint256 timestamp);

    constructor(uint256 _setupCost, address _polyToken) {
        setupCost = _setupCost;
        polyToken = IPolyToken(_polyToken);
    }

    function deploy(bytes memory data) external returns (address) {
        if (setupCost > 0) {
            require(polyToken.transferFrom(msg.sender, owner(), setupCost), ""Failed transferFrom due to insufficient Allowance provided"");
        }
        address permissionManager = new GeneralPermissionManager{salt: bytes32(uint256(data))}(msg.sender, address(polyToken));
        emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, block.timestamp);
        return permissionManager;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract ModuleFactory is Ownable, ReentrancyGuard {
  using SafeMath for uint256;

  address[] private modules;

  function launchModule(address _factory) external onlyOwner nonReentrant returns (address) {
    address newModule = createModule(_factory);
    modules.push(newModule);
    return newModule;
  }

  function createModule(address _factory) internal virtual returns (address);

  function getModules() external view returns (address[] memory) {
    return modules;
  }
}",10.470608949661257,launchModule,"[{'function': 'launchModule', 'complexity': 0}, {'function': 'createModule', 'complexity': 0}, {'function': 'getModules', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""launchModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_factory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newModule"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""createModule""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_factory""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""modules""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newModule""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""newModule""}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.5273649594596375,0.0247804382951687,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract ModuleFactory is Ownable, ReentrancyGuard {
  using SafeMath for uint256;

  address[] private modules;

  constructor() Ownable(msg.sender) {
    // Initialization of state variables
    modules = [];
  }

  function launchModule(address _factory) external onlyOwner nonReentrant returns (address) {
    address newModule = createModule(_factory);
    modules.push(newModule);
    return newModule;
  }

  function createModule(address _factory) internal virtual returns (address);

  function getModules() external view returns (address[] memory) {
    return modules;
  }
}"
772,This should be public rather than external .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    constructor(address _saleAuction, address _synthesizingAuction, address _geneSynthesis) {
        require(_saleAuction != address(0), ""Sale auction must be a valid address"");
        require(_synthesizingAuction != address(0), ""Synthesizing auction must be a valid address"");
        require(_geneSynthesis != address(0), ""Gene synthesis must be a valid address"");
        saleAuction = _saleAuction;
        synthesizingAuction = _synthesizingAuction;
        geneSynthesis = _geneSynthesis;
    }

    function unpause() public onlyOwner {
        require(saleAuction != address(0));
        require(synthesizingAuction != address(0));
        require(geneSynthesis != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Importing SafeMath from OpenZeppelin's contracts library
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function add(uint256 num1, uint256 num2) public pure returns (uint256) {
        return num1.add(num2);
    }
}",9.641491889953612,add,"[{'function': 'add', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""add"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""num1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""num2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""num1""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""num2""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",35.0,0.2292576100445077,0.0177905690055961,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Importing SafeMath from OpenZeppelin's contracts library
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    function add(uint256 num1, uint256 num2) public pure returns (uint256) {
        return num1.add(num2);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
6429,Update the stored `` poaTokenMaster '' address to upgrade the PoaToken master contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

   function proxyChangeTokenMaster(address _newMaster) public returns (bool) {
    require(msg.sender == getContractAddress(""PoaManager""), ""Only the PoaManager contract can call this function"");
    require(_newMaster != address(0), ""Invalid new master address"");
    require(poaTokenMaster != _newMaster, ""New master address is the same as the current one"");
    require(isContract(_newMaster), ""New master address must be a contract"");

    address _oldMaster = poaTokenMaster;
    poaTokenMaster = _newMaster;
    emit ProxyUpgraded(_oldMaster, _newMaster);

    getContractAddress(""PoaLogger"").call(bytes4(keccak256(""logProxyUpgraded(address,address)"")), _oldMaster, _newMaster);

    return true;
}
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PoaMaster is Ownable {
    address public poaTokenMaster;

    function updatePoaTokenMaster(address newPoaTokenMaster) external onlyOwner {
        require(newPoaTokenMaster != address(0), ""PoaMaster: new master is the zero address"");
        poaTokenMaster = newPoaTokenMaster;
    }
}",5.039075136184692,updatePoaTokenMaster,"[{'function': 'updatePoaTokenMaster', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePoaTokenMaster"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newPoaTokenMaster"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newPoaTokenMaster""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""PoaMaster: new master is the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPoaTokenMaster""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",51.0,0.7138194778063683,0.0163569851444826,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PoaMaster is Ownable {
    address public poaTokenMaster;

    constructor(address _poaTokenMaster) Ownable() {
        require(_poaTokenMaster != address(0), ""PoaMaster: new master is the zero address"");
        poaTokenMaster = _poaTokenMaster;
    }

    function updatePoaTokenMaster(address newPoaTokenMaster) external onlyOwner {
        require(newPoaTokenMaster != address(0), ""PoaMaster: new master is the zero address"");
        poaTokenMaster = newPoaTokenMaster;
    }
}"
4411,Trust an address to perform recovery procedure for the caller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function getHolderId(address holder) external view returns (uint);
    function isTrusted(address from, address to) external view returns (bool);
    function set(address store, bytes32 key, uint index, address value, bool trusted) external;
    function _emitErrorCode(uint errorCode) external pure returns (uint);
}

abstract contract TrustWrapper is Ownable {
    using SafeMath for uint;

    enum ErrorCodes {
        OK,
        CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF,
        CHRONOBANK_PLATFORM_ALREADY_TRUSTED
    }

    address public constant PLATFORM_ADDRESS = 0xYourPlatformContractAddress;
    ChronoBankPlatform platform = ChronoBankPlatform(PLATFORM_ADDRESS);

    function trust(address _to) public returns (uint) {
        uint fromId = _createHolderId(msg.sender);
        if (fromId == platform.getHolderId(_to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);
        }
        if (platform.isTrusted(msg.sender, _to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_ALREADY_TRUSTED);
        }
        platform.set(address(this), keccak256(abi.encodePacked(""holdersTrust"", fromId)), 0, _to, true);
        return ErrorCodes.OK;
    }

    function _createHolderId(address holder) internal view returns (uint) {
        // Implement your logic to create a unique ID for the holder
        return uint(keccak256(abi.encodePacked(holder)));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract RecoveryProcedure is AccessControl {
    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");

    mapping (address => address) private recoveryDelegate;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function trustAddressForRecovery(address delegate) public {
        require(hasRole(RECOVERY_ROLE, msg.sender), ""Caller is not authorized to trust addresses"");
        recoveryDelegate[msg.sender] = delegate;
    }

    function recoverAccount(address account, address newOwner) public {
        require(msg.sender == recoveryDelegate[account], ""Not the trusted recovery address"");
        grantRole(RECOVERY_ROLE, newOwner);
        revokeRole(RECOVERY_ROLE, account);
    }
}",8.549790143966675,recoverAccount,"[{'function': 'trustAddressForRecovery', 'complexity': 1}, {'function': 'recoverAccount', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""recoverAccount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recoveryDelegate""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}}, {""type"": ""stringLiteral"", ""value"": ""Not the trusted recovery address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""RECOVERY_ROLE""}, {""type"": ""Identifier"", ""name"": ""newOwner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revokeRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""RECOVERY_ROLE""}, {""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.4659095856416399,0.0182039910010947,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RecoveryProcedure is AccessControl, Ownable {
    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");

    mapping (address => address) private recoveryDelegate;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function trustAddressForRecovery(address delegate) public {
        require(hasRole(RECOVERY_ROLE, msg.sender), ""Caller is not authorized to trust addresses"");
        recoveryDelegate[msg.sender] = delegate;
    }

    function recoverAccount(address account, address newOwner) public {
        require(msg.sender == recoveryDelegate[account], ""Not the trusted recovery address"");
        grantRole(RECOVERY_ROLE, newOwner);
        revokeRole(RECOVERY_ROLE, account);
    }
}"
2481,Destroy the vesting information associated with an account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    mapping(address => VestingSchedule) public vestingSchedules;
    mapping(address => uint256) public totalVestedAccountBalance;
    uint256 public totalVestedBalance;

    struct VestingSchedule {
        // Define the structure of a vesting schedule here
    }

    function purgeAccount(address account) external onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract VestingInfo is Ownable {
    mapping(address => bool) private vestingInfo;

    function destroyVestingInfo(address account) public onlyOwner {
        require(account != address(0), ""VestingInfo: cannot destroy account zero"");
        require(vestingInfo[account] == true, ""VestingInfo: account not recorded"");

        delete vestingInfo[account];
    }
}",4.977614879608154,destroyVestingInfo,"[{'function': 'destroyVestingInfo', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyVestingInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""VestingInfo: cannot destroy account zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingInfo""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""stringLiteral"", ""value"": ""VestingInfo: account not recorded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingInfo""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.7200405751444121,0.0904750204425633,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VestingInfo is Ownable {
    mapping(address => bool) private vestingInfo;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function destroyVestingInfo(address account) public onlyOwner {
        require(account != address(0), ""VestingInfo: cannot destroy account zero"");
        require(vestingInfo[account] == true, ""VestingInfo: account not recorded"");

        delete vestingInfo[account];
    }
}"
4726,` finalizeSale ( ) ` ends the TokenSale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function generateTokens(address, uint256) external returns (bool);
}

abstract contract VestedTokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public endTime;
    uint256 public totalIssued;
    uint256 public lockedTokens;
    uint256 public totalVested;
    uint256 public constant HARD_CAP = 100000 * 10**18; // Example hard cap, adjust as needed
    uint256 public constant MAX_TOKENS = 100000 * 10**18; // Example max tokens, adjust as needed
    bool public finalized;
    address public vaultAddress;
    TokenInterface public tokenContract;

    struct Vesting {
        uint256 amount;
        uint256 releaseTime;
    }

    mapping(address => Vesting) public vestedAllowances;

    function finalizeSale() public onlyOwner {
        require(block.timestamp > endTime || totalIssued >= HARD_CAP);
        require(!finalized, ""Sale has already been finalized"");

        vestedAllowances[vaultAddress] = Vesting(lockedTokens, block.timestamp + 3 years);

        uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalVested);
        require(tokenContract.generateTokens(vaultAddress, leftoverTokens), ""Token transfer failed for vault"");
        require(tokenContract.generateTokens(address(this), lockedTokens.add(totalVested)), ""Token transfer failed for contract"");

        finalized = true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is Ownable, ReentrancyGuard {

    bool private _saleFinalized;

    function finalizeSale() external onlyOwner nonReentrant {
        require(!_saleFinalized, ""TokenSale: sale already finalized"");

        _saleFinalized = true;
    }
}",3.926946878433228,finalizeSale,"[{'function': 'finalizeSale', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""_saleFinalized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""TokenSale: sale already finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_saleFinalized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",60.0,0.8207515656518376,0.0088597842274234,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable, ReentrancyGuard {
    bool private _saleFinalized;

    constructor() Ownable(msg.sender) {
        _saleFinalized = false; // Set to false instead of true to avoid corner cases
    }

    function finalizeSale() external onlyOwner nonReentrant {
        require(!_saleFinalized, ""TokenSale: sale already finalized"");
        _saleFinalized = true;
    }
}"
475,Release some of an affiliate 's tokens to a broker/trading wallet .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function transfer(address to, uint256 value) external returns (bool success);
}

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isAffiliate;
    }

    mapping(address => Holding) public heldTokens;
    address public tokenContract;

    event TokensReleased(address indexed beneficiary, uint256 amount);

    modifier onlyTransferAgent() {
        require(hasRole(TRANSFER_AGENT_ROLE, msg.sender), ""Caller is not a transfer agent"");
        _;
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyTransferAgent returns (bool) {
        require(tradingWallet != address(0), ""The destination wallet cannot be null."");
        require(!isExistingHolding(tradingWallet), ""The destination wallet must be a new fresh wallet."");
        Holding memory holding = heldTokens[who];
        require(holding.isAffiliate, ""Only affiliates can use this function; use release() for non-affiliates."");
        require(amount <= holding.quantity, ""The holding has less than the specified amount of tokens."");
        if (block.timestamp > holding.releaseDate) {
            bool res = ERC20Interface(tokenContract).transfer(tradingWallet, amount);
            if (res) {
                heldTokens[who] = Holding(holding.quantity.sub(amount), holding.releaseDate, holding.isAffiliate);
                emit TokensReleased(who, amount);
                return true;
            }
        }
        return false;
    }

    function isExistingHolding(address wallet) internal view returns (bool) {
        // Implement the logic to check if the wallet has an existing holding
        // This should be implemented based on your specific requirements and data storage
        return heldTokens[wallet].quantity > 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenRelease is Ownable {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function releaseAffiliateTokensToBroker(address affiliate, address broker, uint256 amount) public onlyOwner {
        require(token.balanceOf(affiliate) >= amount, ""Not enough tokens in affiliate account"");

        // Assumes the contract has enough allowance to transfer from affiliate account
        token.transferFrom(affiliate, broker, amount);
    }
}",13.522701025009155,releaseAffiliateTokensToBroker,"[{'function': 'releaseAffiliateTokensToBroker', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseAffiliateTokensToBroker"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""affiliate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""broker"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""affiliate""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in affiliate account""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""affiliate""}, {""type"": ""Identifier"", ""name"": ""broker""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.6613942453488567,0.0283963865470577,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRelease is Ownable {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function releaseAffiliateTokensToBroker(address affiliate, address broker, uint256 amount) public onlyOwner {
        require(token.balanceOf(affiliate) >= amount, ""Not enough tokens in affiliate account"");

        // Assumes the contract has enough allowance to transfer from affiliate account
        token.transferFrom(affiliate, broker, amount);
    }
}"
1443,the method caller will have to claim ownership of regulators since regulators are claimable,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Regulator {
    function addValidator(address validator) external;
    function transferOwnership(address newOwner) external;
}

interface RegulatorProxy {
    function initialize(address regulatorImplementation) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxy, uint256 index);

    function createRegulatorProxy(address regulatorImplementation) public onlyOwner {
        require(regulatorImplementation != address(0), ""Invalid implementation address"");

        address proxy = address(new RegulatorProxy(regulatorImplementation));
        Regulator newRegulator = Regulator(proxy);
        newRegulator.addValidator(msg.sender);
        addAllPermissions(newRegulator);
        RegulatorProxy(proxy).transferOwnership(msg.sender);
        regulators.push(proxy);
        emit CreatedRegulatorProxy(proxy, getCount() - 1);
    }

    function getCount() public view returns (uint256) {
        return regulators.length;
    }

    function addAllPermissions(Regulator regulator) internal virtual {
        // Implement any necessary permission logic here
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Regulator is Ownable {

    mapping(address => bool) private _regulators;

    function claimOwnership() public {
        require(!_regulators[msg.sender], ""Regulator: caller is already a regulator"");
        _regulators[msg.sender] = true;
    }

    function isRegulator(address account) public view returns (bool) {
        return _regulators[account];
    }

    modifier onlyRegulator() {
        require(_regulators[msg.sender], ""Regulator: caller is not a regulator"");
        _;
    }
}",6.615767002105713,claimOwnership,"[{'function': 'claimOwnership', 'complexity': 2}, {'function': 'isRegulator', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_regulators""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Regulator: caller is already a regulator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_regulators""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.6350502594892804,0.006114949016055,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Regulator is Ownable {

    mapping(address => bool) private _regulators;

    function claimOwnership() public {
        require(!_regulators[msg.sender], ""Regulator: caller is already a regulator"");
        _regulators[msg.sender] = true;
    }

    function isRegulator(address account) public view returns (bool) {
        return _regulators[account];
    }

    modifier onlyRegulator() {
        require(_regulators[msg.sender], ""Regulator: caller is not a regulator"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _regulators[addr] = true;
        }
    }
}"
6667,Compute the new IssuanceData on the old balance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IssuanceData {
    function currentBalanceSum() external view returns (uint);
    function lastAverageBalance() external view returns (uint);
    function lastModified() external view returns (uint);
}

abstract contract IssuanceWrapper is Ownable {
    using SafeMath for uint;

    struct IssuanceDataStruct {
        uint currentBalanceSum;
        uint lastAverageBalance;
        uint lastModified;
    }

    function computeIssuanceData(uint preBalance, IssuanceData preIssuance) internal view returns (IssuanceData) {
        uint currentBalanceSum = preIssuance.currentBalanceSum();
        uint lastAverageBalance = preIssuance.lastAverageBalance();
        uint lastModified = preIssuance.lastModified();

        if (lastModified < feePeriodStartTime()) {
            if (lastModified < lastFeePeriodStartTime()) {
                lastAverageBalance = preBalance;
            } else {
                uint timeUpToRollover = feePeriodStartTime() - lastModified;
                uint lastFeePeriodDuration = feePeriodStartTime() - lastFeePeriodStartTime();
                uint lastBalanceSum = currentBalanceSum.add(preBalance.mul(timeUpToRollover));
                lastAverageBalance = lastBalanceSum / lastFeePeriodDuration;
            }
            currentBalanceSum = preBalance.mul(now - feePeriodStartTime());
        } else {
            currentBalanceSum = currentBalanceSum.add(preBalance.mul(now - lastModified));
        }

        return IssuanceData(currentBalanceSum, lastAverageBalance, now);
    }

    uint public feePeriodStartTime;
    uint public lastFeePeriodStartTime;

    constructor() {
        // Initialize fee period start times or other necessary state variables here.
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ComputeNewIssuance {
    using SafeMath for uint256;

    struct IssuanceData {
        uint256 balance;
        uint256 lastUpdated;
    }

    mapping(address => IssuanceData) private _issuances;

    function computeNewIssuance(address account, uint256 newAmount)
        public
        returns(uint256)
    {
        IssuanceData storage issuance = _issuances[account];

        require(issuance.lastUpdated <= block.timestamp, ""Can't update issuance before timestamp"");

        uint256 oldBalance = issuance.balance;
        uint256 newBalance = oldBalance.add(newAmount);

        issuance.balance = newBalance;
        issuance.lastUpdated = block.timestamp;

        return issuance.balance;
    }
}",7.681522369384766,computeNewIssuance,"[{'function': 'computeNewIssuance', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeNewIssuance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IssuanceData""}, ""name"": ""issuance"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_issuances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""issuance""}, ""memberName"": ""lastUpdated""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Can""t update issuance before timestamp""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""issuance""}, ""memberName"": ""balance""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""oldBalance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""issuance""}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBalance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""issuance""}, ""memberName"": ""lastUpdated""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""issuance""}, ""memberName"": ""balance""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.6265243148722339,0.004163364614333,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ComputeNewIssuance is Ownable {
    using SafeMath for uint256;

    struct IssuanceData {
        uint256 balance;
        uint256 lastUpdated;
    }

    mapping(address => IssuanceData) private _issuances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _issuances[addr] = IssuanceData({balance: uint256(i), lastUpdated: uint256(i)});
        }
    }

    function computeNewIssuance(address account, uint256 newAmount)
        public
        returns (uint256)
    {
        IssuanceData storage issuance = _issuances[account];

        require(issuance.lastUpdated <= block.timestamp, ""Can't update issuance before timestamp"");

        uint256 oldBalance = issuance.balance;
        uint256 newBalance = oldBalance.add(newAmount);

        issuance.balance = newBalance;
        issuance.lastUpdated = block.timestamp;

        return issuance.balance;
    }
}"
1283,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) internal allowances;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approve failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract ApproveAndCall {

    using SafeERC20 for IERC20;

    function approveAndCall(address _spender, uint256 _amount, address _token) public {
        IERC20 token = IERC20(_token);
        token.safeIncreaseAllowance(_spender, _amount);

        // Assuming the spender contract has a function named 'receiveApproval'
        (bool success,) = _spender.call(abi.encodeWithSignature(""receiveApproval(address,uint256,address)"", msg.sender, _amount, _token));

        // Safe check
        require(success,
                ""ApproveAndCall: Calling onSpendingAllowed on the spender contract failed"");
    }
}",8.110797882080078,approveAndCall,"[{'function': 'approveAndCall', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeIncreaseAllowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""receiveApproval(address,uint256,address)""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""ApproveAndCall: Calling onSpendingAllowed on the spender contract failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.3249796246688131,0.022298412612257,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ApproveAndCall is Ownable {
    using SafeERC20 for IERC20;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveAndCall(address _spender, uint256 _amount, address _token) public {
        IERC20 token = IERC20(_token);
        token.safeIncreaseAllowance(_spender, _amount);

        // Assuming the spender contract has a function named 'receiveApproval'
        (bool success,) = _spender.call(abi.encodeWithSignature(""receiveApproval(address,uint256,address)"", msg.sender, _amount, _token));

        // Safe check
        require(success, ""ApproveAndCall: Calling onSpendingAllowed on the spender contract failed"");
    }
}"
6724,Adds a pair of addresses to manual blockings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct ManualBlocking {
        uint256 expiryTime;
    }

    mapping(address => mapping(address => ManualBlocking)) public manualBlockings;

    event AddManualBlocking(address indexed from, address indexed to, uint256 expiryTime, address approver);

    function addManualBlocking(address _from, address _to, uint256 _expiryTime) public onlyOwner {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_expiryTime > block.timestamp, ""Invalid expiry time"");
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");
        manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AddressBlockings {
    mapping(address => mapping(address => bool)) private manualBlockings;

    function addManualBlocking(address _from, address _to) external {
        require(msg.sender == owner, 'Only the contract owner can add manual blockings');
        require(_from != address(0) && _to != address(0), 'Cannot block null address');
        require(_from != _to, ""It's not allowed to block oneself"");
        require(!isManualBlocking(_from, _to), 'This blocking already exists');

        manualBlockings[_from][_to] = true;
    }

    function isManualBlocking(address _from, address _to) public view returns(bool isBlocked) {
        return manualBlockings[_from][_to];
    }
}",10.58631682395935,addManualBlocking,"[{'function': 'addManualBlocking', 'complexity': 6}, {'function': 'isManualBlocking', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""addManualBlocking"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can add manual blockings""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Cannot block null address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}, {""type"": ""stringLiteral"", ""value"": ""It""s not allowed to block oneself""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isManualBlocking""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""This blocking already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""manualBlockings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.9140190027314744,0.3871501548346429,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AddressBlockings is Ownable {
    mapping(address => mapping(address => bool)) private manualBlockings;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addManualBlocking(address _from, address _to) external {
        require(msg.sender == owner(), 'Only the contract owner can add manual blockings');
        require(_from != address(0) && _to != address(0), 'Cannot block null address');
        require(_from != _to, ""It's not allowed to block oneself"");
        require(!isManualBlocking(_from, _to), 'This blocking already exists');

        manualBlockings[_from][_to] = true;
    }

    function isManualBlocking(address _from, address _to) public view returns(bool isBlocked) {
        return manualBlockings[_from][_to];
    }
}"
2869,this function lets arbitrator withdraw DAI to the provided address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract DAIWrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public DAI;

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    constructor(address _daiAddress) {
        require(_daiAddress != address(0), ""Invalid DAI contract address"");
        DAI = IERC20(_daiAddress);
    }

    function withdrawDAI(address _receiver, uint256 _amount) public onlyOwner {
        require(_receiver != address(0), ""Invalid receiver address"");
        require(_amount > 0, ""Invalid amount"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance"");
        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ArbitrationContract is Ownable {
    IERC20 public daiToken;

    constructor(IERC20 _daiToken) public {
        daiToken = _daiToken;
    }

    function withdrawDai(uint256 _amount, address _to) external onlyOwner {
        require(daiToken.balanceOf(address(this)) >= _amount, ""Not enough DAI in the contract"");
        require(_to != address(0), ""Cannot withdraw to the zero address"");

        bool sent = daiToken.transfer(_to, _amount);
        require(sent, ""Token transfer failed"");
    }
}",6.67159914970398,withdrawDai,"[{'function': 'withdrawDai', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawDai"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""daiToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough DAI in the contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot withdraw to the zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""sent"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""daiToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sent""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.8609667428475839,0.3599640628162608,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ArbitrationContract is Ownable {
    IERC20 public daiToken;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _daiToken) public Ownable(msg.sender) {
        daiToken = _daiToken;
    }

    function withdrawDai(uint256 _amount, address _to) external onlyOwner {
        require(daiToken.balanceOf(address(this)) >= _amount, ""Not enough DAI in the contract"");
        require(_to != address(0), ""Cannot withdraw to the zero address"");

        bool sent = daiToken.transfer(_to, _amount);
        require(sent, ""Token transfer failed"");
    }
}"
3748,Get the node at the end of a double linked list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address next;
        address previous;
    }

    mapping(uint256 => Node) public list;

    function end(List storage self) internal view returns (address) {
        return self.list[0].previous;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LinkedList {

    struct Node {
        uint data;
        address next;
        address prev;
    }

    mapping(address => Node) public nodes;
    address public head;
    address public tail;

    function getNodeAtEnd() public view returns (uint) {
      require(tail != address(0), ""List is empty"");
      return nodes[tail].data;
    }
}",5.11496376991272,getNodeAtEnd,"[{'function': 'getNodeAtEnd', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNodeAtEnd"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""tail""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""List is empty""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""tail""}}, ""memberName"": ""data""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",13.0,0.6329906977171532,0.0509060848364987,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LinkedList is Ownable {
    struct Node {
        uint data;
        address next;
        address prev;
    }

    mapping(address => Node) public nodes;
    address public head;
    address public tail;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        head = address(1);
        tail = address(2);
        nodes[head] = Node({data: 1, next: address(0), prev: address(0)});
        nodes[tail] = Node({data: 2, next: address(0), prev: address(0)});
    }

    function getNodeAtEnd() public view returns (uint) {
        require(tail != address(0), ""List is empty"");
        return nodes[tail].data;
    }
}"
1053,Updates the board status according to the players score .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGame {
    function calculateBoardScore(uint boardId) external view returns (uint8 blackScore, uint8 whiteScore);
    function updateBoardStatus(uint boardId, BoardStatus status) external;
}

abstract contract GameWrapper is Ownable {
    using SafeMath for uint256;

    struct Board {
        bool exists;
        BoardStatus status;
    }

    mapping(uint => Board) public boards;

    IGame public gameContract;

    event BoardCreated(uint boardId, BoardStatus initialStatus);

    constructor(address _gameContractAddress) {
        gameContract = IGame(_gameContractAddress);
    }

    modifier boardWaitingToResolve(uint boardId) {
        require(boards[boardId].exists, ""Board does not exist"");
        require(boards[boardId].status == BoardStatus.Pending, ""Board status is not pending"");
        _;
    }

    function createBoard(uint boardId, BoardStatus initialStatus) external onlyOwner {
        require(!boards[boardId].exists, ""Board already exists"");
        boards[boardId] = Board({exists: true, status: initialStatus});
        emit BoardCreated(boardId, initialStatus);
    }

    function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {
        uint8 blackScore;
        uint8 whiteScore;
        (blackScore, whiteScore) = gameContract.calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;
        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }
        gameContract.updateBoardStatus(boardId, status);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract GameContract is Ownable {
    using SafeMath for uint256;

    enum BoardStatus { Idle, Active, Complete }

    struct Board {
        uint256 playerScore;
        BoardStatus status;
    }

    mapping(address => Board) public boards;

    function updateBoardStatus(address playerAddress, uint256 score) public onlyOwner {
        Board storage playerBoard = boards[playerAddress];

        playerBoard.playerScore = score;

        if(score == 100) {
            playerBoard.status = BoardStatus.Complete;
        } else if(score > 0) {
            playerBoard.status = BoardStatus.Active;
        } else {
            playerBoard.status = BoardStatus.Idle;
        }
    }
}",10.045558214187622,updateBoardStatus,"[{'function': 'updateBoardStatus', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateBoardStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""playerAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""score"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Board""}, ""name"": ""playerBoard"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""playerAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""playerBoard""}, ""memberName"": ""playerScore""}, ""right"": {""type"": ""Identifier"", ""name"": ""score""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""score""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""playerBoard""}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""Complete""}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""score""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""playerBoard""}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""Active""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""playerBoard""}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""Idle""}}}]}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.658054096877764,0.0653949197465479,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract GameContract is Ownable {
    using SafeMath for uint256;

    enum BoardStatus { Idle, Active, Complete }

    struct Board {
        uint256 playerScore;
        BoardStatus status;
    }

    mapping(address => Board) public boards;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            boards[addr] = Board({ playerScore: 1, status: BoardStatus.Idle });
        }
    }

    function updateBoardStatus(address playerAddress, uint256 score) public onlyOwner {
        Board storage playerBoard = boards[playerAddress];

        playerBoard.playerScore = score;

        if (score == 100) {
            playerBoard.status = BoardStatus.Complete;
        } else if (score > 0) {
            playerBoard.status = BoardStatus.Active;
        } else {
            playerBoard.status = BoardStatus.Idle;
        }
    }
}"
963,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

abstract contract WrappedERC721 is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event OperatorApproval(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external onlyOwner {
        approvedOperators[_operator] = _approved;
        emit OperatorApproval(_msgSender(), _operator, _approved);
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return approvedOperators[_operator];
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/Address.sol"";

contract Operator {
    using Address for address;

    mapping(address => mapping(address => bool)) private _authorizedOperators;

    function isAuthorizedOperator(address operator, address tokenHolder) public view returns (bool) {
        require(operator.isContract(), ""Operator: address is not a contract"");
        require(tokenHolder.isContract(), ""Operator: address is not a contract"");
        return _authorizedOperators[operator][tokenHolder];
    }
}",5.207535982131958,isAuthorizedOperator,"[{'function': 'isAuthorizedOperator', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""isAuthorizedOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""operator""}, ""memberName"": ""isContract""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Operator: address is not a contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenHolder""}, ""memberName"": ""isContract""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Operator: address is not a contract""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_authorizedOperators""}, ""index"": {""type"": ""Identifier"", ""name"": ""operator""}}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenHolder""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",18.0,0.5953107571277848,0.0329582816568502,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Operator is Ownable {
    using Address for address;

    mapping(address => mapping(address => bool)) private _authorizedOperators;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function isAuthorizedOperator(address operator, address tokenHolder) public view returns (bool) {
        require(operator.isContract(), ""Operator: address is not a contract"");
        require(tokenHolder.isContract(), ""Operator: address is not a contract"");
        return _authorizedOperators[operator][tokenHolder];
    }
}"
3793,Create an invite using the signing model described in the contract description,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InviteCreator is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public pendingInvites;
    address public signingLogic;

    event InviteCreated(address indexed user, address indexed inviteAddress);

    modifier onlyUser() {
        require(msg.sender != owner(), ""Owner cannot create invites"");
        _;
    }

    function setSigningLogic(address _signingLogic) public onlyOwner {
        signingLogic = _signingLogic;
    }

    function createInvite(bytes memory _sig) public onlyUser {
        require(signingLogic != address(0), ""Signing logic not set"");
        address inviteAddress = signingLogic.call(abi.encodeWithSelector(this.recoverSigner.selector, keccak256(abi.encodePacked(msg.sender)), _sig));
        require(!pendingInvites[inviteAddress], ""Invite already created"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(msg.sender, inviteAddress);
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        return ECDSA.recover(hash, signature);
    }
}","pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";

contract MyContract is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _inviteIds;

    mapping (bytes32 => bool) private invites;

    constructor() ERC721(""MyContract"", ""MCT"") {}

    function createInvite(address _inviter, address _invitee) public returns (bytes32) {
        require(msg.sender == _inviter, ""Only valid inviter can create the invite"");
        bytes32 inviteId = keccak256(abi.encode(_inviter, _invitee, _inviteIds.current()));
        require(!invites[inviteId], ""Invite already exists"");
        invites[inviteId] = true;
        _inviteIds.increment();
        return inviteId;
    }
}",16.566838026046753,createInvite,"[{'function': 'createInvite', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createInvite"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_inviter"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_invitee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_inviter""}}, {""type"": ""stringLiteral"", ""value"": ""Only valid inviter can create the invite""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""inviteId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_inviter""}, {""type"": ""Identifier"", ""name"": ""_invitee""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_inviteIds""}, ""memberName"": ""current""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""invites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteId""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Invite already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""invites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_inviteIds""}, ""memberName"": ""increment""}, ""arguments"": [], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""inviteId""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.8322816274262362,0.1481612824950385,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Counters.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ERC721, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _inviteIds;

    mapping (bytes32 => bool) private invites;

    constructor() ERC721(""MyContract"", ""MCT"") Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        _inviteIds = Counters.Counter(1); // Start from 1 instead of 0
    }

    function createInvite(address _inviter, address _invitee) public returns (bytes32) {
        require(msg.sender == _inviter, ""Only valid inviter can create the invite"");
        bytes32 inviteId = keccak256(abi.encode(_inviter, _invitee, _inviteIds.current()));
        require(!invites[inviteId], ""Invite already exists"");
        invites[inviteId] = true;
        _inviteIds.increment();
        return inviteId;
    }
}"
3662,Allow pre-approved user to take ownership of a token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToOwner;

    function takeOwnership(uint256 _tokenId) public override {
        address newOwner = msg.sender;
        address oldOwner = allStarIndexToOwner[_tokenId];
        require(_addressNotNull(newOwner), ""Address should not be null"");
        require(_approved(newOwner, _tokenId), ""Token is not approved for transfer"");
        _transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address addr) internal pure returns (bool) {
        return addr != address(0);
    }

    function _approved(address operator, uint256 tokenId) internal view returns (bool) {
        // Assuming there's a way to check if the operator is approved for the tokenId
        // This should be implemented based on your contract logic
        return true; // Placeholder implementation
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(to != address(0), ""Transfer to zero address"");
        allStarIndexToOwner[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenContract is ERC721, Ownable, ReentrancyGuard {
    mapping (uint256 => address) private _approvedTransfers;

    function approveTransfer(uint256 tokenId, address receiver) public onlyOwner nonReentrant {
        _approvedTransfers[tokenId] = receiver;
    }

    function claimOwnership(uint256 tokenId) public nonReentrant {
        require(_approvedTransfers[tokenId] == msg.sender, ""Transfer not approved for this address"");
        _approve(msg.sender, tokenId);
        transferFrom(ownerOf(tokenId), msg.sender, tokenId);
    }
}",7.25975227355957,claimOwnership,"[{'function': 'approveTransfer', 'complexity': 0}, {'function': 'claimOwnership', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_approvedTransfers""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Transfer not approved for this address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.7366178084252749,0.0456680389005804,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is ERC721, Ownable, ReentrancyGuard {
    mapping (uint256 => address) private _approvedTransfers;

    constructor() ERC721(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            _approvedTransfers[i] = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
        }
    }

    function approveTransfer(uint256 tokenId, address receiver) public onlyOwner nonReentrant {
        _approvedTransfers[tokenId] = receiver;
    }

    function claimOwnership(uint256 tokenId) public nonReentrant {
        require(_approvedTransfers[tokenId] == msg.sender, ""Transfer not approved for this address"");
        _approve(msg.sender, tokenId);
        transferFrom(ownerOf(tokenId), msg.sender, tokenId);
    }
}"
4592,Function use to change the lower and upper bound of the compatible version st,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyOwner {
        // Implementation of the function
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract VersionControl is Ownable {

    uint256 public lowerBound;
    uint256 public upperBound;

    function changeVersionBounds(uint256 _lowerBound, uint256 _upperBound) external onlyOwner {
        require(_lowerBound <= _upperBound, ""Lower bound must be less than or equal to upper bound"");

        lowerBound = _lowerBound;
        upperBound = _upperBound;
    }
}",5.4183080196380615,changeVersionBounds,"[{'function': 'changeVersionBounds', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeVersionBounds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_lowerBound"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_upperBound"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_lowerBound""}, ""right"": {""type"": ""Identifier"", ""name"": ""_upperBound""}}, {""type"": ""stringLiteral"", ""value"": ""Lower bound must be less than or equal to upper bound""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lowerBound""}, ""right"": {""type"": ""Identifier"", ""name"": ""_lowerBound""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upperBound""}, ""right"": {""type"": ""Identifier"", ""name"": ""_upperBound""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.7444302000748617,0.0721475093102872,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VersionControl is Ownable {
    uint256 public lowerBound;
    uint256 public upperBound;

    constructor() Ownable(msg.sender) {
        lowerBound = 1;
        upperBound = 1;
    }

    function changeVersionBounds(uint256 _lowerBound, uint256 _upperBound) external onlyOwner {
        require(_lowerBound <= _upperBound, ""Lower bound must be less than or equal to upper bound"");

        lowerBound = _lowerBound;
        upperBound = _upperBound;
    }
}"
6054,Only the owner of a locked wallet can unlock the tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UnlockFunctionWrapper is Ownable {
    using SafeMath for uint256;

    struct Allocation {
        bool locked;
        uint256 value;
        uint256 end;
    }

    mapping(address => Allocation) public allocations;
    mapping(address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed account, address indexed sender, uint256 value);

    function unlock() external {
        require(allocations[msg.sender].locked, ""Allocation is not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Unlock time has not arrived yet"");
        balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);
        allocations[msg.sender].locked = false;
        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(msg.sender, address(this), allocations[msg.sender].value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Wallet is Ownable {
    bool private _isLocked;

    function lockWallet() public onlyOwner {
        _isLocked = true;
    }

    function unlockWallet() public onlyOwner {
        require(_isLocked, ""Wallet: Wallet must be locked to unlock it"");
        _isLocked = false;
    }

    function isLocked() public view returns (bool) {
        return _isLocked;
    }
}",5.313471078872681,unlockWallet,"[{'function': 'lockWallet', 'complexity': 0}, {'function': 'unlockWallet', 'complexity': 1}, {'function': 'isLocked', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""unlockWallet"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_isLocked""}, {""type"": ""stringLiteral"", ""value"": ""Wallet: Wallet must be locked to unlock it""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_isLocked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",64.0,0.6794517438215942,0.0134792658790868,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Wallet is Ownable {
    bool private _isLocked;

    constructor() {
        _isLocked = true;
    }

    function lockWallet() public onlyOwner {
        _isLocked = true;
    }

    function unlockWallet() public onlyOwner {
        require(_isLocked, ""Wallet: Wallet must be locked to unlock it"");
        _isLocked = false;
    }

    function isLocked() public view returns (bool) {
        return _isLocked;
    }
}"
6003,Proxy function which allows sending of transactions in behalf of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransactionExecutor is Ownable {
    using SafeMath for uint256;

    event Execution(address indexed destination, uint256 value, bytes data);
    event ExecutionFailure(address indexed destination, uint256 value, bytes data);

    function executeTransaction(address destination, uint value, bytes memory data) public onlyOwner {
        if (destination.call{value: value}(data)) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Proxy {
    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == _owner, ""Only owner can call this function."");
        _;
    }

    function forward(
        address target,
        bytes calldata data
    )
        external
        onlyOwner
        payable
        returns (bool, bytes memory)
    {
        require(target != address(0), ""Invalid target address."");

        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);
        require(success, ""External call failed."");

        return (success, returnData);
    }
}",14.527924060821531,forward,"[{'function': 'forward', 'complexity': -1}]",4.0,{},0.0,0.494200083823876,0.1009102950696846,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Proxy {
    address private _owner;

    constructor(address owner) {
        require(owner != address(0), ""Invalid owner address."");
        _owner = owner;
    }

    modifier onlyOwner {
        require(msg.sender == _owner, ""Only owner can call this function."");
        _;
    }

    function forward(
        address target,
        bytes calldata data
    )
        external
        onlyOwner
        payable
        returns (bool, bytes memory)
    {
        require(target != address(0), ""Invalid target address."");

        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);
        require(success, ""External call failed."");

        return (success, returnData);
    }
}"
1262,Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorSendWrapper is Ownable {
    using SafeMath for uint256;

    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) external {
        require(isOperatorFor(msg.sender, _from), ""Not authorized to send from this account"");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenTransfer is ERC20, ReentrancyGuard {
    using SafeMath for uint256;

    function transferFrom(address from, address to, uint256 _amount) public nonReentrant returns (bool){
        uint256 senderBalance = balanceOf(from);
        require(senderBalance >= _amount, ""Transfer amount exceeds balance"");

        _transfer(from, to, _amount);

        return true;
    }
}",6.761079072952271,transferFrom,"[{'function': 'transferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.6141219555996755,0.0387436509459734,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is ERC20, ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialization of state variables
        _totalSupply = 1 * 10 ** decimals(); // Initialize total supply to 1 token
        _balances[owner()] = _totalSupply; // Assign all tokens to the owner
    }

    function transferFrom(address from, address to, uint256 _amount) public nonReentrant returns (bool) {
        uint256 senderBalance = balanceOf(from);
        require(senderBalance >= _amount, ""Transfer amount exceeds balance"");

        _transfer(from, to, _amount);

        return true;
    }
}"
4646,Returns the bond of a given darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeRegistryInterface {
    function darknodeBond(address darknodeID) external view returns (uint256);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address) public darknodeRegistries;

    constructor() {}

    function darknodeBond(address darknodeID, address darknodeRegistryAddress) external view returns (uint256) {
        require(darknodeRegistries[darknodeRegistryAddress] != address(0), ""Darknode registry not set"");
        DarknodeRegistryInterface darknodeRegistry = DarknodeRegistryInterface(darknodeRegistryAddress);
        return darknodeRegistry.darknodeBond(darknodeID);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DarknodeBonding {
    using SafeMath for uint256;

    struct Darknode {
        uint256 bond;
        bool isRegistered;
    }

    // Mapping from Darknode to its properties
    mapping(address => Darknode) public darknodes;

    function getDarknodeBond(address _darknodeAddress) public view returns (uint256) {
        require(darknodes[_darknodeAddress].isRegistered, ""Darknode is not registered"");
        return darknodes[_darknodeAddress].bond;
    }
}",14.849175930023192,getDarknodeBond,"[{'function': 'getDarknodeBond', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDarknodeBond"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_darknodeAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknodeAddress""}}, ""memberName"": ""isRegistered""}, {""type"": ""stringLiteral"", ""value"": ""Darknode is not registered""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknodeAddress""}}, ""memberName"": ""bond""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",14.0,0.8720211893358114,0.1750926015739579,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DarknodeBonding is Ownable {
    using SafeMath for uint256;

    struct Darknode {
        uint256 bond;
        bool isRegistered;
    }

    // Mapping from Darknode to its properties
    mapping(address => Darknode) public darknodes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            darknodes[addr] = Darknode({bond: uint256(i), isRegistered: true});
        }
    }

    function getDarknodeBond(address _darknodeAddress) public view returns (uint256) {
        require(darknodes[_darknodeAddress].isRegistered, ""Darknode is not registered"");
        return darknodes[_darknodeAddress].bond;
    }
}"
476,Transfer ` _value ` SAT tokens from sender 's account ` msg.sender ` to provided account address ` _to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address _to, uint256 _value) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    bool public funding_ended = false;
    address public founders;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(!funding_ended, ""Funding has ended"");
        require(msg.sender != founders, ""Founders cannot transfer tokens"");
        uint256 senderBalance = balances[msg.sender];
        require(senderBalance >= _value && _value > 0, ""Insufficient balance or invalid value"");

        balances[msg.sender] = safeSub(senderBalance, _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract SATToken is ERC20 {
    constructor(uint256 initialSupply) ERC20(""SAT Token"", ""SAT"") {
        _mint(msg.sender, initialSupply);
    }

    function transferSATTokens(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0), ""Receiver address cannot be 0"");
        require(balanceOf(msg.sender) >= _value, ""Insufficient balance"");

        _transfer(msg.sender, _to, _value);

        return true;
    }
}",6.273076057434082,transferSATTokens,"[{'function': 'transferSATTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferSATTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Receiver address cannot be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",43.0,0.7972899349292288,0.3017617249703657,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SATToken is Ownable, ERC20 {
    mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply) ERC20(""SAT Token"", ""SAT"") {
        _mint(msg.sender, initialSupply);
    }

    function transferSATTokens(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0), ""Receiver address cannot be 0"");
        require(balanceOf(msg.sender) >= _value, ""Insufficient balance"");

        _transfer(msg.sender, _to, _value);

        return true;
    }
}"
2119,Returns the order amount for trader ` _trader ` at '_price ',"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function getAmount(uint _price, address _trader) public pure returns (uint) {
        return _price;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TradingContract {
    using SafeMath for uint256;

    mapping(address => mapping(uint256 => uint256)) private orders;

    function getOrderAmount(address _trader, uint256 _price) public view returns (uint256) {
        require(_trader != address(0), ""Invalid trader address"");
        require(_price > 0, ""Invalid price"");
        return orders[_trader][_price];
    }
}",6.039412021636963,getOrderAmount,"[{'function': 'getOrderAmount', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getOrderAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_trader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_trader""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid trader address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid price""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_trader""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_price""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",20.0,0.7938433890175228,0.0208524269399843,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TradingContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(uint256 => uint256)) private orders;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getOrderAmount(address _trader, uint256 _price) public view returns (uint256) {
        require(_trader != address(0), ""Invalid trader address"");
        require(_price > 0, ""Invalid price"");
        return orders[_trader][_price];
    }
}"
3447,Set the Synth contract that the issuance controller uses to issue Synths .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    Synth public synth;

    event SynthUpdated(Synth indexed synth);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setSynth(Synth _synth) external onlyOwner {
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/Ownable.sol';
import './Synth.sol';

contract IssuanceController is Ownable {
    Synth private synth;

    function setSynthContract(address _synthContract) external onlyOwner {
        require(_synthContract != address(0), ""Invalid synth contract address"");
        synths = Synth(_synthContract);
    }
}",6.329282283782959,setSynthContract,"[{'function': 'setSynthContract', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setSynthContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_synthContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_synthContract""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid synth contract address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""synths""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synth""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_synthContract""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.7892036170719005,0.1226029504520199,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import './Synth.sol';
import ""openzeppelin/SafeMath.sol"";
contract IssuanceController is Ownable {
    Synth private synth;

    constructor(address _synthContract) Ownable(msg.sender) {
        require(_synthContract != address(0), ""Invalid synth contract address"");
        synth = Synth(_synthContract);
    }

    function setSynthContract(address _synthContract) external onlyOwner {
        require(_synthContract != address(0), ""Invalid synth contract address"");
        synth = Synth(_synthContract);
    }
}"
2394,Migrate tokens to the new token contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MigrationAgent {
    function migrateFrom(address _from, uint256 _value) external;
}

event Migrate(address indexed from, address indexed agent, uint256 value);

abstract contract MigrableToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    uint256 public totalMigrated;
    address public migrationAgent;

    function migrate(uint256 _value) external {
        if (migrationAgent == address(0)) revert();
        if (_value == 0) revert();
        if (_value > balances[msg.sender]) revert();
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalMigrated = totalMigrated.add(_value);
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
        emit Migrate(msg.sender, migrationAgent, _value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenMigrator is Ownable {
    IERC20 public oldToken;
    IERC20 public newToken;

    constructor(IERC20 _oldToken, IERC20 _newToken) {
        oldToken = _oldToken;
        newToken = _newToken;
    }

    function migrate(address user, uint256 amount) public onlyOwner {
        require(oldToken.balanceOf(user) >= amount, ""User does not have enough tokens"");
        oldToken.transferFrom(user, address(this), amount);
        newToken.transfer(user, amount);
    }
}",10.815569877624512,migrate,"[{'function': 'migrate', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""migrate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""oldToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""User does not have enough tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""oldToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.654377942958168,0.0248199683509916,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenMigrator is Ownable {
    IERC20 public oldToken;
    IERC20 public newToken;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _oldToken, IERC20 _newToken) Ownable(msg.sender) {
        oldToken = _oldToken;
        newToken = _newToken;
    }

    function migrate(address user, uint256 amount) public onlyOwner {
        require(oldToken.balanceOf(user) >= amount, ""User does not have enough tokens"");
        oldToken.transferFrom(user, address(this), amount);
        newToken.transfer(user, amount);
    }
}"
6317,This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContributionProxy is Ownable {
    using SafeMath for uint256;

    function proxy_contribution(address _toAddr) public payable {
        require(_toAddr != address(0));
        process_contribution(_toAddr);
    }

    function process_contribution(address _toAddr) internal {
        // Implementation of the contribution processing logic
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract BuyTokensOnBehalf is ReentrancyGuard {
    IERC20 public token;
    address payable public tokenOwner;

    constructor(IERC20 _token, address payable _tokenOwner) {
        token = _token;
        tokenOwner = _tokenOwner;
    }

    function buyTokensOnBehalf(address beneficiary) external payable nonReentrant {
        require(msg.value > 0, ""Need some ether to buy tokens"");
        uint256 tokensToBuy = tokensForEther(msg.value);
        require(token.balanceOf(tokenOwner) >= tokensToBuy, ""Insufficient tokens to buy"");

        (bool sent,) = tokenOwner.call{value: msg.value}("""");
        require(sent, ""Failed to send Ether"");

        bool tokensTransferred = token.transferFrom(tokenOwner, beneficiary, tokensToBuy);
        require(tokensTransferred, ""Failed to transfer tokens"");
    }

    function tokensForEther(uint256 amountInEther) public pure returns (uint256) {
        // calculate number of tokens obtainable for the amount of Ether
        return amountInEther * 100;  // assuming 1 Ether = 100 tokens
    }
}",11.906633138656616,buyTokensOnBehalf,"[{'function': 'buyTokensOnBehalf', 'complexity': 4}, {'function': 'tokensForEther', 'complexity': 0}]",5.0,{},17.0,0.4421419821604966,0.0224908636011067,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BuyTokensOnBehalf is ReentrancyGuard, Ownable {
    IERC20 public token;
    address payable public tokenOwner;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token, address payable _tokenOwner) Ownable(msg.sender) {
        token = _token;
        tokenOwner = _tokenOwner;
    }

    function buyTokensOnBehalf(address beneficiary) external payable nonReentrant {
        require(msg.value > 0, ""Need some ether to buy tokens"");
        uint256 tokensToBuy = tokensForEther(msg.value);
        require(token.balanceOf(tokenOwner) >= tokensToBuy, ""Insufficient tokens to buy"");

        (bool sent,) = tokenOwner.call{value: msg.value}("""");
        require(sent, ""Failed to send Ether"");

        bool tokensTransferred = token.transferFrom(tokenOwner, beneficiary, tokensToBuy);
        require(tokensTransferred, ""Failed to transfer tokens"");
    }

    function tokensForEther(uint256 amountInEther) public pure returns (uint256) {
        // calculate number of tokens obtainable for the amount of Ether
        return amountInEther * 100;  // assuming 1 Ether = 100 tokens
    }
}"
5800,` seal ( ) ` ends the Campaign by calling ` seal ( ) ` in the CampaignToken contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public tokenContract;
    uint256 public endFundingTime;

    constructor(address _tokenContract, uint256 _endFundingTime) {
        require(_endFundingTime > now, ""End funding time must be in the future"");
        tokenContract = _tokenContract;
        endFundingTime = _endFundingTime;
    }

    function seal() public {
        if (now < endFundingTime) throw;
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(tokenContract != address(0), ""Token contract must be set"");
        IToken(tokenContract).seal();
    }

    interface IToken {
        function seal() external;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./CampaignToken.sol"";

contract Campaign {
    CampaignToken private campaignToken;
    address private owner;

    constructor(CampaignToken _campaignToken) {
        campaignToken = _campaignToken;
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Caller is not owner"");
        _;
    }

    function seal() public onlyOwner {
        campaignToken.seal();
    }

}",5.358423948287964,seal,"[{'function': 'seal', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""seal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaignToken""}, ""memberName"": ""seal""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.7890234787435368,0.01393734704589,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""./CampaignToken.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    CampaignToken private campaignToken;

    constructor(CampaignToken _campaignToken) Ownable(msg.sender) {
        campaignToken = _campaignToken;
    }

    modifier onlyOwner {
        require(msg.sender == owner(), ""Caller is not owner"");
        _;
    }

    function seal() public onlyOwner {
        campaignToken.seal();
    }
}"
5101,Returns asset balance for a particular holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function balanceOf(address _owner, bytes32 smbl) external view returns (uint);
}

abstract contract BalanceWrapper {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;
    bytes32 public smbl;

    constructor(address platformAddress, bytes32 symbol) {
        chronoBankPlatform = ChronoBankPlatform(platformAddress);
        smbl = symbol;
    }

    function balanceOf(address _owner) public view returns (uint) {
        return chronoBankPlatform.balanceOf(_owner, smbl);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract AssetBalance {
    function getAssetBalance(address tokenAddress, address holderAddress) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.balanceOf(holderAddress);
    }
}",4.435975074768066,getAssetBalance,"[{'function': 'getAssetBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAssetBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holderAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""holderAddress""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.6773082145915377,0.1918957006804739,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetBalance is Ownable {
    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are not defined in this contract
    }

    function getAssetBalance(address tokenAddress, address holderAddress) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.balanceOf(holderAddress);
    }
}"
752,"Called by ` settle ` , executes the settlement for a RenEx order or distributes the fees for a RenExAtomic swap .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRENexBalances {
    function transferBalanceWithFee(address, address, address, uint256, uint256, address) external;
}

abstract contract RenExWrapper is Ownable {
    using SafeMath for uint256;

    struct TokenPair {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    mapping(bytes32 => bytes32) public orderDetails;
    mapping(bytes32 => address) public orderSubmitter;
    IRENexBalances public renExBalancesContract;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = keccak256(""RENEX_ATOMIC_SETTLEMENT"");

    function execute(bytes32 _buyID, bytes32 _sellID, address _buyer, address _seller, TokenPair memory _tokens) public {
        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ? calculateAtomicFees(_buyID, _sellID, _tokens) : calculateSettlementDetails(_buyID, _sellID, _tokens);
        renExBalancesContract.transferBalanceWithFee(_buyer, _seller, settlementDetails.leftTokenAddress, settlementDetails.leftVolume, settlementDetails.leftTokenFee, orderSubmitter[_buyID]);
        renExBalancesContract.transferBalanceWithFee(_seller, _buyer, settlementDetails.rightTokenAddress, settlementDetails.rightVolume, settlementDetails.rightTokenFee, orderSubmitter[_sellID]);
    }

    function calculateAtomicFees(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of atomic fee calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }

    function calculateSettlementDetails(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of settlement details calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }
}",,11.196738958358765,settle,[],0.0,{},59.0,0.1583857957122864,0.0,nan
1142,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _amount) public override returns (bool) {
        require(_spender != address(0));
        require(_amount > 0);
        require(_amount <= balanceOf[msg.sender]);

        allowances[_spender][msg.sender] = _amount;

        emit Approval(msg.sender, _spender, _amount);

        return true;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function approveSpender(address _spender, uint256 _amount) external {
        require(_spender != address(0), ""Spender cannot be a zero address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        bool success = token.approve(_spender, _amount);
        require(success, ""Approval failed"");
    }
}",5.596526145935059,approveSpender,"[{'function': 'approveSpender', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Spender cannot be a zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.8496804258583889,0.4276437542897928,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public token;

    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function approveSpender(address _spender, uint256 _amount) external {
        require(_spender != address(0), ""Spender cannot be a zero address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        bool success = token.approve(_spender, _amount);
        require(success, ""Approval failed"");
    }
}"
3633,` _value ` tokens will be sended to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITransfer {
    function transfer(bytes32 _to, uint256 _value) external returns (bool);
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event TransferHash(bytes32 indexed from, bytes32 indexed to, uint256 value);

    function transfer(bytes32 _to, uint256 _value) external onlyOwner returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit TransferHash(keccak256(abi.encodePacked(msg.sender)), _to, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MyContract {
    using SafeERC20 for IERC20;

    function transferTokens(IERC20 _token, address _to, uint256 _value) public {
        require(_to != address(0), ""Invalid recipient address."");
        require(_value > 0, ""Value must be greater than 0."");

        uint256 balance = _token.balanceOf(address(this));
        require(_value <= balance, ""Insufficient token balance."");

        _token.safeTransfer(_to, _value);
    }
}",6.401808023452759,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than 0.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.7280834980962624,0.1657767309039573,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeERC20 for IERC20;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(IERC20 _token, address _to, uint256 _value) public {
        require(_to != address(0), ""Invalid recipient address."");
        require(_value > 0, ""Value must be greater than 0."");

        uint256 balance = _token.balanceOf(address(this));
        require(_value <= balance, ""Insufficient token balance."");

        _token.safeTransfer(_to, _value);
    }
}"
4852,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function burn(uint256 _amount) public requiresPermission whenNotPaused {
        _burn(msg.sender, _amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";

contract MintableToken is ERC721URIStorage, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    constructor() ERC721(""MintableToken"", ""MNT"") {
        _setupRole(MINTER_ROLE, _msgSender());
    }

    function mintToken(address to, uint256 tokenId, string calldata tokenURI) external {
        require(hasRole(MINTER_ROLE, _msgSender()), ""Must have minter role to mint"");
        _mint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
    }
}",9.935801029205322,mintToken,"[{'function': 'mintToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""tokenURI"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Must have minter role to mint""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setTokenURI""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}, {""type"": ""Identifier"", ""name"": ""tokenURI""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.3743059771540143,0.0250428785406311,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MintableToken is ERC721URIStorage, AccessControl, Ownable {
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    constructor() ERC721(""MintableToken"", ""MNT"") {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // Assuming DEFAULT_ADMIN_ROLE is used for Ownable pattern
        _setupRole(MINTER_ROLE, msg.sender);
    }

    function mintToken(address to, uint256 tokenId, string calldata tokenURI) external {
        require(hasRole(MINTER_ROLE, _msgSender()), ""Must have minter role to mint"");
        _mint(to, tokenId);
        _setTokenURI(tokenId, tokenURI);
    }
}"
2521,Returns the address currently assigned ownership of a given Warrior .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WarriorsWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    function ownerOf(uint208 _tokenId) external view returns (address owner) {
        require(_tokenId < warriors.length);
        owner = warriorToOwner[_tokenId];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract WarriorOwnership is Ownable {
    mapping(address => address) private warriorToOwner;

    function getWarriorOwner(address _warriorAddress) public view returns (address) {
        require(_warriorAddress != address(0), ""Warrior address cannot be the zero address"");
        require(warriorToOwner[_warriorAddress] != address(0), ""Warrior does not have an owner"");

        return warriorToOwner[_warriorAddress];
    }
}",7.716181039810181,getWarriorOwner,"[{'function': 'getWarriorOwner', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getWarriorOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_warriorAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_warriorAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Warrior address cannot be the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""warriorToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_warriorAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Warrior does not have an owner""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""warriorToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_warriorAddress""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",13.0,0.7054601585353296,0.1069263251472741,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WarriorOwnership is Ownable {
    mapping(address => address) private warriorToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getWarriorOwner(address _warriorAddress) public view returns (address) {
        require(_warriorAddress != address(0), ""Warrior address cannot be the zero address"");
        require(warriorToOwner[_warriorAddress] != address(0), ""Warrior does not have an owner"");

        return warriorToOwner[_warriorAddress];
    }
}"
402,Contract owner or Multisig can clawback ether after refund period is finished,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ClawbackEtherWrapper is Ownable {
    using SafeMath for uint256;

    bool public contractFailed;
    bool public contractRefundStarted;
    bool public contractRefundFinished;

    constructor() {}

    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
        require(contractFailed);
        require(contractRefundStarted);
        require(contractRefundFinished);
        require(value > 0);
        require(value <= address(this).balance);
        payable(msg.sender).transfer(value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ClawbackContract is Ownable {

    address payable[] public recipients;
    uint public refundPeriod; // eg. specified in seconds from contract creation
    uint private contractCreated;

    // for simplicity assuming multisig is joint owner with all powers, which may vary in actual use case
    address public multisig;

    constructor(address _multisig, uint _refundPeriod) {
        multisig = _multisig;
        refundPeriod = _refundPeriod;
        contractCreated = block.timestamp;
    }

    modifier onlyOwners() {
        require(msg.sender == owner() || msg.sender == multisig, ""Not an owner"");
        _;
    }

    function clawbackEther() external onlyOwners {
        require(block.timestamp > contractCreated + refundPeriod, ""Refund period still in effect"");
        uint totalBalance = address(this).balance;

        for(uint i=0; i < recipients.length; i++) {
           (bool success, ) = recipients[i].call{value: totalBalance / recipients.length}("""");
           require(success, ""Transfer failed."");
        }
    }
}",11.591517210006714,clawbackEther,"[{'function': 'clawbackEther', 'complexity': 3}]",4.0,{},41.0,0.7605546278953832,0.1187603071564367,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ClawbackContract is Ownable {

    address payable[] public recipients;
    uint public refundPeriod; // eg. specified in seconds from contract creation
    uint private contractCreated;

    // for simplicity assuming multisig is joint owner with all powers, which may vary in actual use case
    address public multisig;

    constructor(address _multisig, uint _refundPeriod) Ownable(_multisig) {
        multisig = _multisig;
        refundPeriod = _refundPeriod;
        contractCreated = block.timestamp;
    }

    modifier onlyOwners() {
        require(msg.sender == owner() || msg.sender == multisig, ""Not an owner"");
        _;
    }

    function clawbackEther() external onlyOwners {
        require(block.timestamp > contractCreated + refundPeriod, ""Refund period still in effect"");
        uint totalBalance = address(this).balance;

        for(uint i=0; i < recipients.length; i++) {
           (bool success, ) = recipients[i].call{value: totalBalance / recipients.length}("""");
           require(success, ""Transfer failed."");
        }
    }
}"
2323,By using this function you accept the terms of DXF,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Multisig {
    function send(uint256 amount) external returns (bool);
}

abstract contract DXFContract is Ownable {
    using SafeMath for uint256;

    uint public startingDateFunding;
    bool public dxfOpen = true;
    uint public maxNumberMembers = 1000;
    uint public totalTokens;
    uint public tokensCreationCap = 10000 ether;
    uint public remainingTokensVIPs;
    mapping(address => uint) public balances;
    address[] public members;
    mapping(address => uint) public indexMembers;
    mapping(address => bool) public vips;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function acceptTermsAndJoinDXF() payable external {
        require(now > startingDateFunding + 365 days, ""Too early"");
        require(dxfOpen, ""DXF is closed"");
        require(!vips[msg.sender], ""Already a VIP"");
        require(msg.value >= 10 ether, ""Minimum contribution is 10 ether"");
        require(msg.value <= (tokensCreationCap - totalTokens), ""Exceeds token creation cap"");
        require(msg.value <= 10000 ether - balances[msg.sender], ""Exceeds balance limit"");

        if (balances[msg.sender] == 0) {
            newMember(msg.sender);
            indexMembers[msg.sender] = members.length;
            members.push(Member(msg.sender, now, msg.value));
        } else {
            members[indexMembers[msg.sender]].initial_value += msg.value;
        }

        require(members.length <= maxNumberMembers, ""Max number of members reached"");
        require(multisigDXF != address(0), ""Invalid multisig contract"");

        Multisig multisig = Multisig(multisigDXF);
        require(multisig.send(msg.value), ""Transfer failed"");

        uint numTokens = msg.value;
        totalTokens += numTokens;
        require((tokensCreationCap - totalTokens) >= remainingTokensVIPs, ""Exceeds VIP tokens limit"");

        balances[msg.sender] += numTokens;
        Transfer(address(0), msg.sender, numTokens);
    }

    function newMember(address member) internal {
        // Implementation of newMember logic if needed
    }
}","Sorry, but your instruction is unclear. There seems to be no detailed description about what the function is supposed to do. Please provide detailed functionalities that the function would have so I can generate a fully implemented Solidity function for you.",2.9213600158691406,,[],3.0,{},144.0,0.3307810482461991,8.735177197158314e-06,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant MAX_SUPPLY = 1000 * 10**6 * 10**18; // 1 million tokens with 18 decimals
    uint256 private _totalSupply;
    address[] private _owners;
    bool private _isInitialized;
    string private _tokenName;
    bytes32 private _initHash;

    uint256 public totalSupply;

 constructor() {
        // Initialization logic will be added here
    }
}
```

### Step-by-Step Rewriting:

1. **Add a Constructor**: Since the contract does not have a uint256 public totalSupply;

 constructor, we need to add one.
2. **Remove Abstract from Abstract Contract**: Change `contract` to `contract`.
3. **Initialize State Variables**: Initialize each state variable according to the specified rules.
4. **Properly Invoke Parent Constructors**: Use the correct syntax for invoking parent uint256 public totalSupply;

 constructors.

### Modified Contract:"
36,Function used by the creator to set the contractor manager smart contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractorManagerSetter is Ownable {
    using SafeMath for uint256;

    event ContractorManagerSet(address indexed contractorManager);

    function setContractorManager(address _contractorManager) public onlyOwner {
        require(_contractorManager != address(0), ""Invalid contractor manager address"");
        emit ContractorManagerSet(_contractorManager);
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    address public contractorManager;

    function setContractorManager(address _newContractorManager) public onlyOwner {
        require(_newContractorManager != address(0), ""MyContract: new contractorManager is the zero address"");
        contractorManager = _newContractorManager;
    }
}",5.070505857467651,setContractorManager,"[{'function': 'setContractorManager', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setContractorManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newContractorManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newContractorManager""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""MyContract: new contractorManager is the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contractorManager""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newContractorManager""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",2.0,0.9327655378884796,0.4044783342972707,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public contractorManager;
    uint256 public constant DEFAULT_CONTRACTOR_MANAGER = 1;
    bool public initialized = true;
    bytes32 public constant INITIALIZED_VALUE = bytes32('init');

    constructor() Ownable(msg.sender) {
        contractorManager = address(0x1111111111111111111111111111111111111111);
        // Set default values for other variables as needed
    }

    function setContractorManager(address _newContractorManager) public onlyOwner {
        require(_newContractorManager != address(0), ""MyContract: new contractorManager is the zero address"");
        contractorManager = _newContractorManager;
    }
}"
1979,Get comprehensive information on an attribute type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAttributeType {
    struct AttributeType {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }
}

abstract contract AttributeTypeWrapper {
    using SafeMath for uint256;

    mapping(uint256 => IAttributeType.AttributeType) private _attributeTypes;

    function getAttributeTypeInformation(uint256 attributeTypeID) external view returns (string memory, bool, bool, address, uint256, uint256, uint256) {
        return (
            _attributeTypes[attributeTypeID].description,
            _attributeTypes[attributeTypeID].isRestricted,
            _attributeTypes[attributeTypeID].isOnlyPersonal,
            _attributeTypes[attributeTypeID].secondarySource,
            _attributeTypes[attributeTypeID].secondaryId,
            _attributeTypes[attributeTypeID].minimumRequiredStake,
            _attributeTypes[attributeTypeID].jurisdictionFee
        );
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AttributeTypeInformation is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        uint256 id;
        string name;
        string description;
        uint256 createTime;
    }

    mapping(uint256 => AttributeType) private attributeTypes;

    function getAttributeTypeInfo(uint256 attributeTypeID) public view returns (uint256, string memory, string memory, uint256) {
        require(attributeTypes[attributeTypeID].id != 0, ""Attribute type with provided ID does not exist."");

        AttributeType storage attribute = attributeTypes[attributeTypeID];
        return (attribute.id, attribute.name, attribute.description, attribute.createTime);
    }
}",7.655366897583008,getAttributeTypeInfo,"[{'function': 'getAttributeTypeInfo', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAttributeTypeInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""id""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Attribute type with provided ID does not exist.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""AttributeType""}, ""name"": ""attribute"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attribute""}, ""memberName"": ""id""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attribute""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attribute""}, ""memberName"": ""description""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attribute""}, ""memberName"": ""createTime""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",27.0,0.851597967186251,0.1609706017426334,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AttributeTypeInformation is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        uint256 id;
        string name;
        string description;
        uint256 createTime;
    }

    mapping(uint256 => AttributeType) private attributeTypes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            attributeTypes[i] = AttributeType({
                id: i,
                name: 'AttributeTypeName',
                description: 'Description of AttributeType',
                createTime: block.timestamp
            });
        }
    }

    function getAttributeTypeInfo(uint256 attributeTypeID) public view returns (uint256, string memory, string memory, uint256) {
        require(attributeTypes[attributeTypeID].id != 0, ""Attribute type with provided ID does not exist."");

        AttributeType storage attribute = attributeTypes[attributeTypeID];
        return (attribute.id, attribute.name, attribute.description, attribute.createTime);
    }
}"
2733,Set the stale period on the updated havven price,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public priceStalePeriod;

    function setPriceStalePeriod(uint time) external optionalProxy_onlyOwner {
        priceStalePeriod = time;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract HavvenContract is Ownable {
    using SafeMath for uint256;

    uint256 private priceStalePeriod;

    event PriceStalePeriodUpdated(uint256 period);

    function setPriceStalePeriod(uint256 _priceStalePeriod) public onlyOwner {
        require(_priceStalePeriod > 0, ""Price stale period must be greater than 0"");
        priceStalePeriod = _priceStalePeriod;
        emit PriceStalePeriodUpdated(priceStalePeriod);
    }
}",12.172641038894652,setPriceStalePeriod,"[{'function': 'setPriceStalePeriod', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPriceStalePeriod"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_priceStalePeriod"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_priceStalePeriod""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price stale period must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""priceStalePeriod""}, ""right"": {""type"": ""Identifier"", ""name"": ""_priceStalePeriod""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PriceStalePeriodUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""priceStalePeriod""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.8288172463715026,0.0371749241029078,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract HavvenContract is Ownable {
    using SafeMath for uint256;

    uint256 private priceStalePeriod;

    event PriceStalePeriodUpdated(uint256 period);

    constructor() Ownable(msg.sender) {
        priceStalePeriod = 1; // Set to a non-zero, safe value
    }

    function setPriceStalePeriod(uint256 _priceStalePeriod) public onlyOwner {
        require(_priceStalePeriod > 0, ""Price stale period must be greater than 0"");
        priceStalePeriod = _priceStalePeriod;
        emit PriceStalePeriodUpdated(priceStalePeriod);
    }
}"
1587,allows EtherToken to reclaim tokens wrongly sent to its address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/SafeMath.sol"";

interface IBasicToken {
    // Define the interface of the token contract here if needed
}

abstract contract Reclaimable is Ownable {
    using SafeMath for uint256;

    address public constant RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function reclaim(IBasicToken token) public onlyOwner {
        require(token != IBasicToken(RECLAIM_ETHER));
        Reclaimable.reclaim(token);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract EtherToken is Ownable, ReentrancyGuard {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function reclaimTokens(address _to) external onlyOwner nonReentrant {
        require(_to != address(0), ""EtherToken: zero address"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""EtherToken: no tokens to reclaim"");
        token.transfer(_to, balance);
    }
}",11.91671085357666,reclaimTokens,"[{'function': 'reclaimTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""EtherToken: zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""EtherToken: no tokens to reclaim""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.7749592327232983,0.0410095241955743,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EtherToken is Ownable, ReentrancyGuard {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function reclaimTokens(address _to) external onlyOwner nonReentrant {
        require(_to != address(0), ""EtherToken: zero address"");
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""EtherToken: no tokens to reclaim"");
        token.transfer(_to, balance);
    }
}"
1004,"Used to reference a loan that is not yet created , and by that does not have an index","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentifierBuilder {
    using SafeMath for uint256;

    function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public view returns (bytes32) {
        return keccak256(abi.encodePacked(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LoanContract is Ownable {
    using SafeMath for uint256;

    struct Loan {
        address borrower;
        uint256 amount;
        bool isCreated;
    }

    mapping (address => Loan) public loans;

    function createLoanRecord(address _borrower, uint256 _amount) public onlyOwner {
        require(!loans[_borrower].isCreated,""LoanContract: Loan already exists for the borrower"");
        loans[_borrower] = Loan(_borrower, _amount, true);
    }
}",8.032160997390747,createLoanRecord,"[{'function': 'createLoanRecord', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createLoanRecord"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_borrower"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""_borrower""}}, ""memberName"": ""isCreated""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""LoanContract: Loan already exists for the borrower""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""_borrower""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Loan""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_borrower""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.4222671850272199,0.0162833508237259,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract LoanContract is Ownable {
    using SafeMath for uint256;

    struct Loan {
        address borrower;
        uint256 amount;
        bool isCreated;
    }

    mapping (address => Loan) public loans;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function createLoanRecord(address _borrower, uint256 _amount) public onlyOwner {
        require(!loans[_borrower].isCreated,""LoanContract: Loan already exists for the borrower"");
        loans[_borrower] = Loan(_borrower, _amount, true);
    }
}"
6826,Returns the block number for when the channel was closed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        uint closed;
    }

    Data private data;

    function closed() public view returns (uint) {
        return data.closed;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Channel {
    struct ChannelInfo {
        uint256 closeBlockNumber;
        bool isClosed;
    }

    mapping(address => ChannelInfo) private channels;

    function getCloseBlockNumber(address channelAddress) public view returns (uint256) {
        ChannelInfo storage channel = channels[channelAddress];
        require(channel.isClosed, ""Channel is not closed"");

        return channel.closeBlockNumber;
    }
}",5.980950117111206,getCloseBlockNumber,"[{'function': 'getCloseBlockNumber', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCloseBlockNumber"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""channelAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ChannelInfo""}, ""name"": ""channel"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""Identifier"", ""name"": ""channelAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""channel""}, ""memberName"": ""isClosed""}, {""type"": ""stringLiteral"", ""value"": ""Channel is not closed""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""channel""}, ""memberName"": ""closeBlockNumber""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",14.0,0.5436875112819936,0.1445835022685117,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Channel is Ownable {
    struct ChannelInfo {
        uint256 closeBlockNumber;
        bool isClosed;
    }

    mapping(address => ChannelInfo) private channels;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            channels[addr] = ChannelInfo({closeBlockNumber: 1, isClosed: true});
        }
    }

    function getCloseBlockNumber(address channelAddress) public view returns (uint256) {
        ChannelInfo storage channel = channels[channelAddress];
        require(channel.isClosed, ""Channel is not closed"");

        return channel.closeBlockNumber;
    }
}"
4437,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value > 0, ""Invalid value"");
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {

    mapping(address => mapping(address => uint256)) private _allowances;

    function approve(address _spender, uint256 _value) public returns (bool) {

        // Contract should own the token that is being sent
        require(msg.sender != address(0), ""ERC20: approve from the zero address"");
        require(_spender != address(0), ""ERC20: approve to the zero address"");

        // This will overwrite the previous allowance limitation
        _allowances[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
}",8.493042945861816,approve,"[{'function': 'approve', 'complexity': 2}, {'function': 'allowance', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8939654456728575,0.4237062013391758,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    mapping(address => mapping(address => uint256)) private _allowances;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function approve(address _spender, uint256 _value) public override returns (bool) {
        require(msg.sender != address(0), ""ERC20: approve from the zero address"");
        require(_spender != address(0), ""ERC20: approve to the zero address"");
        _allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
}"
2473,Finalize an upgrade process setting new asset implementation contract address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UpgradeHandler is Ownable {
    using SafeMath for uint256;

    uint256 public pendingVersion;
    uint256 public pendingVersionTimestamp;
    uint256 public constant UPGRADE_FREEZE_TIME = 7 days; // Example freeze time, adjust as needed
    uint256 public latestVersion;

    function commitUpgrade() public onlyOwner returns (bool) {
        if (pendingVersion == 0x0) {
            return false;
        }

        if (pendingVersionTimestamp.add(UPGRADE_FREEZE_TIME) > block.timestamp) {
            return false;
        }

        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;

        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/Ownable.sol';

contract AssetUpgrade is Ownable {
    address public assetImplementation;

    function finalizeUpgrade(address newAssetImplementation) external onlyOwner {
        require(newAssetImplementation != address(0), ""AssetUpgrade: new implementation is the zero address"");
        assetImplementation = newAssetImplementation;
    }
}",5.510486841201782,finalizeUpgrade,"[{'function': 'finalizeUpgrade', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeUpgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAssetImplementation"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newAssetImplementation""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""AssetUpgrade: new implementation is the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""assetImplementation""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAssetImplementation""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.5206635561934151,0.0073026419796746,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetUpgrade is Ownable {
    address public assetImplementation;

    constructor(address _assetImplementation) {
        require(_assetImplementation != address(0), ""AssetUpgrade: new implementation is the zero address"");
        assetImplementation = _assetImplementation;
    }

    function finalizeUpgrade(address newAssetImplementation) external onlyOwner {
        require(newAssetImplementation != address(0), ""AssetUpgrade: new implementation is the zero address"");
        assetImplementation = newAssetImplementation;
    }
}"
4258,Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    constructor (uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_value <= totalSupply(), ""Approval amount exceeds total supply"");
        require(_spender != address(0), ""Approve to the zero address"");

        _approve(msg.sender, _spender, _value);

        return true;
    }
}",7.724179029464722,approve,"[{'function': 'approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Approval amount exceeds total supply""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Approve to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.906416082546115,0.3813181960250328,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    uint256 public totalSupply;

 constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
        initializeOwner();
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_value <= totalSupply(), ""Approval amount exceeds total supply"");
        require(_spender != address(0), ""Approve to the zero address"");

        _approve(msg.sender, _spender, _value);

        return true;
    }

    function initializeOwner() internal {
        transferOwnership(msg.sender);
    }
}"
3893,should be called off chain with as much gas as needed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface KyberReserveInterface {
    // Define the interface of the KyberReserve here if needed
}

abstract contract KyberReserveWrapper is Ownable {
    using SafeMath for uint256;

    KyberReserveInterface[] public reserves;

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}","here is a misunderstanding. Solidity smart contracts can't be executed off-chain. The operations performed by Solidity smart contracts are performed on the Ethereum blockchain network, which means they are performed on-chain. The gas for operations is also determined by the network based on the complexity of the operations performed. I cannot create a function to be executed off-chain with arbitrary gas, as this is a contradiction to the functionality of the Ethereum network.

If you are referring to the process of estimating the gas that needs to be provided to execute a function within a smart contract without actually sending a transaction to the network, that is achievable. But it's not done within the smart contract itself - instead, it would be done from your off-chain client (like Web3.js or ethers.js).

Here is how you would do it in JavaScript code, using Web3.js:

```javascript
const contract = new web3.eth.Contract(abi, contractAddress);

contract.methods.myMethod(param1, param2).estimateGas({from: account})
.then((gasAmount) => {
    console.log('Estimated gas:', gasAmount);
})
.catch((error) => {
    console.error('Failed to estimate gas:', error);
});",13.468558311462402,,[],0.0,{},8.0,0.2217628120602979,0.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyToken {
    string public name;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;

    constructor() ERC20(""MyToken"", ""MYT"") {
        // Initialize instance variables to fixed, safe values
        name = ""My Token"";
        totalSupply = 1000000; // 1 million tokens
        balanceOf[msg.sender] = 1000; // Give the deployer 1 token
    }

    function transfer(address recipient, uint256 amount) public {
        require(amount > 0, ""Transfer amount must be greater than zero"");
        require(balanceOf[msg.sender] >= amount, ""Insufficient balance"");

        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;

        emit Transfer(msg.sender, recipient, amount);
    }
}
```

Now, let's analyze and modify this contract according to the provided rules:

1.  Add a constructor if it doesn't exist:
    *   The contract already has a constructor, so we'll proceed to the next step.

2.  Rewrite the existing constructor (if any) and remove `abstract` from contracts:
    *   Since our contract is not an contract, this rule doesn't apply here.

3.  Initialize all instance variables to fixed, safe values:
    *   We've already done this in the provided constructor.

4.  If the contract inherits from parent contracts (e.g., `Ownable`, `ERC20`), properly invoke their constructors using the correct syntax:
    *   Our contract doesn't inherit from any parent contracts, so we don't need to modify this part.

Here's the modified contract code:

```solidity
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyToken {
    string public name;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;

    constructor() ERC20(""MyToken"", ""MYT"") {
        // Initialize instance variables to fixed, safe values
        name = ""My Token"";
        totalSupply = 1000000; // 1 million tokens
        balanceOf[msg.sender] = 1000; // Give the deployer 1 token
    }

    function transfer(address recipient, uint256 amount) public {
        require(amount > 0, ""Transfer amount must be greater than zero"");
        require(balanceOf[msg.sender] >= amount, ""Insufficient balance"");

        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;

        emit Transfer(msg.sender, recipient, amount);
    }
}"
3338,Exposes that this contract thinks it is an AffiliateProgram,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AffiliateProgramWrapper is Ownable {
    using SafeMath for uint256;

    function isAffiliateProgram() public pure returns (bool) {
    return true;
}
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract MyContract is AccessControl {

    bytes32 public constant AFFILIATE_ROLE = keccak256(""AFFILIATE_ROLE"");

    function isAffiliateProgram(address account) public view returns (bool) {
        return hasRole(AFFILIATE_ROLE, account);
    }
}",9.282120943069458,isAffiliateProgram,"[{'function': 'isAffiliateProgram', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isAffiliateProgram"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""AFFILIATE_ROLE""}, {""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",6.0,0.7493510176402144,0.3009429889037875,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is AccessControl {
    bytes32 public constant AFFILIATE_ROLE = keccak256(""AFFILIATE_ROLE"");

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        uint256 _uintValue = 1;
        address _addressValue = 0x1111111111111111111111111111111111111111; // Replace with actual address
        bool _boolValue = true;
        string _stringValue = 'initialized';
        bytes32 _bytes32Value = bytes32('init');
    }

    function isAffiliateProgram(address account) public view returns (bool) {
        return hasRole(AFFILIATE_ROLE, account);
    }
}"
812,Allow users to buy tokens for ` newRate ` x eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public tokensPerEther;

    function setPrices(uint256 newRate) public onlyOwner {
        tokensPerEther = newRate;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale is ReentrancyGuard {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate;

    constructor(IERC20 _token, uint256 _rate) {
        require(_rate > 0, ""Rate is 0"");
        require(_token != IERC20(address(0)), ""Token is the zero address"");

        token = _token;
        rate = _rate;
    }

    function buyTokens() external payable nonReentrant {
        require(msg.value > 0, ""Ether value is 0"");

        uint256 tokens = calculateTokenAmount(msg.value);
        token.transferFrom(address(this), msg.sender, tokens);
    }

    function calculateTokenAmount(uint256 _ether) internal view returns (uint256) {
        return _ether.mul(rate);
    }

    // Function to modify the rate
    function modifyRate(uint256 newRate) external {
        require(newRate > 0, ""Rate is 0"");
        rate = newRate;
    }
}",14.16553807258606,buyTokens,"[{'function': 'buyTokens', 'complexity': 1}, {'function': 'calculateTokenAmount', 'complexity': 0}, {'function': 'modifyRate', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Ether value is 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateTokenAmount""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",24.0,0.4862282660624477,0.0073257399350977,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate;

    constructor(IERC20 _token, uint256 _rate) Ownable(msg.sender) {
        require(_rate > 0, ""Rate is 0"");
        require(_token != IERC20(address(0)), ""Token is the zero address"");

        token = _token;
        rate = _rate;
    }

    function buyTokens() external payable nonReentrant {
        require(msg.value > 0, ""Ether value is 0"");

        uint256 tokens = calculateTokenAmount(msg.value);
        token.transferFrom(address(this), msg.sender, tokens);
    }

    function calculateTokenAmount(uint256 _ether) internal view returns (uint256) {
        return _ether.mul(rate);
    }

    // Function to modify the rate
    function modifyRate(uint256 newRate) external {
        require(newRate > 0, ""Rate is 0"");
        rate = newRate;
    }
}"
714,Transfers ` amount ` from msg.sender to ` destination `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function balances(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address destination, uint256 amount) public tradable(msg.sender) returns (bool success) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);
        emit Transfer(msg.sender, destination, amount);
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract TokenTransfer is ReentrancyGuard {
    using SafeERC20 for IERC20;
    using Address for address;

    function transferToken(address token, address destination, uint256 amount) external nonReentrant {
        require(destination.isContract() == false, ""Destination address must not be a contract"");
        require(IERC20(token).balanceOf(msg.sender) >= amount, ""Insufficient balance"");

        IERC20(token).safeTransferFrom(msg.sender, destination, amount);
    }
}",11.47992777824402,transferToken,"[{'function': 'transferToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""destination"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""destination""}, ""memberName"": ""isContract""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""Destination address must not be a contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""destination""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.7486396251308618,0.3355115321120508,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;
    using Address for address;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function transferToken(address token, address destination, uint256 amount) external nonReentrant {
        require(destination.isContract() == false, ""Destination address must not be a contract"");
        require(IERC20(token).balanceOf(msg.sender) >= amount, ""Insufficient balance"");

        IERC20(token).safeTransferFrom(msg.sender, destination, amount);
    }
}"
6517,Set ` _token_address ` as the token address to be used in the auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RaidenToken {
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

abstract contract Auction is Ownable {
    using SafeMath for uint256;

    enum Stages { NotDeployed, AuctionDeployed, AuctionSetUp, AuctionEnded }
    Stages public stage;

    RaidenToken public token;
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;

    event Setup();

    modifier atStage(Stages expectedStage) {
        require(stage == expectedStage, ""Auction: Invalid stage"");
        _;
    }

    function setup(address _token_address) public onlyOwner atStage(Stages.AuctionDeployed) {
        require(_token_address != address(0), ""Token address must be valid"");
        token = RaidenToken(_token_address);
        num_tokens_auctioned = token.balanceOf(address(this));
        token_multiplier = 10 ** uint256(token.decimals());
        stage = Stages.AuctionSetUp;
        emit Setup();
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Auction is Ownable {
    address private _token_address;

    function setTokenAddress(address newTokenAddress) external onlyOwner {
        require(newTokenAddress != address(0), ""Invalid address"");
        _token_address = newTokenAddress;
    }
}",3.502784013748169,setTokenAddress,"[{'function': 'setTokenAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTokenAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newTokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newTokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_token_address""}, ""right"": {""type"": ""Identifier"", ""name"": ""newTokenAddress""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.623220425052789,0.0624328811208596,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    address private _token_address;

    constructor(address newTokenAddress) {
        require(newTokenAddress != address(0), ""Invalid address"");
        _token_address = newTokenAddress;
        __Ownable_init();
        initializeOwner(msg.sender);
    }

    function setTokenAddress(address newTokenAddress) external onlyOwner {
        require(newTokenAddress != address(0), ""Invalid address"");
        _token_address = newTokenAddress;
    }
}"
2209,"match orders with admins involved , only admin","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Matcher {
    using SafeMath for uint256;

    address public admin;
    mapping(uint256 => address) public userId2Address;
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;

    constructor() {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    function matchByAdmin_TwH36(uint256[] memory inputs) external onlyAdmin {
        uint256 data = inputs[3];
        address user = userId2Address[data & USER_MASK];
        require(data >> 224 > userNonce[user]);
        (address token, bool isBuy) = decodeOrderTokenAndIsBuy(data);
        bytes32 orderHash = keccak256(this, inputs[0], inputs[1], inputs[2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
        require(verify(orderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[4]), bytes32(inputs[5])));
        uint256 tokenExecute = isBuy ? inputs[1] : inputs[0];
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        require(tokenExecute != 0);
        uint256 etherExecute = 0;
        isBuy = !isBuy;
        for (uint256 i = 6; i < inputs.length; i += 6) {
            require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));
            data = inputs[i + 3];
            user = userId2Address[data & USER_MASK];
            require(data >> 224 > userNonce[user]);
            bytes32 makerOrderHash = keccak256(this, inputs[i], inputs[i + 1], inputs[i + 2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
            require(verify(makerOrderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 4]), bytes32(inputs[i + 5])));
            (tokenExecute, etherExecute) = internalTrade(inputs[i], inputs[i + 1], inputs[i + 2], data, tokenExecute, etherExecute, isBuy, token, 0, makerOrderHash);
        }
        isBuy = !isBuy;
        tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        processTakerOrder(inputs[2], inputs[3], tokenExecute, etherExecute, isBuy, token, 0, orderHash);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract MatchOrders is AccessControl {

    // define admin role
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    event MatchedOrder(uint256 orderId);

    mapping(uint256 => address) private orderToAdmin;

    constructor() {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function matchOrder(uint256 orderId, address adminAddress)
        public
        onlyRole(ADMIN_ROLE)
    {
        require(hasRole(ADMIN_ROLE, adminAddress), ""Caller is not an admin"");
        orderToAdmin[orderId] = adminAddress;
        emit MatchedOrder(orderId);
    }
}",8.572980880737305,matchOrder,"[{'function': 'matchOrder', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""matchOrder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""orderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""adminAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""Identifier"", ""name"": ""adminAddress""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderToAdmin""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""adminAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MatchedOrder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""orderId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",298.0,0.6339565281565157,8.888759572217219e-05,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MatchOrders is AccessControl, Ownable {

    // define admin role
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    event MatchedOrder(uint256 orderId);

    mapping(uint256 => address) private orderToAdmin;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function matchOrder(uint256 orderId, address adminAddress)
        public
        onlyRole(ADMIN_ROLE)
    {
        require(hasRole(ADMIN_ROLE, adminAddress), ""Caller is not an admin"");
        orderToAdmin[orderId] = adminAddress;
        emit MatchedOrder(orderId);
    }
}"
5033,Returns the total number of Properties currently in existence .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PropertyRegistry is Ownable {
    using SafeMath for uint256;

    struct Property {
        // Define property structure here
    }

    Property[] public properties;

    function totalSupply() public view returns (uint) {
        return properties.length;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract RealEstateContract is Ownable {

    struct Property {
        string location;
        uint256 price;
        address owner;
        bool exists;
    }

    mapping(uint => Property) public properties;
    uint public propertyCount;

    function totalProperties() public view returns (uint256) {
        return propertyCount;
    }

}",6.31214165687561,totalProperties,"[{'function': 'totalProperties', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalProperties"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""propertyCount""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.7851588465219943,0.4682568791024402,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RealEstateContract is Ownable {

    struct Property {
        string location;
        uint256 price;
        address owner;
        bool exists;
    }

    mapping(uint => Property) public properties;
    uint public propertyCount;

    function totalProperties() public view returns (uint256) {
        return propertyCount;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        propertyCount = 1;
        properties[0] = Property({
            location: 'initialized',
            price: 1,
            owner: address(0x111),
            exists: true
        });
    }
}"
2439,Grant ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionManager {
    using SafeMath for uint256;

    struct Permission {
        address entity;
        bytes32 role;
        bytes32 paramsHash;
    }

    mapping(address => mapping(address => mapping(bytes32 => Permission))) private permissions;
    bytes32 public constant EMPTY_PARAM_HASH = keccak256("""");

    address public owner;

    modifier onlyPermissionManager(address _app, bytes32 _role) {
        require(permissions[msg.sender][_app][_role].entity != address(0), ""Only permission manager can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] memory _params) public onlyPermissionManager(_app, _role) {
        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal pure returns (bytes32) {
        require(_params.length > 0, ""Params array must not be empty"");
        return keccak256(abi.encodePacked(_params));
    }

    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {
        permissions[_entity][_app][_role] = Permission({
            entity: _entity,
            role: _role,
            paramsHash: _paramsHash
        });
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract RoleContract is AccessControl {

    function grantRole(address _app, address _entity, bytes32 _role) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        _setRoleAdmin(_role, DEFAULT_ADMIN_ROLE);
        grantRole(_role, _entity);

        emit RoleGranted(_role, _entity, msg.sender);
    }
}",5.0034120082855225,grantRole,"[{'function': 'grantRole', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantRole"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_app"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_entity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setRoleAdmin""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_role""}, {""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_role""}, {""type"": ""Identifier"", ""name"": ""_entity""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RoleGranted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_role""}, {""type"": ""Identifier"", ""name"": ""_entity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.6315944556625374,0.0604361435326287,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RoleContract is AccessControl {
    constructor() {
        _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function grantRole(address _app, address _entity, bytes32 _role) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        _setRoleAdmin(_role, DEFAULT_ADMIN_ROLE);
        grantRole(_role, _entity);

        emit RoleGranted(_role, _entity, msg.sender);
    }
}"
6671,Offer ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy for day ` aday ` at a price ` ( aprice / 1.0e3 ) .toFixed ( 3 ) + ' ct/kWh ' ` above market price for a date given as day ` aday ` whilst asserting that the current date and time in nanoseconds since 1970 is ` atimestamp ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface BidInterface {
    struct Bid {
        address producer;
        uint32 day;
        uint32 price;
        uint64 energy;
        uint64 timestamp;
    }
}

abstract contract EnergyMarket is Ownable, BidInterface {
    using SafeMath for uint256;

    uint public kWh = 1000; // Example value for kWh
    Bid[] public bids;
    mapping(address => mapping(uint32 => uint)) public bidsIndex;

    event BidMade(address indexed producer, uint32 day, uint price, uint energy);
    event BidRevoked(address indexed producer, uint32 day, uint price, uint energy);

    modifier onlyRegisteredProducers() {
        require(isProducerRegistered(msg.sender), ""Only registered producers can call this function"");
        _;
    }

    function offer_energy(uint32 aday, uint32 aprice, uint64 aenergy, uint64 atimestamp) onlyRegisteredProducers external {
        require(aenergy >= kWh);
        uint idx = bidsIndex[msg.sender][aday];
        if ((bids.length > idx) && (bids[idx].producer == msg.sender) && (bids[idx].day == aday)) {
            require(atimestamp > bids[idx].timestamp);
            emit BidRevoked(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
        }
        idx = bids.length;
        bidsIndex[msg.sender][aday] = idx;
        bids.push(Bid({producer: msg.sender, day: aday, price: aprice, energy: aenergy, timestamp: atimestamp}));
        emit BidMade(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
    }

    function isProducerRegistered(address producer) internal view returns (bool) {
        // Implement your logic to check if the producer is registered
        return true; // Placeholder for actual implementation
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract EnergyMarket {
    using SafeMath for uint256;

    struct Offer {
        uint256 energy;
        uint256 priceAddition;
        uint256 day;
    }

    mapping(address => Offer) public offers;

    function offerEnergy(uint256 aenergy, uint256 aprice, uint256 aday, uint256 atimestamp) public {
        require(atimestamp <= block.timestamp, ""Timestamp must be in the past or present"");
        uint256 energyKWh = aenergy.div(1e6);
        uint256 priceCtPerKWh = aprice.div(1e3);
        offers[msg.sender] = Offer(energyKWh, priceCtPerKWh, aday);
    }
}",7.573436975479126,offerEnergy,"[{'function': 'offerEnergy', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""offerEnergy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aenergy"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aprice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aday"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""atimestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""atimestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Timestamp must be in the past or present""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""energyKWh"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""aenergy""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1e6"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceCtPerKWh"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""aprice""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1e3"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Offer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""energyKWh""}, {""type"": ""Identifier"", ""name"": ""priceCtPerKWh""}, {""type"": ""Identifier"", ""name"": ""aday""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",66.0,0.832262588734001,0.0402029378493392,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract EnergyMarket is Ownable {
    using SafeMath for uint256;

    struct Offer {
        uint256 energy;
        uint256 priceAddition;
        uint256 day;
    }

    mapping(address => Offer) public offers;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        offers[msg.sender] = Offer({energy: 1, priceAddition: 1, day: 1});
    }

    function offerEnergy(uint256 aenergy, uint256 aprice, uint256 aday, uint256 atimestamp) public {
        require(atimestamp <= block.timestamp, ""Timestamp must be in the past or present"");
        uint256 energyKWh = aenergy.div(1e6);
        uint256 priceCtPerKWh = aprice.div(1e3);
        offers[msg.sender] = Offer(energyKWh, priceCtPerKWh, aday);
    }
}"
4083,Calculates unpaid rewards of a given address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RewardCalculator {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] rewardsCumulative;
        mapping(address => uint) addressToPaidRewardIndex;
    }

    uint constant PIXEL_COUNT = 100; // Assuming PIXEL_COUNT is defined somewhere in your contract

    mapping(uint32 => FeeHistory) private feeHistories;

    function _getFeeHistory(uint32 _canvasId) internal view returns (FeeHistory storage) {
        return feeHistories[_canvasId];
    }

    function getPaintedPixelsCountByAddress(address _address, uint32 _canvasId) public view returns (uint);

    function calculateRewardToWithdraw(uint32 _canvasId, address _address) public view stateOwned(_canvasId) returns (uint reward, uint pixelsOwned) {
        FeeHistory storage _history = _getFeeHistory(_canvasId);
        uint _lastIndex = _history.rewardsCumulative.length - 1;
        uint _lastPaidIndex = _history.addressToPaidRewardIndex[_address];
        uint _pixelsOwned = getPaintedPixelsCountByAddress(_address, _canvasId);
        if (_lastIndex < 0) {
            return (0, _pixelsOwned);
        }
        uint _rewardsSum = _history.rewardsCumulative[_lastIndex];
        uint _lastWithdrawn = _history.rewardsCumulative[_lastPaidIndex];
        uint _toWithdraw = ((_rewardsSum - _lastWithdrawn) / PIXEL_COUNT) * _pixelsOwned;
        return (_toWithdraw, _pixelsOwned);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract UnpaidRewards {
    using SafeMath for uint256;

    struct Account {
        uint256 totalReward;
        uint256 lastClaimedReward;
    }

    mapping(address => Account) private accounts;

    function calculateUnpaidReward(address accountAddress) public view returns (uint256) {
        Account memory account = accounts[accountAddress];
        uint256 unpaidReward = account.totalReward.sub(account.lastClaimedReward);
        return unpaidReward;
    }
}",4.6457459926605225,calculateUnpaidReward,"[{'function': 'calculateUnpaidReward', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateUnpaidReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""accountAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Account""}, ""name"": ""account"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""accountAddress""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""unpaidReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""account""}, ""memberName"": ""totalReward""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""account""}, ""memberName"": ""lastClaimedReward""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""unpaidReward""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",56.0,0.5709042115307525,0.0057551956549552,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract UnpaidRewards is Ownable {
    using SafeMath for uint256;

    struct Account {
        uint256 totalReward;
        uint256 lastClaimedReward;
    }

    mapping(address => Account) private accounts;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            accounts[addr] = Account({totalReward: 1, lastClaimedReward: 0});
        }
    }

    function calculateUnpaidReward(address accountAddress) public view returns (uint256) {
        Account memory account = accounts[accountAddress];
        uint256 unpaidReward = account.totalReward.sub(account.lastClaimedReward);
        return unpaidReward;
    }
}"
6519,ERC20 transfer function overridden to disable transfers when paused,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    modifier notPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _value) public notPaused {
        super.transfer(_to, _value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

contract MyToken is ERC20, Pausable {

    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function transfer(address recipient, uint256 amount) public override whenNotPaused returns (bool) {
        return super.transfer(recipient, amount);
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }
}",7.74470591545105,transfer,"[{'function': 'transfer', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.7631723243108419,0.177976440457712,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Pausable, Ownable {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
        initializeOwner();
    }

    function initializeOwner() internal {
        Ownable.__Ownable_init();
        transferOwnership(msg.sender);
    }

    function transfer(address recipient, uint256 amount) public override whenNotPaused returns (bool) {
        return super.transfer(recipient, amount);
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }
}"
5444,"Set a new campaign owner Based on the Campaign id , update the owner of the refered campaign .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CampaignManager is Ownable {
    using SafeMath for uint256;

    struct Campaign {
        address owner;
        // other campaign details...
    }

    mapping(bytes32 => Campaign) public campaigns;

    event CampaignUpdated(bytes32 indexed bidId, address newOwner);

    modifier onlyIfCampaignExists(bytes32 bidId) {
        require(campaigns[bidId].owner != address(0), ""Campaign does not exist"");
        _;
    }

    modifier onlyIfWhitelisted(address user) {
        // Assuming whitelist is managed elsewhere, implement as needed.
        require(isWhitelisted(user), ""User is not whitelisted"");
        _;
    }

    function setCampaignOwnerById(bytes32 bidId, address newOwner) public onlyIfCampaignExists(bidId) onlyIfWhitelisted(newOwner) {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }

    function isWhitelisted(address user) internal view returns (bool) {
        // Implement whitelist logic here.
        return true; // Placeholder for actual implementation.
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Campaign is Ownable {
    using SafeMath for uint256;

    struct CampaignDetail {
        address payable owner;
        uint256 minDonation;
    }

    mapping(uint256 => CampaignDetail) public campaigns;

    function setCampaignOwner(uint256 _campaignId, address payable _newOwner) public onlyOwner {
        require(_newOwner != address(0), ""New owner address cannot be 0"");
        require(campaigns[_campaignId].owner != address(0), ""Campaign does not exist"");
        CampaignDetail storage campaign = campaigns[_campaignId];
        campaign.owner = _newOwner;
    }
}",11.37778615951538,setCampaignOwner,"[{'function': 'setCampaignOwner', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCampaignOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_campaignId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New owner address cannot be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""_campaignId""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Campaign does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""CampaignDetail""}, ""name"": ""campaign"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""_campaignId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaign""}, ""memberName"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOwner""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.8471238334280754,0.0161002180086818,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Campaign is Ownable {
    using SafeMath for uint256;

    struct CampaignDetail {
        address payable owner;
        uint256 minDonation;
    }

    mapping(uint256 => CampaignDetail) public campaigns;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            campaigns[i].owner = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
            campaigns[i].minDonation = 1;
        }
    }

    function setCampaignOwner(uint256 _campaignId, address payable _newOwner) public onlyOwner {
        require(_newOwner != address(0), ""New owner address cannot be 0"");
        require(campaigns[_campaignId].owner != address(0), ""Campaign does not exist"");
        CampaignDetail storage campaign = campaigns[_campaignId];
        campaign.owner = _newOwner;
    }
}"
2581,Checks if the makeOrder price is reasonable and not manipulative,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TakePermitWrapper {
    using SafeMath for uint256;

    function isTakePermitted(uint orderPrice, uint referencePrice, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (bool) {
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Order is Ownable {

    uint256 private maximumPrice;

    constructor() {
        maximumPrice = 100;
    }

    function makeOrder(string memory _itemName, uint256 _price) public onlyOwner {
        require(_price > 0 && _price <= maximumPrice, ""makeOrder: Invalid price"");
        // Add logic for order creation
    }

    function setMaximumPrice(uint256 _maximumPrice) public onlyOwner {
        maximumPrice = _maximumPrice;
    }
}",6.564130067825317,makeOrder,"[{'function': 'makeOrder', 'complexity': 2}, {'function': 'setMaximumPrice', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""makeOrder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_itemName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_price""}, ""right"": {""type"": ""Identifier"", ""name"": ""maximumPrice""}}}, {""type"": ""stringLiteral"", ""value"": ""makeOrder: Invalid price""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.47859867995062,0.0163083171817727,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Order is Ownable {
    uint256 private maximumPrice;

    constructor() Ownable(msg.sender) {
        maximumPrice = 100;
    }

    function makeOrder(string memory _itemName, uint256 _price) public onlyOwner {
        require(_price > 0 && _price <= maximumPrice, ""makeOrder: Invalid price"");
        // Add logic for order creation
    }

    function setMaximumPrice(uint256 _maximumPrice) public onlyOwner {
        maximumPrice = _maximumPrice;
    }
}"
4669,Transfer a LAND owned by an Estate to a new owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LandRegistry is Ownable {
    using SafeMath for uint256;

    struct Estate {
        address owner;
        mapping(uint256 => address) lands;
    }

    mapping(uint256 => Estate) public estates;

    modifier canTransfer(uint256 estateId) {
        require(msg.sender == estates[estateId].owner, ""Not the owner"");
        _;
    }

    function _transferLand(uint256 estateId, uint256 landId, address destinatary) internal returns (bool) {
        require(destinatary != address(0), ""Invalid recipient"");
        estates[estateId].lands[landId] = destinatary;
        return true;
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) external canTransfer(estateId) {
        _transferLand(estateId, landId, destinatary);
    }
}","SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Estate is AccessControl {
    using SafeMath for uint256;

    struct Land {
        address currentOwner;
        uint256 landId;
    }

    mapping(uint256 => Land) public lands;

    bytes32 public constant ESTATE_OWNER_ROLE = keccak256(""ESTATE_OWNER_ROLE"");

    event LandTransferred(uint256 indexed landId, address indexed oldOwner, address indexed newOwner);

    constructor() {
        _setupRole(ESTATE_OWNER_ROLE, msg.sender);
    }

    function transferLand(uint256 _landId, address _newOwner) public {
        require(hasRole(ESTATE_OWNER_ROLE, msg.sender), ""Caller is not an estate owner"");
        require(_newOwner != address(0), ""New owner cannot be the zero address"");

        Land storage land = lands[_landId];

        require(land.currentOwner != address(0), ""The Land does not exist"");
        require(land.currentOwner == msg.sender, ""Only the current owner can transfer the land"");

        address oldOwner = land.currentOwner;
        land.currentOwner = _newOwner;

        emit LandTransferred(_landId, oldOwner, _newOwner);
    }
}",15.20095992088318,transferLand,"[{'function': 'transferLand', 'complexity': 4}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferLand"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_landId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ESTATE_OWNER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an estate owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New owner cannot be the zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Land""}, ""name"": ""land"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lands""}, ""index"": {""type"": ""Identifier"", ""name"": ""_landId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""currentOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""The Land does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""currentOwner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only the current owner can transfer the land""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""currentOwner""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""currentOwner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOwner""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LandTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_landId""}, {""type"": ""Identifier"", ""name"": ""oldOwner""}, {""type"": ""Identifier"", ""name"": ""_newOwner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",51.0,0.7763256527335407,0.0761785714012237,"SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Estate is Ownable, AccessControl {
    using SafeMath for uint256;

    struct Land {
        address currentOwner;
        uint256 landId;
    }

    mapping(uint256 => Land) public lands;

    bytes32 public constant ESTATE_OWNER_ROLE = keccak256(""ESTATE_OWNER_ROLE"");

    event LandTransferred(uint256 indexed landId, address indexed oldOwner, address indexed newOwner);

    constructor() Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ESTATE_OWNER_ROLE, msg.sender);

        for (uint256 i = 1; i <= 3; i++) {
            lands[i] = Land({currentOwner: address(uint160(uint256(keccak256(abi.encodePacked(""address"", i))))), landId: i});
        }
    }

    function transferLand(uint256 _landId, address _newOwner) public {
        require(hasRole(ESTATE_OWNER_ROLE, msg.sender), ""Caller is not an estate owner"");
        require(_newOwner != address(0), ""New owner cannot be the zero address"");

        Land storage land = lands[_landId];

        require(land.currentOwner != address(0), ""The Land does not exist"");
        require(land.currentOwner == msg.sender, ""Only the current owner can transfer the land"");

        address oldOwner = land.currentOwner;
        land.currentOwner = _newOwner;

        emit LandTransferred(_landId, oldOwner, _newOwner);
    }
}"
689,Set both ethPreAmount and mtdPreAmount at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) external onlyOwner {
        require(mtdPreAmountInWei > 0);
        require(ethPreAmountInWei > 0);
        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices logic
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PreAmountSetter is Ownable {
    uint256 ethPreAmount;
    uint256 mtdPreAmount;

    function setPreAmounts(uint256 _ethPreAmount, uint256 _mtdPreAmount) public onlyOwner {
        require(_ethPreAmount >= 0, ""ETH Pre-Amount must be non-negative"");
        require(_mtdPreAmount >= 0, ""MTD Pre-Amount must be non-negative"");

        ethPreAmount = _ethPreAmount;
        mtdPreAmount = _mtdPreAmount;
    }
}",7.596173048019409,setPreAmounts,"[{'function': 'setPreAmounts', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreAmounts"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_ethPreAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_mtdPreAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_ethPreAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ETH Pre-Amount must be non-negative""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_mtdPreAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""MTD Pre-Amount must be non-negative""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""ethPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_ethPreAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_mtdPreAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.8959222578663945,0.1990723946923955,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PreAmountSetter is Ownable {
    uint256 ethPreAmount;
    uint256 mtdPreAmount;

    constructor() Ownable(msg.sender) {
        ethPreAmount = 1; // Set to 1 (never 0)
        mtdPreAmount = 1; // Set to 1 (never 0)
    }

    function setPreAmounts(uint256 _ethPreAmount, uint256 _mtdPreAmount) public onlyOwner {
        require(_ethPreAmount >= 0, ""ETH Pre-Amount must be non-negative"");
        require(_mtdPreAmount >= 0, ""MTD Pre-Amount must be non-negative"");

        ethPreAmount = _ethPreAmount;
        mtdPreAmount = _mtdPreAmount;
    }
}"
4185,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract Collectible is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public collectibleIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    using SafeERC20 for ERC20;

    constructor () ERC20(""MyToken"", ""MTKN"") {}

    function grantTransferRights(address grantee, uint256 tokenId) public onlyOwner {
        require(grantee != address(0), ""Invalid address"");
        require(!_exists(tokenId), ""Token does not exists"");
        _mint(grantee, tokenId);
    }

    function takeOwnership(address from, address to, uint256 tokenId) public {
        require(msg.sender == to, ""Not authorized"");
        require(_exists(tokenId), ""Token does not exist"");
        _transfer(from, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(msg.sender == from, ""Not authorized"");
        require(_exists(tokenId), ""Token does not exist"");
        _transfer(from, to, tokenId);
    }
}",12.62699818611145,grantTransferRights,"[{'function': 'grantTransferRights', 'complexity': 3}, {'function': 'takeOwnership', 'complexity': 2}, {'function': 'transferFrom', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantTransferRights"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""grantee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""grantee""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Token does not exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""grantee""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.5546964836142673,0.0541205186590173,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    using SafeERC20 for ERC20;

    constructor() ERC20(""MyToken"", ""MTKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 1 ether; // Set to 1 ether equivalent in tokens
        _mint(msg.sender, initialSupply);
    }

    function grantTransferRights(address grantee, uint256 tokenId) public onlyOwner {
        require(grantee != address(0), ""Invalid address"");
        require(!_exists(tokenId), ""Token does not exists"");
        _mint(grantee, tokenId);
    }

    function takeOwnership(address from, address to, uint256 tokenId) public {
        require(msg.sender == to, ""Not authorized"");
        require(_exists(tokenId), ""Token does not exist"");
        _transfer(from, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(msg.sender == from, ""Not authorized"");
        require(_exists(tokenId), ""Token does not exist"");
        _transfer(from, to, tokenId);
    }
}"
6513,"Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface tokenltkrecipiente {
    function approve(address _spender, uint256 _value) external returns (bool success);
    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        tokenltkrecipiente spender = tokenltkrecipiente(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    function approve(address _spender, uint256 _value) internal returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Value must be greater than zero"");
        return tokenltkrecipiente(_spender).approve(_spender, _value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract YourContract is ERC20Burnable, Ownable {
    using SafeMath for uint256;

    function allowSpendAndPing(address _spender, uint256 _value) public onlyOwner {
        require(_spender != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be greater than 0"");

        IERC20(this).approve(_spender, _value);
        _ping(_spender);
    }

    function _ping(address _spender) private {
        // Ping logic here
    }
}",7.179645776748657,allowSpendAndPing,"[{'function': 'allowSpendAndPing', 'complexity': 2}, {'function': '_ping', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowSpendAndPing"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_ping""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.6683686458943974,0.2540508086691119,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract YourContract is ERC20Burnable, Ownable {
    using SafeMath for uint256;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        someUint = 1;          // uint/uint256: Set to 1 (never 0)
        someAddress = address(0x111); // address: Use fixed value 0x1111111111111111111111111111111111111111
        someBool = true;       // bool: Set to true
        someString = 'initialized'; // string: Set to 'initialized'
        someBytes32 = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function allowSpendAndPing(address _spender, uint256 _value) public onlyOwner {
        require(_spender != address(0), ""Invalid address"");
        require(_value > 0, ""Amount must be greater than 0"");

        IERC20(this).approve(_spender, _value);
        _ping(_spender);
    }

    function _ping(address _spender) private {
        // Ping logic here
    }
}"
5584,Function that allows synth contract to delegate sending fee to the fee Pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISynth {
    function burn(address from, uint amount) external;
    function issue(address to, uint amount) external;
    function triggerTokenFallbackIfNeeded(address from, address to, uint amount) external;
}

interface IFeePool {
    function FEE_ADDRESS() external view returns (address);
    function amountReceivedFromExchange(uint amount) external pure returns (uint);
}

abstract contract ExchangeWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes4 => ISynth) public synths;
    IFeePool public feePool;
    address public proxy;

    constructor(address _feePool, address _proxy) {
        feePool = IFeePool(_feePool);
        proxy = _proxy;
    }

    function _internalExchange(
        address from,
        bytes4 sourceCurrencyKey,
        uint sourceAmount,
        bytes4 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal returns (bool) {
        require(destinationAddress != address(0), ""Zero destination"");
        require(destinationAddress != address(this), ""Synthetix is invalid destination"");
        require(destinationAddress != proxy, ""Proxy is invalid destination"");
        synths[sourceCurrencyKey].burn(from, sourceAmount);
        uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);
        uint amountReceived = destinationAmount;
        uint fee = 0;
        if (chargeFee) {
            amountReceived = feePool.amountReceivedFromExchange(destinationAmount);
            fee = destinationAmount.sub(amountReceived);
        }
        synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);
        if (fee > 0) {
            uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, ""XDR"");
            synths[""XDR""].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);
        }
        synths[destinationCurrencyKey].triggerTokenFallbackIfNeeded(from, destinationAddress, amountReceived);
        return true;
    }

    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey) internal view returns (uint) {
        // Implement the logic to calculate effective value based on currency keys and amounts
        // This is a placeholder for actual implementation details
        return sourceAmount;
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FeePool is Ownable {
    using SafeMath for uint256;

    address payable public feeRecipient;

    constructor(address payable _feeRecipient) {
        feeRecipient = _feeRecipient;
    }

    function setFeeRecipient(address payable _newRecipient) external onlyOwner {
        feeRecipient = _newRecipient;
    }

    function delegateFeeFromSynth(address _synthContract, uint256 _feeAmount) external onlyOwner {
        Synth synth = Synth(_synthContract);

        require(synth.balanceOf(address(this)) >= _feeAmount);
        synth.transfer(feeRecipient, _feeAmount);
    }
}

interface Synth {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}",8.308887004852295,delegateFeeFromSynth,"[{'function': 'setFeeRecipient', 'complexity': 0}, {'function': 'delegateFeeFromSynth', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""delegateFeeFromSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_synthContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Synth""}, ""name"": ""synth"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synth""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_synthContract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""feeRecipient""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",72.0,0.5900934990428459,0.0093618922903849,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract FeePool is Ownable {
    using SafeMath for uint256;

    address payable public feeRecipient;

    mapping(address => uint256) public balanceOf;

 constructor(address payable _feeRecipient) Ownable() {
        feeRecipient = _feeRecipient;
    }

    function setFeeRecipient(address payable _newRecipient) external onlyOwner {
        feeRecipient = _newRecipient;
    }

    function delegateFeeFromSynth(address _synthContract, uint256 _feeAmount) external onlyOwner {
        Synth synth = Synth(_synthContract);

        require(synth.balanceOf(address(this)) >= _feeAmount);
        synth.transfer(feeRecipient, _feeAmount);
    }
}

interface Synth {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}"
4746,"Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onApprove(address _owner, address _spender, uint256 _amount) public returns (bool) {
        if (isRegistered(_owner)) {
            return true;
        } else {
            return false;
        }
    }

    function isRegistered(address _owner) internal view returns (bool) {
        // Implement the logic to check if the owner is registered
        revert(""Not implemented"");
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract Campaign is Ownable {
    ERC20 public token;

    mapping(address => uint256) public approvals;

    event Approval(address indexed user, uint256 amount);

    constructor(ERC20 _token) {
        token = _token;
    }

    function notifyApproval(address _user, uint256 _amount) external onlyOwner {
        require(token.allowance(_user, address(this)) >= _amount, ""Insufficient allowance"");
        approvals[_user] = _amount;
        emit Approval(_user, _amount);
    }
}",5.103425741195679,notifyApproval,"[{'function': 'notifyApproval', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""notifyApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_user""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_user""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.6765322046981249,0.0933508131891745,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    ERC20 public token;

    mapping(address => uint256) public approvals;

    event Approval(address indexed user, uint256 amount);

    constructor(ERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function notifyApproval(address _user, uint256 _amount) external onlyOwner {
        require(token.allowance(_user, address(this)) >= _amount, ""Insufficient allowance"");
        approvals[_user] = _amount;
        emit Approval(_user, _amount);
    }
}"
5679,Sets the new dividend percentage for buyouts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContract {
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public buyoutDividendPercentage;

    constructor(uint256 initialBuyoutDividendPercentage) {
        require(2000 <= initialBuyoutDividendPercentage && initialBuyoutDividendPercentage <= 12500);
        buyoutDividendPercentage = initialBuyoutDividendPercentage;
    }
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
    require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500);
    buyoutDividendPercentage = _buyoutDividendPercentage;
}
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DividendContract is Ownable {
    using SafeMath for uint256;

    uint256 private _dividendPercentage;

    function setDividendPercentage(uint256 newDividendPercentage) public onlyOwner {
        require(newDividendPercentage >= 0 && newDividendPercentage <= 100, ""Invalid percentage"");
        _dividendPercentage = newDividendPercentage;
    }
}",5.829051017761231,setDividendPercentage,"[{'function': 'setDividendPercentage', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setDividendPercentage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newDividendPercentage"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""newDividendPercentage""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""newDividendPercentage""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid percentage""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_dividendPercentage""}, ""right"": {""type"": ""Identifier"", ""name"": ""newDividendPercentage""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.7323582159193157,0.0592759803346307,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DividendContract is Ownable {
    using SafeMath for uint256;

    uint256 private _dividendPercentage;

    constructor() Ownable(msg.sender) {
        _dividendPercentage = 1; // Set to a safe, non-corner-case value of 1
    }

    function setDividendPercentage(uint256 newDividendPercentage) public onlyOwner {
        require(newDividendPercentage >= 0 && newDividendPercentage <= 100, ""Invalid percentage"");
        _dividendPercentage = newDividendPercentage;
    }
}"
5099,This is mainly an helper function to ` finalize ` but can be used if ` finalize ` has issues with the loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;
    uint256 public tokensFinalized;
    uint256 public constant MAX_TOKENS = 1000000 * (10 ** 18); // Example value, adjust as needed
    IERC20 public token;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor(address _token) {
        token = IERC20(_token);
    }

    function finalizeSingleInvestor(address investorAddr) public onlyOwner {
        require(investorAddr != address(0) && investorAddr != address(this));
        require(balancesToken[investorAddr] > 0);
        require(isWhitelisted[investorAddr] == true);
        uint256 balanceToTransfer = balancesToken[investorAddr];
        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;
        require(token.transfer(investorAddr, balanceToTransfer));
        tokensFinalized = tokensFinalized.add(balanceToTransfer);
        assert(tokensFinalized <= MAX_TOKENS);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SampleContract {
    using SafeMath for uint256;

    address public owner;
    uint256[] public balances;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(owner == msg.sender, ""Caller is not the owner"");
        _;
    }

    function finalizeHelper(uint256[] memory arr) public onlyOwner {
        require(arr.length > 0, ""Array cannot be empty"");
        for (uint256 i = 0; i < arr.length; i++) {
            require(balances.length > arr[i], ""Index out of bounds"");
            balances[arr[i]] = balances[arr[i]].add(1);
        }
    }
}",14.717472076416016,finalizeHelper,"[{'function': 'finalizeHelper', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeHelper"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""arr"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""arr""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Array cannot be empty""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""arr""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balances""}, ""memberName"": ""length""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""arr""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""stringLiteral"", ""value"": ""Index out of bounds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""arr""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""arr""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",53.0,0.553485959403365,0.1085112797695732,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract SampleContract is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256[] public balances;

    constructor() Ownable(msg.sender) {
        // No need to initialize balances array as it will be managed by finalizeHelper
    }

    modifier onlyOwner {
        require(owner == msg.sender, ""Caller is not the owner"");
        _;
    }

    function finalizeHelper(uint256[] memory arr) public onlyOwner {
        require(arr.length > 0, ""Array cannot be empty"");
        for (uint256 i = 0; i < arr.length; i++) {
            require(balances.length > arr[i], ""Index out of bounds"");
            balances[arr[i]] = balances[arr[i]].add(1);
        }
    }
}"
1617,Suspends a given supported market ( asset ) from use with Compound .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Market {
    function isSupported() external view returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint;

    struct MarketInfo {
        bool isSupported;
    }

    mapping(address => MarketInfo) public markets;

    event SuspendedMarket(address indexed asset);

    function suspendMarket(address asset) external returns (uint) {
        if (msg.sender != owner()) {
            return uint(Error.UNAUTHORIZED);
        }
        if (!markets[asset].isSupported) {
            return uint(Error.NO_ERROR);
        }
        markets[asset].isSupported = false;
        emit SuspendedMarket(asset);
        return uint(Error.NO_ERROR);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/AccessControl.sol';

interface ICompound {
    function isListed(address asset) external view returns (bool);
    function listAsset(address asset) external returns (bool);
    function delistAsset(address asset) external returns (bool);
}

contract CompoundController is AccessControl {
    ICompound public compound;
    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');

    constructor(address _compound) {
        compound = ICompound(_compound);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function suspendMarket(address market) public {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Not an admin!"");
        bool isAssetListed = compound.isListed(market);
        require(isAssetListed, 'Market is not listed');

        bool success = compound.delistAsset(market);
        require(success, 'Operation failed');
    }
}",11.953112840652466,suspendMarket,"[{'function': 'delistAsset', 'complexity': 0}, {'function': 'suspendMarket', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""suspendMarket"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""market"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Not an admin!""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isAssetListed"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""compound""}, ""memberName"": ""isListed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""market""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isAssetListed""}, {""type"": ""stringLiteral"", ""value"": ""Market is not listed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""compound""}, ""memberName"": ""delistAsset""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""market""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Operation failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.8026454521858797,0.0891934534605295,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/AccessControl.sol';
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface ICompound {
    function isListed(address asset) external view returns (bool);
    function listAsset(address asset) external returns (bool);
    function delistAsset(address asset) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract CompoundController is AccessControl, Ownable {
    ICompound public compound;
    bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');

    constructor(address _compound) Ownable(msg.sender) {
        compound = ICompound(_compound);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function suspendMarket(address market) public {
        require(hasRole(ADMIN_ROLE, msg.sender), ""Not an admin!"");
        bool isAssetListed = compound.isListed(market);
        require(isAssetListed, 'Market is not listed');

        bool success = compound.delistAsset(market);
        require(success, 'Operation failed');
    }
}"
4581,set beneficiary - the account receiving platform fees .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public beneficiary;

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Fees is Ownable {

    address private _beneficiary;

    function setBeneficiary(address newBeneficiary) public onlyOwner {
        require(newBeneficiary != address(0), ""New beneficiary is the zero address"");
        _beneficiary = newBeneficiary;
    }
}",3.836996078491211,setBeneficiary,"[{'function': 'setBeneficiary', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newBeneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newBeneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New beneficiary is the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBeneficiary""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.912192122027078,0.216311874592157,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Fees is Ownable {
    address private _beneficiary;

    constructor(address newBeneficiary) {
        require(newBeneficiary != address(0), ""New beneficiary is the zero address"");
        _beneficiary = newBeneficiary;
        Ownable.__Ownable_init();
        Ownable.transferOwnership(msg.sender);
    }

    function setBeneficiary(address newBeneficiary) public onlyOwner {
        require(newBeneficiary != address(0), ""New beneficiary is the zero address"");
        _beneficiary = newBeneficiary;
    }
}"
5894,Get the address of channel with a partner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ChannelWrapper {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        address[] all_channels;
    }

    function getChannelWith(Data storage self, address partner) public view returns (address) {
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint256 channel_pos = self.partyhash_to_channelpos[party_hash];
        if (channel_pos != 0) {
            return self.all_channels[channel_pos - 1];
        }
    }
}","ur function:

```sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Channel {

    struct Channel {
       address partner;
    }

    mapping(address => Channel) private channels;

    function getChannelAddress(address _partner) public view returns (address) {
        Channel memory channel = channels[_partner];
        require(channel.partner != address(0), ""Channel not found"");

        return channel.partner;
    }
}",4.685141086578369,getChannelAddress,"[{'function': 'getChannelAddress', 'complexity': 1}]",2.0,{},32.0,0.7851941818530696,0.1860985229251401,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Channel is Ownable {
    struct Channel {
        address partner;
    }

    mapping(address => Channel) private channels;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            channels[addr] = Channel({partner: addr});
        }
    }

    function getChannelAddress(address _partner) public view returns (address) {
        Channel memory channel = channels[_partner];
        require(channel.partner != address(0), ""Channel not found"");

        return channel.partner;
    }
}"
1558,function mint to be executed by Manager of token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract MintableToken is Ownable, IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyManager() {
        require(owner() == msg.sender, ""Only the manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
        require(target != address(0), ""Invalid target address"");
        require(mintedAmount > 0, ""Mint amount must be greater than zero"");
        require(balanceOf[target].add(mintedAmount) >= balanceOf[target], ""SafeMath: addition overflow"");
        require(totalSupply.add(mintedAmount) >= totalSupply, ""SafeMath: addition overflow"");
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(0), target, mintedAmount);
        emit Transfer(target, target, mintedAmount);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Token is ERC20, Ownable {
    using SafeMath for uint256;

    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}

    function mint(address to, uint256 amount) external onlyOwner {
        require(amount > 0, ""Token: mint amount must be positive"");
        _mint(to, amount);
    }
}",9.908132076263428,mint,"[{'function': 'mint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token: mint amount must be positive""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",61.0,0.7258238010877925,0.0230485022216038,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Token is ERC20, Ownable {
    using SafeMath for uint256;

    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        _initOwnable();
    }

    function _initOwnable() internal {
        // Initialize Ownable with the deployer's address
        __Ownable_init();
    }

    function mint(address to, uint256 amount) external onlyOwner {
        require(amount > 0, ""Token: mint amount must be positive"");
        _mint(to, amount);
    }
}"
2515,A getter to look up a Admin 's details,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminStorage {
    using SafeMath for uint256;

    struct PledgeAdmin {
        // Define the structure of PledgeAdmin here if needed
    }

    PledgeAdmin[] private admins;

    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {
        require(idAdmin < admins.length, ""Index out of bounds"");
        return admins[idAdmin];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract AdminContract is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    struct Admin {
        string name;
        address adminAddress;
    }

    mapping(address => Admin) private admins;

    constructor() {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function addAdmin(address _address, string memory _name) public {
        require(
            hasRole(ADMIN_ROLE, msg.sender),
            ""Caller is not an admin""
        );
        admins[_address] = Admin(_name, _address);
    }

    function getAdmin(address _address) public view returns (string memory name, address adminAddress) {
        require(
            hasRole(ADMIN_ROLE, msg.sender),
            ""Caller is not an admin""
        );

        Admin storage admin = admins[_address];

        return (admin.name, admin.adminAddress);
    }
}",14.28567385673523,getAdmin,"[{'function': 'addAdmin', 'complexity': 1}, {'function': 'getAdmin', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""adminAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Admin""}, ""name"": ""admin"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admin""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admin""}, ""memberName"": ""adminAddress""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",13.0,0.6236644630540503,0.0769383015459435,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AdminContract is AccessControl, Ownable {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    struct Admin {
        string name;
        address adminAddress;
    }

    mapping(address => Admin) private admins;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function addAdmin(address _address, string memory _name) public {
        require(
            hasRole(ADMIN_ROLE, msg.sender),
            ""Caller is not an admin""
        );
        admins[_address] = Admin(_name, _address);
    }

    function getAdmin(address _address) public view returns (string memory name, address adminAddress) {
        require(
            hasRole(ADMIN_ROLE, msg.sender),
            ""Caller is not an admin""
        );

        Admin storage admin = admins[_address];

        return (admin.name, admin.adminAddress);
    }
}"
4942,"enables withdrawals , only callable by the owner when the withdrawals are disabled","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bool public withdrawalEnabled = false;
    event WithdrawalEnabled(address indexed owner);

    modifier whenStopped() {
        require(!withdrawalEnabled, ""Withdrawal is enabled"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawal is already enabled"");
        _;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(owner());
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    bool private _withdrawalsEnabled;

    function enableWithdrawals() public onlyOwner {
        require(!_withdrawalsEnabled, ""Withdrawals are already enabled"");
        _withdrawalsEnabled = true;
    }
}",2.749715805053711,enableWithdrawals,"[{'function': 'enableWithdrawals', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableWithdrawals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""_withdrawalsEnabled""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Withdrawals are already enabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_withdrawalsEnabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.8765151101232038,0.1700107809840422,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool private _withdrawalsEnabled;

    constructor() Ownable(msg.sender) {
        _withdrawalsEnabled = false; // Set to false instead of true, as it's the default state for a boolean variable
    }

    function enableWithdrawals() public onlyOwner {
        require(!_withdrawalsEnabled, ""Withdrawals are already enabled"");
        _withdrawalsEnabled = true;
    }
}"
3452,Called by moduleFactory owner to register new modules for SecurityToken to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    function registerModule(address _moduleFactory) external returns (bool) {
        // Implementation of the registration logic
        return true;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    struct Module {
        bytes32 name;
        address moduleAddress;
    }

    Module[] public modules;

    function registerModule(bytes32 name, address moduleAddress) public onlyOwner {
        require(moduleAddress != address(0), ""Invalid module address"");
        modules.push(Module(name, moduleAddress));
    }
}",3.522602081298828,registerModule,"[{'function': 'registerModule', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""name"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""moduleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""moduleAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid module address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""modules""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Module""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""moduleAddress""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.6160258426181847,0.0326441473651154,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    struct Module {
        bytes32 name;
        address moduleAddress;
    }

    Module[] public modules;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        modules = [];
    }

    function registerModule(bytes32 name, address moduleAddress) public onlyOwner {
        require(moduleAddress != address(0), ""Invalid module address"");
        modules.push(Module(name, moduleAddress));
    }
}"
1228,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IWPR {
    function totalSupply() external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function finishMinting() external returns (bool);
    function transferOwnership(address newOwner) external;
}

abstract contract WPRCrowdsale is Ownable {
    using SafeMath for uint256;

    IWPR public wpr;
    address public teamHolder;
    address public communityHolder;
    address public futureHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 indexed finalizedBlock);

    constructor(IWPR _wpr, address _teamHolder, address _communityHolder, address _futureHolder, uint256 _startTime, uint256 _endTime) {
        wpr = _wpr;
        teamHolder = _teamHolder;
        communityHolder = _communityHolder;
        futureHolder = _futureHolder;
        startTime = _startTime;
        endTime = _endTime;
    }

    function getBlockTimestamp() internal view returns (uint256) {
        return block.timestamp;
    }

    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function weiToCollect() public view returns (uint256) {
        // Implement the logic to calculate the amount of Wei collected if needed.
        return 0; // Placeholder implementation.
    }

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == owner || getBlockTimestamp() > endTime || weiToCollect() == 0);

        uint256 CROWDSALE_PCT = 62;
        uint256 TEAMHOLDER_PCT = 20;
        uint256 COMMUNITYHOLDER_PCT = 15;
        uint256 FUTUREHOLDER_PCT = 3;
        assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

        uint256 tokenCap = wpr.totalSupply().mul(100).div(CROWDSALE_PCT);
        wpr.mint(teamHolder, tokenCap.mul(TEAMHOLDER_PCT).div(100));
        wpr.mint(communityHolder, tokenCap.mul(COMMUNITYHOLDER_PCT).div(100));
        wpr.mint(futureHolder, tokenCap.mul(FUTUREHOLDER_PCT).div(100));

        require(wpr.finishMinting());
        wpr.transferOwnership(owner);

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Crowdsale is Ownable, Pausable, ReentrancyGuard {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public endTime;
    address public controller;

    constructor (IERC20 _token, uint256 _endTime, address _controller) {
        token = _token;
        endTime = _endTime;
        controller = _controller;
    }

    function finalizeContribution() external whenNotPaused nonReentrant {
        require(block.timestamp > endTime || _msgSender() == controller, ""Not allowed"");
    }
}",16.266682863235474,finalizeContribution,"[{'function': 'finalizeContribution', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeContribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}}, {""type"": ""stringLiteral"", ""value"": ""Not allowed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",126.0,0.563190850206076,0.0004169743123256,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Crowdsale is Ownable, Pausable, ReentrancyGuard {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public endTime;
    address public controller;

    constructor(IERC20 _token, uint256 _endTime, address _controller) Ownable(_controller) {
        token = _token;
        endTime = _endTime;
        controller = _controller;
    }

    function finalizeContribution() external whenNotPaused nonReentrant {
        require(block.timestamp > endTime || _msgSender() == controller, ""Not allowed"");
    }
}"
6786,Decrease the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping (address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed newOwner, uint256 value, uint256 fee);

    function decreaseApprovalPreSignedHashing(address _token, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _subtractedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27, _signature[:64], _signature[64:]);
    }

    function decreaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);
        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));
        nonces[_signature] = true;
        uint oldValue = allowed[from][_spender];
        if (_subtractedValue > oldValue) {
            allowed[from][_spender] = 0;
        } else {
            allowed[from][_spender] = oldValue.sub(_subtractedValue);
        }
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSpender is Ownable {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public onlyOwner returns (bool) {
        uint256 currentAllowance = token.allowance(msg.sender, spender);
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        uint256 newAllowanceValue = currentAllowance - subtractedValue;
        token.approve(spender, newAllowanceValue);
        return true;
    }
}",5.596512079238892,decreaseAllowance,"[{'function': 'decreaseAllowance', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""subtractedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""subtractedValue""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: decreased allowance below zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newAllowanceValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""subtractedValue""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""newAllowanceValue""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.6506701194635918,0.0357957951639539,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSpender is Ownable {
    IERC20 public token;

    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public onlyOwner returns (bool) {
        uint256 currentAllowance = token.allowance(msg.sender, spender);
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        uint256 newAllowanceValue = currentAllowance - subtractedValue;
        token.approve(spender, newAllowanceValue);
        return true;
    }
}"
3195,Retrieves the encryption public key of the darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeStore {
    function darknodePublicKey(address) external view returns (bytes memory);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    DarknodeStore public store;

    constructor(address _storeAddress) {
        store = DarknodeStore(_storeAddress);
    }

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        return store.darknodePublicKey(_darknodeID);
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract Darknode is AccessControl {
    bytes32 public constant DARKNODE_ROLE = keccak256(""DARKNODE_ROLE"");
    mapping(address => bytes32) private encryptionKeys;

    constructor() {
        _setupRole(DARKNODE_ROLE, _msgSender());
    }

    function getEncryptionPublicKey(address _darknode) public view returns (bytes32) {
        require(hasRole(DARKNODE_ROLE, _darknode), ""Caller is not a darknode"");
        return encryptionKeys[_darknode];
    }
}",5.318387985229492,getEncryptionPublicKey,"[{'function': 'getEncryptionPublicKey', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getEncryptionPublicKey"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_darknode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DARKNODE_ROLE""}, {""type"": ""Identifier"", ""name"": ""_darknode""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a darknode""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""encryptionKeys""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknode""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.7996204804829609,0.0533662613578733,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Darknode is AccessControl, Ownable {
    bytes32 public constant DARKNODE_ROLE = keccak256(""DARKNODE_ROLE"");
    mapping(address => bytes32) private encryptionKeys;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(DARKNODE_ROLE, msg.sender);
    }

    function getEncryptionPublicKey(address _darknode) public view returns (bytes32) {
        require(hasRole(DARKNODE_ROLE, _darknode), ""Caller is not a darknode"");
        return encryptionKeys[_darknode];
    }
}"
761,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function enableTransfers(bool _transfersEnabled) external onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken is IERC20, Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;
    bool public isTransferAllowed;

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        require(isTransferAllowed, ""MyToken: transfers are not allowed"");
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""MyToken: transfer from the zero address"");
        require(recipient != address(0), ""MyToken: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount, ""MyToken: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);
    }

    function allowTransfers() public onlyOwner {
        isTransferAllowed = true;
    }

    function denyTransfers() public onlyOwner {
        isTransferAllowed = false;
    }

}",15.849499940872192,_transfer,"[{'function': 'transfer', 'complexity': 1}, {'function': '_transfer', 'complexity': 2}, {'function': 'allowTransfers', 'complexity': 0}, {'function': 'denyTransfers', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""MyToken: transfer from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""MyToken: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""stringLiteral"", ""value"": ""MyToken: transfer amount exceeds balance""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",48.0,0.5206181808589478,0.0034152387934095,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyToken is IERC20, Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply = 1000000000000000000; // Set to 1 instead of 0
    bool public isTransferAllowed = true; // Default to true instead of false

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _balances[owner()] = _totalSupply; // Owner has the total supply
        emit Transfer(address(0), owner(), _totalSupply); // Emit an event for the initial transfer
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        require(isTransferAllowed, ""MyToken: transfers are not allowed"");
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""MyToken: transfer from the zero address"");
        require(recipient != address(0), ""MyToken: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount, ""MyToken: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);

        emit Transfer(sender, recipient, amount);
    }

    function allowTransfers() public onlyOwner {
        isTransferAllowed = true;
    }

    function denyTransfers() public onlyOwner {
        isTransferAllowed = false;
    }
}"
3170,Set an upgrade agent contract to process the upgrade .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface UpgradeAgent {
    function isUpgradeAgent() external view returns (bool);
    function originalSupply() external view returns (uint256);
}

enum UpgradeState { NotUpgradable, Upgrading }

abstract contract Token {
    using SafeMath for uint256;

    address public upgradeAgent;
    uint256 public totalSupply_;

    function getUpgradeState() internal virtual returns (UpgradeState);
    function canUpgrade() internal virtual returns (bool);

    event UpgradeAgentSet(address indexed agent);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }
}

abstract contract UpgradableToken is Token, Ownable {
    using SafeMath for uint256;

    function setUpgradeAgent(UpgradeAgent _upgradeAgent) external onlyOwner {
        require(canUpgrade(), ""Ensure the token is upgradeable in the first place"");
        require(_upgradeAgent != address(0), ""Ensure upgrade agent address is not blank"");
        require(getUpgradeState() != UpgradeState.Upgrading, ""Ensure upgrade has not started"");

        upgradeAgent = address(_upgradeAgent);
        require(UpgradeAgent(upgradeAgent).isUpgradeAgent(), ""New upgradeAgent must be UpgradeAgent"");
        require(UpgradeAgent(upgradeAgent).originalSupply() == totalSupply_, ""Make sure that token supplies match in source and target token contracts"");

        emit UpgradeAgentSet(upgradeAgent);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

interface UpgradeAgent {
    function upgradeFrom(address _from, uint256 _value) external;
}

contract UpgradableToken is Ownable {
    UpgradeAgent public upgradeAgent;
    bool public upgradeAllowed = false;

    modifier onlyWhenUpgradeAllowed() {
        require(upgradeAllowed, ""Upgrade not allowed"");
        _;
    }

    modifier onlyUpgradeAgent() {
        require(msg.sender == address(upgradeAgent), ""Only UpgradeAgent can call this function"");
        _;
    }

    function setUpgradeAgent(address _upgradeAgent) external onlyOwner {
        require(_upgradeAgent != address(0), ""Invalid address"");
        upgradeAgent = UpgradeAgent(_upgradeAgent);
        upgradeAllowed = true;
    }

    function upgrade(uint256 value) external onlyWhenUpgradeAllowed onlyUpgradeAgent {
        upgradeAgent.upgradeFrom(msg.sender, value);
    }
}",8.566972255706787,setUpgradeAgent,"[{'function': 'upgradeFrom', 'complexity': 0}, {'function': 'setUpgradeAgent', 'complexity': 1}, {'function': 'upgrade', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUpgradeAgent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_upgradeAgent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_upgradeAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradeAgent""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradeAllowed""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.8801283547502124,0.0483559120517313,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface UpgradeAgent {
    function upgradeFrom(address _from, uint256 _value) external;
}
import ""openzeppelin/SafeMath.sol"";
contract UpgradableToken is Ownable {
    UpgradeAgent public upgradeAgent;
    bool public upgradeAllowed = false;
    address public owner;
    string public name;
    string public symbol;

    constructor() Ownable(msg.sender) {
        // Initialize fixed values
        upgradeAgent = UpgradeAgent(0x1111111111111111111111111111111111111111);
        upgradeAllowed = true;
        owner = msg.sender;
        name = ""MyToken"";
        symbol = ""TKN"";
    }

    modifier onlyWhenUpgradeAllowed() {
        require(upgradeAllowed, ""Upgrade not allowed"");
        _;
    }

    modifier onlyUpgradeAgent() {
        require(msg.sender == address(upgradeAgent), ""Only UpgradeAgent can call this function"");
        _;
    }

    function setUpgradeAgent(address _upgradeAgent) external onlyOwner {
        require(_upgradeAgent != address(0), ""Invalid address"");
        upgradeAgent = UpgradeAgent(_upgradeAgent);
        upgradeAllowed = true;
    }

    function upgrade(uint256 value) external onlyWhenUpgradeAllowed onlyUpgradeAgent {
        upgradeAgent.upgradeFrom(msg.sender, value);
    }
}"
3368,Check whether an address is a regular address or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

    function isRegularAddress(address _addr) public view returns (bool) {
        if (_addr == address(0)) {
            return false;
        }
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }
}","pragma solidity ^0.8.0;

contract AddressChecker {
    function isContract(address _addr) public view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }
        return (size > 0);
    }

    function isRegularAddress(address _addr) public view returns (bool) {
        return !isContract(_addr);
    }
}",4.9836719036102295,isContract,"[{'function': 'isContract', 'complexity': 0}, {'function': 'isRegularAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_addr"", ""arguments"": []}]}}]}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.7622600026188012,0.499878772982429,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract AddressChecker is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isContract(address _addr) public view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }
        return (size > 0);
    }

    function isRegularAddress(address _addr) public view returns (bool) {
        return !isContract(_addr);
    }
}"
5919,Initiates a `` send '' operation towards another user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenStorage {
    function balanceOf(address account) external view returns (uint256);
    function subBalance(address account, uint256 amount) external;
    function addBalance(address account, uint256 amount) external;
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    ITokenStorage public tokenStorage;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {
        require(_to != address(0), ""to address cannot be 0x0"");
        require(_amount <= tokenStorage.balanceOf(msg.sender), ""not enough balance to transfer"");
        tokenStorage.subBalance(msg.sender, _amount);
        tokenStorage.addBalance(_to, _amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function setTokenStorage(address _tokenStorage) public onlyOwner {
        tokenStorage = ITokenStorage(_tokenStorage);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    modifier userNotBlacklisted(address user) {
        require(!isBlacklisted[user], ""User is blacklisted"");
        _;
    }

    mapping(address => bool) public isBlacklisted;

    function blacklistUser(address user) public onlyOwner {
        isBlacklisted[user] = true;
    }

    function removeFromBlacklist(address user) public onlyOwner {
        isBlacklisted[user] = false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    function sendFund(address _to, uint256 _amount) public onlyOwner {
        require(_balances[msg.sender] >= _amount, ""Not enough funds"");
        _balances[msg.sender] = _balances[msg.sender].sub(_amount);
        _balances[_to] = _balances[_to].add(_amount);
    }
}",7.8302528858184814,sendFund,"[{'function': 'sendFund', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendFund"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",39.0,0.6370676016713274,0.0965348701530827,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _balances[msg.sender] = 1000; // Set initial balance to 1 for the owner
    }

    function sendFund(address _to, uint256 _amount) public onlyOwner {
        require(_balances[msg.sender] >= _amount, ""Not enough funds"");
        _balances[msg.sender] = _balances[msg.sender].sub(_amount);
        _balances[_to] = _balances[_to].add(_amount);
    }
}"
4803,This is a state-modifying function that can be called while the contract is paused .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Sale {
        address seller;
        // other sale details
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function _isOnSale(Sale storage sale) internal view returns (bool) {
        return sale.seller != address(0);
    }

    function _cancelSale(uint256 _tokenId, address seller) internal {
        delete tokenIdToSale[_tokenId];
        emit SaleCancelled(_tokenId, seller);
    }

    function cancelSale(uint256 _tokenId) public {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(sale));
        address seller = sale.seller;
        require(msg.sender == seller);
        _cancelSale(_tokenId, seller);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";

contract MyContract is Pausable {

    constructor() public {
        _pause();
    }

    function modifyState(string memory newValue) public whenPaused {
        _unpause();
        // Assume state is a string state variable in MyContract
        state = newValue;
        _pause();
    }
}",4.48299503326416,modifyState,"[{'function': 'modifyState', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""modifyState"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""newValue"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_unpause""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""Identifier"", ""name"": ""newValue""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_pause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.2737805969450009,0.0385850870376732,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Pausable, Ownable {
    string public state;

    constructor() Pausable(), Ownable(msg.sender) {
        _pause();
        state = 'initialized';
    }

    function modifyState(string memory newValue) public whenPaused {
        require(paused(), ""Contract must be paused to modify state"");
        _unpause();
        state = newValue;
        _pause();
    }
}"
2141,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

function submitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address answerer) onlyArbitrator(question_id) statePendingArbitration(question_id) bondMustBeZero external {
    require(answerer != NULL_ADDRESS, ""answerer must be provided"");
    emit LogFinalize(question_id, answer);
    questions[question_id].is_pending_arbitration = false;
    _addAnswerToHistory(question_id, answer, answerer, 0, false);
    _updateCurrentAnswer(question_id, answer, 0);
}
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract QuizContract is Ownable {
    mapping(uint256 => string) private answers;

    function submitAnswer(uint256 _questionId, string calldata _answer) external onlyOwner {
        require(bytes(_answer).length > 0, ""Answer cannot be empty"");
        answers[_questionId] = _answer;
    }

    // A needed function to get the answer for testing
    function getAnswer(uint256 _questionId) public view returns (string memory) {
        return answers[_questionId];
    }
}",10.310370922088625,submitAnswer,"[{'function': 'submitAnswer', 'complexity': 1}, {'function': 'getAnswer', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_questionId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_answer"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_answer""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Answer cannot be empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""answers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_questionId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_answer""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.7169118935439327,0.0172311678540921,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract QuizContract is Ownable {
    mapping(uint256 => string) private answers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function submitAnswer(uint256 _questionId, string calldata _answer) external onlyOwner {
        require(bytes(_answer).length > 0, ""Answer cannot be empty"");
        answers[_questionId] = _answer;
    }

    // A needed function to get the answer for testing
    function getAnswer(uint256 _questionId) public view returns (string memory) {
        return answers[_questionId];
    }
}"
381,"Get the remaining funds needed to end the auction , calculated at the current GOT price in WEI .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AuctionWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public num_tokens_auctioned;
    uint256 public received_wei;
    uint256 public price_per_token;
    uint256 public token_multiplier;

    function remainingFundsToEndAuction() public view returns (uint256) {
        require(num_tokens_auctioned > 0, ""Number of tokens auctioned must be greater than zero"");
        require(token_multiplier > 0, ""Token multiplier must be greater than zero"");
        uint256 required_wei_at_price = num_tokens_auctioned.mul(price_per_token) / token_multiplier;
        if (required_wei_at_price <= received_wei) {
            return 0;
        }
        return required_wei_at_price.sub(received_wei);
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Auction is Ownable {
    using SafeMath for uint256;

    uint256 public gotPriceInWei;
    uint256 public auctionEnd;

    function remainingFunds() public view returns (uint256) {
        require(block.timestamp < auctionEnd, ""Auction has end"");

        uint256 currentBalance = address(this).balance;
        uint256 totalRequired = gotPriceInWei;

        if(currentBalance >= totalRequired) {
            return 0;
        }

        return totalRequired.sub(currentBalance);
    }
}",10.884742021560667,remainingFunds,"[{'function': 'remainingFunds', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""remainingFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""auctionEnd""}}, {""type"": ""stringLiteral"", ""value"": ""Auction has end""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalRequired"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""gotPriceInWei""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalRequired""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalRequired""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentBalance""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",15.0,0.8572923190841705,0.2539183741365617,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Auction is Ownable {
    using SafeMath for uint256;

    uint256 public gotPriceInWei = 1;
    uint256 public auctionEnd = block.timestamp + 7 days;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done here
    }

    function remainingFunds() public view returns (uint256) {
        require(block.timestamp < auctionEnd, ""Auction has ended"");

        uint256 currentBalance = address(this).balance;
        uint256 totalRequired = gotPriceInWei;

        if (currentBalance >= totalRequired) {
            return 0;
        }

        return totalRequired.sub(currentBalance);
    }
}"
242,Withdraw ETH for ` receiverAddress ` after the auction has canceled .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionCreated, AuctionCanceled, AuctionEnded }
    mapping(address => uint) public bids;
    Stages public stage = Stages.AuctionCreated;

    function proxyWithdraw(address receiverAddress) public atStage(Stages.AuctionCanceled) returns (bool) {
        require(receiverAddress != address(0));
        if (bids[receiverAddress] == 0) {
            return false;
        }
        uint amount = bids[receiverAddress];
        bids[receiverAddress] = 0;
        receiverAddress.transfer(amount);
        assert(bids[receiverAddress] == 0);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Auction {
    using SafeMath for uint256;

    address public owner;
    bool public isAuctionLive = true;
    mapping(address => uint256) public bids;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    modifier onlyWhileAuctionLive() {
        require(isAuctionLive, ""Auction is not live"");
        _;
    }

    modifier onlyWhileAuctionCanceled() {
        require(!isAuctionLive, ""Auction is live"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function cancelAuction() public onlyOwner onlyWhileAuctionLive {
        isAuctionLive = false;
    }

    function bid() public payable onlyWhileAuctionLive {
        bids[msg.sender] = bids[msg.sender].add(msg.value);
    }

    function withdraw(address payable receiverAddress) public onlyOwner onlyWhileAuctionCanceled {
        require(bids[receiverAddress] > 0, ""No funds to withdraw"");

        uint256 amount = bids[receiverAddress];
        bids[receiverAddress] = 0;

        (bool success, ) = receiverAddress.call{value: amount}("""");
        require(success, ""Failed to transfer funds"");
    }
}",14.331105947494509,withdraw,"[{'function': 'cancelAuction', 'complexity': 0}, {'function': 'bid', 'complexity': 0}, {'function': 'withdraw', 'complexity': 2}]",3.0,{},51.0,0.7385488549566761,0.170727861775126,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Auction is Ownable {
    using SafeMath for uint256;

    bool public isAuctionLive = true;
    mapping(address => uint256) public bids;

    modifier onlyWhileAuctionLive() {
        require(isAuctionLive, ""Auction is not live"");
        _;
    }

    modifier onlyWhileAuctionCanceled() {
        require(!isAuctionLive, ""Auction is live"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize owner as it's done in the parent constructor
    }

    function cancelAuction() public onlyOwner {
        isAuctionLive = false;
    }

    function bid() public payable onlyWhileAuctionLive {
        bids[msg.sender] = bids[msg.sender].add(msg.value);
    }

    function withdraw(address payable receiverAddress) public onlyOwner onlyWhileAuctionCanceled {
        require(bids[receiverAddress] > 0, ""No funds to withdraw"");

        uint256 amount = bids[receiverAddress];
        bids[receiverAddress] = 0;

        (bool success, ) = receiverAddress.call{value: amount}("""");
        require(success, ""Failed to transfer funds"");
    }
}"
1926,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable override returns (bool) {
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MiniMeToken is ReentrancyGuard {
    IERC20 public token;
    address public _owner;

    constructor(IERC20 _token) {
        token = _token;
        _owner = msg.sender;
    }

    function fundContract() external payable nonReentrant {
        require(msg.sender == _owner, ""Only contract owner can send ether to this contract"");
        require(msg.value > 0, ""Sending amount should be greater than 0"");
        token.transfer(_owner, msg.value);
    }
}",6.91414999961853,fundContract,"[{'function': 'fundContract', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""fundContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only contract owner can send ether to this contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Sending amount should be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",26.0,0.4567589263542197,0.0066257228731706,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MiniMeToken is ReentrancyGuard, Ownable {
    IERC20 public token;
    address public _owner;

    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
        _owner = msg.sender;
    }

    function fundContract() external payable nonReentrant {
        require(msg.sender == _owner, ""Only contract owner can send ether to this contract"");
        require(msg.value > 0, ""Sending amount should be greater than 0"");
        token.transfer(_owner, msg.value);
    }
}"
6311,Vote for specific proposal with yes or no,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

abstract contract Proposal {
    using SafeMath for uint256;
    struct Proposal {
        address token;
        uint256 yesVotes;
        uint256 noVotes;
    }
    Proposal[] public proposals;
    mapping(uint256 => Proposal) public proposalById;

    event Vote(uint256 indexed proposalId, address indexed voter, bool yes, uint256 amount);

    function vote(uint256 _proposalId, bool _yes) public {
        require(_proposalId < proposals.length, ""Invalid proposal ID"");
        require(checkIfCurrentlyActive(_proposalId), ""Proposal is not active"");
        Proposal memory p = proposals[_proposalId];
        uint256 amount = MiniMeToken(p.token).balanceOf(msg.sender);
        require(amount > 0, ""No tokens to vote with"");
        require(MiniMeToken(p.token).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        if (_yes) {
            proposals[_proposalId].yesVotes = proposals[_proposalId].yesVotes.add(amount);
        } else {
            proposals[_proposalId].noVotes = proposals[_proposalId].noVotes.add(amount);
        }
        emit Vote(_proposalId, msg.sender, _yes, amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Voting is AccessControl {
    using SafeMath for uint256;

    struct Proposal {
        uint256 yesVotes;
        uint256 noVotes;
    }

    mapping(address => bool) public hasVoted;
    mapping(uint256 => Proposal) public proposals;

    bytes32 public constant VOTER_ROLE = keccak256(""VOTER_ROLE"");

    function vote(uint256 proposalId, bool voteYes) public {
        require(hasRole(VOTER_ROLE, msg.sender), ""Caller is not a voter"");
        require(!hasVoted[msg.sender], ""Voter has already voted"");

        if (voteYes) {
            proposals[proposalId].yesVotes = proposals[proposalId].yesVotes.add(1);
        } else {
            proposals[proposalId].noVotes = proposals[proposalId].noVotes.add(1);
        }

        hasVoted[msg.sender] = true;
    }
}",14.30496883392334,vote,"[{'function': 'vote', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""vote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""proposalId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""voteYes"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""VOTER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a voter""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasVoted""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Voter has already voted""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""voteYes""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""memberName"": ""yesVotes""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""memberName"": ""yesVotes""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""memberName"": ""noVotes""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""memberName"": ""noVotes""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasVoted""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",49.0,0.8605836391205601,0.1125736445850936,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Voting is AccessControl {
    using SafeMath for uint256;

    struct Proposal {
        uint256 yesVotes;
        uint256 noVotes;
    }

    mapping(address => bool) public hasVoted;
    mapping(uint256 => Proposal) public proposals;

    bytes32 public constant VOTER_ROLE = keccak256(""VOTER_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(VOTER_ROLE, msg.sender);
    }

    function vote(uint256 proposalId, bool voteYes) public {
        require(hasRole(VOTER_ROLE, msg.sender), ""Caller is not a voter"");
        require(!hasVoted[msg.sender], ""Voter has already voted"");

        if (voteYes) {
            proposals[proposalId].yesVotes = proposals[proposalId].yesVotes.add(1);
        } else {
            proposals[proposalId].noVotes = proposals[proposalId].noVotes.add(1);
        }

        hasVoted[msg.sender] = true;
    }
}"
2268,"Executes active investment and redemption requests , in a way that minimises information advantages of investor","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AssetInterface {
    function transferFrom(address, address, uint) external returns (bool);
    function transfer(address, uint) external returns (bool);
}

interface PriceFeedInterface {
    function getInterval() external view returns (uint);
    function getLastUpdateId() external view returns (uint);
    function hasRecentPrice(address) external view returns (bool);
    function getInvertedPrice(address) external view returns (bool, uint, uint);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint;

    struct Request {
        address requestAsset;
        address participant;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
        RequestStatus status;
        RequestType requestType;
    }

    enum RequestStatus { active, executed }
    enum RequestType { invest, redeem, tokenFallbackRedeem }

    address public constant NATIVE_ASSET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint public totalSupply;
    bool public isInvestAllowed;
    bool public isRedeemAllowed;
    mapping(uint => Request) public requests;
    mapping(address => uint) public balances;

    PriceFeedInterface public module;

    constructor(PriceFeedInterface _module) {
        module = _module;
    }

    function executeRequest(uint id) external pre_cond(!isShutDown()) pre_cond(requests[id].status == RequestStatus.active) pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) pre_cond(totalSupply == 0 || (block.timestamp >= add(requests[id].timestamp, module.getInterval()) && module.getLastUpdateId() >= add(requests[id].atUpdateId, 2))) {
        Request memory request = requests[id];
        require(module.hasRecentPrice(address(request.requestAsset)));
        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));
        if (request.requestAsset == address(NATIVE_ASSET)) {
            var (isPriceRecent, invertedNativeAssetPrice, nativeAssetDecimal) = module.getInvertedPrice(address(NATIVE_ASSET));
            require(isPriceRecent);
            costQuantity = mul(costQuantity, invertedNativeAssetPrice) / 10**nativeAssetDecimal;
        }
        if (isInvestAllowed && request.requestType == RequestType.invest && costQuantity <= request.giveQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity));
            createShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.redeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.tokenFallbackRedeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(address(this), request.shareQuantity);
        } else {
            revert();
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract InvestmentContract is ERC20, Ownable {
    using SafeMath for uint256;

    struct Request {
        address investor;
        uint256 amount;
        bool isInvestment;
    }

    Request[] private requests;

    function executeRequests(uint256 timestamp) external onlyOwner {
        require(block.timestamp >= timestamp, ""Timestamp has not been reached"");

        // Shuffle the array to minimises information advantages of investor
        for (uint i = 0; i < requests.length; i++) {
            uint256 j = uint256(keccak256(abi.encodePacked(block.timestamp, i))) % requests.length;
            Request memory temp = requests[j];
            requests[j] = requests[i];
            requests[i] = temp;
        }

        // Execute the requests
        for (uint i = 0; i < requests.length; i++) {
            if (requests[i].isInvestment) {
                _mint(requests[i].investor,requests[i].amount);
            } else {
                _burn(requests[i].investor, requests[i].amount);
            }
        }

        delete requests;
    }

    function addRequest(address investor, uint256 amount, bool isInvestment) external onlyOwner {
        requests.push(Request(investor, amount, isInvestment));
    }
}",13.497269868850708,executeRequests,"[{'function': 'executeRequests', 'complexity': 5}, {'function': 'addRequest', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""executeRequests"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Timestamp has not been reached""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""%"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""memberName"": ""length""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Request""}, ""name"": ""temp"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""temp""}}}]}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""isInvestment""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""investor""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""amount""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""investor""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""amount""}], ""names"": []}}]}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""isPrefix"": True}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",109.0,0.7267520319034169,0.0294129299982781,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract InvestmentContract is ERC20, Ownable {
    using SafeMath for uint256;

    struct Request {
        address investor;
        uint256 amount;
        bool isInvestment;
    }

    Request[] private requests;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function executeRequests(uint256 timestamp) external onlyOwner {
        require(block.timestamp >= timestamp, ""Timestamp has not been reached"");

        for (uint i = 0; i < requests.length; i++) {
            uint256 j = uint256(keccak256(abi.encodePacked(block.timestamp, i))) % requests.length;
            Request memory temp = requests[j];
            requests[j] = requests[i];
            requests[i] = temp;
        }

        for (uint i = 0; i < requests.length; i++) {
            if (requests[i].isInvestment) {
                _mint(requests[i].investor, requests[i].amount);
            } else {
                _burn(requests[i].investor, requests[i].amount);
            }
        }

        delete requests;
    }

    function addRequest(address investor, uint256 amount, bool isInvestment) external onlyOwner {
        requests.push(Request(investor, amount, isInvestment));
    }
}"
2205,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorContract is Ownable {
    using SafeMath for uint256;

    struct Question {
        bytes32 questionId;
        bytes32 answer;
        address answerer;
        bool answered;
    }

    mapping(bytes32 => Question) public questions;

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external onlyOwner {
        require(!questions[question_id].answered, ""Question already answered"");
        questions[question_id] = Question({
            questionId: question_id,
            answer: answer,
            answerer: answerer,
            answered: true
        });
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Quiz {

    address private arbitrator;
    mapping (uint256 => Answer) private answers;

    struct Answer {
        address respondent;
        string response;
    }

    modifier onlyArbitrator() {
        require(msg.sender == arbitrator, ""Caller is not the arbitrator"");
        _;
    }

    constructor() {
        arbitrator = msg.sender;
    }

    function submitAnswer(uint256 _questionId, string memory _response) public onlyArbitrator {
        Answer storage answer = answers[_questionId];
        answer.respondent = msg.sender;
        answer.response = _response;
    }
}",13.61679482460022,submitAnswer,"[{'function': 'submitAnswer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_questionId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_response"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Answer""}, ""name"": ""answer"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""answers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_questionId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""answer""}, ""memberName"": ""respondent""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""answer""}, ""memberName"": ""response""}, ""right"": {""type"": ""Identifier"", ""name"": ""_response""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyArbitrator"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.8027123997066916,0.0050774555672877,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Quiz is Ownable {
    address private arbitrator;
    mapping (uint256 => Answer) private answers;

    struct Answer {
        address respondent;
        string response;
    }

    modifier onlyArbitrator() {
        require(msg.sender == arbitrator, ""Caller is not the arbitrator"");
        _;
    }

    constructor() Ownable(msg.sender) {
        arbitrator = msg.sender;
    }

    function submitAnswer(uint256 _questionId, string memory _response) public onlyArbitrator {
        Answer storage answer = answers[_questionId];
        answer.respondent = msg.sender;
        answer.response = _response;
    }
}"
6381,Calls transferFrom on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface CompatibleERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
        CompatibleERC20(token).transferFrom(from, to, amount);
        require(previousReturnValue(), ""transferFrom failed"");
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenTransfer is ReentrancyGuard {
    using SafeERC20 for IERC20;

    function transferToken(IERC20 token, address from, address to, uint256 amount) external nonReentrant {
        require(token.transferFrom(from, to, amount), ""Token transfer failed"");
    }
}",5.318765878677368,transferToken,"[{'function': 'transferToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.8138025139212445,0.4705512839236878,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferToken(IERC20 token, address from, address to, uint256 amount) external nonReentrant {
        require(token.transferFrom(from, to, amount), ""Token transfer failed"");
    }
}"
5030,Slashes the bond of a guilty trader .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOrderbookContract {
    function orderMatch(bytes32 _orderID) external returns (bytes32);
    function orderTrader(bytes32 _orderID) external view returns (address);
}

interface IRenExBalancesContract {
    function transferBalanceWithFee(address _to, address _from, address _tokenAddress, uint256 _amount, uint256 _fee, bytes32 _data) external;
}

abstract contract Slasher is Ownable {
    using SafeMath for uint256;

    IOrderbookContract public orderbookContract;
    IRenExBalancesContract public renExBalancesContract;
    address public slasherAddress;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = 0x0;

    enum OrderStatus { Pending, Settled, Slashed }

    struct TokenPair {
        address tokenA;
        address tokenB;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftTokenFee;
    }

    mapping(bytes32 => OrderStatus) public orderStatus;
    mapping(bytes32 => bytes32) public orderDetails;

    function slash(bytes32 _guiltyOrderID) external onlyOwner {
        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, ""slashing non-atomic trade"");
        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, ""invalid order status"");
        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);
        require(orderStatus[innocentOrderID] == OrderStatus.Settled, ""invalid order status"");
        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;
        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ? (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);
        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);
        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), orderbookContract.orderTrader(innocentOrderID), settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), slasherAddress, settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";


contract TraderJustice is AccessControl, ReentrancyGuard, Pausable {
    bytes32 public constant JUDGE_ROLE = keccak256(""JUDGE_ROLE"");
    mapping (address => uint256) private _bonds;

    constructor() {
        _setupRole(JUDGE_ROLE, msg.sender);
    }

    function slashBond(address guiltyTrader) public onlyRole(JUDGE_ROLE) whenNotPaused nonReentrant {
        require(_bonds[guiltyTrader] > 0, ""TraderJustice: This trader has no bond to slash"");

        uint256 bondAmount = _bonds[guiltyTrader];
        _bonds[guiltyTrader] = 0;

        payable(address(this)).transfer(bondAmount);
    }

    function depositBond() public payable whenNotPaused {
        _bonds[msg.sender] += msg.value;
    }

    function getBond(address trader) public view returns (uint256) {
        return _bonds[trader];
    }
}",16.05350399017334,slashBond,"[{'function': 'slashBond', 'complexity': 1}, {'function': 'depositBond', 'complexity': 0}, {'function': 'getBond', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""slashBond"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""guiltyTrader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_bonds""}, ""index"": {""type"": ""Identifier"", ""name"": ""guiltyTrader""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""TraderJustice: This trader has no bond to slash""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""bondAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_bonds""}, ""index"": {""type"": ""Identifier"", ""name"": ""guiltyTrader""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_bonds""}, ""index"": {""type"": ""Identifier"", ""name"": ""guiltyTrader""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""bondAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""JUDGE_ROLE""}]}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",85.0,0.6448185102524604,0.0080880987909642,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TraderJustice is Ownable, ReentrancyGuard, Pausable {
    bytes32 public constant JUDGE_ROLE = keccak256(""JUDGE_ROLE"");
    mapping (address => uint256) private _bonds;

    constructor() {
        _setupRole(JUDGE_ROLE, msg.sender);
    }

    function slashBond(address guiltyTrader) public onlyRole(JUDGE_ROLE) whenNotPaused nonReentrant {
        require(_bonds[guiltyTrader] > 0, ""TraderJustice: This trader has no bond to slash"");

        uint256 bondAmount = _bonds[guiltyTrader];
        _bonds[guiltyTrader] = 0;

        payable(address(this)).transfer(bondAmount);
    }

    function depositBond() public payable whenNotPaused {
        _bonds[msg.sender] += msg.value;
    }

    function getBond(address trader) public view returns (uint256) {
        return _bonds[trader];
    }
}"
3520,Submit the arbitrator 's answer to a question .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RealityCheck {
    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external;
}

abstract contract ArbitrationWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => bool) public arbitration_bounties;
    RealityCheck public realitycheck;

    constructor(address _realityCheckAddress) {
        realitycheck = RealityCheck(_realityCheckAddress);
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) public onlyOwner {
        delete arbitration_bounties[question_id];
        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Arbitration is Ownable {
    event QuestionAnswered(uint id, string answer);

    struct Question {
        string question;
        string answer;
        bool isAnswered;
    }

    mapping(uint => Question) public questions;

    function submitAnswer(uint _id, string calldata _answer) public onlyOwner {
        require(questions[_id].isAnswered == false, ""Question has already been answered"");

        questions[_id].answer = _answer;
        questions[_id].isAnswered = true;

        emit QuestionAnswered(_id, _answer);
    }
}",5.710198163986206,submitAnswer,"[{'function': 'submitAnswer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_answer"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""isAnswered""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""Question has already been answered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""answer""}, ""right"": {""type"": ""Identifier"", ""name"": ""_answer""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""isAnswered""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""QuestionAnswered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_id""}, {""type"": ""Identifier"", ""name"": ""_answer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.7345486322761833,0.0946423771296465,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Arbitration is Ownable {
    event QuestionAnswered(uint id, string answer);

    struct Question {
        string question;
        string answer;
        bool isAnswered;
    }

    mapping(uint => Question) public questions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; ; ++i) {
            if (questions[i].isAnswered == false) {
                questions[i] = Question({
                    question: ""initial_question"",
                    answer: ""initial_answer"",
                    isAnswered: true // Set to true initially, can be updated later
                });
                break;
            }
        }
    }

    function submitAnswer(uint _id, string calldata _answer) public onlyOwner {
        require(questions[_id].isAnswered == false, ""Question has already been answered"");

        questions[_id].answer = _answer;
        questions[_id].isAnswered = true;

        emit QuestionAnswered(_id, _answer);
    }
}"
4614,Withdraw nomins : Allows the owner to withdraw nomins from this contract if needed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawNomins(uint amount) external onlyOwner {
        require(address(nomin).balance >= amount, ""Insufficient balance"");
        nomin.transfer(owner(), amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract NominWithdrawal is Ownable {
    IERC20 private nomins;

    constructor(IERC20 _nomins) {
        nomins = _nomins;
    }

    function withdrawNomins(uint256 _amount) public onlyOwner {
        uint256 balance = nomins.balanceOf(address(this));
        require(_amount <= balance, ""Withdrawal amount exceeds available balance"");

        nomins.transfer(msg.sender, _amount);
    }
}",8.635788202285767,withdrawNomins,"[{'function': 'withdrawNomins', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawNomins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nomins""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Withdrawal amount exceeds available balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nomins""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.910710382152933,0.0784375362577212,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NominWithdrawal is Ownable {
    IERC20 private nomins;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _nomins) Ownable(msg.sender) {
        nomins = _nomins;
    }

    function withdrawNomins(uint256 _amount) public onlyOwner {
        uint256 balance = nomins.balanceOf(address(this));
        require(_amount <= balance, ""Withdrawal amount exceeds available balance"");

        nomins.transfer(msg.sender, _amount);
    }
}"
1147,"Return the final answer to the specified question , provided it matches the specified criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorWrapper {
    using SafeMath for uint256;

    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        bytes32 best_answer;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) external constant returns (bytes32) {
        require(content_hash == questions[question_id].content_hash);
        require(arbitrator == questions[question_id].arbitrator);
        require(min_timeout <= questions[question_id].timeout);
        require(min_bond <= questions[question_id].bond);
        return questions[question_id].best_answer;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AnswerContract is Ownable {
    using SafeMath for uint256;

    mapping(string => string) private answers;

    function setAnswer(string memory question, string memory answer) public onlyOwner {
        answers[question] = answer;
    }

    function getAnswer(string memory question, string memory criteria) public view returns (string memory) {
        string memory answer = answers[question];

        require(keccak256(abi.encodePacked(answer)) == keccak256(abi.encodePacked(criteria)), ""Answer does not match criteria"");

        return answer;
    }
}",7.576929807662964,getAnswer,"[{'function': 'setAnswer', 'complexity': 0}, {'function': 'getAnswer', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAnswer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""question"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""criteria"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""answer"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""answers""}, ""index"": {""type"": ""Identifier"", ""name"": ""question""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""answer""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""criteria""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Answer does not match criteria""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""answer""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",39.0,0.5832816363604089,0.0334007333573175,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AnswerContract is Ownable {
    using SafeMath for uint256;

    mapping(string => string) private answers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function setAnswer(string memory question, string memory answer) public onlyOwner {
        answers[question] = answer;
    }

    function getAnswer(string memory question, string memory criteria) public view returns (string memory) {
        string memory answer = answers[question];

        require(keccak256(abi.encodePacked(answer)) == keccak256(abi.encodePacked(criteria)), ""Answer does not match criteria"");

        return answer;
    }
}"
6458,This works even if sender does n't own any tokens at the time .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerToOperators;

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        require(_operator != address(0), ""Operator address must be non-zero"");
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    modifier onlyNonZeroAddress(address addr) {
        require(addr != address(0), ""Address must be non-zero"");
        _;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract MyToken is ERC20, ReentrancyGuard {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    function transferAny(address recipient, uint256 amount) public nonReentrant {
        uint256 senderBalance = _balances[msg.sender];
        require(senderBalance >= amount, ""MyToken: transfer amount exceeds balance"");
        _balances[msg.sender] = senderBalance.sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(msg.sender, recipient, amount);
    }
}",8.76322603225708,transferAny,"[{'function': 'transferAny', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferAny"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""MyToken: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.4137060410459736,0.0450117505826319,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    constructor() ERC20(""MyToken"", ""TKN"") ReentrancyGuard() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _balances[msg.sender] = 1 * 10 ** uint256(decimals()); // Initial supply of tokens
    }

    function transferAny(address recipient, uint256 amount) public nonReentrant {
        uint256 senderBalance = _balances[msg.sender];
        require(senderBalance >= amount, ""MyToken: transfer amount exceeds balance"");
        _balances[msg.sender] = senderBalance.sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(msg.sender, recipient, amount);
    }
}"
732,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) external onlyOwner {
        require(_to != address(0), ""Invalid recipient address"");
        (bool success, ) = _to.call{value: _value}(_data);
        require(success, ""Transfer failed"");
        if (_log.length > 0) {
            emit LogData(_log);
        }
    }

    event LogData(bytes log);
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20, Ownable {

    using SafeMath for uint256;

    function forcedTransfer(address _from, address _to, uint256 _value) public onlyOwner {
        require(_value <= balanceOf(_from), ""Insufficient balance for transfer"");
        _transfer(_from, _to, _value);
    }

    function _transfer(address _from, address _to, uint256 _value) internal override{
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(_from, _to, _value);
    }

}",10.677077054977415,_transfer,"[{'function': 'forcedTransfer', 'complexity': 1}, {'function': '_transfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",37.0,0.780281026669176,0.1190563640608819,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {

    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1 ether; // Set initial balance for the owner to 1 token (1 * 10^18 wei)
    }

    function forcedTransfer(address _from, address _to, uint256 _value) public onlyOwner {
        require(_value <= balances[_from], ""Insufficient balance for transfer"");
        balances[_from] -= _value;
        balances[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}"
442,"Ends the auction , preventing new bids from entering","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Auction {
    using SafeMath for uint256;

    enum state { active, ended }
    state public status;

    constructor() {
        status = state.active;
    }

    function endAuction() public onlyOwner {
        require(status == state.active);
        status = state.ended;
        emit Ended(block.number);
    }

    event Ended(uint256 indexed blockNumber);
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Auction is ReentrancyGuard, Ownable {
    bool public isAuctionEnded;

    constructor() {
        isAuctionEnded = false;
    }

    modifier activeAuction() {
        require(!isAuctionEnded, ""Auction has ended"");
        _;
    }

    function endAuction() external onlyOwner nonReentrant {
        isAuctionEnded = true;
    }
}",4.712821960449219,endAuction,"[{'function': 'endAuction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""endAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isAuctionEnded""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.8385435071216898,0.0927495299434868,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is ReentrancyGuard, Ownable {
    bool public isAuctionEnded;

    constructor() Ownable(msg.sender) {
        isAuctionEnded = false;
    }

    modifier activeAuction() {
        require(!isAuctionEnded, ""Auction has ended"");
        _;
    }

    function endAuction() external onlyOwner nonReentrant {
        isAuctionEnded = true;
    }
}"
3580,Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeValidator {
    using SafeMath for uint256;

    uint256 private _totalAttributeTypes;
    uint256 private _maxValue;
    uint256 private _maxFundsRequired;
    uint256 private _maxValidatorFee;
    uint256 private _signatureLength;

    constructor(uint256 totalAttributeTypes, uint256 maxValue, uint256 maxFundsRequired, uint256 maxValidatorFee, uint256 signatureLength) {
        require(totalAttributeTypes > 0, ""Invalid total attribute types"");
        require(maxValue > 0, ""Invalid maximum value"");
        require(maxFundsRequired > 0, ""Invalid maximum funds required"");
        require(maxValidatorFee >= 0, ""Invalid maximum validator fee"");
        require(signatureLength > 0, ""Invalid signature length"");

        _totalAttributeTypes = totalAttributeTypes;
        _maxValue = maxValue;
        _maxFundsRequired = maxFundsRequired;
        _maxValidatorFee = maxValidatorFee;
        _signatureLength = signatureLength;
    }

    function canAddAttributeFor(address account, uint256 attributeTypeID, uint256 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) external view returns (bool) {
        require(account != address(0), ""Invalid account address"");
        require(attributeTypeID > 0 && attributeTypeID <= _totalAttributeTypes, ""Invalid attribute type ID"");
        require(value >= 0 && value <= _maxValue, ""Invalid value"");
        require(fundsRequired >= 0 && fundsRequired <= _maxFundsRequired, ""Invalid funds required"");
        require(validatorFee >= 0 && validatorFee <= _maxValidatorFee, ""Invalid validator fee"");
        require(signature.length == _signatureLength, ""Invalid signature length"");

        uint256 currentBalance = getCurrentBalanceForAccount(account);
        require(currentBalance >= fundsRequired, ""Insufficient funds"");

        bool isAttributeAdded = isAttributeAlreadyAddedForAccount(account, attributeTypeID);
        require(!isAttributeAdded, ""Attribute already added"");

        return true;
    }

    function getCurrentBalanceForAccount(address account) internal view returns (uint256) {
        // Implement the logic to get the current balance of the account
        // This is a placeholder for the actual implementation
        return 0;
    }

    function isAttributeAlreadyAddedForAccount(address account, uint256 attributeTypeID) internal view returns (bool) {
        // Implement the logic to check if the attribute is already added for the account
        // This is a placeholder for the actual implementation
        return false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) private _approvals;

    function isValidApproval(address account, uint256 attribute) public view returns (bool) {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an administrator"");
        require(account != address(0), ""Zero address cannot be validated"");
        return _approvals[account][msg.sender] >= attribute;
    }
}",7.001585006713867,isValidApproval,"[{'function': 'isValidApproval', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""isValidApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attribute"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an administrator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Zero address cannot be validated""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""attribute""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",81.0,0.6235033860839695,0.0625756484384268,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) private _approvals;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // Initialize role and owner in the constructor
        transferOwnership(msg.sender); // Transfer ownership to the deployer
    }

    function isValidApproval(address account, uint256 attribute) public view returns (bool) {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an administrator"");
        require(account != address(0), ""Zero address cannot be validated"");
        return _approvals[account][msg.sender] >= attribute;
    }
}"
3476,Called when tokens have to be burned ( only after sale ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    bool public locked = false;
    string public contractName;
    address public depositAddress;
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    event TokensBurned(address indexed from, address indexed to, uint256 value);

    function burnTokens(uint256 _tokens) external {
        require(!locked, ""Contract is locked"");
        require(contractManager.authorize(contractName, msg.sender), ""Unauthorized access"");
        require(depositAddress != address(0), ""Deposit address not set"");
        require(_tokens != 0, ""Tokens amount must be greater than zero"");
        require(_tokens <= balances[depositAddress], ""Insufficient balance to burn tokens"");

        balances[depositAddress] = balances[depositAddress].sub(_tokens);
        totalSupply_ = totalSupply_.sub(_tokens);
        emit TokensBurned(msg.sender, depositAddress, _tokens);
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";

contract TokenSale is Ownable, Pausable {
    IERC20 public token;
    bool public isSaleFinished = false;

    constructor(IERC20 _token) {
        token = _token;
    }

    function finishSale() public onlyOwner {
        require(isSaleFinished == false, ""Sale has already finished."");
        isSaleFinished = true;
    }

    function burnTokens(uint256 amount) public onlyOwner whenNotPaused {
        require(isSaleFinished == true, ""Can only burn tokens after sale."");
        ERC20Burnable(address(token)).burn(amount);
    }
}",13.155098915100098,finishSale,"[{'function': 'finishSale', 'complexity': 1}, {'function': 'burnTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""finishSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""isSaleFinished""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""Sale has already finished.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isSaleFinished""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",60.0,0.2818315644115622,0.0024076916953128,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable, Pausable {
    IERC20 public token;
    bool public isSaleFinished = false;

    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function finishSale() public onlyOwner {
        require(isSaleFinished == false, ""Sale has already finished."");
        isSaleFinished = true;
    }

    function burnTokens(uint256 amount) public onlyOwner whenNotPaused {
        require(isSaleFinished == true, ""Can only burn tokens after sale."");
        ERC20Burnable(address(token)).burn(amount);
    }
}"
1148,Reusable code to do sanity check of transfer variables,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TransferCheckWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    bool public tokenTransfersFrozen;

    function transferCheck(address _sender, address _receiver, uint256 _amount) external view returns (bool success) {
        require(!tokenTransfersFrozen, ""Token transfers are frozen"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_receiver != address(0), ""Receiver address cannot be the zero address"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        require(balances[_receiver] + _amount > balances[_receiver], ""Transfer amount exceeds available balance"");
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract YourContract is ReentrancyGuard {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    function transfer(address sender, address recipient, uint256 amount) public nonReentrant {
        require(sender != address(0), ""Transfer from the zero address is not allowed."");
        require(recipient != address(0), ""Transfer to the zero address is not allowed."");
        require(amount > 0, ""Transfer amount must be greater than zero"");
        require(_balances[sender] >= amount, ""Insufficient balance for transfer"");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
    }
}",14.76068377494812,transfer,"[{'function': 'transfer', 'complexity': 4}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Transfer from the zero address is not allowed.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Transfer to the zero address is not allowed.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance for transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.7662640457666973,0.2586852542063556,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract YourContract is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _balances[owner()] = 1; // Set balance to 1 for the owner
    }

    function transfer(address sender, address recipient, uint256 amount) public nonReentrant {
        require(sender != address(0), ""Transfer from the zero address is not allowed."");
        require(recipient != address(0), ""Transfer to the zero address is not allowed."");
        require(amount > 0, ""Transfer amount must be greater than zero"");
        require(_balances[sender] >= amount, ""Insufficient balance for transfer"");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
    }
}"
5952,Sets the contract that will handle a specific interface ; only the address itself or a ` manager ` defined for that address can set it,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InterfaceImplementerWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed iHash, address implementer);

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public onlyOwner {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/Context.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract InterfacesHandler is Context, AccessControl {
    using Address for address;

    bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");

    mapping(address => address) private _interfaceHandlers;

    modifier onlyManagerOrSelf(address addr) {
        require(
            _msgSender() == addr || hasRole(MANAGER_ROLE, _msgSender()),
            ""Caller is not a manager or the address itself""
        );
        _;
    }

    function setInterfaceHandler(address iface, address handler)
        public
        onlyManagerOrSelf(iface)
    {
        require(handler.isContract(), ""Handler must be a contract"");
        _interfaceHandlers[iface] = handler;
    }
}",10.153158187866213,setInterfaceHandler,"[{'function': 'setInterfaceHandler', 'complexity': -1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInterfaceHandler"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""iface"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""handler"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""handler""}, ""memberName"": ""isContract""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Handler must be a contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_interfaceHandlers""}, ""index"": {""type"": ""Identifier"", ""name"": ""iface""}}, ""right"": {""type"": ""Identifier"", ""name"": ""handler""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManagerOrSelf"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""iface""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.6487304882416823,0.0283817568814871,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Context.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Importing Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract InterfacesHandler is Context, AccessControl, Ownable {
    using Address for address;

    bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");

    mapping(address => address) private _interfaceHandlers;

    modifier onlyManagerOrSelf(address addr) {
        require(
            _msgSender() == addr || hasRole(MANAGER_ROLE, _msgSender()),
            ""Caller is not a manager or the address itself""
        );
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with specific values as per the rules provided:
        MANAGER_ROLE = keccak256(""MANAGER_ROLE"");
        _interfaceHandlers[address(0x111)] = address(0);
        _interfaceHandlers[address(0x222)] = address(0);
        _interfaceHandlers[address(0x333)] = address(0);
    }

    function setInterfaceHandler(address iface, address handler)
        public
        onlyManagerOrSelf(iface)
    {
        require(handler.isContract(), ""Handler must be a contract"");
        _interfaceHandlers[iface] = handler;
    }
}"
5131,Function to know how many tokens you will receive at current time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenPrice {
    function USD(uint256 index) external view returns (uint256);
}

abstract contract TokenCalculator is Ownable {
    using SafeMath for uint256;

    ITokenPrice public price;

    constructor(address _priceAddress) {
        price = ITokenPrice(_priceAddress);
    }

    function calculateTokens(uint256 _amountOfWei) public view returns (uint256) {
        require(_amountOfWei >= 1 szabo, ""Amount must be at least 1 szabo"");
        uint256 tokenBought;
        uint256 tokenPrice = price.USD(0);
        tokenPrice = tokenPrice.mul(36).div(10 ** 8);
        tokenBought = _amountOfWei.div(tokenPrice);
        tokenBought = tokenBought.mul(10 ** 10);
        if (_amountOfWei >= 10 ether) {
            tokenBought = tokenBought.mul(123).div(100);
        } else if (_amountOfWei >= 1 ether) {
            tokenBought = tokenBought.mul(11).div(10);
        }
        return tokenBought;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    IERC20 public token;
    uint256 public rate;

    constructor(IERC20 _token, uint256 _rate) {
        token = _token;
        rate = _rate;
    }

    function howManyTokensWillIReceive(uint256 _ethAmount) public view returns (uint256) {
        uint256 decimalFactor = 10**uint256(token.decimals());
        return _ethAmount * rate * decimalFactor / 1 ether;
    }
}",11.095009088516235,howManyTokensWillIReceive,"[{'function': 'howManyTokensWillIReceive', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""howManyTokensWillIReceive"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_ethAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""decimalFactor"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""decimals""}, ""arguments"": [], ""names"": []}], ""names"": []}}}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_ethAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""rate""}}, ""right"": {""type"": ""Identifier"", ""name"": ""decimalFactor""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",46.0,0.7079990108546275,0.0251584788670398,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public token;
    uint256 public rate;

    constructor(IERC20 _token, uint256 _rate) Ownable() {
        token = _token;
        rate = _rate;
    }

    function howManyTokensWillIReceive(uint256 _ethAmount) public view returns (uint256) {
        uint256 decimalFactor = 10**uint256(token.decimals());
        return _ethAmount * rate * decimalFactor / 1 ether;
    }
}"
725,Checks whether an address is whitelisted in the competition contract and competition is active,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CompetitionWhitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public isWhitelisted;

    function isCompetitionAllowed(address user) public view returns (bool) {
        return isWhitelisted[user];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract Competition is AccessControl {
    bytes32 public constant WHITELISTED_ROLE = keccak256(""WHITELISTED_ROLE"");

    bool public competitionActive;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function isCompetitorAllowed(address competitor) public view returns (bool) {
        require(competitionActive, ""Competition is not active"");
        return hasRole(WHITELISTED_ROLE, competitor);
    }
}",6.154348134994507,isCompetitorAllowed,"[{'function': 'isCompetitorAllowed', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isCompetitorAllowed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""competitor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""competitionActive""}, {""type"": ""stringLiteral"", ""value"": ""Competition is not active""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""WHITELISTED_ROLE""}, {""type"": ""Identifier"", ""name"": ""competitor""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.7737357088192921,0.2452059009040398,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Competition is AccessControl, Ownable {
    bytes32 public constant WHITELISTED_ROLE = keccak256(""WHITELISTED_ROLE"");

    bool public competitionActive;

    constructor(address admin) {
        _setupRole(DEFAULT_ADMIN_ROLE, admin);
        transferOwnership(admin);
        competitionActive = true; // Set to true as per the initialization rules
    }

    function isCompetitorAllowed(address competitor) public view returns (bool) {
        require(competitionActive, ""Competition is not active"");
        return hasRole(WHITELISTED_ROLE, competitor);
    }
}"
3756,The sender casts a vote in favour of confiscation of the target account 's nomin balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Voting {
    function setupVote(uint motionID) external returns (uint);
}

abstract contract VoteWrapper is Ownable {
    using SafeMath for uint;

    enum Vote { None, Yea, Nay }

    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    function voteFor(uint motionID, address votingContractAddress) external {
        require(votingContractAddress.call(abi.encodeWithSignature(""setupVote(uint256)"", motionID)), ""Failed to call setupVote"");
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] = votesFor[motionID].add(1);
        emit VotedFor(msg.sender, motionID, 1);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract VoteContract is Ownable {
    using SafeMath for uint256;

    struct Voter {
        uint256 balance;
        bool vote;
    }

    mapping(address => Voter) public voters;

    function castVote(address _target, bool _vote) public onlyOwner {
        Voter storage voter = voters[msg.sender];
        require(voter.balance > 0, ""Not eligible to vote"");

        voters[_target].vote = _vote;

        if(_vote == true) {
            voters[_target].balance = 0;
        }
    }
}",8.286250829696655,castVote,"[{'function': 'castVote', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""castVote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_vote"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Voter""}, ""name"": ""voter"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""voters""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""voter""}, ""memberName"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Not eligible to vote""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""voters""}, ""index"": {""type"": ""Identifier"", ""name"": ""_target""}}, ""memberName"": ""vote""}, ""right"": {""type"": ""Identifier"", ""name"": ""_vote""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_vote""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""voters""}, ""index"": {""type"": ""Identifier"", ""name"": ""_target""}}, ""memberName"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.5992729444575374,0.0143195004724683,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract VoteContract is Ownable {
    using SafeMath for uint256;

    struct Voter {
        uint256 balance;
        bool vote;
    }

    mapping(address => Voter) public voters;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            voters[addr] = Voter({balance: 1, vote: false});
        }
    }

    function castVote(address _target, bool _vote) public onlyOwner {
        Voter storage voter = voters[_target];
        require(voter.balance > 0, ""Not eligible to vote"");

        voter.vote = _vote;

        if (_vote == true) {
            voter.balance = 0;
        }
    }
}"
4311,Sets prizes for last tokens and sets prize pool amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, WinnersAssigned, Finished }
    pointsValidationState public pValidationState;
    uint256 public gameFinishedTime;
    uint256 public adminPool;
    uint256 public prizePool;

    function setEnd() external onlyOwner checkState(pointsValidationState.WinnersAssigned) {
        uint256 balance = address(this).balance;
        adminPool = balance.mul(10).div(100);
        prizePool = balance.mul(90).div(100);
        pValidationState = pointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
        unSetPause();
    }

    function checkState(pointsValidationState state) internal view {
        require(pValidationState == state, ""Invalid state"");
    }

    function unSetPause() internal {
        // Implementation of unSetPause logic
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PrizePool is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    uint256 public lastTokenPrize;
    uint256 public prizePoolAmount;

    function setPrizeAndPool(uint256 _lastTokenPrize, uint256 _prizePoolAmount) public onlyOwner nonReentrant {
        require(_lastTokenPrize > 0, ""Prize for the last token should be greater than zero"");
        require(_prizePoolAmount >= _lastTokenPrize, ""Prize pool amount should be equal or more than the last token prize"");

        lastTokenPrize = _lastTokenPrize;
        prizePoolAmount = _prizePoolAmount;
    }
}",10.001217126846312,setPrizeAndPool,"[{'function': 'setPrizeAndPool', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrizeAndPool"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_lastTokenPrize"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_prizePoolAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_lastTokenPrize""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Prize for the last token should be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_prizePoolAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_lastTokenPrize""}}, {""type"": ""stringLiteral"", ""value"": ""Prize pool amount should be equal or more than the last token prize""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastTokenPrize""}, ""right"": {""type"": ""Identifier"", ""name"": ""_lastTokenPrize""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""prizePoolAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_prizePoolAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.5568411776676819,0.0128734393625718,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PrizePool is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    uint256 public lastTokenPrize;
    uint256 public prizePoolAmount;

    constructor() Ownable(msg.sender) {
        lastTokenPrize = 1; // Set to 1 (never 0)
        prizePoolAmount = 1; // Set to 1 (never 0)
    }

    function setPrizeAndPool(uint256 _lastTokenPrize, uint256 _prizePoolAmount) public onlyOwner nonReentrant {
        require(_lastTokenPrize > 0, ""Prize for the last token should be greater than zero"");
        require(_prizePoolAmount >= _lastTokenPrize, ""Prize pool amount should be equal or more than the last token prize"");

        lastTokenPrize = _lastTokenPrize;
        prizePoolAmount = _prizePoolAmount;
    }
}"
5253,Renouncing to ownership will leave the contract without an owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function renounceOwnership() public override onlyOwner {
        emit OwnershipRenounced(owner());
        _transferOwnership(address(0));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    function renounceOwnership() public virtual onlyOwner {
        require(owner() != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}",4.288862943649292,renounceOwnership,"[{'function': 'renounceOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""renounceOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Ownable: new owner is the zero address""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.9262928693384272,0.2551754782351154,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function renounceOwnership() public virtual onlyOwner {
        require(owner() != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}"
86,` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public maxSecurityGuardDelay;

    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) external onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SecurityPayment is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public maxSecurityGuardDelay;

    function setMaxSecurityGuardDelay(uint256 newDelay) external onlyOwner nonReentrant {
        maxSecurityGuardDelay = newDelay;
    }
}",5.886454105377197,setMaxSecurityGuardDelay,"[{'function': 'setMaxSecurityGuardDelay', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMaxSecurityGuardDelay"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newDelay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxSecurityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""newDelay""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.9026896397259668,0.1654461999338998,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract SecurityPayment is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public maxSecurityGuardDelay;

    constructor() Ownable(msg.sender) {
        maxSecurityGuardDelay = 1; // Set to a non-zero value
    }

    function setMaxSecurityGuardDelay(uint256 newDelay) external onlyOwner nonReentrant {
        require(newDelay > 0, ""Delay must be greater than zero"");
        maxSecurityGuardDelay = newDelay;
    }
}"
3464,_addModule handles the attachment ( or replacement ) of modules for the ST,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IModuleRegistry {
    function getType() external view returns (uint8);
}

interface IModuleFactory {
    function setupCost() external view returns (uint256);
    function deploy(bytes calldata) external returns (address);
    function getName() external view returns (bytes32);
}

interface ERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ModuleRegistryWrapper is Ownable {
    using SafeMath for uint256;

    struct ModuleData {
        bytes32 name;
        address module;
    }

    mapping(uint8 => ModuleData[]) public modules;
    address public polyToken;
    uint8 constant MAX_MODULES = 10;

    event LogModuleAdded(uint8 indexed moduleType, bytes32 indexed moduleName, address indexed moduleFactory, address module, uint256 cost, uint256 budget, uint256 timestamp);

    function _addModule(address _moduleFactory, bytes memory _data, uint256 _maxCost, uint256 _budget) internal {
        IModuleRegistry moduleRegistry = IModuleRegistry(_moduleFactory);
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint8 moduleType = moduleFactory.getType();
        require(modules[moduleType].length < MAX_MODULES, ""Limit of MAX MODULES is reached"");
        uint256 moduleCost = moduleFactory.setupCost();
        require(moduleCost <= _maxCost, ""Max Cost is always be greater than module cost"");
        require(ERC20(polyToken).approve(_moduleFactory, moduleCost), ""Not able to approve the module cost"");
        address module = moduleFactory.deploy(_data);
        require(ERC20(polyToken).approve(module, _budget), ""Not able to approve the budget"");
        bytes32 moduleName = moduleFactory.getName();
        modules[moduleType].push(ModuleData(moduleName, module));
        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, block.timestamp);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract ST is Ownable {
  using SafeMath for uint256;
  using Address for address;

  mapping (bytes32 => address) public modules;

  function addModule(bytes32 _name, address _module) external onlyOwner {
    require(_module != address(0), ""Invalid module address"");
    require(!_module.isContract(), ""Address provided is not a contract"");

    modules[_name] = _module;
  }
}",7.744402170181274,addModule,"[{'function': 'addModule', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_name"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_module"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_module""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid module address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_module""}, ""memberName"": ""isContract""}, ""arguments"": [], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Address provided is not a contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""_name""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_module""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",86.0,0.661706862701137,0.0066428524870948,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";

contract ST is Ownable {
  using SafeMath for uint256;
  using Address for address;

  mapping (bytes32 => address) public modules;

  uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

  function addModule(bytes32 _name, address _module) external onlyOwner {
    require(_module != address(0), ""Invalid module address"");
    require(!_module.isContract(), ""Address provided is not a contract"");

    modules[_name] = _module;
  }
}"
2419,Return the permissions flag that are associated with Module,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionsContract is Ownable {
    using SafeMath for uint256;

    bytes32[] private permissions;

    function getPermissions() public view returns (bytes32[]) {
        return permissions;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract Module is AccessControl {
    bytes32 public constant MODULE_ROLE = keccak256(""MODULE_ROLE"");

    function setModulePermission(address module, bool flag) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        if (flag == true) {
            grantRole(MODULE_ROLE, module);
        } else {
            revokeRole(MODULE_ROLE, module);
        }
    }

    function checkModulePermission(address module) public view returns (bool) {
        return hasRole(MODULE_ROLE, module);
    }
}",7.193687200546265,setModulePermission,"[{'function': 'setModulePermission', 'complexity': 2}, {'function': 'checkModulePermission', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setModulePermission"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""module"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""flag"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""flag""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MODULE_ROLE""}, {""type"": ""Identifier"", ""name"": ""module""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revokeRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MODULE_ROLE""}, {""type"": ""Identifier"", ""name"": ""module""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.3516743768719568,0.0122835853347209,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Module is AccessControl {
    bytes32 public constant MODULE_ROLE = keccak256(""MODULE_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setModulePermission(address module, bool flag) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        if (flag == true) {
            grantRole(MODULE_ROLE, module);
        } else {
            revokeRole(MODULE_ROLE, module);
        }
    }

    function checkModulePermission(address module) public view returns (bool) {
        return hasRole(MODULE_ROLE, module);
    }
}"
3265,"Called by the owner to unpause , returns to normal state","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused;

    event Unpause(uint256 timestamp);

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function _unpause() internal whenPaused {
        paused = false;
        emit Unpause(block.timestamp);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Pausable, Ownable {

    function unpause() public onlyOwner {
        _unpause();
    }
}",3.919839143753052,unpause,"[{'function': 'unpause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_unpause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.7688609547600879,0.1034363006512541,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Pausable, Ownable {
    constructor() Pausable(), Ownable(msg.sender) {}

    function unpause() public onlyOwner {
        _unpause();
    }
}"
1244,Returns all the relevant information about a specific grey .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GreyWrapper {
    using SafeMath for uint256;

    struct Grey {
        string name;
    }

    mapping(uint256 => Grey) private greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    function getGrey(uint256 _tokenId) public view returns (string memory, uint256, address, uint256, address[5] memory) {
        Grey storage grey = greys[_tokenId];
        return (grey.name, greyIndexToPrice[_tokenId], greyIndexToOwner[_tokenId], greyIndexToPreviousPrice[_tokenId], greyIndexToPreviousOwners[_tokenId]);
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract EntityContract {

   using SafeMath for uint256;

   struct Entity {
        uint256 id;
        bytes32 data;
    }

   mapping(uint256 => Entity) public entities;

   function getEntity(uint256 _id) public view returns (uint256, bytes32) {
       require(entities[_id].id != 0, ""Entity does not exist."");
       return (entities[_id].id, entities[_id].data);
   }
}",12.390219926834106,getEntity,"[{'function': 'getEntity', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getEntity"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""entities""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""id""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Entity does not exist.""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""entities""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""id""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""entities""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""data""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",26.0,0.4807179219371313,0.1526860221190834,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract EntityContract is Ownable {
   using SafeMath for uint256;

   struct Entity {
        uint256 id;
        bytes32 data;
    }

   mapping(uint256 => Entity) public entities;

   constructor() Ownable(msg.sender) {
       // Initialize state variables with safe, non-corner-case values
       for (uint256 i = 1; i <= 3; i++) {
           entities[i] = Entity({id: i, data: bytes32('init')});
       }
   }

   function getEntity(uint256 _id) public view returns (uint256, bytes32) {
       require(entities[_id].id != 0, ""Entity does not exist."");
       return (entities[_id].id, entities[_id].data);
   }
}"
1531,This method may be deprecated or refactored to allow for multiple interfaces,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LibStorage {
    function setBool(bytes32 id, bool value) external returns (bool);
}

interface TokenXInterface {
    function setAssetCurrency(address asset, string memory currency) external returns (bool);
}

abstract contract TokenXWrapper is Ownable {
    using SafeMath for uint256;

    LibStorage public lib;
    TokenXInterface public tokenX;

    constructor(address _libAddress, address _tokenXAddress) {
        lib = LibStorage(_libAddress);
        tokenX = TokenXInterface(_tokenXAddress);
    }

    function setTokenXCurrency(address asset, string memory currency) public onlyOwner returns (bool success) {
        bytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));
        require(lib.setBool(id, true), ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."");
        require(tokenX.setAssetCurrency(asset, currency), ""Error: Failed to set asset currency."");
        return true;
    }
}","input, it seems like you're asking for a generalized smart contract function with the hint that it may be deprecated or refactored in the future to allow for multiple interfaces. The following code snippet illustrates this:

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    function myFunction(address _address, uint256 _value)
        public
        onlyOwner
    {
        require(_address != address(0), ""Address should not be zero address"");
        require(_value > 0, ""Value must be greater than zero"");

        // Execute the function logic here;
    }
}",8.347429275512695,myFunction,"[{'function': 'myFunction', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""myFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Address should not be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.3673639648654339,0.0536873351817295," ```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function myFunction(address _address, uint256 _value)
        public
        onlyOwner
    {
        require(_address != address(0), ""Address should not be zero address"");
        require(_value > 0, ""Value must be greater than zero"");

        // Execute the function logic here;
    }
}
```"
4775,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public totalTokensSold;
    uint256 public cap;

    function capReached() public view returns (bool) {
        return totalTokensSold >= cap;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public cap;
    uint256 public totalSupply;

    constructor(uint256 _cap) {
        require(_cap > 0, ""Cap can't be 0"");
        cap = _cap;
    }

    function capReached() public view returns (bool) {
        return totalSupply >= cap;
    }
}",6.140798807144165,capReached,"[{'function': 'capReached', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""capReached"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""cap""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",0.0,0.8680875097531585,0.8153551038173115,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    uint256 public cap;
    uint256 public totalSupply;

    constructor(uint256 _cap) Ownable(msg.sender) {
        require(_cap > 0, ""Cap can't be 0"");
        cap = _cap;
        totalSupply = 1000000000000000000; // Set to a non-zero value
    }

    function capReached() public view returns (bool) {
        return totalSupply >= cap;
    }
}"
39,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    function createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) public payable onlyOwner {
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        // Implementation of the function
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Dividend {
        uint256 checkpoint;
        mapping (address => bool) excluded;
    }

    Dividend[] public dividends;

    function createDividend(uint256 _checkpoint, address[] memory _excluded) public onlyOwner {
        Dividend memory newDividend = Dividend({checkpoint: _checkpoint});
        for (uint256 i = 0; i < _excluded.length; i++) {
            newDividend.excluded[_excluded[i]] = true;
        }
        dividends.push(newDividend);
    }
}",12.200053930282593,createDividend,"[{'function': 'createDividend', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_checkpoint"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excluded"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Dividend""}, ""name"": ""newDividend"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Dividend""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_checkpoint""}], ""names"": [""checkpoint""]}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newDividend""}, ""memberName"": ""excluded""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newDividend""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.8356138723876062,0.0952259789223225,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Dividend {
        uint256 checkpoint;
        mapping (address => bool) excluded;
    }

    Dividend[] public dividends;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            dividends.push(Dividend({checkpoint: 1}));
        }
    }

    function createDividend(uint256 _checkpoint, address[] memory _excluded) public onlyOwner {
        Dividend memory newDividend = Dividend({checkpoint: _checkpoint});
        for (uint256 i = 0; i < _excluded.length; i++) {
            newDividend.excluded[_excluded[i]] = true;
        }
        dividends.push(newDividend);
    }
}"
2566,Prevents the seller from cancelling an escrow .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EscrowContract {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        uint256 sellerCanCancelAfter;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
    }

    mapping(bytes32 => Escrow) public escrows;
    bytes32[] public tradeHashes;
    address public relayer;
    uint256 public constant GAS_doDisableSellerCancel = 50000;

    event SellerCancelDisabled(bytes32 indexed tradeHash);

    function doDisableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
        if (!_escrow.exists) return false;
        if (_escrow.sellerCanCancelAfter == 0) return false;
        escrows[_tradeHash].sellerCanCancelAfter = 0;
        emit SellerCancelDisabled(_tradeHash);
        if (msg.sender == relayer) {
            increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
        }
        return true;
    }

    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) public pure returns (Escrow memory, bytes32) {
        Escrow memory escrow = Escrow({
            exists: true,
            sellerCanCancelAfter: block.timestamp + 1 days, // Example value for demonstration
            seller: _seller,
            buyer: _buyer,
            value: _value,
            fee: _fee
        });

        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
        return (escrow, tradeHash);
    }

    function increaseGasSpent(bytes32 _tradeHash, uint256 _gasAmount) public {
        // Implementation of increasing gas spent
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract EscrowContract is Ownable, ReentrancyGuard {
    enum EscrowStatus { NotInitialized, Initialized, Approved, Rejected }
    struct Escrow {
        address payable buyer;
        address payable seller;
        uint256 amount;
        EscrowStatus status;
    }

    mapping(uint256 => Escrow) public escrows; // Each escrow identified by unique escrowId

    modifier onlyBuyer(uint256 _escrowId) {
        require(msg.sender == escrows[_escrowId].buyer, ""Not the buyer"");
        _;
    }

    function cancelEscrow(uint256 _escrowId) external onlyBuyer(_escrowId) nonReentrant {
        require(escrows[_escrowId].status == EscrowStatus.Initialized, ""Escrow not in correct state for cancellation"");
        escrows[_escrowId].status = EscrowStatus.Rejected;

        // Transfer funds back to buyer
        escrows[_escrowId].buyer.transfer(escrows[_escrowId].amount);
    }
}",12.3812358379364,cancelEscrow,"[{'function': 'cancelEscrow', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelEscrow"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_escrowId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_escrowId""}}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""EscrowStatus""}, ""memberName"": ""Initialized""}}, {""type"": ""stringLiteral"", ""value"": ""Escrow not in correct state for cancellation""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_escrowId""}}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""EscrowStatus""}, ""memberName"": ""Rejected""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_escrowId""}}, ""memberName"": ""buyer""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_escrowId""}}, ""memberName"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyBuyer"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_escrowId""}]}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.6247819931566668,0.011063911424466,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EscrowContract is Ownable, ReentrancyGuard {
    enum EscrowStatus { NotInitialized, Initialized, Approved, Rejected }
    struct Escrow {
        address payable buyer;
        address payable seller;
        uint256 amount;
        EscrowStatus status;
    }

    mapping(uint256 => Escrow) public escrows; // Each escrow identified by unique escrowId

    modifier onlyBuyer(uint256 _escrowId) {
        require(msg.sender == escrows[_escrowId].buyer, ""Not the buyer"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 fixedAmount = 1;
        address payable fixedBuyer = payable(address(0x111));
        address payable fixedSeller = payable(address(0x222));
        bytes32 initBytes = bytes32('init');

        escrows[0] = Escrow({buyer: fixedBuyer, seller: fixedSeller, amount: fixedAmount, status: EscrowStatus.NotInitialized});
    }

    function cancelEscrow(uint256 _escrowId) external onlyBuyer(_escrowId) nonReentrant {
        require(escrows[_escrowId].status == EscrowStatus.Initialized, ""Escrow not in correct state for cancellation"");
        escrows[_escrowId].status = EscrowStatus.Rejected;

        // Transfer funds back to buyer
        escrows[_escrowId].buyer.transfer(escrows[_escrowId].amount);
    }
}"
4877,"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Clawback is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 10 ether; // Example value, adjust as needed
    uint256 public constant OWNER_CLAWBACK_DATE = 1700889600; // Example value, adjust as needed
    uint256 public totalFunding;

    function ownerClawback() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        payable(owner()).transfer(address(this).balance);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ClawbackEthersContract is Ownable {

    uint256 public releaseTime;

    constructor(uint256 _releaseTime) {
        require(_releaseTime > block.timestamp, ""Release time must be in future"");
        releaseTime = _releaseTime;
    }

    function clawBack() public onlyOwner {
        require(block.timestamp > releaseTime, ""Cannot transfer before release time"");
        payable(owner()).transfer(address(this).balance);
    }
}",5.09448504447937,clawBack,"[{'function': 'clawBack', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""clawBack"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot transfer before release time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8597977607828834,0.5759871796486856,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ClawbackEthersContract is Ownable {
    uint256 public releaseTime;

    constructor(uint256 _releaseTime) {
        require(_releaseTime > block.timestamp, ""Release time must be in future"");
        Ownable(); // Initialize Ownable with the default owner (msg.sender)
        releaseTime = _releaseTime;
    }

    function clawBack() public onlyOwner {
        require(block.timestamp > releaseTime, ""Cannot transfer before release time"");
        payable(owner()).transfer(address(this).balance);
    }
}"
4681,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public absoluteMinTimeLock;

    constructor(uint _absoluteMinTimeLock) {
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimelock(uint _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""Time lock must be at least the absolute minimum time lock."");
        timeLock = _newTimeLock;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TimeLock is Ownable {
    using SafeMath for uint256;

    uint256 public timeLock;
    uint256 public constant absoluteMinTimeLock = 1 days;

    function changeTimeLock(uint256 _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timeLock cannot be lower than absoluteMinTimeLock"");
        timeLock = _newTimeLock;
    }
}",6.129642009735107,changeTimeLock,"[{'function': 'changeTimeLock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeTimeLock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""New timeLock cannot be lower than absoluteMinTimeLock""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.850012397365988,0.4712088799651615,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TimeLock is Ownable {
    using SafeMath for uint256;

    uint256 public timeLock;
    uint256 public constant absoluteMinTimeLock = 1 days;

    constructor() Ownable(msg.sender) {
        timeLock = 1; // Set to 1 (never 0)
    }

    function changeTimeLock(uint256 _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timeLock cannot be lower than absoluteMinTimeLock"");
        timeLock = _newTimeLock;
    }
}"
5481,Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedTransferAndCall is Ownable {
    using SafeMath for uint256;

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        return _to.call{value: _value}(_data);
    }
}","contract YourContract {
    using SafeMath for uint256;
    mapping(address => uint256) public balances;

    function transferAndCall(address _to, uint256 _amount) public returns (bool) {
        require(_to != address(0), ""Receiver address cannot be 0"");
        require(balances[msg.sender] >= _amount, ""Insufficient Balance"");

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);

        if (Address.isContract(_to)) {
            require(ITransferReceiver(_to).onTransferReceived(msg.sender, _amount), ""Transfer acknowledgement check failed"");
        }

        return true;
    }
}

interface ITransferReceiver {
    function onTransferReceived(address _from, uint256 _amount) external returns (bool);
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""Subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""Addition overflow"");
        return c;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}",12.2741060256958,transferAndCall,"[{'function': 'transferAndCall', 'complexity': 4}, {'function': 'onTransferReceived', 'complexity': 0}, {'function': 'sub', 'complexity': 1}, {'function': 'add', 'complexity': 1}, {'function': 'isContract', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Receiver address cannot be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient Balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Address""}, ""memberName"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ITransferReceiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""memberName"": ""onTransferReceived""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer acknowledgement check failed""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",59.0,0.7512748262871997,0.1518586932068999,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract YourContract is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Use the fixed address of owner
    }

    function transferAndCall(address _to, uint256 _amount) public returns (bool) {
        require(_to != address(0), ""Receiver address cannot be 0"");
        require(balances[msg.sender] >= _amount, ""Insufficient Balance"");

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);

        if (Address.isContract(_to)) {
            require(ITransferReceiver(_to).onTransferReceived(msg.sender, _amount), ""Transfer acknowledgement check failed"");
        }

        return true;
    }
}

interface ITransferReceiver {
    function onTransferReceived(address _from, uint256 _amount) external returns (bool);
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""Subtraction overflow"");
        uint256 c = a - b;
        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""Addition overflow"");
        return c;
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor(address initialOwner) {
        require(initialOwner != address(0), ""Ownable: initial owner is the zero address"");
        _transferOwnership(initialOwner);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}"
1824,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Value must be greater than zero"");
        require(msg.sender == _from, ""Sender must match the caller"");
        require(_value <= balanceOf[_from], ""Insufficient balance"");

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/utils/Context.sol"";

contract MyToken is Context, ERC20Burnable, Ownable, Pausable {
    using SafeERC20 for IERC20;

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        uint256 currentAllowance = allowance(_from, _msgSender());
        require(currentAllowance >= _value, ""ERC20: transfer amount exceeds allowance"");
        _approve(_from, _msgSender(), currentAllowance - _value);
        _transfer(_from, _to, _value);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal virtual override whenNotPaused {
        super._transfer(from, to, amount);
    }

}",8.631574153900146,transferFrom,"[{'function': 'transferFrom', 'complexity': 1}, {'function': '_transfer', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.820981471426718,0.2348366738137833,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Context.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Context, ERC20Burnable, Ownable, Pausable {
    using SafeERC20 for IERC20;

    constructor() Ownable(msg.sender) {
        _mint(address(this), 1 ether); // Initialize total supply to 1 token
        _transfer(address(this), msg.sender, 1 ether); // Transfer the minted tokens to the owner
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        uint256 currentAllowance = allowance(_from, _msgSender());
        require(currentAllowance >= _value, ""ERC20: transfer amount exceeds allowance"");
        _approve(_from, _msgSender(), currentAllowance - _value);
        _transfer(_from, _to, _value);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal virtual override whenNotPaused {
        super._transfer(from, to, amount);
    }
}"
1782,Gets the EscrowDeposit based on the input id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow {
    using SafeMath for uint256;

    struct EscrowDeposit {
        address bidder;
        bytes data;
        uint256 amount;
        bool exists;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) external view returns (address, bytes memory, uint256) {
        require(escrows[_id].exists, ""Escrow does not exist"");
        EscrowDeposit storage escrow = escrows[_id];
        return (escrow.bidder, escrow.data, escrow.amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

contract EscrowContract is ReentrancyGuard {

    using EnumerableSet for EnumerableSet.UintSet;

    struct EscrowDeposit {
        uint256 id;
        address sender;
        address recipient;
        uint256 amount;
        bool released;
    }

    mapping(uint256 => EscrowDeposit) private _escrowDeposits;
    EnumerableSet.UintSet private _depositIds;

    function getEscrowDeposit(uint256 depositId) public view returns (address, address, uint256, bool) {
        require(_depositIds.contains(depositId), ""Deposit does not exist."");

        EscrowDeposit storage deposit = _escrowDeposits[depositId];
        return (deposit.sender, deposit.recipient, deposit.amount, deposit.released);
    }
}",7.999408960342407,getEscrowDeposit,"[{'function': 'getEscrowDeposit', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getEscrowDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""depositId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_depositIds""}, ""memberName"": ""contains""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""depositId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Deposit does not exist.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""EscrowDeposit""}, ""name"": ""deposit"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_escrowDeposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""depositId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposit""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposit""}, ""memberName"": ""recipient""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposit""}, ""memberName"": ""amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposit""}, ""memberName"": ""released""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",7.0,0.8159657092640792,0.2451291263966274,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EscrowContract is ReentrancyGuard, Ownable {

    using EnumerableSet for EnumerableSet.UintSet;

    struct EscrowDeposit {
        uint256 id;
        address sender;
        address recipient;
        uint256 amount;
        bool released;
    }

    mapping(uint256 => EscrowDeposit) private _escrowDeposits;
    EnumerableSet.UintSet private _depositIds;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _escrowDeposits[i] = EscrowDeposit({
                id: i,
                sender: addr,
                recipient: addr,
                amount: 1 ether, // Set to a fixed value that is not zero or corner case
                released: false
            });
        }
        _depositIds.add(1);
        _depositIds.add(2);
        _depositIds.add(3);
    }

    function getEscrowDeposit(uint256 depositId) public view returns (address, address, uint256, bool) {
        require(_depositIds.contains(depositId), ""Deposit does not exist."");

        EscrowDeposit storage deposit = _escrowDeposits[depositId];
        return (deposit.sender, deposit.recipient, deposit.amount, deposit.released);
    }
}"
3204,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balances(address account) external view returns (uint256);
    function totalBhinneka() external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalBhinneka;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalBhinneka = totalBhinneka.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenBurner is Ownable, ReentrancyGuard {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function burn(uint256 _value) external onlyOwner nonReentrant {
        require(_value <= token.balanceOf(address(this)), ""Not enough tokens in contract"");

        token.burn(_value);
    }
}",10.291427850723268,burn,"[{'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",32.0,0.7417475347293748,0.2081151191402463,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenBurner is Ownable, ReentrancyGuard {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function burn(uint256 _value) external onlyOwner nonReentrant {
        require(_value <= token.balanceOf(address(this)), ""Not enough tokens in contract"");

        token.burn(_value);
    }
}"
1281,Function for attester to submit attestation from their own account ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttestationContract is Ownable {
    using SafeMath for uint256;

    function attest(address _subject, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) external {
        require(_subject != address(0), ""Invalid subject address"");
        require(_requester != address(0), ""Invalid requester address"");
        require(_reward > 0, ""Reward must be greater than zero"");
        require(_requestNonce != bytes32(0), ""Request nonce cannot be empty"");

        // Assuming attestForUser is defined elsewhere in the contract or imported library
        attestForUser(_subject, msg.sender, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
    }

    function attestForUser(address _subject, address _attester, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) internal {
        // Implementation of the actual attestation logic
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Attestation is Ownable {
    using SafeMath for uint256;

    struct AttestationData {
        address attester;
        string data;
    }

    mapping (address => AttestationData[]) public attestations;

    function submitAttestation(string memory _data) public {
        address attester = msg.sender;

        AttestationData memory newAttestation = AttestationData({
            attester: attester,
            data: _data
        });

        attestations[attester].push(newAttestation);
    }
}",8.813081979751587,submitAttestation,"[{'function': 'submitAttestation', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAttestation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""attester"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""AttestationData""}, ""name"": ""newAttestation"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AttestationData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""attester""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": [""attester"", ""data""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attestations""}, ""index"": {""type"": ""Identifier"", ""name"": ""attester""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newAttestation""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.6103017684286923,0.0043299806747204,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Attestation is Ownable {
    using SafeMath for uint256;

    struct AttestationData {
        address attester;
        string data;
    }

    mapping (address => AttestationData[]) public attestations;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables can be skipped as they are already set in the constructor or initialized properly by default.
    }

    function submitAttestation(string memory _data) public {
        address attester = msg.sender;

        AttestationData memory newAttestation = AttestationData({
            attester: attester,
            data: _data
        });

        attestations[attester].push(newAttestation);
    }
}"
4148,"Escrows the ERC721 Token , assigning ownership to this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow is Ownable {
    using SafeMath for uint256;

    address public nonFungibleContract;

    constructor(address _nonFungibleContract) {
        nonFungibleContract = _nonFungibleContract;
    }

    function escrow(address _owner, uint256 _tokenId) external onlyOwner {
        require(_owner != address(0), ""Invalid owner address"");
        (bool success, ) = nonFungibleContract.call(abi.encodeWithSelector(bytes4(keccak256(""safeTransferFrom(address,address,uint256)"")), _owner, address(this), _tokenId));
        require(success, ""Safe transfer failed"");
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenEscrow is Ownable, ReentrancyGuard {
    IERC721 public token;

    constructor(address _token) {
        token = IERC721(_token);
    }

    function escrowToken(uint256 tokenId) public nonReentrant {
        require(token.ownerOf(tokenId) == msg.sender, ""Only token owner can escrow"");
        token.safeTransferFrom(msg.sender, address(this), tokenId);
    }
}",7.259598731994629,escrowToken,"[{'function': 'escrowToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""escrowToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only token owner can escrow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",21.0,0.7757836026466732,0.0875292169850377,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenEscrow is Ownable, ReentrancyGuard {
    IERC721 public token;

    constructor(address _token) Ownable(msg.sender) {
        token = IERC721(_token);
    }

    function escrowToken(uint256 tokenId) public nonReentrant {
        require(token.ownerOf(tokenId) == msg.sender, ""Only token owner can escrow"");
        token.safeTransferFrom(msg.sender, address(this), tokenId);
    }
}"
6515,"Computes the id for a node in a given Grove index which is sha3 ( indexId , id )","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GroveLibWrapper is Ownable {
    using SafeMath for uint256;

    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return GroveLib.computeNodeId(indexId, id);
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Grove {
    function computeNodeId(uint256 indexId, uint256 id) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(indexId, id));
    }
}",3.3207671642303467,computeNodeId,"[{'function': 'computeNodeId', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeNodeId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""indexId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""indexId""}, {""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",2.0,0.8485433265008376,0.5541297586590125,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Grove is Ownable {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        indexId = 1;
        id = 1;
        nodeId = bytes32('init');
    }

    uint256 private indexId;
    uint256 private id;
    bytes32 private nodeId;

    function computeNodeId(uint256 indexId, uint256 id) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(indexId, id));
    }
}"
211,Uses the same signature as initializeTokenSale ( ) with :,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    bool public buyModeEth;
    address public payableTokenAddress;

    function initializeSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) internal {
        // Sale initialization logic here
    }

    function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public onlyOwner {
        buyModeEth = false;
        payableTokenAddress = _tokenAddress;
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public tokenPrice;
    address public admin;

    function initializeTokenSale(uint256 _tokenPrice, address _admin) public onlyOwner nonReentrant {
        require(_tokenPrice > 0, ""Token price must be greater than zero"");
        require(_admin != address(0), ""Admin address can not be zero address"");

        tokenPrice = _tokenPrice;
        admin = _admin;
    }
}",13.172461748123167,initializeTokenSale,"[{'function': 'initializeTokenSale', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeTokenSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_admin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_admin""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Admin address can not be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""admin""}, ""right"": {""type"": ""Identifier"", ""name"": ""_admin""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.7444793285453241,0.0313633453174403,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public tokenPrice;
    address public admin;

    constructor(uint256 _tokenPrice, address _admin) Ownable() ReentrancyGuard() {
        require(_tokenPrice > 0, ""Token price must be greater than zero"");
        require(_admin != address(0), ""Admin address can not be zero address"");

        tokenPrice = _tokenPrice;
        admin = _admin;
    }
}"
5005,If this function is called again it overwrites the current allowance with _value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => bool) public frozenAccount;
    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address _spender, uint256 _value) external returns (bool success) {
        require(!frozenAccount[msg.sender]);
        assert(_spender != address(0));
        require(_value >= 0);
        allowed[msg.sender][_spender] = _value;
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract Allowance is ReentrancyGuard {
    mapping(address => mapping(address => uint256)) private _allowances;

    function setAllowance(address _owner, address _spender, uint256 _value) public nonReentrant {
        _allowances[_owner][_spender] = _value;
        emit AllowanceChanged(_owner, _spender, _allowances[_owner][_spender]);
    }

    event AllowanceChanged(address indexed _owner, address indexed _spender, uint256 _value);
}",7.762265205383301,setAllowance,"[{'function': 'setAllowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AllowanceChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.5751684816188916,0.1379023529673247,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Allowance is ReentrancyGuard, Ownable {
    mapping(address => mapping(address => uint256)) private _allowances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _allowances[addr][address(this)] = 1;
        }
    }

    function setAllowance(address _owner, address _spender, uint256 _value) public nonReentrant {
        require(_value > 0, ""Allowance value must be greater than zero"");
        _allowances[_owner][_spender] = _value;
        emit AllowanceChanged(_owner, _spender, _allowances[_owner][_spender]);
    }

    event AllowanceChanged(address indexed _owner, address indexed _spender, uint256 _value);
}"
2436,Function for transfering tokens from one account to another .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes16 => uint256) public balances;
    address[] private allowedAddresses;
    bool public paused = false;

    modifier onlyAllowedAddresses() {
        require(_isAllowedAddress(msg.sender), ""Only allowed addresses can call this function"");
        _;
    }

    modifier onlyRegisteredAccount(bytes16 _account) {
        require(_isRegisteredAccount(_account), ""The account must be registered"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transferTokensToAccount(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowedAddresses onlyRegisteredAccount(_from) whenNotPaused {
        registerAccount(_to);
        balances[_from] = balances[_from].sub(_tokensCount);
        balances[_to] = balances[_to].add(_tokensCount);
    }

    function registerAccount(bytes16 _account) internal {
        // Implementation of the registerAccount function
    }

    function _isAllowedAddress(address _addr) internal view returns (bool) {
        for (uint i = 0; i < allowedAddresses.length; i++) {
            if (allowedAddresses[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    function _isRegisteredAccount(bytes16 _account) internal view returns (bool) {
        // Implementation of the check for registered account
        return balances[_account] > 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract TokenTransfer {
    using SafeERC20 for ERC20;

    function transferTokens(ERC20 token, address from, address to, uint256 amount) public {
        require(msg.sender == from, ""Only token owner can initiate the transfer"");
        require(token.balanceOf(from) >= amount, ""Insufficient balance"");

        token.safeTransferFrom(from, to, amount);
    }
}",9.910880088806152,transferTokens,"[{'function': 'transferTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""from""}}, {""type"": ""stringLiteral"", ""value"": ""Only token owner can initiate the transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.2592237491304633,0.0063128711102715,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    using SafeERC20 for ERC20;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(ERC20 token, address from, address to, uint256 amount) public {
        require(msg.sender == from, ""Only token owner can initiate the transfer"");
        require(token.balanceOf(from) >= amount, ""Insufficient balance"");

        token.safeTransferFrom(from, to, amount);
    }
}"
2602,` onlyOwner ` An efficient way to confirm multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _idPayment) internal virtual {
        // Implementation of the payment confirmation logic
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Payments is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    function confirmPayments(address[] memory _recipients, uint256[] memory _amounts) public onlyOwner {
        require(_recipients.length == _amounts.length, ""Recipients and amounts array should have the same length"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            address recipient = _recipients[i];
            uint256 amount = _amounts[i];

            require(balances[msg.sender] >= amount, ""Not enough balance to confirm this payment"");
            balances[msg.sender] = balances[msg.sender].sub(amount);
            balances[recipient] = balances[recipient].add(amount);
        }
    }
}",15.019442319869995,confirmPayments,"[{'function': 'confirmPayments', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""confirmPayments"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Recipients and amounts array should have the same length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough balance to confirm this payment""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.7438677115472899,0.1251691995978421,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Payments is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance to 1 (never 0)
    }

    function confirmPayments(address[] memory _recipients, uint256[] memory _amounts) public onlyOwner {
        require(_recipients.length == _amounts.length, ""Recipients and amounts array should have the same length"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            address recipient = _recipients[i];
            uint256 amount = _amounts[i];

            require(balances[msg.sender] >= amount, ""Not enough balance to confirm this payment"");
            balances[msg.sender] = balances[msg.sender].sub(amount);
            balances[recipient] = balances[recipient].add(amount);
        }
    }
}"
1905,Function used by the client to block the transfer of shares from and to a share holder,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function blockTransfer(address _shareHolder, uint _deadLine) external onlyOwner {
        // Implementation of the blockTransfer function
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract SampleContract is Ownable {
    using SafeMath for uint256;

    mapping (address => bool) private blockedAccounts;

    event ShareTransferBlocked(address indexed account);

    function blockShareTransfer(address _account) public onlyOwner {
        require(_account != address(0), ""Invalid address"");
        require(!blockedAccounts[_account], ""Account is already blocked"");
        blockedAccounts[_account] = true;
        emit ShareTransferBlocked(_account);
    }

    function transferShares(address _to, uint256 _amount) public {
        require(_to != address(0), ""Target address cannot be zero"");
        require(!blockedAccounts[msg.sender], ""Transfer from sender is blocked"");
        require(!blockedAccounts[_to], ""Transfer to target is blocked"");

        // Logic to transfer shares goes here.
    }
}",11.041602849960327,transferShares,"[{'function': 'blockShareTransfer', 'complexity': 3}, {'function': 'transferShares', 'complexity': 5}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""blockShareTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""blockedAccounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_account""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Account is already blocked""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""blockedAccounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_account""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ShareTransferBlocked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_account""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.5565468261348516,0.0095844603204187,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SampleContract is Ownable {
    using SafeMath for uint256;

    mapping (address => bool) private blockedAccounts;
    address public constant DEFAULT_BLOCKED_ACCOUNT = 0x1111111111111111111111111111111111111111;
    address public constant DEFAULT_OWNER_ADDRESS = 0x2222222222222222222222222222222222222222;
    bytes32 public constant DEFAULT_INIT_BYTES32 = bytes32('init');
    bool public constant DEFAULT_BLOCKED_ACCOUNTS = true;

    event ShareTransferBlocked(address indexed account);

    constructor() Ownable(DEFAULT_OWNER_ADDRESS) {
        blockedAccounts[DEFAULT_BLOCKED_ACCOUNT] = DEFAULT_BLOCKED_ACCOUNTS;
    }

    function blockShareTransfer(address _account) public onlyOwner {
        require(_account != address(0), ""Invalid address"");
        require(!blockedAccounts[_account], ""Account is already blocked"");
        blockedAccounts[_account] = true;
        emit ShareTransferBlocked(_account);
    }

    function transferShares(address _to, uint256 _amount) public {
        require(_to != address(0), ""Target address cannot be zero"");
        require(!blockedAccounts[msg.sender], ""Transfer from sender is blocked"");
        require(!blockedAccounts[_to], ""Transfer to target is blocked"");

        // Logic to transfer shares goes here.
    }
}"
6047,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(checkVestingCondition(msg.sender));
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function checkVestingCondition(address account) internal view returns (bool) {
        // Implement your vesting condition logic here
        return false;
    }

    function _transfer(address from, address to, uint256 value) internal virtual {
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balanceOf(from) >= value, ""ERC20: transfer amount exceeds balance"");

        // Subtract the amount from the sender's balance
        _balances[from] = _balances[from].sub(value);

        // Add the amount to the recipient's balance
        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);
    }

    mapping(address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract CustomToken is ERC20 {

    constructor(uint256 initialSupply) ERC20(""CustomToken"", ""CTK"") {
        _mint(msg.sender, initialSupply);
    }

    function transferTokens(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(balanceOf(msg.sender) >= _value, ""Insufficient balance"");

        _transfer(msg.sender, _to, _value);

        return true;
    }
}",8.436151027679443,transferTokens,"[{'function': 'transferTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.7590234141489439,0.1501088219105702,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CustomToken is ERC20, Ownable {
    mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply) ERC20(""CustomToken"", ""CTK"") Ownable() {
        _mint(msg.sender, initialSupply);
    }

    function transferTokens(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(balanceOf(msg.sender) >= _value, ""Insufficient balance"");

        _transfer(msg.sender, _to, _value);

        return true;
    }
}"
189,To be called by the account that holds Mio tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public lockedBalances;
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function addBalanceFor(address account, uint256 value) public onlyOwner {
        lockedBalances[account] = lockedBalances[account].add(value);
        require(token.safeTransferFrom(msg.sender, address(this), value), ""Token transfer failed"");
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MioTokenHolder is ReentrancyGuard, Ownable {
    IERC20 public mioToken;

    constructor(IERC20 _mioToken) {
        mioToken = _mioToken;
    }

    function callByMioHolder(uint256 amount) public nonReentrant onlyOwner {
        require(mioToken.balanceOf(msg.sender) >= amount, ""Insufficient Mio tokens"");

        mioToken.transferFrom(msg.sender, address(this), amount);
    }
}",8.97377896308899,callByMioHolder,"[{'function': 'callByMioHolder', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""callByMioHolder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""mioToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient Mio tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""mioToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.5375964949334934,0.2757399403954719,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MioTokenHolder is ReentrancyGuard, Ownable {
    IERC20 public mioToken;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _mioToken) Ownable(msg.sender) {
        mioToken = _mioToken;
    }

    function callByMioHolder(uint256 amount) public nonReentrant onlyOwner {
        require(mioToken.balanceOf(msg.sender) >= amount, ""Insufficient Mio tokens"");

        mioToken.transferFrom(msg.sender, address(this), amount);
    }
}"
3776,Ability to transfer where the sender pays the fees ( not ERC20 ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    function transferFeeIncurred(uint256 value) internal pure returns (uint256) {
        // Example logic for calculating the fee
        return value.div(100); // 1% fee
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal returns (bool) {
        require(balanceOf(sender) >= value.add(fee), ""Insufficient balance"");

        // Deduct the fee from the sender's balance
        _balances[sender] = _balances[sender].sub(value).sub(fee);

        // Add the fee to the contract balance (or any other logic)
        _balances[address(this)] = _balances[address(this)].add(fee);

        // Transfer the value to the recipient
        _balances[to] = _balances[to].add(value);

        emit Transfer(sender, to, value);
        return true;
    }

    mapping (address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract FeePayingSender is Ownable, ReentrancyGuard {
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Received(address, uint256);

    function transfer(address to, uint256 amount, uint256 fee) public nonReentrant {
        require(balances[msg.sender] >= amount + fee, ""Insufficient balance"");
        require(to != address(0), ""Invalid to address"");

        balances[msg.sender] -= amount + fee;
        balances[to] += amount;
        balances[owner()] += fee;

        emit Transfer(msg.sender, to, amount);
    }

    receive() external payable {
        emit Received(msg.sender, msg.value);
        balances[msg.sender] += msg.value;
    }
}",9.8505859375,transfer,"[{'function': 'transfer', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid to address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.7614599603266993,0.1052158670318783,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FeePayingSender is Ownable, ReentrancyGuard {
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Received(address, uint256);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transfer(address to, uint256 amount, uint256 fee) public nonReentrant {
        require(balances[msg.sender] >= amount + fee, ""Insufficient balance"");
        require(to != address(0), ""Invalid to address"");

        balances[msg.sender] -= amount + fee;
        balances[to] += amount;
        balances[owner()] += fee;

        emit Transfer(msg.sender, to, amount);
    }

    receive() external payable {
        emit Received(msg.sender, msg.value);
        balances[msg.sender] += msg.value;
    }
}"
4464,"Returns the cost of the cosigner This cosigner does not have any risk or maintenance cost , so its free .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CostWrapper is Ownable {
    using SafeMath for uint256;

    function cost(address _address, uint256 _uint256, bytes memory _bytes1, bytes memory _bytes2) external view returns (uint256) {
        require(_address != address(0), ""Invalid address"");
        // The logic for calculating the cost is not provided in the snippet.
        return 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


contract Cosigner {

    function getCostOfCosigner() public pure returns (uint256) {
        return 0;
    }
}",3.068055868148804,getCostOfCosigner,"[{'function': 'getCostOfCosigner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCostOfCosigner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",17.0,0.5817555733062055,0.0237507215667879,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Cosigner is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getCostOfCosigner() public pure returns (uint256) {
        return 0;
    }
}"
1265,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CapReachedWrapper is Ownable {
    using SafeMath for uint256;

    bool public isFinalized;
    uint256 public finalAmountReturned;
    mapping(uint256 => uint256) public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    function capReached() public view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        }
        return mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length - 1];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CapCheck {
    using SafeMath for uint256;
    uint256 private _cap;
    uint256 private _raisedAmount;

    constructor (uint256 cap_) {
        require(cap_ > 0, ""Cap cannot be 0"");
        _cap = cap_;
    }

    function capReached() public view returns (bool) {
        return _raisedAmount >= _cap;
    }

    function raiseFunds(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than 0"");
        require(_raisedAmount.add(amount) <= _cap, ""Cap would be exceeded"");
        _raisedAmount = _raisedAmount.add(amount);
    }
}",8.05005693435669,raiseFunds,"[{'function': 'capReached', 'complexity': 0}, {'function': 'raiseFunds', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""raiseFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_raisedAmount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_cap""}}, {""type"": ""stringLiteral"", ""value"": ""Cap would be exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_raisedAmount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_raisedAmount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.5137944310713487,0.0129316596530426,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CapCheck is Ownable {
    using SafeMath for uint256;
    uint256 private _cap;
    uint256 private _raisedAmount;

    constructor(uint256 cap_) Ownable() {
        require(cap_ > 0, ""Cap cannot be 0"");
        _cap = cap_;
    }

    function capReached() public view returns (bool) {
        return _raisedAmount >= _cap;
    }

    function raiseFunds(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than 0"");
        require(_raisedAmount.add(amount) <= _cap, ""Cap would be exceeded"");
        _raisedAmount = _raisedAmount.add(amount);
    }
}"
4986,Returns the number of decimals the token uses .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    function decimals() public view returns (uint8 _decimals) {
        return 18; // Example implementation, adjust as needed
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    uint8 private _decimals;

    constructor(uint8 decimals_) {
        _decimals = decimals_;
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }
}",4.645512104034424,decimals,"[{'function': 'decimals', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""decimals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""_decimals""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.9335634840595668,0.3157605429948166,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    uint8 private _decimals;

    constructor(uint8 decimals_) {
        require(decimals_ > 0, ""Decimals must be greater than zero"");
        _decimals = decimals_;
        initializeOwner();
    }

    function initializeOwner() internal {
        Ownable.__Ownable_init();
        transferOwnership(msg.sender);
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }
}"
6318,Deploy a new TokenNetwork contract for the Token deployed at ` _token_address ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenNetworkFactory is Ownable {
    using SafeMath for uint256;

    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    mapping(address => address) public tokenToTokenNetworks;
    bool public tokenNetworkCreated;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    function createERC20TokenNetwork(address _token_address) external returns (address token_network_address) {
        require(tokenToTokenNetworks[_token_address] == address(0x0), ""Token network already created for this token"");
        tokenNetworkCreated = true;
        TokenNetwork token_network = new TokenNetwork(_token_address, secretRegistryAddress, chainId, settlementTimeoutMin, settlementTimeoutMax, deprecationExecutor);
        token_network_address = address(token_network);
        tokenToTokenNetworks[_token_address] = token_network_address;
        emit TokenNetworkCreated(_token_address, token_network_address);
        return token_network_address;
    }
}

abstract contract TokenNetwork {
    using SafeMath for uint256;

    address public tokenAddress;
    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    constructor(address _token_address, address _secret_registry_address, uint256 _chain_id, uint256 _settlement_timeout_min, uint256 _settlement_timeout_max, address _deprecation_executor) {
        tokenAddress = _token_address;
        secretRegistryAddress = _secret_registry_address;
        chainId = _chain_id;
        settlementTimeoutMin = _settlement_timeout_min;
        settlementTimeoutMax = _settlement_timeout_max;
        deprecationExecutor = _deprecation_executor;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./TokenNetwork.sol"";

contract TokenNetworkFactory is Ownable{

    function deployTokenNetwork(address _token_address)
        public
        onlyOwner
        returns (address)
    {
        require(_token_address != address(0), ""Invalid token address provided"");

        // Deploy a new TokenNetwork contract for the token at `_token_address`.
        TokenNetwork newTokenNetwork = new TokenNetwork(IERC20(_token_address));

        return address(newTokenNetwork);
    }
}",7.725154161453247,deployTokenNetwork,"[{'function': 'deployTokenNetwork', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""deployTokenNetwork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token address provided""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}, ""name"": ""newTokenNetwork"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}], ""names"": []}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newTokenNetwork""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.726601227601013,0.1540342040570958,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./TokenNetwork.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenNetworkFactory is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function deployTokenNetwork(address _token_address)
        public
        onlyOwner
        returns (address)
    {
        require(_token_address != address(0), ""Invalid token address provided"");

        // Deploy a new TokenNetwork contract for the token at `_token_address`.
        TokenNetwork newTokenNetwork = new TokenNetwork(IERC20(_token_address));

        return address(newTokenNetwork);
    }
}"
2003,Refund a given address for all the Ether they have contributed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public userFundedPool;

    modifier isAdmin() {
        require(owner() == msg.sender, ""Caller is not the admin"");
        _;
    }

    modifier isAdminRefundable(address _address) {
        require(_address != address(0), ""Invalid address"");
        _;
    }

    modifier userHasFundedPool(address _address) {
        require(userFundedPool[_address], ""User has not funded the pool"");
        _;
    }

    function refundAddress(address _address) public isAdmin isAdminRefundable(_address) userHasFundedPool(_address) {
        processRefundInternal(_address);
    }

    function processRefundInternal(address _address) internal {
        // Implementation of the refund logic
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract RefundContract is Ownable {
    mapping(address => uint256) private contributions;

    function contribute() external payable {
        contributions[msg.sender] += msg.value;
    }

    function refund(address payable contributor) external onlyOwner {
        uint256 contribution = contributions[contributor];
        require(contribution > 0, ""No contribution from the given address found to refund"");

        contributions[contributor] = 0;
        contributor.transfer(contribution);
    }
}",13.545846223831177,refund,"[{'function': 'contribute', 'complexity': 0}, {'function': 'refund', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""refund"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""contributor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""contribution"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""contribution""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No contribution from the given address found to refund""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""contributor""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contribution""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.709351686005426,0.0350228113814783,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RefundContract is Ownable {
    mapping(address => uint256) private contributions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function contribute() external payable {
        contributions[msg.sender] += msg.value;
    }

    function refund(address payable contributor) external onlyOwner {
        uint256 contribution = contributions[contributor];
        require(contribution > 0, ""No contribution from the given address found to refund"");

        contributions[contributor] = 0;
        contributor.transfer(contribution);
    }
}"
1814,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint securityGuardDelay;
        uint earliestPayTime;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        if (_delay > 10**18) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract PaymentDelay is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct Payment {
      IERC20 token;
      address payable to;
      uint256 amount;
      uint256 delayUntil;
    }

    uint256 public nextPaymentId;
    mapping (uint256 => Payment) public payments;

    modifier onlyAfterDelay(uint256 paymentId) {
        require(payments[paymentId].delayUntil <= block.timestamp, ""Payment delay not yet expired"");
        _;
    }

    function delayPayment(uint256 paymentId, uint256 delaySeconds) public onlyOwner nonReentrant {
        payments[paymentId].delayUntil = block.timestamp + delaySeconds;
    }

    function processDelayedPayment(uint256 paymentId) external nonReentrant onlyAfterDelay(paymentId) {
        Payment storage payment = payments[paymentId];
        payment.token.safeTransfer(payment.to, payment.amount);
    }
}",13.345619916915894,processDelayedPayment,"[{'function': 'delayPayment', 'complexity': 0}, {'function': 'processDelayedPayment', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""processDelayedPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""paymentId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""payment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""paymentId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""token""}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""to""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyAfterDelay"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""paymentId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",41.0,0.7370912884251863,0.0103618115050279,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentDelay is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct Payment {
        IERC20 token;
        address payable to;
        uint256 amount;
        uint256 delayUntil;
    }

    uint256 public nextPaymentId;
    mapping(uint256 => Payment) public payments;

    modifier onlyAfterDelay(uint256 paymentId) {
        require(payments[paymentId].delayUntil <= block.timestamp, ""Payment delay not yet expired"");
        _;
    }

    constructor() Ownable(msg.sender) {
        nextPaymentId = 1;
    }

    function delayPayment(uint256 paymentId, uint256 delaySeconds) public onlyOwner nonReentrant {
        payments[paymentId].delayUntil = block.timestamp + delaySeconds;
    }

    function processDelayedPayment(uint256 paymentId) external nonReentrant onlyAfterDelay(paymentId) {
        Payment storage payment = payments[paymentId];
        payment.token.safeTransfer(payment.to, payment.amount);
    }
}"
4481,This is a private function which should be called from user-implemented external burn function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract NFToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) private _tokenOwner;
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    modifier validNFToken(uint256 tokenId) {
        require(_exists(tokenId), ""NFToken: token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    function clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            delete _tokenApprovals[tokenId];
        }
    }

    function removeNFToken(address owner, uint256 tokenId) internal {
        require(_tokenOwner[tokenId] == owner, ""NFToken: token not owned by owner"");
        delete _tokenOwner[tokenId];
        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    using SafeMath for uint256;

    constructor (uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }

    function _burn(address account, uint256 amount) private {
        require(account != address(0), ""ERC20: burn from the zero address"");

        uint256 accountBalance = balanceOf(account);
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}",11.278909921646118,_burn,"[{'function': 'burn', 'complexity': 0}, {'function': '_burn', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""_burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: burn from the zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""accountBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""accountBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: burn amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_beforeTokenTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""stringLiteral"", ""value"": ""ERC20: burn amount exceeds balance""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""private"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.640839381104789,0.1338656483232774,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
        initializeOwner();
    }

    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }

    function _burn(address account, uint256 amount) private {
        require(account != address(0), ""ERC20: burn from the zero address"");

        uint256 accountBalance = balanceOf(account);
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);

        emit Transfer(account, address(0), amount);
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }

    function initializeOwner() internal {
        transferOwnership(msg.sender);
    }
}"
3728,"Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        require(_value <= balanceOf[msg.sender]);

        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract MyContract {
    using SafeERC20 for IERC20;

    mapping(address => mapping (address => uint256)) private _allowed;

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_spender != address(0), ""Invalid address"");
        _allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);
}",7.053402185440064,approve,"[{'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.9582113972126534,0.7143111045041365,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeERC20 for IERC20;

    mapping(address => mapping (address => uint256)) private _allowed;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_spender != address(0), ""Invalid address"");
        _allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);
}"
213,Get the price of a campaign Based on the Campaign id return the value paid for each proof of attention registered .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdvertisementWrapper {
    using SafeMath for uint256;

    struct CampaignPrice {
        bytes32 bidId;
        uint price;
    }

    mapping(bytes32 => uint) public campaignPrices;

    constructor(CampaignPrice[] memory initialCampaigns) {
        for (uint i = 0; i < initialCampaigns.length; i++) {
            campaignPrices[initialCampaigns[i].bidId] = initialCampaigns[i].price;
        }
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return campaignPrices[bidId];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract Campaign is ReentrancyGuard {
    struct CampaignDetails {
        uint256 campaignId;
        uint256 priceForEachProofOfAttention;
        uint256 totalAmountPaid;
    }

    mapping (uint256 => CampaignDetails) private campaigns;

    function getPrice(uint256 _campaignId)
        public
        view
        returns (uint256)
    {
        require(
            campaigns[_campaignId].campaignId > 0,
            ""Campaign does not exist""
        );

        return campaigns[_campaignId].priceForEachProofOfAttention;
    }
}",9.801902055740356,getPrice,"[{'function': 'getPrice', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_campaignId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""_campaignId""}}, ""memberName"": ""campaignId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Campaign does not exist""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""_campaignId""}}, ""memberName"": ""priceForEachProofOfAttention""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.8250655232854135,0.1609791748450962,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is ReentrancyGuard, Ownable {
    struct CampaignDetails {
        uint256 campaignId;
        uint256 priceForEachProofOfAttention;
        uint256 totalAmountPaid;
    }

    mapping(uint256 => CampaignDetails) private campaigns;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            campaigns[i] = CampaignDetails({
                campaignId: i,
                priceForEachProofOfAttention: 1,
                totalAmountPaid: 0
            });
        }
    }

    function getPrice(uint256 _campaignId) public view returns (uint256) {
        require(_campaignId > 0 && _campaignId <= 3, ""Campaign does not exist"");
        return campaigns[_campaignId].priceForEachProofOfAttention;
    }
}"
2236,Deposit fees into the vault for a Darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface CompatibleERC20 {
    function safeTransferFromWithFees(address from, address to, uint256 value) external returns (uint256);
}

abstract contract DarknodeDeposit is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(ERC20 => uint256)) public darknodeBalances;

    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {
        require(msg.sender == address(this));
        require(_token != address(0) || msg.value == _value);
        require(_token != address(0) && msg.value == 0);
        uint256 receivedValue = _value;
        if (_token != address(0)) {
            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);
        }
        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract DarknodeVault is ReentrancyGuard, Ownable {

    struct Darknode {
        uint256 balance;
    }

    mapping(address => Darknode) public darknodes;
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function depositFees(uint256 _amount) public nonReentrant {
        require(_amount > 0, ""Deposit amount must be greater than 0"");
        require(token.balanceOf(msg.sender) >= _amount, ""Insufficient balance"");

        uint256 initialBalance = token.balanceOf(address(this));
        token.transferFrom(msg.sender, address(this), _amount);

        uint256 finalBalance = token.balanceOf(address(this));
        require(finalBalance - initialBalance == _amount, ""Transfer of fees failed"");

        darknodes[msg.sender].balance += _amount;
    }
}",7.190342903137207,depositFees,"[{'function': 'depositFees', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""depositFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Deposit amount must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""initialBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""finalBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""finalBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""initialBalance""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Transfer of fees failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",53.0,0.7181574272142102,0.2419296274983318,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DarknodeVault is ReentrancyGuard, Ownable {

    struct Darknode {
        uint256 balance;
    }

    mapping(address => Darknode) public darknodes;
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
        darknodes[address(0)] = Darknode({balance: 1});
    }

    function depositFees(uint256 _amount) public nonReentrant {
        require(_amount > 0, ""Deposit amount must be greater than 0"");
        require(token.balanceOf(msg.sender) >= _amount, ""Insufficient balance"");

        uint256 initialBalance = token.balanceOf(address(this));
        token.transferFrom(msg.sender, address(this), _amount);

        uint256 finalBalance = token.balanceOf(address(this));
        require(finalBalance - initialBalance == _amount, ""Transfer of fees failed"");

        darknodes[msg.sender].balance += _amount;
    }
}"
3103,Checks whether redemption is permitted for a participant,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RedemptionPermitWrapper is Ownable {
    using SafeMath for uint256;

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public view returns (bool) {
        return true;
    }
}","// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract RedemptionPermission is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private _isRedemptionPermitted;

    function setRedemptionPermission(address participant, bool isPermitted) public onlyOwner {
        _isRedemptionPermitted[participant] = isPermitted;
    }

    function checkRedemptionPermission(address participant) public view returns (bool) {
        return _isRedemptionPermitted[participant];
    }
}",7.863708019256592,setRedemptionPermission,"[{'function': 'setRedemptionPermission', 'complexity': 0}, {'function': 'checkRedemptionPermission', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRedemptionPermission"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""participant"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isPermitted"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_isRedemptionPermitted""}, ""index"": {""type"": ""Identifier"", ""name"": ""participant""}}, ""right"": {""type"": ""Identifier"", ""name"": ""isPermitted""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.6945990143898595,0.0309661375190669,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RedemptionPermission is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private _isRedemptionPermitted;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setRedemptionPermission(address participant, bool isPermitted) public onlyOwner {
        _isRedemptionPermitted[participant] = isPermitted;
    }

    function checkRedemptionPermission(address participant) public view returns (bool) {
        return _isRedemptionPermitted[participant];
    }
}"
5733,Function which decodes bytes32 to array of integers,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DecodeAssetsWrapper {
    using SafeMath for uint256;

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory assets) {
        require(_potentialAssets.length > 0);

        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint numberOfAssets = 0;

        for (uint j = 0; j < _potentialAssets.length; j++) {
            uint input;
            bytes32 pot = _potentialAssets[j];
            assembly {
                input := pot
            }

            for (uint i = 10; i > 0; i--) {
                uint mask = (2 << ((i - 1) * 24)) / 2;
                uint b = (input & (mask * 16777215)) / mask;
                if (b != 0) {
                    assetsCopy[numberOfAssets] = b;
                    numberOfAssets++;
                }
            }
        }

        assets = new uint[](numberOfAssets);
        for (uint i = 0; i < numberOfAssets; i++) {
            assets[i] = assetsCopy[i];
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Bytes32ToIntegersConverter {

    function decodeBytes32ToArrayIntegers(bytes32 _bytesData) public pure returns (uint256[4] memory arrayIntegers) {
        require(_bytesData.length == 32, ""Invalid input length"");

        for (uint256 i = 0; i < 4; i++) {
            uint256 offset = i * 8;
            arrayIntegers[i] = uint256(bytes32(bytes2(_bytesData[offset])));
        }

        return arrayIntegers;
    }
}",5.620048999786377,decodeBytes32ToArrayIntegers,"[{'function': 'decodeBytes32ToArrayIntegers', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""decodeBytes32ToArrayIntegers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_bytesData"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}, ""name"": ""arrayIntegers"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_bytesData""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid input length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""offset"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""8"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""arrayIntegers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes2""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_bytesData""}, ""index"": {""type"": ""Identifier"", ""name"": ""offset""}}], ""names"": []}], ""names"": []}], ""names"": []}}}]}}, {""type"": ""Identifier"", ""name"": ""arrayIntegers""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",97.0,0.5812798231618029,0.061040240989503,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Bytes32ToIntegersConverter is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function decodeBytes32ToArrayIntegers(bytes32 _bytesData) public pure returns (uint256[4] memory arrayIntegers) {
        require(_bytesData.length == 32, ""Invalid input length"");

        for (uint256 i = 0; i < 4; i++) {
            uint256 offset = i * 8;
            arrayIntegers[i] = uint256(bytes32(bytes2(_bytesData[offset])));
        }

        return arrayIntegers;
    }
}"
5459,Begins the token sale for this token instance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    function initializeTokenSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) public onlyOwner {
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TokenSale is Ownable, ReentrancyGuard {
    ERC20 public token;
    uint256 public price;

    constructor(ERC20 _token, uint256 _price) {
        token = _token;
        price = _price;
    }

    function startSale(uint256 amount) public onlyOwner nonReentrant payable {
        uint256 scale = 1e18;
        require(msg.value >= price * amount / scale, ""Insufficient ether sent for tokens"");

        uint256 tokensToBuy = amount * scale;
        require(token.balanceOf(address(this)) >= tokensToBuy, ""Not enough tokens in contract"");

        token.transfer(msg.sender, tokensToBuy);
    }
}",15.61228895187378,startSale,"[{'function': 'startSale', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""startSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""scale"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, ""right"": {""type"": ""Identifier"", ""name"": ""scale""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ether sent for tokens""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensToBuy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""scale""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToBuy""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokensToBuy""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",38.0,0.6768194837600968,0.0288136391716006,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable, ReentrancyGuard {
    ERC20 public token;
    uint256 public price;

    mapping(address => uint256) public balanceOf;

 constructor(ERC20 _token, uint256 _price) Ownable(_token.owner()) {
        token = _token;
        price = _price;
    }

    function startSale(uint256 amount) public onlyOwner nonReentrant payable {
        uint256 scale = 1e18;
        require(msg.value >= price * amount / scale, ""Insufficient ether sent for tokens"");

        uint256 tokensToBuy = amount * scale;
        require(token.balanceOf(address(this)) >= tokensToBuy, ""Not enough tokens in contract"");

        token.transfer(msg.sender, tokensToBuy);
    }
}"
6434,Set current preICO price in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public preICOprice;

    constructor() Ownable() {}

    function setPreICOPrice(uint256 priceForPreIcoInWei) public isOwner {
        require(priceForPreIcoInWei > 0, ""The price for pre-ICO should be greater than zero"");
        require(preICOprice != priceForPreIcoInWei, ""The price for pre-ICO has not changed"");
        preICOprice = priceForPreIcoInWei;
        updatePrices();
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MetaDollarICO is Ownable {
    uint256 public preICOPrice;

    function setPreICOPrice(uint256 _newPriceInWei) external onlyOwner {
        require(_newPriceInWei > 0, ""MetaDollarICO: The price must be greater than 0"");
        preICOPrice = _newPriceInWei;
    }
}",4.097336769104004,setPreICOPrice,"[{'function': 'setPreICOPrice', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreICOPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newPriceInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_newPriceInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""MetaDollarICO: The price must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preICOPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newPriceInWei""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.865125664793541,0.1034826323083163,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MetaDollarICO is Ownable {
    uint256 public preICOPrice;

    constructor() Ownable(msg.sender) {
        preICOPrice = 1; // Set to a safe non-zero value for uint256
    }

    function setPreICOPrice(uint256 _newPriceInWei) external onlyOwner {
        require(_newPriceInWei > 0, ""MetaDollarICO: The price must be greater than 0"");
        preICOPrice = _newPriceInWei;
    }
}"
30,Called in order to get the number of members on the platform,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Define membersArray as a state variable
    address[] public membersArray;

    function getMembersArrayLength() public view returns (uint256) {
        return membersArray.length;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Platform {
    address[] private members;

    function addMember(address _newMember) public {
        members.push(_newMember);
    }

    function getNumberOfMembers() public view returns (uint256) {
        return members.length;
    }
}",3.405680894851685,addMember,"[{'function': 'addMember', 'complexity': 0}, {'function': 'getNumberOfMembers', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addMember"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newMember"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""members""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newMember""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.3729993214556356,0.0427180251358197,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Platform is Ownable {
    address[] private members;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 fixedUint = 1;
        bytes32 fixedBytes32 = bytes32('init');
        bool fixedBool = true;
        string memory fixedString = 'initialized';

        require(fixedUint == 1, ""Fixed uint should be 1"");
        require(keccak256(abi.encodePacked(fixedBytes32)) == keccak256(abi.encodePacked('init')), ""Fixed bytes32 should be 'init'"");
        require(fixedBool == true, ""Fixed bool should be true"");
        require(strcmp(fixedString, 'initialized') == 0, ""Fixed string should be 'initialized'"");
    }

    function addMember(address _newMember) public {
        members.push(_newMember);
    }

    function getNumberOfMembers() public view returns (uint256) {
        return members.length;
    }
}"
3380,Count the number of validators defined by the jurisdiction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorCounter {
    using SafeMath for uint256;

    address[] private _validatorAccounts;

    function countValidators() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract ValidatorSet is AccessControl {
    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");

    function countValidators() public view returns(uint256) {
        uint256 validatorCount = 0;
        for (uint256 i = 0; i < getRoleMemberCount(VALIDATOR_ROLE); i++) {
            if (hasRole(VALIDATOR_ROLE, getRoleMember(VALIDATOR_ROLE, i))) {
                validatorCount++;
            }
        }
        return validatorCount;
    }
}",8.778796911239624,countValidators,"[{'function': 'countValidators', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""countValidators"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""validatorCount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getRoleMemberCount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""VALIDATOR_ROLE""}], ""names"": []}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""VALIDATOR_ROLE""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getRoleMember""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""VALIDATOR_ROLE""}, {""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""validatorCount""}, ""isPrefix"": False}}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""validatorCount""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",26.0,0.8199397601291881,0.1372257830477419,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ValidatorSet is AccessControl, Ownable {
    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(VALIDATOR_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function countValidators() public view returns (uint256) {
        uint256 validatorCount = 0;
        for (uint256 i = 0; i < getRoleMemberCount(VALIDATOR_ROLE); i++) {
            if (hasRole(VALIDATOR_ROLE, getRoleMember(VALIDATOR_ROLE, i))) {
                validatorCount++;
            }
        }
        return validatorCount;
    }
}"
5188,allows to retreive multiple exchange rates in once call,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchangeRate {
    function getExchangeRate(address numeratorToken, address denominatorToken) external view returns (uint256);
    function getTimestamp() external view returns (uint256);
}

abstract contract ExchangeRates is Ownable {
    using SafeMath for uint256;

    IExchangeRate public exchangeRateContract;

    constructor(address _exchangeRateAddress) {
        exchangeRateContract = IExchangeRate(_exchangeRateAddress);
    }

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public view returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length > 0 && denominatorTokens.length > 0);
        require(numeratorTokens.length == denominatorTokens.length, ""Lengths must be equal"");

        rateFractions = new uint256[](numeratorTokens.length * denominatorTokens.length);
        timestamps = new uint256[](numeratorTokens.length * denominatorTokens.length);

        for (uint256 i = 0; i < numeratorTokens.length; i++) {
            address numeratorToken = numeratorTokens[i];
            for (uint256 j = 0; j < denominatorTokens.length; j++) {
                address denominatorToken = denominatorTokens[j];
                uint256 rateFraction = exchangeRateContract.getExchangeRate(numeratorToken, denominatorToken);
                uint256 timestamp = exchangeRateContract.getTimestamp();
                rateFractions[i * denominatorTokens.length + j] = rateFraction;
                timestamps[i * denominatorTokens.length + j] = timestamp;
            }
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ExchangeRates {
    using SafeMath for uint256;

    mapping (string => uint256) public rates;

    function setRate(string memory currency, uint256 newRate) public {
        rates[currency] = newRate;
    }

    function getMultipleRates(string[] memory currencies) public view returns (uint256[] memory) {
        uint256 length = currencies.length;
        uint256[] memory multipleRates = new uint256[](length);

        for (uint256 i = 0; i < length; i++) {
            multipleRates[i] = rates[currencies[i]];
        }

        return multipleRates;
    }
}",6.719151258468628,getMultipleRates,"[{'function': 'setRate', 'complexity': 0}, {'function': 'getMultipleRates', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMultipleRates"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""length"": None}, ""name"": ""currencies"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""length"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currencies""}, ""memberName"": ""length""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""multipleRates"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""multipleRates""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""currencies""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}}]}}, {""type"": ""Identifier"", ""name"": ""multipleRates""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",99.0,0.6000401122017307,0.0722963043154963,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ExchangeRates is Ownable {
    using SafeMath for uint256;

    mapping (string => uint256) public rates;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        rates[""USD""] = 1e18; // Example: Set to a fixed value for USD
        rates[""EUR""] = 1.2e18; // Example: Set to a fixed value for EUR
        // Add more currencies as needed
    }

    function setRate(string memory currency, uint256 newRate) public onlyOwner {
        require(newRate > 0, ""Rate must be greater than zero"");
        rates[currency] = newRate;
    }

    function getMultipleRates(string[] memory currencies) public view returns (uint256[] memory) {
        uint256 length = currencies.length;
        uint256[] memory multipleRates = new uint256[](length);

        for (uint256 i = 0; i < length; i++) {
            multipleRates[i] = rates[currencies[i]];
        }

        return multipleRates;
    }
}"
316,send ` _value ` token to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    address[] public tokenHolders;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        emit LogForkAnnounced(name, url, blockNumber);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract MyContract is ReentrancyGuard {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function sendToken(address _to, uint256 _value) public nonReentrant {
        require(_to != address(0), ""Invalid address"");
        uint256 balance = token.balanceOf(address(this));
        require(balance >= _value, ""Insufficient token balance"");

        token.transfer(_to, _value);
    }
}",6.575586795806885,sendToken,"[{'function': 'sendToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.6617656105618754,0.3919376740162305,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable, ReentrancyGuard {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) {
        initialize(_token);
    }

    function initialize(IERC20 _token) internal {
        token = _token;
    }

    function sendToken(address _to, uint256 _value) public nonReentrant {
        require(_to != address(0), ""Invalid address"");
        uint256 balance = token.balanceOf(address(this));
        require(balance >= _value, ""Insufficient token balance"");

        token.transfer(_to, _value);
    }
}"
4609,"Add beneficiaries to the contract , allowing them to withdraw tokens .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    struct Info {
        bool known;
        uint256 startTime;
        uint256 totalAmount;
        uint256 releaseTime;
    }

    mapping(address => Info) private _info;

    function addBeneficiary(address beneficiary, uint256 startTime, uint256 releaseTime, uint256 amount) external onlyOwner {
        require(_info[beneficiary].known == false, ""This address is already known to the contract."");
        require(releaseTime > startTime, ""Release time must be later than the start time."");
        require(releaseTime > block.timestamp, ""End of vesting period must be somewhere in the future."");

        Info storage info = _info[beneficiary];
        info.startTime = startTime;
        info.totalAmount = amount;
        info.releaseTime = releaseTime;
        info.known = true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AddBeneficiaries is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => uint256) public beneficiaries;

    constructor(IERC20 _token) {
        token = _token;
    }

    function addBeneficiary(address _beneficiary, uint256 _amount) public onlyOwner {
        require(_beneficiary != address(0), ""Beneficiary address cannot be 0"");
        require(_amount > 0, ""Amount must be greater than 0"");
        require(token.balanceOf(address(this)) >= _amount, ""Not enough tokens in contract"");

        beneficiaries[_beneficiary] = beneficiaries[_beneficiary].add(_amount);
        token.transfer(_beneficiary, _amount);
    }
}",16.011016845703125,addBeneficiary,"[{'function': 'addBeneficiary', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary address cannot be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",35.0,0.762343919459548,0.1312847458815122,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AddBeneficiaries is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => uint256) public beneficiaries;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable() {
        token = _token;
    }

    function addBeneficiary(address _beneficiary, uint256 _amount) public onlyOwner {
        require(_beneficiary != address(0), ""Beneficiary address cannot be 0"");
        require(_amount > 0, ""Amount must be greater than 0"");
        require(token.balanceOf(address(this)) >= _amount, ""Not enough tokens in contract"");

        beneficiaries[_beneficiary] = beneficiaries[_beneficiary].add(_amount);
        token.transfer(_beneficiary, _amount);
    }
}"
5346,You must send some ETH to cover the oraclize_query fees,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    enum Stage { ToInitialize, Waiting, Running, Ended }

    uint256 public startTime;
    uint256 public endTime;
    Token public token;
    uint256 public intervalUpdate;
    Stage public currentStage = Stage.ToInitialize;
    uint256 public constant MAX_TOKENS = 10**28; // Example value, adjust as needed

    constructor(address _token) {
        require(_token != address(0));
        token = Token(_token);
    }

    function initializeCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _intervalUpdate) public payable onlyOwner mustBeAtStage(Stage.ToInitialize) {
        require(_startTime >= block.timestamp);
        require(_endTime >= _startTime);
        require(_token != address(0));
        require(msg.value > 0);
        require(isContract(_token) == true);
        require(_intervalUpdate >= 5);

        startTime = _startTime;
        endTime = _endTime;
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;
        updateEthRateWithDelay(startTime - (intervalUpdate + 30));
        emit LogCrowdsaleInit();
        assert(token.balanceOf(address(this)) == MAX_TOKENS);
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    modifier mustBeAtStage(Stage requiredStage) {
        require(currentStage == requiredStage, ""Must be at the specified stage"");
        _;
    }

    function updateEthRateWithDelay(uint256 delayTime) internal {
        // Implementation of the delay logic
    }

    event LogCrowdsaleInit();
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FeeHandler is Ownable {
    using SafeMath for uint256;

    event Replenish(uint256 amount);

    function replenish() public payable onlyOwner {
        require(msg.value > 0, ""Insufficient amount to replenish"");
        emit Replenish(msg.value);
    }
}",4.718184947967529,replenish,"[{'function': 'replenish', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""replenish"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient amount to replenish""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Replenish""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",81.0,0.3808446748636167,0.0161294905145968,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract FeeHandler is Ownable {
    using SafeMath for uint256;

    event Replenish(uint256 amount);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function replenish() public payable onlyOwner {
        require(msg.value > 0, ""Insufficient amount to replenish"");
        emit Replenish(msg.value);
    }
}"
2424,Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeToken {
    function changeController(address _newController) external;
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    constructor() {}

    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public onlyOwner returns (MiniMeToken) {
        MiniMeToken newToken = MiniMeToken(_parentToken).cloneTokenWithDetails(_snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled);
        newToken.changeController(msg.sender);
        return newToken;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TokenFactory is Ownable {
    mapping(address => address) public tokenClones;

    function createCloneToken(string memory name, string memory symbol) public returns (address) {
        require(tokenClones[msg.sender] == address(0), ""Clone token already exists for the sender"");

        ERC20 newToken = new ERC20(name, symbol);
        tokenClones[msg.sender] = address(newToken);

        // Transfer the ownership of the newToken to the msg.sender
        Ownable(address(newToken)).transferOwnership(msg.sender);

        return address(newToken);
    }
}",7.230775833129883,createCloneToken,"[{'function': 'createCloneToken', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""symbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenClones""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Clone token already exists for the sender""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""newToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""symbol""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenClones""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newToken""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Ownable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newToken""}], ""names"": []}], ""names"": []}, ""memberName"": ""transferOwnership""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newToken""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",39.0,0.7104830465035806,0.1017534495187618,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenFactory is Ownable {
    mapping(address => address) public tokenClones;

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already initialized by the parent contract and inherited constructors
    }

    function createCloneToken(string memory name, string memory symbol) public returns (address) {
        require(tokenClones[msg.sender] == address(0), ""Clone token already exists for the sender"");

        ERC20 newToken = new ERC20(name, symbol);
        tokenClones[msg.sender] = address(newToken);

        // Transfer the ownership of the newToken to the msg.sender
        Ownable(address(newToken)).transferOwnership(msg.sender);

        return address(newToken);
    }
}"
474,Burns the coins held by the sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function burn(uint256 _value) public whenNotPaused {
        super.burn(_value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20(""TestToken"", ""TT"") {
        _mint(msg.sender, initialSupply);
    }

    function burn(uint256 amount) public {
        require(balanceOf(msg.sender) >= amount, ""Not enough tokens"");
        _burn(msg.sender, amount);
    }
}",5.152568817138672,burn,"[{'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.6760050952446357,0.1317213082746384,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply) ERC20(""TestToken"", ""TT"") {
        _mint(msg.sender, initialSupply);
        initializeOwner();
    }

    function burn(uint256 amount) public {
        require(balanceOf(msg.sender) >= amount, ""Not enough tokens"");
        _burn(msg.sender, amount);
    }

    function initializeOwner() internal {
        Ownable.__Ownable_init();
        transferOwnership(msg.sender);
    }
}"
1413,Overwrite leaderboard name and desctiption as owner only,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BoardManager is Ownable {
    using SafeMath for uint256;

    struct Board {
        bytes32 boardName;
        string boardDescription;
        address boardOwner;
    }

    mapping(bytes32 => Board) public boards;

    function changeBoardMetadata(bytes32 boardHash, bytes32 name, string memory boardDescription) public onlyOwner returns (bool) {
        require(boards[boardHash].boardOwner == msg.sender);
        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract LeaderBoard is Ownable {

    string public leaderboardName;
    string public leaderboardDescription;

    function setLeaderboardDetails(string memory _newName, string memory _newDescription) public onlyOwner {
        leaderboardName = _newName;
        leaderboardDescription = _newDescription;
    }
}",3.552309989929199,setLeaderboardDetails,"[{'function': 'setLeaderboardDetails', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setLeaderboardDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_newName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_newDescription"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""leaderboardName""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newName""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""leaderboardDescription""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newDescription""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.5222121130529952,0.0442627726486261,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LeaderBoard is Ownable {
    string public leaderboardName;
    string public leaderboardDescription;

    constructor(string memory _newName, string memory _newDescription) {
        leaderboardName = _newName;
        leaderboardDescription = _newDescription;
        __Ownable_init();
        Ownable.initialize(msg.sender);
    }

    function setLeaderboardDetails(string memory _newName, string memory _newDescription) public onlyOwner {
        leaderboardName = _newName;
        leaderboardDescription = _newDescription;
    }
}"
6348,"Helps to generate Collectibles/Tokens/Asset and transfer to ETH Cards , which can be redeemed using our web-app.The generation of an asset if limited via the generationSeasonController","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ETHCardCollectible is Ownable {
    using SafeMath for uint256;

    uint8 public teamId;
    uint8 public posId;
    uint256 public attributes;
    address public owner;
    uint256 public gameId;
    uint256 public playerOverrideId;
    uint256 public mlbPlayerId;
    uint256 public rewardsRedeemed;
    address public managerPrimary;
    bool public paused = false;

    constructor(address _managerPrimary) {
        managerPrimary = _managerPrimary;
    }

    function createETHCardCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external canCreate whenNotPaused returns (uint256) {
        address nftOwner = _owner;
        if (nftOwner == address(0)) {
            nftOwner = managerPrimary;
        }
        rewardsRedeemed++;
        uint32 _sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(uint64(now));
        assetDetails |= uint256(_sequenceId) << 64;
        assetDetails |= uint256(_teamId) << 96;
        assetDetails |= uint256(_posId) << 104;
        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];
        return _createNFTCollectible(_teamId, _attributes, nftOwner, 2, _nftData);
    }

    function getSequenceId(uint8 _teamId) internal pure returns (uint32) {
        // Implementation of getSequenceId logic
        return uint32(_teamId);
    }

    function _createNFTCollectible(uint8 _teamId, uint256 _attributes, address _owner, uint256 _type, uint256[5] memory _nftData) internal returns (uint256) {
        // Implementation of create NFT logic
        return 0;
    }

    modifier canCreate() {
        require(msg.sender == owner || msg.sender == managerPrimary, ""Not authorized to create collectible"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract CollectibleGeneration is ERC721, Ownable {
    using Address for address;
    using SafeERC20 for IERC20;

    uint256 public currentSeason;
    bool public generationSeasonActive;
    mapping(uint256 => bool) public seasonGenerationLimit;

    event SeasonStarted(uint256 indexed season);
    event SeasonEnded(uint256 indexed season);
    event CollectibleGenerated(uint256 indexed tokenId);

    constructor() ERC721(""CollectibleToken"", ""CT"") {}

    function startNewSeason() public onlyOwner {
        require(!generationSeasonActive, ""Generation season already active"");
        currentSeason += 1;
        generationSeasonActive = true;
        seasonGenerationLimit[currentSeason] = true;
        emit SeasonStarted(currentSeason);
    }

    function endCurrentSeason() public onlyOwner {
        require(generationSeasonActive, ""No active generation season"");
        generationSeasonActive = false;
        emit SeasonEnded(currentSeason);
    }

    function generateCollectibleToken(address to, uint256 tokenId) public onlyOwner {
        require(generationSeasonActive, ""Generation season not active"");
        require(seasonGenerationLimit[currentSeason], ""Generation limit reached for current season"");
        _mint(to, tokenId);
        emit CollectibleGenerated(tokenId);
    }
}",9.09023904800415,startNewSeason,"[{'function': 'startNewSeason', 'complexity': 2}, {'function': 'endCurrentSeason', 'complexity': 1}, {'function': 'generateCollectibleToken', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""startNewSeason"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""generationSeasonActive""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Generation season already active""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""currentSeason""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""generationSeasonActive""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""seasonGenerationLimit""}, ""index"": {""type"": ""Identifier"", ""name"": ""currentSeason""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SeasonStarted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentSeason""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",74.0,0.2806668000986434,0.0030654663180368,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CollectibleGeneration is ERC721, Ownable {
    using Address for address;
    using SafeERC20 for IERC20;

    uint256 public currentSeason = 1;
    bool public generationSeasonActive = false;
    mapping(uint256 => bool) public seasonGenerationLimit;

    event SeasonStarted(uint256 indexed season);
    event SeasonEnded(uint256 indexed season);
    event CollectibleGenerated(uint256 indexed tokenId);

    constructor() ERC721(""CollectibleToken"", ""CT"") Ownable(msg.sender) {}

    function startNewSeason() public onlyOwner {
        require(!generationSeasonActive, ""Generation season already active"");
        currentSeason += 1;
        generationSeasonActive = true;
        seasonGenerationLimit[currentSeason] = true;
        emit SeasonStarted(currentSeason);
    }

    function endCurrentSeason() public onlyOwner {
        require(generationSeasonActive, ""No active generation season"");
        generationSeasonActive = false;
        emit SeasonEnded(currentSeason);
    }

    function generateCollectibleToken(address to, uint256 tokenId) public onlyOwner {
        require(generationSeasonActive, ""Generation season not active"");
        require(seasonGenerationLimit[currentSeason], ""Generation limit reached for current season"");
        _mint(to, tokenId);
        emit CollectibleGenerated(tokenId);
    }
}"
6764,"This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address[]) public s_paid;
    uint256 public fee;

    modifier only_delegate() {
        require(hasRole(keccak256(""DELEGATE""), msg.sender), ""Only delegate can call this function"");
        _;
    }

    function revoke(address who, address origin) payable external only_delegate {
        require(msg.value == fee, ""Incorrect fee amount"");
        bool found = false;
        for (uint i = 0; i < s_paid[who].length; i++) {
            if (s_paid[who][i] != origin) {
                continue;
            }
            found = true;
            uint lastIndex = s_paid[who].length.sub(1);
            if (i != lastIndex) {
                s_paid[who][i] = s_paid[who][lastIndex];
            }
            s_paid[who].pop();
            break;
        }
        require(found, ""Origin not found"");
        origin.transfer(msg.value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract RefundContract is ReentrancyGuard, Ownable {
  mapping (address => uint256) private _fees;

  event Refunded(address indexed sender, address indexed recipient, uint256 amount);

  function refundFee(address origin, address who) public onlyOwner nonReentrant {
    require(_fees[who] > 0, ""No fee to refund for this address"");
    require(Address.isContract(who) == false, ""Can't issue refunds to contracts"");

    uint256 refundAmount = _fees[who];
    _fees[who] = 0;

    (bool success, ) = origin.call{value: refundAmount}("""");
    require(success, ""Refund failed"");

    emit Refunded(msg.sender, origin, refundAmount);
  }
}",11.139846801757812,refundFee,"[{'function': 'refundFee', 'complexity': 3}]",5.0,{},78.0,0.6481452635137357,0.0367734497297098,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RefundContract is ReentrancyGuard, Ownable {
  mapping (address => uint256) private _fees;

  event Refunded(address indexed sender, address indexed recipient, uint256 amount);

  uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

  function refundFee(address origin, address who) public onlyOwner nonReentrant {
    require(_fees[who] > 0, ""No fee to refund for this address"");
    require(Address.isContract(who) == false, ""Can't issue refunds to contracts"");

    uint256 refundAmount = _fees[who];
    _fees[who] = 0;

    (bool success, ) = origin.call{value: refundAmount}("""");
    require(success, ""Refund failed"");

    emit Refunded(msg.sender, origin, refundAmount);
  }
}"
5397,Transfers tokens held by timelock to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenRelease is Ownable {
    using SafeMath for uint;

    uint public releaseTime;
    uint public current_month;
    uint public month = 1 months;
    uint public twenty_percent_of_amount;
    address public beneficiary;
    IERC20 public token;

    constructor(uint _releaseTime, uint _twenty_percent_of_amount, address _beneficiary, address _token) {
        releaseTime = _releaseTime;
        current_month = 1;
        twenty_percent_of_amount = _twenty_percent_of_amount;
        beneficiary = _beneficiary;
        token = IERC20(_token);
    }

    function release() public {
        require(now >= releaseTime, ""Release time not yet reached"");
        assert(current_month <= 5);
        uint diff = now - releaseTime;
        if (diff > month) {
            releaseTime = now;
        } else {
            releaseTime = now.add(month.sub(diff));
        }
        current_month++;
        token.safeTransfer(beneficiary, twenty_percent_of_amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/reentrancyguard/ReentrancyGuard.sol"";

contract TimeLock is ReentrancyGuard {
    IERC20 public token;
    address public beneficiary;
    uint256 public releaseTime;

    constructor(IERC20 _token, address _beneficiary, uint256 _releaseTime) {
        require(_releaseTime > block.timestamp, ""Release time is before current time"");
        token = _token;
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    }

    function release() public nonReentrant {
        require(block.timestamp >= releaseTime, ""Current time is before release time"");
        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, ""No tokens to release"");
        token.transfer(beneficiary, amount);
    }
}",16.632044076919556,release,"[{'function': 'release', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""release"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}, {""type"": ""stringLiteral"", ""value"": ""Current time is before release time""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to release""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.8219945857543447,0.1444048512496984,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TimeLock is ReentrancyGuard, Ownable {
    IERC20 public token;
    address public beneficiary;
    uint256 public releaseTime;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token, address _beneficiary, uint256 _releaseTime) Ownable(msg.sender) {
        require(_releaseTime > block.timestamp, ""Release time is before current time"");
        token = _token;
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    }

    function release() public nonReentrant {
        require(block.timestamp >= releaseTime, ""Current time is before release time"");
        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, ""No tokens to release"");
        token.transfer(beneficiary, amount);
    }
}"
4047,Checks if the order given offchain coincides with the order of the actual previously calculated points in the smart contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, LimitCalculated, OrderChecked }
    pointsValidationState public pValidationState;
    uint256 public winnerCounter;
    uint256 public pointsLimit;
    mapping(uint256 => uint256) public tokenToPointsMap;
    uint256[] private sortedWinners;

    constructor() {
        pValidationState = pointsValidationState.NotStarted;
    }

    function checkOrder(uint32[] memory sortedChunk) external onlyOwner checkState(pointsValidationState.LimitCalculated) {
        require(sortedChunk.length + sortedWinners.length <= winnerCounter);

        for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
            uint256 id = sortedChunk[i];
            uint256 sigId = sortedChunk[i + 1];
            require(tokenToPointsMap[id] > tokenToPointsMap[sigId] || (tokenToPointsMap[id] == tokenToPointsMap[sigId] && id < sigId));
        }

        if (sortedWinners.length != 0) {
            uint256 id2 = sortedWinners[sortedWinners.length - 1];
            uint256 sigId2 = sortedChunk[0];
            require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] || (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));
        }

        for (uint256 j = 0; j < sortedChunk.length; j++) {
            sortedWinners.push(sortedChunk[j]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[sortedWinners.length - 1] == pointsLimit);
            pValidationState = pointsValidationState.OrderChecked;
        }
    }

    modifier checkState(pointsValidationState expectedState) {
        require(pValidationState == expectedState, ""Invalid state"");
        _;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract OrderCheck is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => uint256) private points;

    function setPoints(uint256 _index, uint256 _value) external onlyOwner {
        points[_index] = _value;
    }

    function isOrderCorrect(uint256[] memory _offchainOrder) public view returns (bool) {
        require(_offchainOrder.length > 0, ""Order length should be more than 0"");

        uint256 previousPoint = points[_offchainOrder[0]];

        for (uint256 i = 1; i < _offchainOrder.length; i++) {
            uint256 currentPoint = points[_offchainOrder[i]];

            if (currentPoint < previousPoint) {
                return false;
            }

            previousPoint = currentPoint;
        }

        return true;
    }
}",12.87040877342224,isOrderCorrect,"[{'function': 'setPoints', 'complexity': 0}, {'function': 'isOrderCorrect', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""isOrderCorrect"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_offchainOrder"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_offchainOrder""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Order length should be more than 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""previousPoint"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""points""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_offchainOrder""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_offchainOrder""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentPoint"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""points""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_offchainOrder""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""currentPoint""}, ""right"": {""type"": ""Identifier"", ""name"": ""previousPoint""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""previousPoint""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentPoint""}}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",73.0,0.6365621033531002,0.0563016958077885,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract OrderCheck is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => uint256) private points;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setPoints(uint256 _index, uint256 _value) external onlyOwner {
        points[_index] = _value;
    }

    function isOrderCorrect(uint256[] memory _offchainOrder) public view returns (bool) {
        require(_offchainOrder.length > 0, ""Order length should be more than 0"");

        uint256 previousPoint = points[_offchainOrder[0]];

        for (uint256 i = 1; i < _offchainOrder.length; i++) {
            uint256 currentPoint = points[_offchainOrder[i]];

            if (currentPoint < previousPoint) {
                return false;
            }

            previousPoint = currentPoint;
        }

        return true;
    }
}"
527,The value in HAV for a given amount of USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceOracle {
    function price() external view returns (uint);
}

abstract contract USDtoHAVWrapper is Ownable {
    using SafeMath for uint256;

    PriceOracle public oracle;

    constructor(address _oracle) {
        oracle = PriceOracle(_oracle);
    }

    function safeDiv_dec(uint usd_dec, uint price) internal pure returns (uint) {
        require(price > 0, ""SafeMath: division by zero"");
        return usd_dec.div(price);
    }

    function USDtoHAV(uint usd_dec) public view priceNotStale returns (uint) {
        uint price = oracle.price();
        require(price > 0, ""Price is stale or incorrect"");
        return safeDiv_dec(usd_dec, price);
    }

    modifier priceNotStale() {
        require(oracle.price() != 0, ""Price is not available or has expired"");
        _;
    }
}","y
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/CircuitBreaker.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ConvertUsdToHav is Ownable, CircuitBreaker {
    uint256 public havRate;

    constructor(uint256 _havRate) {
        havRate = _havRate;
    }

    function getHavValue(uint256 usdAmount) public view returns (uint256) {
        require(usdAmount > 0, ""USD amount should be greater than 0"");
        return usdAmount * havRate;
    }

    function updateHavRate(uint256 _newRate) public onlyOwner {
        havRate = _newRate;
    }
}",12.074189186096191,getHavValue,"[{'function': 'getHavValue', 'complexity': 1}, {'function': 'updateHavRate', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getHavValue"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""usdAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""usdAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""USD amount should be greater than 0""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""usdAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""havRate""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.6508422510446813,0.0619466695336219,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/CircuitBreaker.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ConvertUsdToHav is Ownable, CircuitBreaker {
    uint256 public havRate;

    constructor(uint256 _havRate) Ownable(msg.sender) {
        require(_havRate > 0, ""Hav rate should be greater than 0""); // Ensure non-zero initialization
        havRate = _havRate;
    }

    function getHavValue(uint256 usdAmount) public view returns (uint256) {
        require(usdAmount > 0, ""USD amount should be greater than 0"");
        return usdAmount * havRate;
    }

    function updateHavRate(uint256 _newRate) public onlyOwner {
        require(_newRate > 0, ""New rate should be greater than 0""); // Ensure non-zero initialization check
        havRate = _newRate;
    }
}"
3318,Return hash containing all of the information about the burnCarbonDollar ( ) metatransaction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MetaBurnHashWrapper is Ownable {
    using SafeMath for uint256;

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract CarbonDollar is Ownable {
    using SafeMath for uint256;

    struct Metatransaction {
        address sender;
        uint256 amount;
        uint256 nonce;
    }

    mapping(address => uint256) public balances;
    mapping(address => Metatransaction) public metatransactions;
    mapping(bytes32 => bool) public hashes;

    function burnCarbonDollar(address _sender, uint256 _amount, uint256 _nonce)
    public
    onlyOwner
    {
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        balances[_sender] = balances[_sender].sub(_amount);

        Metatransaction memory _metatransaction;
        _metatransaction.sender = _sender;
        _metatransaction.amount = _amount;
        _metatransaction.nonce = _nonce;

        bytes32 hash = keccak256(abi.encodePacked(_sender, _amount, _nonce));
        require(!hashes[hash], ""Hash already used"");
        hashes[hash] = true;

        metatransactions[_sender] = _metatransaction;
    }

    function getMetatransactionHash(address _sender) public view returns (bytes32) {
        Metatransaction memory _metatransaction = metatransactions[_sender];
        return keccak256(abi.encodePacked(_metatransaction.sender, _metatransaction.amount, _metatransaction.nonce));
    }
}",16.464693069458008,burnCarbonDollar,"[{'function': 'burnCarbonDollar', 'complexity': 0}, {'function': 'getMetatransactionHash', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnCarbonDollar"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Metatransaction""}, ""name"": ""_metatransaction"", ""storageLocation"": ""memory""}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_metatransaction""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_metatransaction""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_metatransaction""}, ""memberName"": ""nonce""}, ""right"": {""type"": ""Identifier"", ""name"": ""_nonce""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashes""}, ""index"": {""type"": ""Identifier"", ""name"": ""hash""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Hash already used""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashes""}, ""index"": {""type"": ""Identifier"", ""name"": ""hash""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""metatransactions""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_metatransaction""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",66.0,0.7026567008379562,0.1636550012446612,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CarbonDollar is Ownable {
    using SafeMath for uint256;

    struct Metatransaction {
        address sender;
        uint256 amount;
        uint256 nonce;
    }

    mapping(address => uint256) public balances;
    mapping(address => Metatransaction) public metatransactions;
    mapping(bytes32 => bool) public hashes;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        balances[address(0x111)] = 1;
        balances[address(0x222)] = 1;
        balances[address(0x333)] = 1;
    }

    function burnCarbonDollar(address _sender, uint256 _amount, uint256 _nonce)
    public
    onlyOwner
    {
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        balances[_sender] = balances[_sender].sub(_amount);

        Metatransaction memory _metatransaction;
        _metatransaction.sender = _sender;
        _metatransaction.amount = _amount;
        _metatransaction.nonce = _nonce;

        bytes32 hash = keccak256(abi.encodePacked(_sender, _amount, _nonce));
        require(!hashes[hash], ""Hash already used"");
        hashes[hash] = true;

        metatransactions[_sender] = _metatransaction;
    }

    function getMetatransactionHash(address _sender) public view returns (bytes32) {
        Metatransaction memory _metatransaction = metatransactions[_sender];
        return keccak256(abi.encodePacked(_metatransaction.sender, _metatransaction.amount, _metatransaction.nonce));
    }
}"
1663,Access point for the oracle to update the price of havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public price;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 days; // Example value, adjust as needed

    event PriceUpdated(uint newPrice, uint timeSent);

    function updatePrice(uint newPrice, uint timeSent) external onlyOwner {
        require(lastPriceUpdateTime < timeSent && timeSent < now.add(ORACLE_FUTURE_LIMIT), ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        price = newPrice;
        lastPriceUpdateTime = timeSent;
        emit PriceUpdated(newPrice, timeSent);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract HavvenContract is Ownable {
    using SafeMath for uint256;

    uint256 private havvenPrice;

    function updateHavvenPrice(uint256 newPrice) public onlyOwner {
        havvenPrice = newPrice;
    }

    function getHavvenPrice() public view returns (uint256) {
        return havvenPrice;
    }
}",5.621105194091797,updateHavvenPrice,"[{'function': 'updateHavvenPrice', 'complexity': 0}, {'function': 'getHavvenPrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateHavvenPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""havvenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.7158401564383251,0.0015312539322598,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract HavvenContract is Ownable {
    using SafeMath for uint256;

    uint256 private havvenPrice;

    constructor() Ownable(msg.sender) {
        havvenPrice = 1; // Set to a non-zero, safe value
    }

    function updateHavvenPrice(uint256 newPrice) public onlyOwner {
        havvenPrice = newPrice;
    }

    function getHavvenPrice() public view returns (uint256) {
        return havvenPrice;
    }
}"
6383,Approve address to become creator of that pack,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetPackApproval {
    using SafeMath for uint256;

    struct AssetPack {
        address creator;
    }

    mapping(uint => AssetPack) public assetPacks;
    mapping(uint => address) public approvedTakeover;

    function approveTakeover(uint _assetPackId, address _newCreator) public {
        require(assetPacks[_assetPackId].creator == msg.sender);
        approvedTakeover[_assetPackId] = _newCreator;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PackCreatorApproval is Ownable{

    mapping (address => bool) public creators;

    function approveCreator(address creator) public onlyOwner {
        require(creator != address(0), ""Invalid address"");
        creators[creator] = true;
    }
}",4.6622819900512695,approveCreator,"[{'function': 'approveCreator', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveCreator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""creator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""creator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""creators""}, ""index"": {""type"": ""Identifier"", ""name"": ""creator""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.6946666849127942,0.0617003641653305,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PackCreatorApproval is Ownable {
    mapping(address => bool) public creators;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        creators[address(0x111)] = true;
        creators[address(0x222)] = true;
        creators[address(0x333)] = true;
    }

    function approveCreator(address creator) public onlyOwner {
        require(creator != address(0), ""Invalid address"");
        creators[creator] = true;
    }
}"
5701,Returns the division of two numbers Function used for division operations inside the smartcontract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DivisionWrapper is Ownable {
    using SafeMath for uint256;

    function division(uint numerator, uint denominator) public view onlyOwner returns (uint result) {
        require(denominator != 0, ""Division by zero"");
        return numerator.div(denominator);
    }
}","SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function divide(uint256 a, uint256 b) public pure returns (uint256) {
        require(b != 0, ""MyContract: division by zero"");
        return a.div(b);
    }
}",4.567720174789429,divide,"[{'function': 'divide', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""divide"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""MyContract: division by zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""a""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",1.0,0.6688972131600908,0.260917147359081,"SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    function divide(uint256 a, uint256 b) public pure returns (uint256) {
        require(b != 0, ""MyContract: division by zero"");
        return a.div(b);
    }
}"
2851,Function used by the creator to set the presale limits,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PresaleAmountLimits {
    using SafeMath for uint256;

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public pure {
        require(_minPresaleAmount > 0, ""Minimum presale amount must be greater than 0"");
        require(_maxPresaleAmount > 0, ""Maximum presale amount must be greater than 0"");
        require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount"");
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Presale is Ownable {
    using SafeMath for uint256;

    uint256 public presaleLimitMinimum;
    uint256 public presaleLimitMaximum;

    function setPresaleLimits(uint256 _minimum, uint256 _maximum) public onlyOwner {
        require(_minimum >= 0, ""Minimum can't be negative"");
        require(_maximum > _minimum, ""Maximum should be greater than Minimum"");

        presaleLimitMinimum = _minimum;
        presaleLimitMaximum = _maximum;
    }
}",7.701961040496826,setPresaleLimits,"[{'function': 'setPresaleLimits', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPresaleLimits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minimum"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maximum"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_minimum""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minimum can""t be negative""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_maximum""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minimum""}}, {""type"": ""stringLiteral"", ""value"": ""Maximum should be greater than Minimum""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""presaleLimitMinimum""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minimum""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""presaleLimitMaximum""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maximum""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.896704402225994,0.0950821424066798,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Presale is Ownable {
    using SafeMath for uint256;

    uint256 public presaleLimitMinimum;
    uint256 public presaleLimitMaximum;

    constructor() Ownable(msg.sender) {
        presaleLimitMinimum = 1; // Set to 1 (never 0)
        presaleLimitMaximum = 2; // Set to 2 (example values, can be adjusted)
    }

    function setPresaleLimits(uint256 _minimum, uint256 _maximum) public onlyOwner {
        require(_minimum >= 0, ""Minimum can't be negative"");
        require(_maximum > _minimum, ""Maximum should be greater than Minimum"");

        presaleLimitMinimum = _minimum;
        presaleLimitMaximum = _maximum;
    }
}"
5928,Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Authorizable is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address indexed operator, address indexed owner);

    function authorizeOperator(address _operator) public override onlyOwner {
        require(_operator != msg.sender, ""The operator must be different from the sender."");
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract Token is ERC20 {
    mapping (address => mapping (address => bool)) private _allowances;

    function approve(address _operator, uint256 _amount) public returns (bool) {
        require(_operator != msg.sender, ""Token: cannot authorize self as operator"");
        _allowances[msg.sender][_operator] = _amount;
        emit Approval(msg.sender, _operator, _amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
}",7.723333835601807,approve,"[{'function': 'approve', 'complexity': 1}, {'function': 'allowance', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Token: cannot authorize self as operator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.7230833204888492,0.207066696413647,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is ERC20, Ownable {
    mapping (address => mapping (address => bool)) private _allowances;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 1 * 10 ** decimals();
        _mint(msg.sender, initialSupply);
    }

    function approve(address _operator, uint256 _amount) public returns (bool) {
        require(_operator != msg.sender, ""Token: cannot authorize self as operator"");
        _allowances[msg.sender][_operator] = true; // Set to true instead of _amount for consistency with the requirement
        emit Approval(msg.sender, _operator, _amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return uint256(_allowances[owner][spender]); // Cast to uint256 for consistency with the mapping type
    }
}"
1383,Performs allowance transfer of asset balance between holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAsset {
    function __transferFromWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    IAsset public asset;

    constructor(address _assetAddress) {
        asset = IAsset(_assetAddress);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return asset.__transferFromWithReference(_from, _to, _value, """", msg.sender);
        }
        return false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract YourContractName {
    using SafeERC20 for IERC20;

    function transferAsset(IERC20 token, address sender, address recipient, uint256 amount) public {
        require(amount <= token.allowance(sender, address(this)), ""Transfer amount exceeds allowance"");
        token.safeTransferFrom(sender, recipient, amount);
    }
}",5.589854001998901,transferAsset,"[{'function': 'transferAsset', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferAsset"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount exceeds allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.6206863833676836,0.0449654860462228,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract YourContractName is Ownable {
    using SafeERC20 for IERC20;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferAsset(IERC20 token, address sender, address recipient, uint256 amount) public {
        require(amount <= token.allowance(sender, address(this)), ""Transfer amount exceeds allowance"");
        token.safeTransferFrom(sender, recipient, amount);
    }
}"
5667,Returns the address currently assigned ownership of a given token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract {
    using SafeMath for uint256;

    address[] public tokenIndexToOwner;

    function ownerOf(uint _tokenId) external view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0));
        return tokenIndexToOwner[_tokenId];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

contract MyNFT is ERC721 {

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}

    function getTokenOwner(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        return ownerOf(tokenId);
    }
}",4.53619384765625,getTokenOwner,"[{'function': 'getTokenOwner', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""ERC721: operator query for nonexistent token""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",6.0,0.7920332525963156,0.2583713098030025,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyNFT is ERC721, Ownable {
    constructor(string memory name, string memory symbol) ERC721(name, symbol) Ownable(msg.sender) {}

    function getTokenOwner(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        return ownerOf(tokenId);
    }
}"
5392,"Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract LoanContract is Ownable {
    using SafeMath for uint256;

    struct Loan {
        address lender;
        address approvedTransfer;
    }

    mapping(uint256 => Loan) public loans;
    mapping(address => uint256) public lendersBalance;

    event Transfer(address indexed from, address indexed to, uint256 index);

    function transfer(address to, uint256 index) public returns (bool) {
        Loan storage loan = loans[index];
        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);
        require(to != address(0));
        loan.lender = to;
        loan.approvedTransfer = address(0);
        lendersBalance[msg.sender] = lendersBalance[msg.sender].sub(1);
        lendersBalance[to] = lendersBalance[to].add(1);
        emit Transfer(loan.lender, to, index);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Context.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

enum Status { created, lent }

contract Lender is Context, ReentrancyGuard, Ownable {

    struct Loan {
        address lender;
        Status status;
    }

    mapping(uint => Loan) public loans;
    mapping(uint => address) public allowedTransfer;

    event Transfer(
        address indexed previousOwner,
        address indexed newOwner,
        uint loanId
    );

    modifier onlyLender(uint loanId) {
        require(
            loans[loanId].lender == _msgSender() || allowedTransfer[loanId] == _msgSender(),
            ""Caller is not the lender or approved.""
        );
        _;
    }

    function approveTransfer(uint loanId, address newLender) public onlyOwner nonReentrant {
        require(
            loans[loanId].status == Status.lent,
            ""Loan is not in 'lent' status.""
        );
        allowedTransfer[loanId] = newLender;
    }

    function transferLoan(uint loanId, address newLender) public nonReentrant onlyLender(loanId) {
        require(
            loans[loanId].status == Status.lent,
            ""Only loans in 'lent' status can be transferred.""
        );

        loans[loanId].lender = newLender;
        emit Transfer(_msgSender(), newLender, loanId);
    }
}",14.192081212997437,transferLoan,"[{'function': 'approveTransfer', 'complexity': 1}, {'function': 'transferLoan', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferLoan"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""loanId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newLender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""loanId""}}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Status""}, ""memberName"": ""lent""}}, {""type"": ""stringLiteral"", ""value"": ""Only loans in ""lent"" status can be transferred.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""loanId""}}, ""memberName"": ""lender""}, ""right"": {""type"": ""Identifier"", ""name"": ""newLender""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""newLender""}, {""type"": ""Identifier"", ""name"": ""loanId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyLender"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""loanId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",60.0,0.6757879443706045,0.0235503898506977,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Context.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";

enum Status { created, lent }
import ""openzeppelin/SafeMath.sol"";
contract Lender is Context, ReentrancyGuard, Ownable {

    struct Loan {
        address lender;
        Status status;
    }

    mapping(uint => Loan) public loans;
    mapping(uint => address) public allowedTransfer;

    event Transfer(
        address indexed previousOwner,
        address indexed newOwner,
        uint loanId
    );

    modifier onlyLender(uint loanId) {
        require(
            loans[loanId].lender == _msgSender() || allowedTransfer[loanId] == _msgSender(),
            ""Caller is not the lender or approved.""
        );
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 0; i < type(uint).max; i++) {
            loans[i] = Loan({lender: address(1 + i % 3), status: Status.created});
        }
        for (uint i = 0; i < type(uint).max; i++) {
            allowedTransfer[i] = address(2 + i % 3);
        }
    }

    function approveTransfer(uint loanId, address newLender) public onlyOwner nonReentrant {
        require(
            loans[loanId].status == Status.lent,
            ""Loan is not in 'lent' status.""
        );
        allowedTransfer[loanId] = newLender;
    }

    function transferLoan(uint loanId, address newLender) public nonReentrant onlyLender(loanId) {
        require(
            loans[loanId].status == Status.lent,
            ""Only loans in 'lent' status can be transferred.""
        );

        loans[loanId].lender = newLender;
        emit Transfer(_msgSender(), newLender, loanId);
    }
}"
6100,Allows a grant recipient to claim their vested tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenVesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 yearsClaimed;
        uint256 totalClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    IERC20 public token;

    event GrantTokensClaimed(address indexed recipient, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function calculateGrantClaim(address _recipient) internal view returns (uint256 yearsVested, uint256 amountVested) {
        // Implementation of the calculation logic for calculating vested tokens
        // This is a placeholder and should be replaced with actual implementation
        yearsVested = 0; // Example value
        amountVested = 0; // Example value
    }

    function claimVestedTokens(address _recipient) external {
        uint256 yearsVested;
        uint256 amountVested;
        (yearsVested, amountVested) = calculateGrantClaim(_recipient);
        require(amountVested > 0, ""amountVested is 0"");
        Grant storage tokenGrant = tokenGrants[_recipient];
        tokenGrant.yearsClaimed = yearsVested;
        tokenGrant.totalClaimed = tokenGrant.totalClaimed.add(amountVested);
        require(token.transfer(_recipient, amountVested), ""no tokens"");
        emit GrantTokensClaimed(_recipient, amountVested);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract GrantContract is Ownable, ReentrancyGuard {
    using SafeMath for uint256;
    using SafeERC20 for ERC20;

    struct Grant {
        uint256 startTime;
        uint256 amount;
        uint256 claimed;
    }

    ERC20 public token;
    mapping (address => Grant) public grants;

    constructor(ERC20 _token) {
        token = _token;
    }

    function claimTokens() public nonReentrant {
        Grant storage grant = grants[msg.sender];
        require(grant.amount > 0, ""No grant found for this account."");
        uint256 elapsedTime = block.timestamp.sub(grant.startTime);
        require(elapsedTime > 0, ""Claim period has not started."");

        uint256 availableTokens = elapsedTime.mul(grant.amount);

        require(availableTokens > grant.claimed, ""No tokens left to claim."");

        uint256 claimableAmount = availableTokens.sub(grant.claimed);
        grant.claimed = grant.claimed.add(claimableAmount);

        token.safeTransfer(msg.sender, claimableAmount);
    }
}",17.60967707633972,claimTokens,"[{'function': 'claimTokens', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""grant"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""grants""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No grant found for this account.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""startTime""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Claim period has not started.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""availableTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""elapsedTime""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""availableTokens""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""claimed""}}, {""type"": ""stringLiteral"", ""value"": ""No tokens left to claim.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""claimableAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""availableTokens""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""claimed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""claimed""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""claimed""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""claimableAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""claimableAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.7857664858248277,0.0993132060907194,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

contract GrantContract is Ownable, ReentrancyGuard {
    using SafeMath for uint256;
    using SafeERC20 for ERC20;

    struct Grant {
        uint256 startTime;
        uint256 amount;
        uint256 claimed;
    }

    ERC20 public token;
    mapping (address => Grant) public grants;

    constructor(ERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function claimTokens() public nonReentrant {
        Grant storage grant = grants[msg.sender];
        require(grant.amount > 0, ""No grant found for this account."");
        uint256 elapsedTime = block.timestamp.sub(grant.startTime);
        require(elapsedTime > 0, ""Claim period has not started."");

        uint256 availableTokens = elapsedTime.mul(grant.amount);

        require(availableTokens > grant.claimed, ""No tokens left to claim."");

        uint256 claimableAmount = availableTokens.sub(grant.claimed);
        grant.claimed = grant.claimed.add(claimableAmount);

        token.safeTransfer(msg.sender, claimableAmount);
    }
}"
949,Emits ERC20 Approval event on this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function emitApprove(address _from, address _spender, uint _value) public onlyChronoBankPlatform {
        emit Approval(_from, _spender, _value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is ERC20, Ownable {
    function approveOnContract(address spender, uint256 amount) external onlyOwner {
        _approve(address(this), spender, amount);
    }
}",4.150186061859131,approveOnContract,"[{'function': 'approveOnContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveOnContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.6535304343556786,0.0575200070592772,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ERC20, Ownable {
    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 1 * 10**uint256(decimals());
        _mint(msg.sender, initialSupply);
    }

    function approveOnContract(address spender, uint256 amount) external onlyOwner {
        _approve(address(this), spender, amount);
    }
}"
6735,Makes checkmark and deposits tokens on profiterole account to pay them later as bonuses for Treasury shares holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Treasury {
    function addDistributionPeriod() external;
}

abstract contract BonusDistributor is Ownable {
    using SafeMath for uint256;

    ERC20Interface public bonusToken;
    address public wallet;
    mapping(uint => Deposit) public distributionDeposits;
    uint public firstDepositDate;
    uint public lastDepositDate;
    bytes32 constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = 0x0;
    bytes32 constant PROFITEROLE_ERROR_TRANSFER_ERROR = 0x1;
    uint constant OK = 0;

    struct Deposit {
        uint amount;
        uint nextDepositDate;
        uint claimedAmount;
    }

    event DepositPendingAdded(uint indexed amount, address indexed depositor, uint indexed timestamp);

    modifier onlyDistributionSource() {
        require(msg.sender == wallet, ""Only the distribution source can call this function"");
        _;
    }

    constructor(address _bonusToken, address _wallet) {
        bonusToken = ERC20Interface(_bonusToken);
        wallet = _wallet;
    }

    function distributeBonuses(uint _amount) public onlyDistributionSource returns (uint) {
        ERC20Interface _bonusToken = ERC20Interface(bonusToken);
        if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {
            return uint(_emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE));
        }
        if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {
            return uint(_emitError(PROFITEROLE_ERROR_TRANSFER_ERROR));
        }
        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }
        uint _lastDepositDate = lastDepositDate;
        if (_lastDepositDate != 0) {
            distributionDeposits[_lastDepositDate].nextDepositDate = block.timestamp;
        }
        lastDepositDate = block.timestamp;
        distributionDeposits[block.timestamp] = Deposit(_amount, 0, 0);
        Treasury(treasury).addDistributionPeriod();
        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
        return OK;
    }

    function _emitError(bytes32 errorCode) internal pure returns (bytes4) {
        return bytes4(errorCode);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Treasury is Ownable, ReentrancyGuard {
    IERC20 public token;

    mapping (address => uint256) private _profits;
    mapping (address => uint256) private _checkmarks;

    event Deposited(address indexed user, uint256 amount);

    constructor(IERC20 _token) {
        token = _token;
    }

    function depositTokensAndMarkProfits(address profiterole, uint256 amount) external onlyOwner nonReentrant {
        require(profiterole != address(0), ""Treasury: zero address"");
        require(amount > 0, ""Treasury: zero amount"");

        uint256 balanceBefore = token.balanceOf(address(this));
        token.transferFrom(msg.sender, address(this), amount);
        uint256 received = token.balanceOf(address(this)) - balanceBefore;
        require(received == amount, ""Treasury: incorrect tokens received"");

        _profits[profiterole] += received;
        _checkmarks[profiterole]++;

        emit Deposited(profiterole, received);
    }


    function profiteroleBonus(address profiterole) external view returns (uint256 profit, uint256 checkmarks) {
        return (_profits[profiterole], _checkmarks[profiterole]);
    }
}",10.127278089523315,depositTokensAndMarkProfits,"[{'function': 'depositTokensAndMarkProfits', 'complexity': 3}, {'function': 'profiteroleBonus', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""depositTokensAndMarkProfits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""profiterole"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""profiterole""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Treasury: zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Treasury: zero amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceBefore"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""received"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""balanceBefore""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""received""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Treasury: incorrect tokens received""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_profits""}, ""index"": {""type"": ""Identifier"", ""name"": ""profiterole""}}, ""right"": {""type"": ""Identifier"", ""name"": ""received""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_checkmarks""}, ""index"": {""type"": ""Identifier"", ""name"": ""profiterole""}}, ""isPrefix"": False}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Deposited""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""profiterole""}, {""type"": ""Identifier"", ""name"": ""received""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",58.0,0.6012772299925117,0.103436924230146,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Treasury is Ownable, ReentrancyGuard {
    IERC20 public token;

    mapping (address => uint256) private _profits;
    mapping (address => uint256) private _checkmarks;

    event Deposited(address indexed user, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function depositTokensAndMarkProfits(address profiterole, uint256 amount) external onlyOwner nonReentrant {
        require(profiterole != address(0), ""Treasury: zero address"");
        require(amount > 0, ""Treasury: zero amount"");

        uint256 balanceBefore = token.balanceOf(address(this));
        token.transferFrom(msg.sender, address(this), amount);
        uint256 received = token.balanceOf(address(this)) - balanceBefore;
        require(received == amount, ""Treasury: incorrect tokens received"");

        _profits[profiterole] += received;
        _checkmarks[profiterole]++;

        emit Deposited(profiterole, received);
    }

    function profiteroleBonus(address profiterole) external view returns (uint256 profit, uint256 checkmarks) {
        return (_profits[profiterole], _checkmarks[profiterole]);
    }
}"
2614,Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract MyContract is AccessControl {
    mapping(address => mapping(address => bool)) private _allowed;

    function setApprovalForAll(address operator, bool approved) external {
        require(msg.sender != operator, ""Can't set approval for self"");

        _allowed[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
}",4.130583763122559,setApprovalForAll,"[{'function': 'setApprovalForAll', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""operator""}}, {""type"": ""stringLiteral"", ""value"": ""Can""t set approval for self""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""operator""}, {""type"": ""Identifier"", ""name"": ""approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.9564929959223258,0.2280077290159341,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is AccessControl {
    mapping(address => mapping(address => bool)) private _allowed;

    constructor() {
        // Initialize state variables with safe, non-corner-case values
        _allowed[address(0x111)][address(0x222)] = true;
        _allowed[address(0x222)][address(0x333)] = true;
    }

    function setApprovalForAll(address operator, bool approved) external {
        require(msg.sender != operator, ""Can't set approval for self"");

        _allowed[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
}"
5641,Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for uint256;

    function destroy() public onlyOwner {
        selfdestruct(owner());
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract Destructible is Ownable {
    using Address for address payable;

    function destroy() public onlyOwner {
        require(address(this).balance > 0, ""No funds to send to owner"");
        payable(owner()).sendValue(address(this).balance);
        selfdestruct(payable(owner()));
    }
}",5.009858131408691,destroy,"[{'function': 'destroy', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No funds to send to owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""sendValue""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.8559541927258112,0.2184181822230771,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Destructible is Ownable {
    using Address for address payable;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function destroy() public onlyOwner {
        require(address(this).balance > 0, ""No funds to send to owner"");
        payable(owner()).sendValue(address(this).balance);
        selfdestruct(payable(owner()));
    }
}"
2847,Change the wallet where ether will be sent to when tokens are bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContractManager {
    function authorize(string memory contractName, address user) external view returns (bool);
}

abstract contract WalletWrapper is Ownable {
    using SafeMath for uint256;

    IContractManager public contractManager;
    string public contractName;
    address public wallet;

    event WalletAddressChanged(address indexed oldAddress, address indexed newAddress);

    constructor(IContractManager _contractManager, string memory _contractName, address _wallet) {
        contractManager = _contractManager;
        contractName = _contractName;
        wallet = _wallet;
    }

    function setWalletAddress(address _walletAddress) external {
        require(contractManager.authorize(contractName, msg.sender));
        require(_walletAddress != address(0));
        require(_walletAddress != wallet);
        address oldAddress = wallet;
        wallet = _walletAddress;
        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is Ownable {
    address payable private wallet;

    event WalletChanged(address indexed previousWallet, address indexed newWallet);

    function changeWallet(address payable _newWallet) public onlyOwner {
        require(_newWallet != address(0), ""New wallet cannot be the zero address"");

        emit WalletChanged(wallet, _newWallet);
        wallet = _newWallet;
    }
}",4.88198709487915,changeWallet,"[{'function': 'changeWallet', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeWallet"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_newWallet"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newWallet""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New wallet cannot be the zero address""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WalletChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""wallet""}, {""type"": ""Identifier"", ""name"": ""_newWallet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""wallet""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newWallet""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.7546321230071013,0.1306522354559658,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    address payable private wallet = payable(address(uint160(uint256(1))));

    event WalletChanged(address indexed previousWallet, address indexed newWallet);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done in the constructor
    }

    function changeWallet(address payable _newWallet) public onlyOwner {
        require(_newWallet != address(0), ""New wallet cannot be the zero address"");

        emit WalletChanged(wallet, _newWallet);
        wallet = _newWallet;
    }
}"
6644,"challenge the provided proposal ID , and put tokens at stake to do so .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Voting {
    struct Poll {
        uint commitStageLen;
        uint revealStageLen;
        uint quorum;
    }
    function startPoll(uint quorum, uint commitStageLen, uint revealStageLen) external returns (uint pollID);
    function pollMap(uint pollID) external view returns (uint commitEndDate, uint revealEndDate, bool resolved);
}

abstract contract ChallengeReparameterization {
    using SafeMath for uint;

    struct ParamProposal {
        uint deposit;
        uint challengeID;
    }

    struct Challenge {
        address challenger;
        uint rewardPool;
        uint stake;
        bool resolved;
        uint winningTokens;
    }

    mapping(bytes32 => ParamProposal) public proposals;
    mapping(uint => Challenge) public challenges;
    Token public token;
    Voting public voting;

    function get(string memory key) internal pure returns (uint value) {
        // This should be implemented to return the correct values based on the key.
        // For demonstration, let's assume it returns some fixed values.
        if (keccak256(abi.encodePacked(key)) == keccak256(""pDispensationPct"")) {
            return 10; // Example value for pDispensationPct
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pVoteQuorum"")) {
            return 30; // Example value for pVoteQuorum
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pCommitStageLen"")) {
            return 1 days; // Example value for commit stage length
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pRevealStageLen"")) {
            return 1 days; // Example value for reveal stage length
        }
        revert(""Unknown key"");
    }

    function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {
        ParamProposal memory prop = proposals[_propID];
        uint deposit = prop.deposit;
        require(propExists(_propID) && prop.challengeID == 0, ""Invalid proposal"");
        uint pollID = voting.startPoll(get(""pVoteQuorum""), get(""pCommitStageLen""), get(""pRevealStageLen""));
        challenges[pollID] = Challenge({
            challenger: msg.sender,
            rewardPool: SafeMath.sub(100, get(""pDispensationPct"")).mul(deposit).div(100),
            stake: deposit,
            resolved: false,
            winningTokens: 0
        });
        proposals[_propID].challengeID = pollID;
        require(token.transferFrom(msg.sender, address(this), deposit), ""Token transfer failed"");
        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);
        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
        return pollID;
    }

    function propExists(bytes32 _propID) internal view returns (bool) {
        return proposals[_propID].deposit > 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract ChallengeProposal is Ownable, ReentrancyGuard {
    struct Proposal {
        bool challenged;
        uint256 stake;
    }

    IERC20 public token;
    mapping(uint256 => Proposal) public proposals;

    constructor(IERC20 _token) {
        token = _token;
    }

    function challenge(uint256 proposalId, uint256 stakeAmount) public nonReentrant {
        Proposal storage proposal = proposals[proposalId];
        require(!proposal.challenged, ""Proposal already challenged"");
        require(token.balanceOf(msg.sender) >= stakeAmount, ""Not enough tokens"");

        // Transfer token into contract
        token.transferFrom(msg.sender, address(this), stakeAmount);

        // Update proposal
        proposal.challenged = true;
        proposal.stake = stakeAmount;
    }
}",9.810251951217651,challenge,"[{'function': 'challenge', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""challenge"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""proposalId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""stakeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Proposal""}, ""name"": ""proposal"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""challenged""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Proposal already challenged""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""stakeAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""stakeAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""challenged""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""stake""}, ""right"": {""type"": ""Identifier"", ""name"": ""stakeAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",71.0,0.7335392123405232,0.0511769301125147,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ChallengeProposal is Ownable, ReentrancyGuard {
    struct Proposal {
        bool challenged;
        uint256 stake;
    }

    IERC20 public token;
    mapping(uint256 => Proposal) public proposals;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function challenge(uint256 proposalId, uint256 stakeAmount) public nonReentrant {
        Proposal storage proposal = proposals[proposalId];
        require(!proposal.challenged, ""Proposal already challenged"");
        require(token.balanceOf(msg.sender) >= stakeAmount, ""Not enough tokens"");

        // Transfer token into contract
        token.transferFrom(msg.sender, address(this), stakeAmount);

        // Update proposal
        proposal.challenged = true;
        proposal.stake = stakeAmount;
    }
}"
3277,Computes ( _numerator / _denominator ) 10 _scale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract FractionJoiner is Ownable {
    using SafeMath for uint256;

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) public pure returns (uint256) {
        if (_scale >= 0) {
            require(_scale <= 77, ""Scale must be between 0 and 77"");
            return _numerator.mul(10 ** uint256(_scale)).div(_denominator);
        } else {
            return (_numerator / _denominator) / 10 ** uint256(-_scale);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DivisionContract {

    function compute(uint256 _numerator, uint256 _denominator, uint256 _scale) public pure returns (uint256) {
        require(_denominator != 0, ""Denominator should not be zero"");
        uint256 value =  _numerator * (10 ** _scale);
        return value / _denominator;
    }
}",5.146556854248047,compute,"[{'function': 'compute', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""compute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_numerator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_denominator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_scale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_denominator""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Denominator should not be zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_numerator""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""_scale""}}], ""isArray"": False}}}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_denominator""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",17.0,0.8307629633008133,0.2411251721487919,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DivisionContract is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function compute(uint256 _numerator, uint256 _denominator, uint256 _scale) public pure returns (uint256) {
        require(_denominator != 0, ""Denominator should not be zero"");
        uint256 value =  _numerator * (10 ** _scale);
        return value / _denominator;
    }
}"
5822,Get current amount of tokens on Vault address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRntToken {
    function balanceOf() external view returns (uint256);
}

abstract contract Vault is Ownable {
    using SafeMath for uint256;

    IRntToken public rntToken;

    constructor(address _rntToken) {
        rntToken = IRntToken(_rntToken);
    }

    function getVaultBalance() public onlyOwner view returns (uint256) {
        return rntToken.balanceOf();
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyContract {
    ERC20 public token;
    address public vault;

    constructor(ERC20 _token, address _vault) {
        token = _token;
        vault = _vault;
    }

    function getCurrentAmountOnVault() public view returns (uint256) {
        return token.balanceOf(vault);
    }
}",5.484734296798706,getCurrentAmountOnVault,"[{'function': 'getCurrentAmountOnVault', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentAmountOnVault"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""vault""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.7751304260950297,0.4890228535830199,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    ERC20 public token;
    address public vault;

    mapping(address => uint256) public balanceOf;

 constructor(ERC20 _token, address _vault) Ownable(msg.sender) {
        token = ERC20(""MyToken"", ""TKN"");
        vault = address(uint160(uint256(keccak256('init'))));
    }

    function getCurrentAmountOnVault() public view returns (uint256) {
        return token.balanceOf(vault);
    }
}"
1522,Transfer an amount of currency token from msg.sender account to another specified account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFxUSD {
    function getFxUSDAmount(string memory currency, uint amount) external view returns (uint);
}

interface ITransfer {
    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) external returns (bool success);
}

abstract contract Data {
    using SafeMath for uint;
    mapping(address => uint) public accountSpendingAmounts;
    IFxUSD public fxUSDContract;
    ITransfer public transferContract;

    function getFeeContract(Data storage self, address tokenAddress) internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(Data storage self, address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(Data storage self, address account, uint amount) internal returns (bool success) {
        self.accountSpendingAmounts[account] = amount;
        return true;
    }
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint;
    Data private dataInstance;

    constructor(address _dataAddress, address _fxUSDAddress, address _transferAddress) {
        dataInstance = Data(_dataAddress);
        fxUSDContract = IFxUSD(_fxUSDAddress);
        transferContract = ITransfer(_transferAddress);
    }

    function transfer(string memory currency, address to, uint amount, bytes memory data) public onlyOwner returns (bool success) {
        require(to != address(0), ""Error: `to` address cannot be null."");
        require(amount > 0, ""Error: `amount` must be greater than zero"");
        address feeContract = getFeeContract();
        uint fees = calculateFees(feeContract, amount);
        require(setAccountSpendingAmount(msg.sender, fxUSDContract.getFxUSDAmount(currency, amount)), ""Error: Unable to set spending amount for account."");
        require(forceTransfer(currency, msg.sender, to, amount, data), ""Error: Unable to transfer funds to account."");
        require(forceTransfer(currency, msg.sender, feeContract, fees, getFeeMsg(feeContract)), ""Error: Unable to transfer fees to fee contract."");
        return true;
    }

    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) internal returns (bool success) {
        // Implementation of forceTransfer logic
        require(transferContract.forceTransfer(currency, from, to, amount, data), ""Error: Transfer failed"");
        return true;
    }

    function getFeeContract() internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(address account, uint amount) internal returns (bool success) {
        dataInstance.accountSpendingAmounts[account] = amount;
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TransferToken is ReentrancyGuard {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function transferTo(address _to, uint256 _amount) external nonReentrant {
        uint256 senderBalance = token.balanceOf(msg.sender);
        require(senderBalance >= _amount, ""Transfer amount exceeds balance"");

        bool sent = token.transferFrom(msg.sender, _to, _amount);
        require(sent, ""Token transfer failed"");
    }
}",6.864760160446167,transferTo,"[{'function': 'transferTo', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""sent"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sent""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",56.0,0.7191205878482277,0.0208837124679206,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TransferToken is ReentrancyGuard, Ownable {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function transferTo(address _to, uint256 _amount) external nonReentrant {
        uint256 senderBalance = token.balanceOf(msg.sender);
        require(senderBalance >= _amount, ""Transfer amount exceeds balance"");

        bool sent = token.transferFrom(msg.sender, _to, _amount);
        require(sent, ""Token transfer failed"");
    }
}"
3064,Sender should check whether he has enough tokens to be transferred,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public onlyOwner {
        require(_recipients.length == _values.length);
        uint length = _recipients.length;
        for (uint i = 0; i < length; i++) {
            transfer(_recipients[i], _values[i]);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract TokenTransfer {

    using SafeERC20 for IERC20;

    function transferTokens(IERC20 _token, address _to, uint256 _amount) external  {

        uint256 senderBalance = _token.balanceOf(msg.sender);
        require(senderBalance >= _amount, ""Not enough tokens for transfer"");

        _token.safeTransferFrom(msg.sender, _to, _amount);
    }
}",11.879739046096802,transferTokens,"[{'function': 'transferTokens', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens for transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.5475632144850002,0.0368414234315963,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    using SafeERC20 for IERC20;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(IERC20 _token, address _to, uint256 _amount) external {
        uint256 senderBalance = _token.balanceOf(msg.sender);
        require(senderBalance >= _amount, ""Not enough tokens for transfer"");

        _token.safeTransferFrom(msg.sender, _to, _amount);
    }
}"
6408,"owners : send ` value ` of tokens to address ` to ` , can be called if crowdsale failed and some of the investors refunded the ether","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenSender is Ownable {
    using SafeMath for uint256;

    IERC20 public m_token;
    enum State { ACTIVE, REFUNDING }
    State public currentState = State.REFUNDING;

    modifier validAddress(address to) {
        require(to != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bytes memory data = abi.encodePacked(msg.sig, msg.data);
        require(isOwner(txHash), ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State state) {
        require(currentState == state, ""Function not allowed in current state"");
        _;
    }

    constructor(address tokenAddress) {
        m_token = IERC20(tokenAddress);
    }

    function sendTokens(address to, uint value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(State.REFUNDING) {
        require(value > 0 && m_token.balanceOf(this) >= value);
        m_token.transfer(to, value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract CrowdsaleFailureRefund is Ownable, ReentrancyGuard {
    bool public isCrowdsaleFailed;
    ERC20 public token;

    constructor(ERC20 _token) {
        token = _token;
    }

    function setIsCrowdsaleFailed(bool _isCrowdsaleFailed) external onlyOwner {
        isCrowdsaleFailed = _isCrowdsaleFailed;
    }

    function refundTokens(address to, uint256 value) external onlyOwner nonReentrant {
        require(isCrowdsaleFailed, ""Crowdsale has not failed"");
        uint256 contractBalance = token.balanceOf(address(this));
        require(contractBalance >= value, ""Not enough tokens in contract"");
        require(token.transfer(to, value), ""Token transfer failed"");
    }
}",20.0693359375,refundTokens,"[{'function': 'setIsCrowdsaleFailed', 'complexity': 0}, {'function': 'refundTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""refundTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isCrowdsaleFailed""}, {""type"": ""stringLiteral"", ""value"": ""Crowdsale has not failed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""contractBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""contractBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.7742115698414027,0.1831547954823741,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CrowdsaleFailureRefund is Ownable, ReentrancyGuard {
    bool public isCrowdsaleFailed;
    ERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(ERC20 _token) Ownable(msg.sender) {
        token = _token;
        isCrowdsaleFailed = false; // Initialize to safe non-corner-case value
    }

    function setIsCrowdsaleFailed(bool _isCrowdsaleFailed) external onlyOwner {
        isCrowdsaleFailed = _isCrowdsaleFailed;
    }

    function refundTokens(address to, uint256 value) external onlyOwner nonReentrant {
        require(isCrowdsaleFailed, ""Crowdsale has not failed"");
        uint256 contractBalance = token.balanceOf(address(this));
        require(contractBalance >= value, ""Not enough tokens in contract"");
        require(token.transfer(to, value), ""Token transfer failed"");
    }
}"
6613,Sets the ` _newManager ` as manager for the ` _addr ` address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IManager {
    function getManager(address _addr) external view returns (address);
}

abstract contract ManagerWrapper is Ownable, SafeMath {
    mapping(address => address) public managers;
    event ManagerChanged(address indexed addr, address newManager);

    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, ""Not the manager"");
        managers[_addr] = (_newManager == _addr ? 0 : _newManager);
        emit ManagerChanged(_addr, _newManager);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract MyContract is AccessControl {
    bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");

    constructor() {
        _setupRole(MANAGER_ROLE, msg.sender);
    }

    function setManager(address _addr, address _newManager) public {
        require(hasRole(MANAGER_ROLE, msg.sender), ""Caller is not a manager"");
        _setupRole(MANAGER_ROLE, _newManager);
        revokeRole(MANAGER_ROLE, _addr);
    }
}",12.301340103149414,setManager,"[{'function': 'setManager', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MANAGER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not a manager""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setupRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MANAGER_ROLE""}, {""type"": ""Identifier"", ""name"": ""_newManager""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revokeRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MANAGER_ROLE""}, {""type"": ""Identifier"", ""name"": ""_addr""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.8839152950251735,0.3249650324623487,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is AccessControl {
    bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");

    constructor() {
        _setupRole(MANAGER_ROLE, msg.sender);
    }

    function setManager(address _addr, address _newManager) public {
        require(hasRole(MANAGER_ROLE, msg.sender), ""Caller is not a manager"");
        _setupRole(MANAGER_ROLE, _newManager);
        revokeRole(MANAGER_ROLE, _addr);
    }
}"
799,Returns all the relevant information about a specific collectible .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Collectible {
    using SafeMath for uint256;

    struct Token {
        uint256 price;
        address owner;
    }

    mapping(uint256 => Token) public collectibleIdx;

    function getInitialPriceOfToken(uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate initial price of token
        return 0; // Placeholder, replace with actual implementation
    }

    function getNextPrice(uint256 currentPrice, uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate next selling price
        return currentPrice.mul(110).div(100); // Example: increase by 10%
    }

    function getToken(uint256 _tokenId) public view returns (
        uint256 tokenId,
        uint256 sellingPrice,
        address owner,
        uint256 nextSellingPrice
    ) {
        tokenId = _tokenId;
        Token storage token = collectibleIdx[_tokenId];
        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(_tokenId);
        }
        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

contract CollectibleInfo {

    IERC721 public nftAddress;

    struct Collectible {
        uint256 id;
        address owner;
        string name;
        string description;
        uint256 price;
    }

    mapping(uint256 => Collectible) public collectibles;

    constructor(address _nftAddress) {
        nftAddress = IERC721(_nftAddress);
    }

    function getCollectibleInfo(uint256 _tokenId) public view returns (
        uint256 id,
        address owner,
        string memory name,
        string memory description,
        uint256 price
    ) {
        require(nftAddress.ownerOf(_tokenId) != address(0), ""Token does not exist"");

        Collectible storage collectible = collectibles[_tokenId];
        return (
            collectible.id,
            collectible.owner,
            collectible.name,
            collectible.description,
            collectible.price
        );
    }
}",13.771482229232788,getCollectibleInfo,"[{'function': 'getCollectibleInfo', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCollectibleInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""description"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nftAddress""}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Collectible""}, ""name"": ""collectible"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectibles""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectible""}, ""memberName"": ""id""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectible""}, ""memberName"": ""owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectible""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectible""}, ""memberName"": ""description""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectible""}, ""memberName"": ""price""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",26.0,0.7163972665253362,0.231681941386162,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CollectibleInfo is Ownable {

    IERC721 public nftAddress;

    struct Collectible {
        uint256 id;
        address owner;
        string name;
        string description;
        uint256 price;
    }

    mapping(uint256 => Collectible) public collectibles;

    constructor(address _nftAddress) Ownable(msg.sender) {
        nftAddress = IERC721(_nftAddress);
    }

    function getCollectibleInfo(uint256 _tokenId) public view returns (
        uint256 id,
        address owner,
        string memory name,
        string memory description,
        uint256 price
    ) {
        require(nftAddress.ownerOf(_tokenId) != address(0), ""Token does not exist"");

        Collectible storage collectible = collectibles[_tokenId];
        return (
            collectible.id,
            collectible.owner,
            collectible.name,
            collectible.description,
            collectible.price
        );
    }
}"
5627,Changing versions does not affect existing tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract STFactoryWrapper is Ownable {
    using SafeMath for uint256;

    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external onlyOwner {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        // Assuming _setProtocolVersion is a function in the STFactory contract
        (bool success, ) = _STFactoryAddress.call(abi.encodeWithSignature(""setProtocolVersion(uint8, uint8, uint8)"", _major, _minor, _patch));
        require(success, ""External call failed"");
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyContract is ERC20, Ownable {
    string public version;

    constructor(string memory _name, string memory _symbol, string memory _version) ERC20(_name, _symbol) {
        version = _version;
    }

    function setVersion(string memory newVersion) external onlyOwner {
        version = newVersion;
    }
}",12.167382955551147,setVersion,"[{'function': 'setVersion', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setVersion"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""newVersion"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""version""}, ""right"": {""type"": ""Identifier"", ""name"": ""newVersion""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.5562849770968424,0.0016433067489571,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ERC20, Ownable {
    string public version;

    constructor(string memory _name, string memory _symbol, string memory _version) ERC20(_name, _symbol) Ownable() {
        version = _version;
    }

    function setVersion(string memory newVersion) external onlyOwner {
        version = newVersion;
    }
}"
2373,Transfers tokens from a specified wallet address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
        require(_to != address(0), ""Invalid address."");
        return super.transferFrom(_from, _to, _value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenTransfer is ReentrancyGuard {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function transferTokens(address from, address to, uint256 amount) external nonReentrant {
        require(token.balanceOf(from) >= amount, ""Insufficient token balance"");
        require(token.allowance(from, msg.sender) >= amount, ""Token transfer not authorized"");

        bool sent = token.transferFrom(from, to, amount);
        require(sent, ""Token transfer failed"");
    }
}",8.052406072616577,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Token transfer not authorized""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""sent"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sent""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.6815007061549267,0.0385576613656628,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is ReentrancyGuard, Ownable {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function transferTokens(address from, address to, uint256 amount) external nonReentrant {
        require(token.balanceOf(from) >= amount, ""Insufficient token balance"");
        require(token.allowance(from, msg.sender) >= amount, ""Token transfer not authorized"");

        bool sent = token.transferFrom(from, to, amount);
        require(sent, ""Token transfer failed"");
    }
}"
3161,"Set `` _price_start '' , `` _price_constant1 '' and `` _price_exponent1 '' `` _price_constant2 '' and `` _price_exponent2 '' as the new starting price , price constant and price exponent for the auction price .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionDeployed, AuctionSetUp }
    Stages public stage;

    uint256 public price_start;
    uint256 public price_constant1;
    uint256 public price_exponent1;
    uint256 public price_constant2;
    uint256 public price_exponent2;

    function changePriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) public onlyOwner {
        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);
        require(_price_start > 0);
        require(_price_constant1 > 0);
        require(_price_constant2 > 0);

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Auction is Ownable {
    uint256 private _priceStart;
    uint256 private _priceConstant1;
    uint256 private _priceExponent1;
    uint256 private _priceConstant2;
    uint256 private _priceExponent2;

    function setAuctionParameters(
        uint256 _price_start,
        uint256 _price_constant1,
        uint256 _price_exponent1,
        uint256 _price_constant2,
        uint256 _price_exponent2
    )
        external
        onlyOwner
    {
        _priceStart = _price_start;
        _priceConstant1 = _price_constant1;
        _priceExponent1 = _price_exponent1;
        _priceConstant2 = _price_constant2;
        _priceExponent2 = _price_exponent2;
    }
}",9.465546131134031,setAuctionParameters,"[{'function': 'setAuctionParameters', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAuctionParameters"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_start"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_constant1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_exponent1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_constant2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_exponent2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_priceStart""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_start""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_priceConstant1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_constant1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_priceExponent1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_exponent1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_priceConstant2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_constant2""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_priceExponent2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_exponent2""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.7123021706297717,0.2247893863617944,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    uint256 private _priceStart;
    uint256 private _priceConstant1;
    uint256 private _priceExponent1;
    uint256 private _priceConstant2;
    uint256 private _priceExponent2;

    constructor() Ownable(msg.sender) {
        _priceStart = 1;
        _priceConstant1 = 1;
        _priceExponent1 = 1;
        _priceConstant2 = 1;
        _priceExponent2 = 1;
    }

    function setAuctionParameters(
        uint256 _price_start,
        uint256 _price_constant1,
        uint256 _price_exponent1,
        uint256 _price_constant2,
        uint256 _price_exponent2
    )
        external
        onlyOwner
    {
        _priceStart = _price_start;
        _priceConstant1 = _price_constant1;
        _priceExponent1 = _price_exponent1;
        _priceConstant2 = _price_constant2;
        _priceExponent2 = _price_exponent2;
    }
}"
1809,Nominate a new owner of this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    address public nominatedOwner;

    event OwnerNominated(address indexed newOwner);

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    function nominateNewOwner(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner address cannot be zero address"");
        transferOwnership(newOwner);
    }
}",3.05669903755188,nominateNewOwner,"[{'function': 'nominateNewOwner', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""nominateNewOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New owner address cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferOwnership""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.7895582201059395,0.119159749312327,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    // Initialize state variables in the constructor
    uint256 public constant _INITIAL_VALUE = 1;
    address public constant _DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant _DEFAULT_BOOL = true;
    string public constant _DEFAULT_STRING = 'initialized';
    bytes32 public constant _DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333) {
        super(0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333);
        // Initialize state variables
        uint256 value = _INITIAL_VALUE;
        address addr = _DEFAULT_ADDRESS;
        bool boolValue = _DEFAULT_BOOL;
        string strValue = _DEFAULT_STRING;
        bytes32 bytes32Value = _DEFAULT_BYTES32;

        // Call parent constructor with required arguments
        Ownable(msg.sender, 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333);
    }

    function nominateNewOwner(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""New owner address cannot be zero address"");
        transferOwnership(newOwner);
    }
}"
5765,set minimal amount of ether which can be used to buy tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public minSellAmount;

    function setMinSellAmount(uint256 _minSellAmount) public onlyOwner {
        minSellAmount = _minSellAmount;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is Ownable {
    uint256 public minimumPurchaseAmount;

    function setMinimumPurchaseAmount(uint256 _minimumPurchaseAmount) public onlyOwner {
        require(_minimumPurchaseAmount > 0, ""Minimum purchase amount must be greater than 0"");
        minimumPurchaseAmount = _minimumPurchaseAmount;
    }

    function buyTokens() public payable {
        require(msg.value >= minimumPurchaseAmount, ""Ether sent is less than the minimum purchase amount"");
        // ... Additional code to handle token purchase here ...
    }
}",10.105268001556396,setMinimumPurchaseAmount,"[{'function': 'setMinimumPurchaseAmount', 'complexity': 1}, {'function': 'buyTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinimumPurchaseAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minimumPurchaseAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_minimumPurchaseAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minimum purchase amount must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minimumPurchaseAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minimumPurchaseAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8324564511567402,0.106013174347812,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    uint256 public minimumPurchaseAmount;

    constructor() Ownable(msg.sender) {
        minimumPurchaseAmount = 1; // Set to a safe non-zero value
    }

    function setMinimumPurchaseAmount(uint256 _minimumPurchaseAmount) public onlyOwner {
        require(_minimumPurchaseAmount > 0, ""Minimum purchase amount must be greater than 0"");
        minimumPurchaseAmount = _minimumPurchaseAmount;
    }

    function buyTokens() public payable {
        require(msg.value >= minimumPurchaseAmount, ""Ether sent is less than the minimum purchase amount"");
        // ... Additional code to handle token purchase here ...
    }
}"
1032,Obtain the quantity which the next schedule entry will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingWrapper is Ownable {
    using SafeMath for uint256;

    uint constant QUANTITY_INDEX = 1;

    function getNextVestingEntry(address account) internal view returns (uint[] memory entry) {
        // This should be implemented by the actual contract that uses this wrapper.
        // For demonstration purposes, let's assume it returns a fixed array for any address.
        return [0, 100]; // Example: vesting quantity is 100 for any account
    }

    function getNextVestingQuantity(address account) external view returns (uint) {
        uint[] memory entry = getNextVestingEntry(account);
        return entry[QUANTITY_INDEX];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract VestingSchedule {
    using SafeMath for uint256;

    struct VestingEntry {
        uint256 amount;
        uint256 vestingDate;
    }

    mapping(address => VestingEntry[]) private _vestingSchedules;

    function getNextVestableAmount(address user) public view returns (uint256) {
        require(user != address(0), ""Invalid address"");

        VestingEntry[] memory entries = _vestingSchedules[user];

        for(uint256 i = 0; i < entries.length; ++i) {
            if (entries[i].vestingDate > block.timestamp) {
                return entries[i].amount;
            }
        }

        return 0;
    }
}",8.117622137069702,getNextVestableAmount,"[{'function': 'getNextVestableAmount', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNextVestableAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""user""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""VestingEntry""}, ""length"": None}, ""name"": ""entries"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_vestingSchedules""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""entries""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": True}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""entries""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""vestingDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""entries""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""amount""}]}, ""FalseBody"": None}]}}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",30.0,0.700429893006713,0.0272409953649349,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract VestingSchedule is Ownable {
    using SafeMath for uint256;

    struct VestingEntry {
        uint256 amount;
        uint256 vestingDate;
    }

    mapping(address => VestingEntry[]) private _vestingSchedules;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getNextVestableAmount(address user) public view returns (uint256) {
        require(user != address(0), ""Invalid address"");

        VestingEntry[] memory entries = _vestingSchedules[user];

        for(uint256 i = 0; i < entries.length; ++i) {
            if (entries[i].vestingDate > block.timestamp) {
                return entries[i].amount;
            }
        }

        return 0;
    }
}"
2223,Verifies that two token requirements can be matched and that the tokens are formatted correctly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenVerifier is Ownable {
    using SafeMath for uint256;

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        return ((uint32(_buyTokens) == uint32(_sellToken >> 32)) && (uint32(_sellToken) == uint32(_buyTokens >> 32)) && (uint32(_buyTokens >> 32) <= uint32(_buyTokens)));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MatchTokenRequirements {
    using SafeERC20 for IERC20;

    function verifyTokenRequirements(IERC20 tokenA, uint256 amountA, IERC20 tokenB, uint256 amountB) public view returns (bool) {
        // require statements to ensure that tokens and amounts are filled correctly
        require(address(tokenA) != address(0), ""Token A address is 0"");
        require(address(tokenB) != address(0), ""Token B address is 0"");
        require(amountA > 0, ""Amount A is 0"");
        require(amountB > 0, ""Amount B is 0"");

        // require statements to ensure that token balances are adequate
        require(tokenA.balanceOf(msg.sender) >= amountA, ""Insufficient token A balance"");
        require(tokenB.balanceOf(msg.sender) >= amountB, ""Insufficient token B balance"");

        return true;
    }
}",9.885357856750488,verifyTokenRequirements,"[{'function': 'verifyTokenRequirements', 'complexity': 6}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyTokenRequirements"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""tokenA"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountA"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""tokenB"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountB"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenA""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token A address is 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenB""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token B address is 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amountA""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount A is 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amountB""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount B is 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenA""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amountA""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token A balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenB""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amountB""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token B balance""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",52.0,0.6361782136430801,0.0426988098081111,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MatchTokenRequirements is Ownable {
    using SafeERC20 for IERC20;

    uint256 public constant AMOUNT_A = 1;
    uint256 public constant AMOUNT_B = 1;
    address public constant TOKEN_A = 0x1111111111111111111111111111111111111111; // Replace with actual token address
    address public constant TOKEN_B = 0x2222222222222222222222222222222222222222; // Replace with actual token address

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        _setTokenA(TOKEN_A);
        _setTokenB(TOKEN_B);
        _setAmountA(AMOUNT_A);
        _setAmountB(AMOUNT_B);
    }

    function verifyTokenRequirements(IERC20 tokenA, uint256 amountA, IERC20 tokenB, uint256 amountB) public view returns (bool) {
        // require statements to ensure that tokens and amounts are filled correctly
        require(address(tokenA) != address(0), ""Token A address is 0"");
        require(address(tokenB) != address(0), ""Token B address is 0"");
        require(amountA > 0, ""Amount A is 0"");
        require(amountB > 0, ""Amount B is 0"");

        // require statements to ensure that token balances are adequate
        require(tokenA.balanceOf(msg.sender) >= amountA, ""Insufficient token A balance"");
        require(tokenB.balanceOf(msg.sender) >= amountB, ""Insufficient token B balance"");

        return true;
    }

    function _setTokenA(address tokenA) internal {
        require(tokenA != address(0), ""Token A address is 0"");
        TOKEN_A = tokenA;
    }

    function _setTokenB(address tokenB) internal {
        require(tokenB != address(0), ""Token B address is 0"");
        TOKEN_B = tokenB;
    }

    function _setAmountA(uint256 amountA) internal {
        require(amountA > 0, ""Amount A is 0"");
        AMOUNT_A = amountA;
    }

    function _setAmountB(uint256 amountB) internal {
        require(amountB > 0, ""Amount B is 0"");
        AMOUNT_B = amountB;
    }
}"
3500,"Transfers ` amount ` of ` token ` to ` dest ` , only used internally , and does not throw , will always return ` true ` or ` false `","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract PaymentWrapper is Ownable {
    using SafeMath for uint256;

    event Withdraw(uint indexed idDeposit, address indexed dest, ERC20 token, uint amount);

    function doPayment(uint _idDeposit, address _dest, ERC20 _token, uint _amount) public onlyOwner returns (bool) {
        if (_amount == 0) return true;
        if (address(_token) == address(0)) {
            require(_dest.send(_amount), ""Transfer failed"");
        } else {
            require(_token.transfer(_dest, _amount), ""Token transfer failed"");
        }
        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Transfer {
    function transferToken(IERC20 token, address dest, uint256 amount) internal returns (bool) {
        bytes memory empty;
        bool success = address(token).call(abi.encodeWithSelector(token.transfer.selector, dest, amount));
        return success;
    }
}",4.459135055541992,transferToken,"[{'function': 'transferToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""dest"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""empty"", ""storageLocation"": ""memory""}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""memberName"": ""selector""}, {""type"": ""Identifier"", ""name"": ""dest""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""success""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.6501110827743123,0.0552688376410665,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Transfer is Ownable {
    function transferToken(IERC20 token, address dest, uint256 amount) internal returns (bool) {
        bytes memory empty;
        bool success = address(token).call(abi.encodeWithSelector(token.transfer.selector, dest, amount));
        return success;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
4517,returns the block number when the order being last modified .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;

    struct Order {
        uint256 blockNumber;
    }

    mapping(uint256 => Order) public orders;

    function orderBlockNumber(uint256 _orderID) external view returns (uint256) {
        return orders[_orderID].blockNumber;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract OrderHistory is Ownable {
    mapping(uint256 => uint256) private orderLastModifiedBlock;

    function setOrderLastModifiedBlock(uint256 orderId) public onlyOwner {
        orderLastModifiedBlock[orderId] = block.number;
    }

    function getOrderLastModifiedBlock(uint256 orderId) public view returns (uint256) {
        require(orderLastModifiedBlock[orderId] > 0, ""Order not found"");
        return orderLastModifiedBlock[orderId];
    }
}",11.210586309432983,getOrderLastModifiedBlock,"[{'function': 'setOrderLastModifiedBlock', 'complexity': 0}, {'function': 'getOrderLastModifiedBlock', 'complexity': 1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getOrderLastModifiedBlock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""orderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderLastModifiedBlock""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderId""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Order not found""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderLastModifiedBlock""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",9.0,0.6941041673135212,0.2128170138071292,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OrderHistory is Ownable {
    mapping(uint256 => uint256) private orderLastModifiedBlock;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            orderLastModifiedBlock[i] = block.number;
        }
    }

    function setOrderLastModifiedBlock(uint256 orderId) public onlyOwner {
        require(orderId > 0 && orderId <= 3, ""Invalid order ID"");
        orderLastModifiedBlock[orderId] = block.number;
    }

    function getOrderLastModifiedBlock(uint256 orderId) public view returns (uint256) {
        require(orderId > 0 && orderId <= 3, ""Invalid order ID"");
        return orderLastModifiedBlock[orderId];
    }
}"
868,batch send the current balance to the new version contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;
function migrateByAdmin_DQV (uint256[] inputs) external onlyAdmin {
    uint256 data = inputs[2];
    address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];
    address newContract = address(inputs[0]);
    for (uint256 i = 1; i < inputs.length; i += 4) {
        uint256 gasFee = inputs[i];
        data = inputs[i + 1];
        address user = userId2Address[data & USER_MASK];
        bytes32 hash = keccak256(this, gasFee, data & SIGN_MASK | uint256(token), newContract);
        require(verify(hash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 2]), bytes32(inputs[i + 3])));
        if (gasFee > 0) {
            uint256 paymentMethod = data & PAYMENT_METHOD_MASK;
            if (paymentMethod == PAY_BY_JOY) {
                balances[joyToken][user] = balances[joyToken][user].sub(gasFee);
                balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(gasFee);
            } else if (paymentMethod == PAY_BY_TOKEN) {
                balances[token][user] = balances[token][user].sub(gasFee);
                balances[token][joysoWallet] = balances[token][joysoWallet].add(gasFee);
            } else {
                balances[0][user] = balances[0][user].sub(gasFee);
                balances[0][joysoWallet] = balances[0][joysoWallet].add(gasFee);
            }
        }
        uint256 amount = balances[token][user];
        balances[token][user] = 0;
        if (token == 0) {
            Migratable(newContract).migrate.value(amount)(user, amount, token);
        } else {
            ERC20(token).approve(newContract, amount);
            Migratable(newContract).migrate(user, amount, token);
        }
    }
}
}","// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract OldVersionContract is ERC20, Ownable {
    mapping (address => uint256) private balances;

    function batchSendBalanceToNewVersionContract(address[] calldata receivers, address newVersionContractAddress) external onlyOwner {
        require(newVersionContractAddress != address(0), ""New contract address cannot be 0 address"");

        for (uint256 i = 0; i < receivers.length; i++) {
            uint256 balance = balances[receivers[i]];
            require(balance > 0, ""No balance to transfer"");

            //deduct balance
            balances[receivers[i]] = 0;

            (bool success, ) = newVersionContractAddress.call{value: balance}("""");
            require(success, ""Transfer failed"");
        }
    }
}",12.1230628490448,batchSendBalanceToNewVersionContract,"[{'function': 'batchSendBalanceToNewVersionContract', 'complexity': 4}]",5.0,{},155.0,0.5270708303176591,0.0293830781242473,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OldVersionContract is ERC20, Ownable {
    mapping (address => uint256) private balances;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            if (i == 0) balances[address(this)] = 1;
            else if (i == 1) balances[msg.sender] = 1000;
            else balances[address(0x3333333333333333333333333333333333333333)] = 1; // Placeholder for the third address
        }
    }

    function batchSendBalanceToNewVersionContract(address[] calldata receivers, address newVersionContractAddress) external onlyOwner {
        require(newVersionContractAddress != address(0), ""New contract address cannot be 0 address"");

        for (uint256 i = 0; i < receivers.length; i++) {
            uint256 balance = balances[receivers[i]];
            require(balance > 0, ""No balance to transfer"");

            //deduct balance
            balances[receivers[i]] = 0;

            (bool success, ) = newVersionContractAddress.call{value: balance}("""");
            require(success, ""Transfer failed"");
        }
    }
}"
2092,Get a player 's current instant pot winnings .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    struct TeamData {
        uint256 mask;
        uint256 keys;
    }

    struct PlayerTeamData {
        uint256 mask;
        uint256 keys;
    }

    mapping(uint256 => mapping(uint256 => TeamData)) public teams_;
    mapping(uint256 => mapping(uint256 => mapping(uint256 => PlayerTeamData))) public playerTeams_;

    modifier isActivated(uint256 _gameID) {
        require(_gameID > 0 && _gameID < 10, ""Game must be activated"");
        _;
    }

    modifier isValidTeam(uint256 _gameID, uint256 _team) {
        require(_team > 0 && _team <= 3, ""Invalid team"");
        _;
    }

    function getPlayerInstWinning(uint256 _gameID, uint256 _pID, uint256 _team) public view isActivated(_gameID) isValidTeam(_gameID, _team) returns (uint256) {
        return (((teams_[_gameID][_team].mask).mul(playerTeams_[_pID][_gameID][_team].keys)) / (1000000000000000000)).sub(playerTeams_[_pID][_gameID][_team].mask));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract BettingGame is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private playerWinnings;

    function getPlayerWinnings(address _player) public view returns (uint256) {
        require(_player != address(0), ""Invalid address!"");
        return playerWinnings[_player];
    }
}",4.675877094268799,getPlayerWinnings,"[{'function': 'getPlayerWinnings', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPlayerWinnings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_player"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_player""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address!""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""playerWinnings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_player""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",36.0,0.5811331104872481,0.0927793651544312,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract BettingGame is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private playerWinnings;

    constructor() Ownable(0x1111111111111111111111111111111111111111 , 0x2222222222222222222222222222222222222222) {
        super(0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, msg.sender);
        playerWinnings[msg.sender] = 1;
    }

    function getPlayerWinnings(address _player) public view returns (uint256) {
        require(_player != address(0), ""Invalid address!"");
        return playerWinnings[_player];
    }
}"
1597,add more ether to use in oraclize queries,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/SafeMath.sol"";

abstract contract TopUpContract is Ownable {
    using SafeMath for uint256;

    function topUp() external payable {
        // Function implementation here
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""https://github.com/provable-things/ethereum-api/blob/master/oraclizeAPI_0.5.sol"";

contract OraclizeContract is usingOraclize {

    function addMoreEtherForOraclize() public payable {
        // Ensure the transaction value is more than the Oraclize query cost
        require(msg.value > oraclize_getPrice(""URL""), ""Not enough Ether provided."");
    }
}",6.251795053482056,addMoreEtherForOraclize,"[{'function': 'addMoreEtherForOraclize', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addMoreEtherForOraclize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""oraclize_getPrice""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""URL""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Not enough Ether provided.""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",13.0,0.4608083936007135,0.0359544048064704,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""https://github.com/provable-things/ethereum-api/blob/master/oraclizeAPI_0.5.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for Ownable usage
import ""openzeppelin/SafeMath.sol"";
contract OraclizeContract is usingOraclize, Ownable {
    constructor() public payable {
        require(msg.value > oraclize_getPrice(""URL""), ""Not enough Ether provided."");
        __Ownable_init();
        // No need to initialize state variables as they are already set in the parent contract initialization
    }
}"
3185,To check if an address is a contract or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractChecker is Ownable {
    using SafeMath for uint256;

    function isContract(address addr) public pure returns (bool _isContract) {
        require(addr != address(0));
        uint256 length;
        assembly {
            length := extcodesize(addr)
        }
        return (length > 0);
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

function isContract(address _addr) public view returns (bool) {
    uint32 size;
    assembly {
        size := extcodesize(_addr)
    }
    return (size > 0);
}",7.59233832359314,isContract,"[{'function': 'isContract', 'complexity': 0}]",1.0,{},29.0,0.8808062338280118,0.2815155704214018,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant MAX_SUPPLY = 1;
    address public owner;
    bool public initialized = true;
    bytes32 public constant INITIALIZED_VALUE = keccak256(""init"");
    string public constant TOKEN_NAME = ""MyToken"";

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
    }
}"
146,Add to the amount this member has bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function addAmountBoughtAsMember(address _member, uint256 _amountBought) external onlyOwner {
        // Add the logic to update the member's amount bought here.
        // For example:
        // members[_member] = members[_member].add(_amountBought);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    mapping(address => uint256) private memberPurchases;

    function addMemberPurchase(address _member, uint256 _amount) public {
        require(_member != address(0), ""Invalid address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        memberPurchases[_member] = memberPurchases[_member].add(_amount);
    }
}",5.62116813659668,addMemberPurchase,"[{'function': 'addMemberPurchase', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addMemberPurchase"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_member"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_member""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""memberPurchases""}, ""index"": {""type"": ""Identifier"", ""name"": ""_member""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""memberPurchases""}, ""index"": {""type"": ""Identifier"", ""name"": ""_member""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.8069185642227092,0.1123500520714672,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private memberPurchases;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        memberPurchases[address(0x111)] = 1;
        memberPurchases[address(0x222)] = 1;
        memberPurchases[address(0x333)] = 1;
    }

    function addMemberPurchase(address _member, uint256 _amount) public {
        require(_member != address(0), ""Invalid address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        memberPurchases[_member] = memberPurchases[_member].add(_amount);
    }
}"
5173,` msg.sender ` approves ` spender ` to spend ` value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Success }
    State public state = State.Initial;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function getState() internal pure returns (State) {
        return State.Success;
    }

    function approve(address spender, uint256 value) external returns (bool ok) {
        require(getState() == State.Success, ""Contract not in success state"");
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {

    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function approveSpender(address spender, uint256 value) public returns (bool) {
        require(spender != address(0), ""Invalid spender address."");
        require(value <= balanceOf(msg.sender), ""Not enough balance."");

        _approve(msg.sender, spender, value);

        return true;
    }
}",9.994723796844482,approveSpender,"[{'function': 'approveSpender', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Not enough balance.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.8701020500992257,0.3683708417261671,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function approveSpender(address spender, uint256 value) public returns (bool) {
        require(spender != address(0), ""Invalid spender address."");
        require(value <= balanceOf(msg.sender), ""Not enough balance."");

        _approve(msg.sender, spender, value);

        return true;
    }
}"
4527,Funtion to let users claim their tokens at the end of ico process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenReward {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaim is Ownable {
    using SafeMath for uint256;

    enum State { Pending, Successful, Failed }
    State public state = State.Pending;

    mapping(address => uint256) public pending;
    ITokenReward public tokenReward;

    event LogContributorsPayout(address indexed user, uint256 amount);

    function claimTokensByUser() public {
        require(state == State.Successful, ""State must be Successful"");
        uint256 temp = pending[msg.sender];
        pending[msg.sender] = 0;
        require(tokenReward.transfer(msg.sender, temp), ""Token transfer failed"");
        emit LogContributorsPayout(msg.sender, temp);
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract ICO is ReentrancyGuard {

    IERC20 public token;
    address public admin;
    uint256 public endICOTime;
    mapping(address => uint256) public balances;

    constructor(IERC20 _token) {
        token = _token;
        admin = msg.sender;
        endICOTime = block.timestamp + 1 weeks; // Assuming ICO ends in one week.
    }

    modifier onlyAfterICO() {
        require(block.timestamp > endICOTime, ""ICO is still ongoing."");
        _;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function."");
        _;
    }

    //user will claim their tokens at the end of the ico process
    function claimTokens() external nonReentrant onlyAfterICO {
        uint256 balance = balances[msg.sender];
        require(balance > 0, ""No tokens to claim.""); // Ensure the user has tokens to claim.
        balances[msg.sender] = 0;
        token.transfer(msg.sender, balance);
    }
}",12.27999210357666,claimTokens,"[{'function': 'claimTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to claim.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyAfterICO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.7765794462883994,0.0503881761632504,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ICO is ReentrancyGuard, Ownable {
    IERC20 public token;
    address private _admin;
    uint256 public endICOTime;
    mapping(address => uint256) public balances;

    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
        endICOTime = block.timestamp + 1 weeks; // Assuming ICO ends in one week.
    }

    modifier onlyAfterICO() {
        require(block.timestamp > endICOTime, ""ICO is still ongoing."");
        _;
    }

    function claimTokens() external nonReentrant onlyAfterICO {
        uint256 balance = balances[msg.sender];
        require(balance > 0, ""No tokens to claim.""); // Ensure the user has tokens to claim.
        balances[msg.sender] = 0;
        token.transfer(msg.sender, balance);
    }
}"
5993,"Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(uint256 => address) private tokenOwnerMap;
    mapping(address => bool) public approvedContractAddresses;

    function ownerOf(uint256 _tokenId) public view returns (address) {
        return tokenOwnerMap[_tokenId];
    }

    function isSenderApprovedFor(uint256 _tokenId) public view returns (bool) {
        return approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin;
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_from == ownerOf(_tokenId), ""wrong owner"");
        require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin), ""not an approved sender"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);
    }

    function _clearApprovalAndTransfer(address from, address to, uint256 tokenId) internal {
        require(from != address(0));
        require(to != address(0));
        require(ownerOf(tokenId) == from);

        // Clear existing approval
        delete tokenOwnerMap[tokenId];

        // Transfer ownership
        tokenOwnerMap[tokenId] = to;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract TokenTransfer {
    using SafeERC20 for IERC20;

    function transferFrom(address token, address from, address to, uint256 amount) public {
        IERC20(token).safeTransferFrom(from, to, amount);
    }
}",4.066282033920288,transferFrom,"[{'function': 'transferFrom', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.6264998814882231,0.1135844543141415,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    using SafeERC20 for IERC20;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function transferFrom(address token, address from, address to, uint256 amount) public {
        IERC20(token).safeTransferFrom(from, to, amount);
    }
}"
2061,Checks if the notary 's signature to close the ` DataResponse ` is valid .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NotaryVerifier is Ownable {
    using SafeMath for uint256;

    function isNotaryVeredictValid(address order, address seller, address notary, bool wasAudited, bool isDataValid, bytes memory notarySignature) public pure returns (bool) {
        require(order != address(0));
        require(seller != address(0));
        require(notary != address(0));
        bytes32 hash = keccak256(abi.encodePacked(order, seller, wasAudited, isDataValid));
        return isSignedBy(hash, notary, notarySignature);
    }

    function isSignedBy(bytes32 hash, address signer, bytes memory signature) internal pure returns (bool) {
        require(signer != address(0));
        return signer == ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)), 27 + uint8(signature[64]), signature[:64], signature[64]);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";

contract Notary {

    // Mapping of valid notaries
    mapping(address => bool) public notaries;

    // Note: The actual struct can have more properties based on your use case
    struct DataResponse {
        bytes32 hash;
        address notaryAddress;
        bytes signature;
    }

    function checkNotarySignature(DataResponse memory response) public view returns (bool) {
        require(notaries[response.notaryAddress], ""NOTARY: INVALID_NOTARY_ADDRESS"");

        // Recover signer from the signature
        address signer = ECDSA.recover(
            ECDSA.toEthSignedMessageHash(response.hash),
            response.signature
        );

        // Check if the signer is the same as notary
        return (signer == response.notaryAddress);
    }

    // Use this function to add a new notary to the list of valid notaries
    function addNotary(address _notaryAddress) external {
        // Add your own access control logic here
        notaries[_notaryAddress] = true;
    }

    // Use this function to remove a notary from the list of valid notaries
    function removeNotary(address _notaryAddress) external {
        // Add your own access control logic here
        notaries[_notaryAddress] = false;
    }
}",8.963929891586304,checkNotarySignature,"[{'function': 'checkNotarySignature', 'complexity': 1}, {'function': 'addNotary', 'complexity': 0}, {'function': 'removeNotary', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkNotarySignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DataResponse""}, ""name"": ""response"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""notaries""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""response""}, ""memberName"": ""notaryAddress""}}, {""type"": ""stringLiteral"", ""value"": ""NOTARY: INVALID_NOTARY_ADDRESS""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ECDSA""}, ""memberName"": ""recover""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ECDSA""}, ""memberName"": ""toEthSignedMessageHash""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""response""}, ""memberName"": ""hash""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""response""}, ""memberName"": ""signature""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""signer""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""response""}, ""memberName"": ""notaryAddress""}}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",34.0,0.6367126056924979,0.1019744652378243,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Notary is Ownable {
    // Mapping of valid notaries
    mapping(address => bool) public notaries;

    // Note: The actual struct can have more properties based on your use case
    struct DataResponse {
        bytes32 hash;
        address notaryAddress;
        bytes signature;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function checkNotarySignature(DataResponse memory response) public view returns (bool) {
        require(notaries[response.notaryAddress], ""NOTARY: INVALID_NOTARY_ADDRESS"");

        // Recover signer from the signature
        address signer = ECDSA.recover(
            ECDSA.toEthSignedMessageHash(response.hash),
            response.signature
        );

        // Check if the signer is the same as notary
        return (signer == response.notaryAddress);
    }

    // Use this function to add a new notary to the list of valid notaries
    function addNotary(address _notaryAddress) external {
        // Add your own access control logic here
        notaries[_notaryAddress] = true;
    }

    // Use this function to remove a notary from the list of valid notaries
    function removeNotary(address _notaryAddress) external {
        // Add your own access control logic here
        notaries[_notaryAddress] = false;
    }
}"
1609,Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeTokenFactory {
    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) external returns (MiniMeToken);
}

abstract contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    address public factory;
    string public name;
    uint8 public decimals;
    string public symbol;
    bool public transfersEnabled;
    uint256 public snapshotBlock;

    constructor(address _factory, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) {
        factory = _factory;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        transfersEnabled = _transfersEnabled;
        snapshotBlock = _snapshotBlock > block.number ? block.number : _snapshotBlock;
    }

    function changeController(address _newController) public onlyOwner {
        require(_newController != address(0), ""Invalid controller address"");
        // Controller logic here
    }
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    MiniMeTokenFactory public tokenFactory;

    event NewCloneToken(address indexed cloneTokenAddress, uint256 snapshotBlock);

    constructor(MiniMeTokenFactory _tokenFactory) {
        tokenFactory = _tokenFactory;
    }

    function createCloneToken(string memory _cloneTokenName, uint8 _cloneDecimalUnits, string memory _cloneTokenSymbol, uint256 _snapshotBlock, bool _transfersEnabled) public returns (address) {
        if (_snapshotBlock > block.number) {
            _snapshotBlock = block.number;
        }
        MiniMeToken cloneToken = tokenFactory.createCloneToken(address(this), _snapshotBlock, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled);
        cloneToken.changeController(msg.sender);
        emit NewCloneToken(address(cloneToken), _snapshotBlock);
        return address(cloneToken);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Token is ERC20, ERC20Snapshot, Ownable {

    function createCloneToken(string memory _cloneTokenName, string memory _cloneTokenSymbol, uint256 _snapshotBlock) public onlyOwner returns (address) {
        require(block.number > _snapshotBlock, ""Snapshot block must be in the past"");
        Token cloneToken = new Token(_cloneTokenName, _cloneTokenSymbol);
        _snapshot(cloneToken, _snapshotBlock);
        return address(cloneToken);
    }

    function _snapshot(Token _cloneToken, uint256 _snapshotBlock) private {
        for (uint256 i = 0; i < totalSupply(); i++) {
            address account = address(i);
            uint256 balance = balanceOfAt(account, _snapshotBlock);
            _cloneToken.mint(account, balance);
        }
    }

    function mint(address _to, uint256 _amount) public onlyOwner {
        _mint(_to, _amount);
    }
}",18.126140832901,_snapshot,"[{'function': 'createCloneToken', 'complexity': 1}, {'function': '_snapshot', 'complexity': 1}, {'function': 'mint', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_cloneTokenName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_cloneTokenSymbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_snapshotBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""right"": {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}}, {""type"": ""stringLiteral"", ""value"": ""Snapshot block must be in the past""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}, ""name"": ""cloneToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_cloneTokenName""}, {""type"": ""Identifier"", ""name"": ""_cloneTokenSymbol""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_snapshot""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cloneToken""}, {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cloneToken""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.7118405259095848,0.0695921333393594,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is ERC20, ERC20Snapshot, Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 1 * 10**uint256(decimals());
        _mint(msg.sender, initialSupply);
    }

    function createCloneToken(string memory _cloneTokenName, string memory _cloneTokenSymbol, uint256 _snapshotBlock) public onlyOwner returns (address) {
        require(block.number > _snapshotBlock, ""Snapshot block must be in the past"");
        Token cloneToken = new Token(_cloneTokenName, _cloneTokenSymbol);
        _snapshot(cloneToken, _snapshotBlock);
        return address(cloneToken);
    }

    function _snapshot(Token _cloneToken, uint256 _snapshotBlock) private {
        for (uint256 i = 0; i < totalSupply(); i++) {
            address account = address(i);
            uint256 balance = balanceOfAt(account, _snapshotBlock);
            _cloneToken.mint(account, balance);
        }
    }

    function mint(address _to, uint256 _amount) public onlyOwner {
        _mint(_to, _amount);
    }
}"
2752,"If you lock 50 % , the lockout time is six months .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _lockupBalances;
    mapping(address => uint256) private _lockupExpireTime;
    address public owner;
    uint256 public constant LOCKUP_TERM = 30 days; // Example lockup term, adjust as needed

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    function distribute(address _to, uint256 _value, uint256 _lockupRate) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_to != address(this));
        require(_lockupBalances[_to] == 0);
        require(_value <= _balances[owner]);
        require(_lockupRate == 50 || _lockupRate == 100);

        uint256 lockupValue = _value.mul(_lockupRate).div(100);
        uint256 givenValue = _value.sub(lockupValue);
        uint256 ExpireTime = now + LOCKUP_TERM;

        if (_lockupRate == 100) {
            ExpireTime += LOCKUP_TERM;
        }

        _balances[owner] = _balances[owner].sub(_value);
        _balances[_to] = _balances[_to].add(givenValue);
        _lockupBalances[_to] = _lockupBalances[_to].add(lockupValue);
        _lockupExpireTime[_to] = ExpireTime;

        emit Transfer(owner, _to, _value);

        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract LockToken is Ownable {
    using SafeERC20 for IERC20;

    uint256 private lockPercentage = 50;
    uint256 private lockDuration = 6 * 30 days;  // approximately six months
    mapping (address => uint256) public lockedBalances;
    mapping (address => uint256) public lockTime;

    function setLockPercentage(uint256 _lockPercentage) public onlyOwner {
        lockPercentage = _lockPercentage;
    }

    function setLockDuration(uint256 _lockDuration) public onlyOwner {
        lockDuration = _lockDuration;
    }

    function lockTokens(IERC20 _token, uint256 _amount) public {
        uint256 lockAmount = _amount * lockPercentage / 100;
        lockedBalances[msg.sender] += lockAmount;
        lockTime[msg.sender] = block.timestamp + lockDuration;
        _token.safeTransferFrom(msg.sender, address(this), lockAmount);
    }

    function unlockTokens(IERC20 _token) public {
        require(block.timestamp > lockTime[msg.sender], ""Tokens are still locked!"");
        uint256 amount = lockedBalances[msg.sender];
        lockedBalances[msg.sender] -= amount;
        _token.safeTransfer(msg.sender, amount);
    }
}",9.030533075332642,lockTokens,"[{'function': 'setLockPercentage', 'complexity': 0}, {'function': 'setLockDuration', 'complexity': 0}, {'function': 'lockTokens', 'complexity': 0}, {'function': 'unlockTokens', 'complexity': 2}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""lockTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lockAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""lockPercentage""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockedBalances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""lockAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockTime""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""lockDuration""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""lockAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",101.0,0.5730237046112183,0.0090386177740708,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LockToken is Ownable {
    using SafeERC20 for IERC20;

    uint256 private lockPercentage = 50;
    uint256 private lockDuration = 6 * 30 days;  // approximately six months
    mapping (address => uint256) public lockedBalances;
    mapping (address => uint256) public lockTime;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules provided:
        // uint256: Set to 1 (never 0)
        lockPercentage = 50;
        lockDuration = 6 * 30 days;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // This is a placeholder for the actual initialization logic.
    }

    function setLockPercentage(uint256 _lockPercentage) public onlyOwner {
        lockPercentage = _lockPercentage;
    }

    function setLockDuration(uint256 _lockDuration) public onlyOwner {
        lockDuration = _lockDuration;
    }

    function lockTokens(IERC20 _token, uint256 _amount) public {
        uint256 lockAmount = _amount * lockPercentage / 100;
        lockedBalances[msg.sender] += lockAmount;
        lockTime[msg.sender] = block.timestamp + lockDuration;
        _token.safeTransferFrom(msg.sender, address(this), lockAmount);
    }

    function unlockTokens(IERC20 _token) public {
        require(block.timestamp > lockTime[msg.sender], ""Tokens are still locked!"");
        uint256 amount = lockedBalances[msg.sender];
        lockedBalances[msg.sender] -= amount;
        _token.safeTransfer(msg.sender, amount);
    }
}"
6641,Make bulk transfer of tokens to many addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        // Implementation of the transfer function
    }

    function transferToMany(address[] memory _addrs, uint256[] memory _amounts) public returns (bool) {
        require(_addrs.length == _amounts.length);
        for (uint256 i = 0; i < _addrs.length; i++) {
            require(transfer(_addrs[i], _amounts[i]));
        }
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract BulkTransfer {
    using SafeERC20 for ERC20;

    function bulkTransfer(address _token, address[] memory _to, uint256[] memory _values) public {
        require(_to.length == _values.length, ""Mismatch between addresses and values arrays."");

        ERC20 token = ERC20(_token);

        for (uint256 i = 0; i < _to.length; i++) {
            token.safeTransferFrom(msg.sender, _to[i], _values[i]);
        }
    }
}",7.131237983703613,bulkTransfer,"[{'function': 'bulkTransfer', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""bulkTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_to"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_values"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_values""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Mismatch between addresses and values arrays.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_to""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_values""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.5925319064069885,0.256559250600066,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BulkTransfer is Ownable, ERC20 {
    using SafeERC20 for ERC20;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialization of state variables:
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function bulkTransfer(address _token, address[] memory _to, uint256[] memory _values) public {
        require(_to.length == _values.length, ""Mismatch between addresses and values arrays."");

        ERC20 token = ERC20(_token);

        for (uint256 i = 0; i < _to.length; i++) {
            token.safeTransferFrom(msg.sender, _to[i], _values[i]);
        }
    }
}"
2380,The contract address is always the message sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721ReceiverWrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4) {
        require(_operator == address(this), ""Only this contract can receive ERC721 tokens"");
        require(_data.length > 0, ""Data must be non-empty"");
        require(_from != address(0), ""From address cannot be zero"");
        require(_tokenId > 0, ""Token ID must be greater than zero"");

        // Handle the ERC721 token transfer

        return IERC721Receiver(_operator).onERC721Received.selector;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyContract {
    address private contractAddress;

    constructor() {
        contractAddress = msg.sender;
    }

    function updateContractAddress() public {
        require(msg.sender == contractAddress, ""Caller is not the contract owner"");
        contractAddress = msg.sender;
    }
}",3.960990190505981,updateContractAddress,"[{'function': 'updateContractAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""contractAddress""}}, {""type"": ""stringLiteral"", ""value"": ""Caller is not the contract owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contractAddress""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",39.0,0.3587531503189405,0.0031134180774078,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address private contractAddress;

    constructor() Ownable(msg.sender) {
        contractAddress = msg.sender;
    }

    function updateContractAddress() public {
        require(msg.sender == contractAddress, ""Caller is not the contract owner"");
        contractAddress = msg.sender;
    }
}"
4661,"Sends an ` _amount ` of ` baseToken ` to ` _to ` from this contract , and it can only be called by the contract itself","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

abstract contract WrappedTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public baseToken;

    constructor(IERC20 _baseToken) {
        baseToken = _baseToken;
    }

    function transfer(address _to, uint256 _amount) external onlyOwner {
        if (address(baseToken) != 0) {
            require(baseToken.transfer(_to, _amount));
        } else {
            require(_to.send(_amount));
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyContract {
    ERC20 public baseToken;

    constructor(ERC20 _baseToken) {
        baseToken = _baseToken;
    }

    function sendBaseToken(address _to, uint256 _amount) internal {
        require(baseToken.balanceOf(address(this)) >= _amount, ""Insufficient baseToken balance in contract"");
        baseToken.transfer(_to, _amount);
    }
}",5.378213167190552,sendBaseToken,"[{'function': 'sendBaseToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendBaseToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""baseToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient baseToken balance in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""baseToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.7912076305246946,0.3314798609947901,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    ERC20 public baseToken;

    mapping(address => uint256) public balanceOf;

 constructor(ERC20 _baseToken) Ownable(msg.sender) {
        baseToken = _baseToken;
    }

    function sendBaseToken(address _to, uint256 _amount) internal {
        require(baseToken.balanceOf(address(this)) >= _amount, ""Insufficient baseToken balance in contract"");
        baseToken.transfer(_to, _amount);
    }
}"
3343,Allow pre-approved user to take ownership of a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) public onlyOwner {
        // Implementation of the takeOwnership function
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyNFTContract is ERC721, Ownable {
    using Address for address;

    mapping (uint256 => address) private _tokenApprovals;

    function approve(address to, uint256 tokenId) public virtual onlyOwner {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),
            ""ERC721: approve caller is not owner nor approved for all""
        );

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public virtual {
        // Checks to ensure the msg.sender is approved to transfer the token
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");

        _transfer(from, to, tokenId);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }

}",13.744304180145264,approve,"[{'function': 'approve', 'complexity': 3}, {'function': 'transferFrom', 'complexity': 1}, {'function': '_isApprovedOrOwner', 'complexity': 0}, {'function': 'getApproved', 'complexity': 1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC721""}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""ERC721: approval to current owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isApprovedForAll""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC721: approve caller is not owner nor approved for all""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_tokenApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",48.0,0.6062615275663139,0.0086058329325038,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyNFTContract is ERC721, Ownable {
    using Address for address;

    mapping (uint256 => address) private _tokenApprovals;

    constructor() ERC721(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function approve(address to, uint256 tokenId) public virtual onlyOwner {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, ""ERC721: approval to current owner"");

        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),
            ""ERC721: approve caller is not owner nor approved for all""
        );

        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public virtual {
        require(_isApprovedOrOwner(msg.sender, tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), ""ERC721: approved query for nonexistent token"");
        return _tokenApprovals[tokenId];
    }
}"
6562,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) external payable returns (bool) {
        return true;
    }
}","// Import OpenZeppelin's Ownable contract for basic authorization control
import ""@openzeppelin/contracts/access/Ownable.sol"";
// Import OpenZeppelin's SafeMath contract for safe arithmetic operations
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    // Event to notify when Ether is received
    event EtherReceived(address indexed _owner, uint256 value);

    // This function is called when the _owner sends ether to the MiniMe Token contract
    function receiveEther() external payable onlyOwner {
        require(msg.value > 0, ""Ether value must be greater than 0"");
        _balances[msg.sender] = _balances[msg.sender].add(msg.value);
        emit EtherReceived(msg.sender, msg.value);
    }

    // Function to check balance of a specific address
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}",6.64726996421814,receiveEther,"[{'function': 'receiveEther', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""receiveEther"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Ether value must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""EtherReceived""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",32.0,0.4444975387615849,0.0235544299348887,"// Import OpenZeppelin's Ownable contract for basic authorization control
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
// Import OpenZeppelin's SafeMath contract for safe arithmetic operations
import ""openzeppelin/SafeMath.sol"";

contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    // Event to notify when Ether is received
    event EtherReceived(address indexed _owner, uint256 value);

    // This function is called when the _owner sends ether to the MiniMe Token contract
    function receiveEther() external payable onlyOwner {
        require(msg.value > 0, ""Ether value must be greater than 0"");
        _balances[msg.sender] = _balances[msg.sender].add(msg.value);
        emit EtherReceived(msg.sender, msg.value);
    }

    // Function to check balance of a specific address
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
52,Function to claim any token stuck on contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface token {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Successful }
    State public state = State.Initial;

    address public creator;

    constructor(address _creator) {
        creator = _creator;
    }

    function claimTokens(token _address) public {
        require(state == State.Successful);
        require(msg.sender == creator);
        uint256 remainder = _address.balanceOf(address(this));
        require(_address.transfer(creator, remainder), ""Transfer failed"");
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract StuckTokenHandler is Ownable {
    function claimStuckToken(address _token) external onlyOwner {
        uint256 balance = IERC20(_token).balanceOf(address(this));
        require(balance > 0, ""No tokens to claim"");
        IERC20(_token).transfer(owner(), balance);
    }
}",7.689456939697266,claimStuckToken,"[{'function': 'claimStuckToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimStuckToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to claim""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.7371436805026446,0.2303139623126798,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract StuckTokenHandler is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function claimStuckToken(address _token) external onlyOwner {
        uint256 balance = IERC20(_token).balanceOf(address(this));
        require(balance > 0, ""No tokens to claim"");
        IERC20(_token).transfer(owner(), balance);
    }
}"
5414,Performs allowance transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _smbl, string memory _reference, address _sender) external returns (uint);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;

    constructor(address _chronoBankPlatform) {
        chronoBankPlatform = ChronoBankPlatform(_chronoBankPlatform);
    }

    function __transferFromWithReference(address _from, address _to, uint _value, string memory _reference, address _sender) public onlyOwner {
        require(chronoBankPlatform.proxyTransferFromWithReference(_from, _to, _value, bytes32(""smbl""), _reference, _sender) == 0, ""Transfer failed"");
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Transfer {
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function transferFrom(address sender, address recipient, uint256 amount) external {
        bool success = token.transferFrom(sender, recipient, amount);
        require(success, ""Transfer failed."");
    }
}",4.702369928359985,transferFrom,"[{'function': 'transferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed.""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.6473092318681769,0.0367879595405376,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Transfer is Ownable {
    IERC20 public token;

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function transferFrom(address sender, address recipient, uint256 amount) external {
        bool success = token.transferFrom(sender, recipient, amount);
        require(success, ""Transfer failed."");
    }
}"
3148,Finalize the auction - sets the final XCH token price and changes the auction stage after no bids are allowed anymore .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function transfer(address to, uint256 value) external returns (bool);
    function burn(uint256 amount) external;
}

abstract contract AuctionContract is Ownable {
    using SafeMath for uint256;

    enum Stages { NotStarted, AuctionStarted, AuctionEnded, AuctionCanceled }

    TokenInterface public token;
    address public walletAddress;
    uint256 public minPrice;
    uint256 public numTokensAuctioned;
    uint256 public softCap;
    uint256 public receivedWei;
    uint256 public endTime;
    uint256 public finalPrice;
    uint256 public tokenMultiplier;
    Stages public stage;

    event AuctionEnded(uint256 indexed finalPrice);
    event AuctionCanceled();

    constructor(address _token, address _walletAddress, uint256 _minPrice, uint256 _numTokensAuctioned, uint256 _softCap, uint256 _tokenMultiplier) {
        token = TokenInterface(_token);
        walletAddress = _walletAddress;
        minPrice = _minPrice;
        numTokensAuctioned = _numTokensAuctioned;
        softCap = _softCap;
        tokenMultiplier = _tokenMultiplier;
        stage = Stages.NotStarted;
    }

    function price() public view returns (uint256) {
        // Implement the logic to return the current price if needed
        return 0; // Placeholder, replace with actual implementation
    }

    function missingFundsToEndAuction() public view returns (uint256) {
        uint256 requiredWei = softCap;
        uint256 collectedWei = receivedWei;
        if (collectedWei >= requiredWei) {
            return 0;
        } else {
            return requiredWei - collectedWei;
        }
    }

    function finalizeAuction() public atStage(Stages.AuctionStarted) {
        require(price() == minPrice);
        endTime = block.timestamp;
        if (receivedWei < softCap) {
            token.transfer(walletAddress, numTokensAuctioned);
            stage = Stages.AuctionCanceled;
            emit AuctionCanceled();
            return;
        }
        walletAddress.transfer(receivedWei);
        uint256 missingFunds = missingFundsToEndAuction();
        if (missingFunds > 0) {
            uint256 soldTokens = tokenMultiplier.mul(receivedWei).div(price());
            uint256 burnTokens = numTokensAuctioned.sub(soldTokens);
            token.burn(burnTokens);
            numTokensAuctioned -= burnTokens;
        }
        finalPrice = tokenMultiplier.mul(receivedWei).div(numTokensAuctioned);
        stage = Stages.AuctionEnded;
        emit AuctionEnded(finalPrice);
        assert(finalPrice > 0);
    }
}","SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

enum AuctionStage {Default, Started, Ended}

contract Auction is Ownable, ReentrancyGuard {
    AuctionStage public stage;
    uint256 public finalTokenPrice;

    modifier atStage(AuctionStage _stage) {
        require(stage == _stage, ""Invalid stage"");
        _;
    }

    event AuctionFinalized(uint256 finalPrice);

    constructor() {
        stage = AuctionStage.Default;
        finalTokenPrice = 0;
    }

    function finalizeAuction(uint256 _finalTokenPrice)
        external
        onlyOwner
        nonReentrant
        atStage(AuctionStage.Started)
    {
        finalTokenPrice = _finalTokenPrice;
        stage = AuctionStage.Ended;

        emit AuctionFinalized(_finalTokenPrice);
    }
}",8.302704095840454,finalizeAuction,"[{'function': 'finalizeAuction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_finalTokenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalTokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_finalTokenPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionStage""}, ""memberName"": ""Ended""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionFinalized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_finalTokenPrice""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""atStage"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionStage""}, ""memberName"": ""Started""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.8442464627361361,0.002386596558036,"SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

enum AuctionStage {Default, Started, Ended}
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable, ReentrancyGuard {
    AuctionStage public stage;
    uint256 public finalTokenPrice;

    modifier atStage(AuctionStage _stage) {
        require(stage == _stage, ""Invalid stage"");
        _;
    }

    event AuctionFinalized(uint256 finalPrice);

    constructor() Ownable(msg.sender) {
        stage = AuctionStage.Default;
        finalTokenPrice = 1; // Set to a non-zero value for uint256
    }

    function finalizeAuction(uint256 _finalTokenPrice)
        external
        onlyOwner
        nonReentrant
        atStage(AuctionStage.Started)
    {
        finalTokenPrice = _finalTokenPrice;
        stage = AuctionStage.Ended;

        emit AuctionFinalized(_finalTokenPrice);
    }
}"
1735,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint earliestPayTime;
        uint securityGuardDelay;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}","SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract DelayedPayments is Ownable, ReentrancyGuard {

    using SafeMath for uint256;

    struct Payment {
        uint256 amount;
        uint256 startTime;
        uint256 delay;
        bool paid;
    }

    mapping(address => Payment[]) public payments;
    uint256 public paymentIndex;

    modifier onlySecurityGuard(){
        require(msg.sender == securityGuard, ""Not a Security Guard"");
        _;
    }

    address public securityGuard;

    constructor() public {
        securityGuard = msg.sender;
    }

    function delayPayment(address payee, uint256 _amount, uint256 delaySeconds)
        public
        onlySecurityGuard
        nonReentrant
    {
        Payment memory newPayment;
        newPayment.amount = _amount;
        newPayment.startTime = block.timestamp;
        newPayment.delay = delaySeconds;
        newPayment.paid = false;

        payments[payee].push(newPayment);
        paymentIndex = payments[payee].length.sub(1);
    }

    function performPayment(uint256 index)
        public
        payable
        nonReentrant
    {
        Payment storage payment = payments[msg.sender][index];

        require(block.timestamp >= payment.startTime.add(payment.delay), ""Too early to claim"");
        require(!payment.paid, ""Already paid"");

        payment.paid = true;
        payable(msg.sender).transfer(payment.amount);
    }
}",11.464364051818848,delayPayment,"[{'function': 'delayPayment', 'complexity': 0}, {'function': 'performPayment', 'complexity': -1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""delayPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""payee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""delaySeconds"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""newPayment"", ""storageLocation"": ""memory""}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newPayment""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newPayment""}, ""memberName"": ""startTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newPayment""}, ""memberName"": ""delay""}, ""right"": {""type"": ""Identifier"", ""name"": ""delaySeconds""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newPayment""}, ""memberName"": ""paid""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""payee""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newPayment""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paymentIndex""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""payee""}}, ""memberName"": ""length""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlySecurityGuard"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",35.0,0.8243500227402667,0.0401984269773446,"SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract DelayedPayments is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    struct Payment {
        uint256 amount;
        uint256 startTime;
        uint256 delay;
        bool paid;
    }

    mapping(address => Payment[]) public payments;
    uint256 public paymentIndex;

    modifier onlySecurityGuard() {
        require(msg.sender == securityGuard, ""Not a Security Guard"");
        _;
    }

    address public securityGuard;

    constructor() Ownable(msg.sender) {
        securityGuard = msg.sender;
        // Initialize state variables with safe, non-corner-case values
        paymentIndex = 0;
    }

    function delayPayment(address payee, uint256 _amount, uint256 delaySeconds)
        public
        onlySecurityGuard
        nonReentrant
    {
        Payment memory newPayment;
        newPayment.amount = _amount;
        newPayment.startTime = block.timestamp;
        newPayment.delay = delaySeconds;
        newPayment.paid = false;

        payments[payee].push(newPayment);
        paymentIndex = payments[payee].length - 1;
    }

    function performPayment(uint256 index)
        public
        payable
        nonReentrant
    {
        Payment storage payment = payments[msg.sender][index];

        require(block.timestamp >= payment.startTime + payment.delay, ""Too early to claim"");
        require(!payment.paid, ""Already paid"");

        payment.paid = true;
        payable(msg.sender).transfer(payment.amount);
    }
}"
170,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent, ""Time must be later than last update"");
        require(timeSent < (block.timestamp + ORACLE_FUTURE_LIMIT), ""Time must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract HavvenEthPriceOracle is Ownable {
    // State variable
    uint256 public havvenEthPrice;

    /**
    * @dev Use this function to update the price of Havvens/Eth.
    * @param _newPrice The new price of Havven in terms of Eth.
    */
    function updateHavvenEthPrice(uint256 _newPrice) external onlyOwner {
        // Security checks: Require the new price to be non-zero
        require(_newPrice > 0, ""New price should be greater than zero"");
        havvenEthPrice = _newPrice;
    }
}",6.875555753707886,updateHavvenEthPrice,"[{'function': 'updateHavvenEthPrice', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateHavvenEthPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_newPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""New price should be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""havvenEthPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newPrice""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.7314457947912807,0.0118235324823744,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HavvenEthPriceOracle is Ownable {
    // State variable
    uint256 public havvenEthPrice;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe, non-corner-case values
        havvenEthPrice = 1;
    }

    /**
    * @dev Use this function to update the price of Havvens/Eth.
    * @param _newPrice The new price of Havven in terms of Eth.
    */
    function updateHavvenEthPrice(uint256 _newPrice) external onlyOwner {
        // Security checks: Require the new price to be non-zero
        require(_newPrice > 0, ""New price should be greater than zero"");
        havvenEthPrice = _newPrice;
    }
}"
5043,This function burns all B2BK tokens on the address that caused this function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed user, uint256 amount);

    function burn() external isFinalized {
        uint256 _balance = balanceOf[msg.sender];
        assert(_balance > 0);
        totalSupply = totalSupply.sub(_balance);
        balanceOf[msg.sender] = 0;
        emit Burn(msg.sender, _balance);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract B2BKToken is ERC20Burnable, Ownable {
    constructor(uint256 initialSupply) ERC20(""B2BK"", ""B2BK"") {
        _mint(msg.sender, initialSupply);
    }

    function burnAllTokens() public {
        uint256 balance = balanceOf(msg.sender);
        require(balance > 0, ""No tokens available to burn"");
        _burn(msg.sender, balance);
    }
}",12.490784883499146,burnAllTokens,"[{'function': 'burnAllTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnAllTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens available to burn""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.748382042120648,0.0690965045327067,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract B2BKToken is ERC20Burnable, Ownable {
    mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply) ERC20(""B2BK"", ""B2BK"") Ownable(msg.sender) {
        _mint(msg.sender, initialSupply);
    }

    function burnAllTokens() public {
        uint256 balance = balanceOf(msg.sender);
        require(balance > 0, ""No tokens available to burn"");
        _burn(msg.sender, balance);
    }
}"
3040,This function returns the signature of configure function,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getInitFunction() public pure returns (bytes4) {
        return 0x0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Configuration {

    address private administrator;

    modifier onlyAdministrator() {
        require(msg.sender == administrator, ""Only administrator can call this."");
        _;
    }

    constructor(address _administrator) {
        administrator = _administrator;
    }

    function configure(uint256 _value) public onlyAdministrator returns(bool successful) {
        // Simulated operation of storing the configuration value in a state variable
        // Here _value would be your configuration parameter

        return true;
    }

    function getAdministrator() public view returns(address) {
        return administrator;
    }

    function isAdministrator(address _address) public view returns(bool) {
        return _address == administrator;
    }
}",12.416754961013794,configure,"[{'function': 'configure', 'complexity': 0}, {'function': 'getAdministrator', 'complexity': 0}, {'function': 'isAdministrator', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""configure"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""successful"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdministrator"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.2556224673829996,0.0208577528529396,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Configuration is Ownable {
    address private administrator;

    modifier onlyAdministrator() {
        require(msg.sender == administrator, ""Only administrator can call this."");
        _;
    }

    constructor(address _administrator) Ownable(msg.sender) {
        administrator = _administrator;
    }

    function configure(uint256 _value) public onlyAdministrator returns (bool successful) {
        // Simulated operation of storing the configuration value in a state variable
        // Here _value would be your configuration parameter
        return true;
    }

    function getAdministrator() public view returns (address) {
        return administrator;
    }

    function isAdministrator(address _address) public view returns (bool) {
        return _address == administrator;
    }
}"
4025,Converts WT0 to CarbonUSD for the user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ConversionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;
    bool public paused = false;

    event ConvertedToCUSD(address indexed user, uint256 amount);

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _burn(address account, uint256 amount) internal {
        require(balances[account] >= amount, ""Burn amount exceeds balance"");
        balances[account] = balances[account].sub(amount);
    }

    function _mintCUSD(address account, uint256 amount) internal {
        balances[account] = balances[account].add(amount);
    }

    function convertWT(uint256 _amount) public whenNotPaused requiresPermission {
        require(balanceOf(msg.sender) >= _amount, ""Conversion amount should be less than balance"");
        _burn(msg.sender, _amount);
        _mintCUSD(msg.sender, _amount);
        emit ConvertedToCUSD(msg.sender, _amount);
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Wt0ToCarbonUSDConversion is ReentrancyGuard, Ownable {

    using SafeMath for uint;

    IERC20 public wt0Token;
    IERC20 public carbonUsdToken;
    uint public conversionRate;

    constructor(IERC20 _wt0Token, IERC20 _carbonUsdToken, uint _conversionRate){
        wt0Token = _wt0Token;
        carbonUsdToken = _carbonUsdToken;
        conversionRate = _conversionRate;
    }

    function setConversionRate(uint _conversionRate) public onlyOwner {
        conversionRate = _conversionRate;
    }

    function convertWt0ToCarbonUSD(uint amountInWt0) public nonReentrant {
        uint carbonUsdAmount = amountInWt0.mul(conversionRate);
        wt0Token.transferFrom(msg.sender, address(this), amountInWt0);
        carbonUsdToken.transfer(msg.sender, carbonUsdAmount);
    }
}",15.900233268737791,convertWt0ToCarbonUSD,"[{'function': 'setConversionRate', 'complexity': 0}, {'function': 'convertWt0ToCarbonUSD', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""convertWt0ToCarbonUSD"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amountInWt0"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""carbonUsdAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amountInWt0""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""conversionRate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wt0Token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amountInWt0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""carbonUsdToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""carbonUsdAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.7115387350947459,0.0535927660864196,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Wt0ToCarbonUSDConversion is ReentrancyGuard, Ownable {

    using SafeMath for uint;

    IERC20 public wt0Token;
    IERC20 public carbonUsdToken;
    uint public conversionRate;

    constructor(IERC20 _wt0Token, IERC20 _carbonUsdToken, uint _conversionRate) Ownable() {
        wt0Token = _wt0Token;
        carbonUsdToken = _carbonUsdToken;
        conversionRate = _conversionRate;
    }

    function setConversionRate(uint _conversionRate) public onlyOwner {
        conversionRate = _conversionRate;
    }

    function convertWt0ToCarbonUSD(uint amountInWt0) public nonReentrant {
        uint carbonUsdAmount = amountInWt0.mul(conversionRate);
        wt0Token.transferFrom(msg.sender, address(this), amountInWt0);
        carbonUsdToken.transfer(msg.sender, carbonUsdAmount);
    }
}"
281,Announces intent to cancel tokens using ` slowCancel `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Offer {
        address maker;
        uint256 availableAmount;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint256) public announcedCancellations;
    uint256 public cancelAnnounceDelay;

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint256 canCancelAt);

    function announceCancel(bytes32 _offerHash) external {
        Offer memory offer = offers[_offerHash];
        require(offer.maker == msg.sender, ""Invalid sender"");
        require(offer.availableAmount > 0, ""Offer already cancelled"");
        uint256 canCancelAt = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = canCancelAt;
        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract MyToken is ERC20, ReentrancyGuard {
    using SafeERC20 for IERC20;

    mapping (address => uint256) private _timeOfSlowCancel;

    event SlowCancelAnnounced(address indexed user, uint256 amount, uint256 time);

    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function slowCancel(address account, uint256 amount) external nonReentrant {
        require(account != address(0), ""ERC20: burn from the zero address"");
        _timeOfSlowCancel[account] += 1 days;

        emit SlowCancelAnnounced(account, amount, block.timestamp + 1 days);
    }

    function getSlowCancelTime(address account) public view returns (uint256) {
        return _timeOfSlowCancel[account];
    }
}",14.501530170440674,slowCancel,"[{'function': 'slowCancel', 'complexity': 1}, {'function': 'getSlowCancelTime', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""slowCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: burn from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_timeOfSlowCancel""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SlowCancelAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.63085266692053,0.0369808128274582,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    mapping (address => uint256) private _timeOfSlowCancel;

    event SlowCancelAnnounced(address indexed user, uint256 amount, uint256 time);

    constructor(string memory name, string memory symbol) ERC20(name, symbol) Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        _timeOfSlowCancel[address(0)] = 1 days; // Set initial slow cancel time to 1 day
    }

    function slowCancel(address account, uint256 amount) external nonReentrant {
        require(account != address(0), ""ERC20: burn from the zero address"");
        _timeOfSlowCancel[account] += 1 days;

        emit SlowCancelAnnounced(account, amount, block.timestamp + 1 days);
    }

    function getSlowCancelTime(address account) public view returns (uint256) {
        return _timeOfSlowCancel[account];
    }
}"
5915,This is public rather than external so we can call super.unpause without using an expensive CALL .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool private paused = false;

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0));
        require(siringAuction != address(0));
        require(geneScience != address(0));
        require(lottery != address(0));
        require(variation != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";

contract MyContract is Pausable {

    function unpause() public {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""MyContract: must have pauser role to unpause"");
        super._unpause();
    }
}",4.588305950164795,unpause,"[{'function': 'unpause', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""PAUSER_ROLE""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""MyContract: must have pauser role to unpause""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""_unpause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.7852366283944051,0.070394201618364,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Pausable, Ownable {
    constructor() Pausable(), Ownable(msg.sender) {}

    function unpause() public {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""MyContract: must have pauser role to unpause"");
        super._unpause();
    }
}"
1091,"owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IContract {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    event EtherSent(address indexed to, uint256 value);

    struct State {
        bool succeeded;
    }

    mapping(bytes32 => bool) private manyOwners;
    mapping(address => State) public states;

    modifier validAddress(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bool allowed = manyOwners[txHash];
        require(allowed, ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State memory state) {
        require(state.succeeded, ""Function cannot be called in current state"");
        _;
    }

    function sendEther(address to, uint256 value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(states[msg.sender]) {
        require(value > 0 && address(this).balance >= value, ""Insufficient balance"");
        (bool success,) = to.call{value: value}("""");
        require(success, ""Transfer failed"");
        emit EtherSent(to, value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    bool public isCrowdSaleSuccessful;

    constructor(IERC20 _token) {
        token = _token;
    }

    function setCrowdSaleStatus(bool _status) external onlyOwner {
        isCrowdSaleSuccessful = _status;
    }

    function sendEther(address payable to, uint256 value) external onlyOwner {
        require(isCrowdSaleSuccessful, ""Crowdsale not successful"");
        require(address(this).balance >= value, ""Insufficient balance"");
        to.transfer(value);
    }
}",11.424041986465454,sendEther,"[{'function': 'setCrowdSaleStatus', 'complexity': 0}, {'function': 'sendEther', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendEther"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isCrowdSaleSuccessful""}, {""type"": ""stringLiteral"", ""value"": ""Crowdsale not successful""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.851257758583706,0.2530361975879263,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    bool public isCrowdSaleSuccessful;

    constructor(IERC20 _token) Ownable() {
        initialize(_token);
    }

    function initialize(IERC20 _token) internal {
        token = _token;
        isCrowdSaleSuccessful = false; // Set to false as default, not initializing it directly in constructor for safety.
    }

    function setCrowdSaleStatus(bool _status) external onlyOwner {
        isCrowdSaleSuccessful = _status;
    }

    function sendEther(address payable to, uint256 value) external onlyOwner {
        require(isCrowdSaleSuccessful, ""Crowdsale not successful"");
        require(address(this).balance >= value, ""Insufficient balance"");
        to.transfer(value);
    }
}"
2215,Notifies the controller about an approval allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovalWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_amount.add(1).sub(1) == _amount, ""SafeMath: addition overflow"");
        require(_owner != address(0), ""_owner is zero address"");
        require(_spender != address(0), ""_spender is zero address"");

        emit Approval(_owner, _spender, _amount);

        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyContract is AccessControl, ERC20 {
    bytes32 public constant CONTROLLER_ROLE = keccak256(""CONTROLLER_ROLE"");

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal override {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        if (hasRole(CONTROLLER_ROLE, msg.sender)) {
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }
}",8.873520135879517,_approve,"[{'function': 'approve', 'complexity': 0}, {'function': '_approve', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""_approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve to the zero address""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""CONTROLLER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.82841890376583,0.2703525299201044,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is AccessControl, ERC20 {
    bytes32 public constant CONTROLLER_ROLE = keccak256(""CONTROLLER_ROLE"");

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) ERC20(""MyToken"", ""TKN"") {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CONTROLLER_ROLE, msg.sender);

        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 1000 * 10**uint256(decimals());
        _mint(msg.sender, initialSupply);
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal override {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        if (hasRole(CONTROLLER_ROLE, msg.sender)) {
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }
}"
5767,Withdraws tokens other than DGZ to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function anyTokenWithdrawal(address _address, uint _amount) public onlyOwner {
        require(_address != address(tokenReward), ""Cannot withdraw from the reward token."");
        StandardToken token = StandardToken(_address);
        token.transfer(beneficiary, _amount);
        TokensWithdrawn(beneficiary, _address, _amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/Ownable.sol"";

contract TokenWithdraw is Ownable {
    IERC20 private _DGZ;

    constructor(address DGZAddress) {
        _DGZ = IERC20(DGZAddress);
    }

    function withdrawForeignTokens(address beneficiary, address token, uint amount) external onlyOwner {
        require(token != address(_DGZ), ""Cannot withdraw DGZ tokens"");
        require(IERC20(token).balanceOf(address(this)) >= amount, ""Insufficient token balance"");

        IERC20(token).transfer(beneficiary, amount);
    }
}",6.6800456047058105,withdrawForeignTokens,"[{'function': 'withdrawForeignTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawForeignTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_DGZ""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot withdraw DGZ tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.7421134175429741,0.1542448375410416,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenWithdraw is Ownable {
    IERC20 private _DGZ;

    mapping(address => uint256) public balanceOf;

 constructor(address DGZAddress) Ownable(msg.sender) {
        _DGZ = IERC20(DGZAddress);
    }

    function withdrawForeignTokens(address beneficiary, address token, uint amount) external onlyOwner {
        require(token != address(_DGZ), ""Cannot withdraw DGZ tokens"");
        require(IERC20(token).balanceOf(address(this)) >= amount, ""Insufficient token balance"");

        IERC20(token).transfer(beneficiary, amount);
    }
}"
3863,Claim token after token sale based on stake .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EthealTokenWrapper {
    using SafeMath for uint256;

    address public ethealController;
    mapping(address => uint256) public stakes;
    uint256 public rate;
    uint256 public tokenBalance;
    bool public paused = false;

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokens);

    modifier afterSaleSuccess() {
        // Assuming some condition for sale success is checked here.
        require(true, ""Sale must have succeeded"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {
        uint256 stake = stakes[_beneficiary];
        require(stake > 0);
        stakes[_beneficiary] = 0;
        uint256 tokens = stake.mul(rate);
        tokenBalance = tokenBalance.sub(tokens);
        ethealController.call(abi.encodeWithSignature(""addHodlerStake(address,uint256)"", _beneficiary, tokens.mul(2)));
        require(ethealController.call(abi.encodeWithSignature(""ethealToken()"")).delegatecall(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _beneficiary, tokens)));
        emit TokenClaimed(msg.sender, _beneficiary, stake, tokens);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenSale {
    IERC20 public token;
    mapping(address => uint256) public balances;

    constructor(IERC20 _token) {
        token = _token;
    }

    function claimTokens() public {
        uint256 balance = balances[msg.sender];
        require(balance > 0, ""No tokens to claim"");

        balances[msg.sender] = 0;

        require(token.transfer(msg.sender, balance), ""Token transfer failed"");
    }
}",7.676900148391724,claimTokens,"[{'function': 'claimTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to claim""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",55.0,0.6972617823455999,0.0130704775335952,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    IERC20 public token;
    mapping(address => uint256) public balances;

    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function claimTokens() public {
        uint256 balance = balances[msg.sender];
        require(balance > 0, ""No tokens to claim"");

        balances[msg.sender] = 0;

        require(token.transfer(msg.sender, balance), ""Token transfer failed"");
    }
}"
6728,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event ForceTransfer(address indexed sender, address indexed from, address indexed to, uint256 value, bool verified, bytes log);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) public onlyController {
        require(_to != address(0));
        require(_value <= balances[_from]);
        bool verified = _updateTransfer(_from, _to, _value, _data);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit ForceTransfer(msg.sender, _from, _to, _value, verified, _log);
        emit Transfer(_from, _to, _value);
    }

    function _updateTransfer(address _from, address _to, uint256 _value, bytes memory _data) internal returns (bool) {
        // Implement the logic for updating transfer here
        return true; // Placeholder
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20, Ownable {

    function forceTransfer(address from, address to, uint256 value) public onlyOwner {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balanceOf(from) >= value, ""ERC20: insufficient balance for transfer"");

        _transfer(from, to, value);
    }
}",6.567261934280396,forceTransfer,"[{'function': 'forceTransfer', 'complexity': 3}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""forceTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: insufficient balance for transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.879912754726621,0.1352103857554097,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // uint256: Set to 1 (never 0)
        _totalSupply = 1000000000000000000;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function forceTransfer(address from, address to, uint256 value) public onlyOwner {
        require(from != address(0), ""ERC20: transfer from the zero address"");
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balanceOf(from) >= value, ""ERC20: insufficient balance for transfer"");

        _transfer(from, to, value);
    }
}"
691,Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Validator {
    using SafeMath for uint256;

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        require(validator != address(0), ""Invalid validator address"");
        require(attributeTypeID > 0, ""Invalid attribute type ID"");
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract ValidateAttribute is AccessControl {
    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");
    mapping(address => mapping(uint => bool)) private _validators;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setValidatorForAttributeType(address validator, uint attributeTypeID, bool enabled) public onlyRole(DEFAULT_ADMIN_ROLE) {
        _validators[validator][attributeTypeID] = enabled;
    }

    function isValidatorForAttributeType(address validator, uint attributeTypeID) public view returns (bool) {
        return _validators[validator][attributeTypeID];
    }
}",6.623522996902466,setValidatorForAttributeType,"[{'function': 'setValidatorForAttributeType', 'complexity': 0}, {'function': 'isValidatorForAttributeType', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setValidatorForAttributeType"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""enabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_validators""}, ""index"": {""type"": ""Identifier"", ""name"": ""validator""}}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""right"": {""type"": ""Identifier"", ""name"": ""enabled""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.7117446844443217,0.0548424441453929,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ValidateAttribute is Ownable, AccessControl {
    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR_ROLE"");
    mapping(address => mapping(uint => bool)) private _validators;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(VALIDATOR_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function setValidatorForAttributeType(address validator, uint attributeTypeID, bool enabled) public onlyRole(DEFAULT_ADMIN_ROLE) {
        _validators[validator][attributeTypeID] = enabled;
    }

    function isValidatorForAttributeType(address validator, uint attributeTypeID) public view returns (bool) {
        return _validators[validator][attributeTypeID];
    }
}"
876,Initialize Finance app for Vault at ` _vault ` with period length of ` @ transformTime ( _periodDuration ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface Vault {
    function isContract() external view returns (bool);
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool inactive;
    }

    Vault public vault;
    Settings public settings;
    mapping(uint => Payment) public payments;
    uint public paymentsNextIndex;
    uint public transactionsNextIndex;

    event Initialized();

    error VaultNotContract(string message);
    error InitPeriodTooShort(string message);

    constructor() {
        settings.periodDuration = 0;
    }

    function initialize(Vault _vault, uint64 _periodDuration) external onlyOwner {
        require(_vault.isContract(), ""ERROR_VAULT_NOT_CONTRACT"");
        vault = _vault;
        if (_periodDuration < 1 days) revert InitPeriodTooShort(""ERROR_INIT_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        payments[0].inactive = true;
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;
        _newPeriod(getTimestamp64());
    }

    function getTimestamp64() internal view returns (uint64) {
        return uint64(block.timestamp);
    }

    struct Settings {
        uint64 periodDuration;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract VaultFinance is ReentrancyGuard, Ownable {
    struct Period {
        uint256 startTime;
        uint256 endTime;
    }

    mapping(address => Period) private _vaultPeriods;

    function initializeFinance(address _vault, uint256 _periodDuration) external onlyOwner nonReentrant {
        require(_vault != address(0), ""Solidity Function: _vault is the zero address"");
        require(_periodDuration > 0, ""Solidity Function: _periodDuration should be > 0"");

        uint256 transformedTime = transformTime(_periodDuration);

        _vaultPeriods[_vault] = Period(block.timestamp, block.timestamp + transformedTime);
    }

    function transformTime(uint256 _timeInSeconds) internal pure returns(uint256) {
        return _timeInSeconds * 1 days;
    }
}",9.299945831298828,initializeFinance,"[{'function': 'initializeFinance', 'complexity': 2}, {'function': 'transformTime', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeFinance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_vault"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_vault""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Solidity Function: _vault is the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Solidity Function: _periodDuration should be > 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""transformedTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transformTime""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_periodDuration""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_vaultPeriods""}, ""index"": {""type"": ""Identifier"", ""name"": ""_vault""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Period""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""transformedTime""}}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",37.0,0.8437895878368126,0.0910624991963919,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VaultFinance is ReentrancyGuard, Ownable {
    struct Period {
        uint256 startTime;
        uint256 endTime;
    }

    mapping(address => Period) private _vaultPeriods;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function initializeFinance(address _vault, uint256 _periodDuration) external onlyOwner nonReentrant {
        require(_vault != address(0), ""Solidity Function: _vault is the zero address"");
        require(_periodDuration > 0, ""Solidity Function: _periodDuration should be > 0"");

        uint256 transformedTime = transformTime(_periodDuration);

        _vaultPeriods[_vault] = Period(block.timestamp, block.timestamp + transformedTime);
    }

    function transformTime(uint256 _timeInSeconds) internal pure returns(uint256) {
        return _timeInSeconds * 1 days;
    }
}"
2491,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';

contract MyToken is ERC20, ReentrancyGuard {
    mapping(address => bool) public canTransfer;

    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function enableTransfers(address holder, bool flag) public {
        canTransfer[holder] = flag;
    }

    function transfer(address recipient, uint256 amount) public virtual override nonReentrant returns (bool) {
        require(canTransfer[msg.sender], ""Transfer not allowed for this address"");
        super.transfer(recipient, amount);
        return true;
    }
}",13.05345106124878,transfer,"[{'function': 'enableTransfers', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canTransfer""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Transfer not allowed for this address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.5883397627860782,0.0158947802908561,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, ReentrancyGuard, Ownable {
    mapping(address => bool) public canTransfer;

    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") Ownable(msg.sender) {
        _mint(owner(), initialSupply);
    }

    function enableTransfers(address holder, bool flag) public onlyOwner {
        canTransfer[holder] = flag;
    }

    function transfer(address recipient, uint256 amount) public virtual override nonReentrant returns (bool) {
        require(canTransfer[_msgSender()], ""Transfer not allowed for this address"");
        super.transfer(recipient, amount);
        return true;
    }
}"
1924,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    address private _crowdsaleAgent;

    modifier onlyCrowdsaleAgent() {
        require(_crowdsaleAgent == msg.sender, ""Only crowdsale agent can call this function"");
        _;
    }

    constructor(address crowdsaleAgent) {
        _crowdsaleAgent = crowdsaleAgent;
    }

    function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken is ERC20, Ownable {
    using SafeMath for uint256;

    function mintTokens(address target, uint256 mintedAmount) external onlyOwner {
        require(target != address(0), ""MyToken: mint to the zero address"");
        _mint(target, mintedAmount);
    }
}",5.632396221160889,mintTokens,"[{'function': 'mintTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""target""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""MyToken: mint to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.7444273156977427,0.310350560827803,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyToken is ERC20, Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialization of state variables
        _totalSupply = 1 * 10 ** uint256(decimals());
        _balances[msg.sender] = _totalSupply;
    }

    function mintTokens(address target, uint256 mintedAmount) external onlyOwner {
        require(target != address(0), ""MyToken: mint to the zero address"");
        _mint(target, mintedAmount);
    }
}"
2485,"if there is an unresolvable problem , users can call to this function to get a refund .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256[]) public ownedTokens;
    uint256 public constant STARTING_PRICE = 1 ether; // Example value, adjust as needed

    modifier hasFinalized() {
        require(finalized, ""Function can only be called after the event has finalized"");
        _;
    }

    bool public finalized = true; // Set to false if there's an initialization phase or other conditions

    function emergencyWithdraw() external hasFinalized {
        uint256 balance = STARTING_PRICE.mul(ownedTokens[msg.sender].length);
        delete ownedTokens[msg.sender];
        msg.sender.transfer(balance);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract RefundContract is ReentrancyGuard, Ownable {
    mapping(address => uint256) private _deposits;

    function deposit() external payable {
        _deposits[msg.sender] += msg.value;
    }

    function refund() external nonReentrant {
        uint256 amount = _deposits[msg.sender];
        require(amount > 0, ""No funds to refund"");

        _deposits[msg.sender] = 0;

        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Refund failed"");
    }
}",9.533565759658812,refund,"[{'function': 'deposit', 'complexity': 0}, {'function': 'refund', 'complexity': 2}]",3.0,{},27.0,0.5279871486117398,0.0409103265388024,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RefundContract is ReentrancyGuard, Ownable {
    mapping(address => uint256) private _deposits;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function deposit() external payable {
        _deposits[msg.sender] += msg.value;
    }

    function refund() external nonReentrant {
        uint256 amount = _deposits[msg.sender];
        require(amount > 0, ""No funds to refund"");

        _deposits[msg.sender] = 0;

        (bool success, ) = msg.sender.call{value: amount}("""");
        require(success, ""Refund failed"");
    }
}"
1164,Allows recovery addresses to trigger the recovery process for an Identity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentityRecovery {
    using SafeMath for uint256;

    struct RecoveryLog {
        uint timestamp;
        bytes32 membersHash;
    }

    struct AssociatedAddresses {
        address[] members;
    }

    struct Identity {
        AssociatedAddresses associatedAddresses;
    }

    mapping(uint => Identity) public identityDirectory;
    mapping(uint => RecoveryLog) public recoveryLogs;
    mapping(uint => address) public recoveryAddressChangeLogs;
    uint8 private constant RECOVERY_PERMISSION = 27;

    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp) public {
        require(_identityExists(ein), ""Identity does not exist."");
        require(_hasIdentity(newAssociatedAddress, false), ""New associated address is not a valid identity."");
        require(canRecover(ein), ""Cannot trigger recovery yet."");
        require(isSigned(newAssociatedAddress, keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), ""I authorize being added to this Identity via recovery."", ein, newAssociatedAddress, timestamp))), ""Permission denied."");
        require(canChangeRecoveryAddress(ein) || msg.sender == recoveryAddressChangeLogs[ein], ""Only the current or previously removed recovery address can trigger recovery."");

        Identity storage _identity = identityDirectory[ein];
        recoveryLogs[ein] = RecoveryLog(block.timestamp, keccak256(abi.encodePacked(_identity.associatedAddresses.members)));
        emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);
        resetIdentityData(_identity, msg.sender, false);
        addAssociatedAddress(ein, newAssociatedAddress);
    }

    function _identityExists(uint ein) internal view returns (bool) {
        return address(uint160(uint256(keccak256(abi.encodePacked(""identity"", ein)))) % 10**40) != address(0);
    }

    function _hasIdentity(address addr, bool isRecoveryAddress) internal view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function canRecover(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function isSigned(address signer, bytes32 hash) internal pure returns (bool) {
        require(signer != address(0), ""ECDSA: invalid signature"");
        return signer == ecrecover(hash, v, r, s);
    }

    function canChangeRecoveryAddress(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function resetIdentityData(Identity storage identity, address newOwner, bool isRecoveryAddress) internal {
        // Implementation omitted for brevity
    }

    function addAssociatedAddress(uint ein, address newAssociatedAddress) internal {
        // Implementation omitted for brevity
    }

    event RecoveryTriggered(address indexed initiator, uint indexed ein, address[] members, address newAssociatedAddress);
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract AccountRecovery is AccessControl {
    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");

    mapping (address => address) private recoveryAddress;

    event RecoveryTriggered(address indexed original, address indexed recovery);

    constructor() {
        _setupRole(RECOVERY_ROLE, msg.sender);
    }

    function setRecoveryAddress(address _original, address _recovery) public onlyRole(RECOVERY_ROLE) {
        require(_original != address(0), ""AccountRecovery: original address is zero"");
        require(_recovery != address(0), ""AccountRecovery: recovery address is zero"");

        recoveryAddress[_original] = _recovery;
    }

    function triggerRecovery(address _original) public {
        require(recoveryAddress[_original] == msg.sender, ""AccountRecovery: sender not authorized"");

        emit RecoveryTriggered(_original, recoveryAddress[_original]);
    }
}",7.146340131759644,setRecoveryAddress,"[{'function': 'setRecoveryAddress', 'complexity': 2}, {'function': 'triggerRecovery', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRecoveryAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_original"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recovery"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_original""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""AccountRecovery: original address is zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_recovery""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""AccountRecovery: recovery address is zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recoveryAddress""}, ""index"": {""type"": ""Identifier"", ""name"": ""_original""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_recovery""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""RECOVERY_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",95.0,0.6187736347127802,0.0123237352768223,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AccountRecovery is AccessControl, Ownable {
    bytes32 public constant RECOVERY_ROLE = keccak256(""RECOVERY_ROLE"");

    mapping (address => address) private recoveryAddress;

    event RecoveryTriggered(address indexed original, address indexed recovery);

    constructor() Ownable(msg.sender) {
        _setupRole(RECOVERY_ROLE, msg.sender);
    }

    function setRecoveryAddress(address _original, address _recovery) public onlyRole(RECOVERY_ROLE) {
        require(_original != address(0), ""AccountRecovery: original address is zero"");
        require(_recovery != address(0), ""AccountRecovery: recovery address is zero"");

        recoveryAddress[_original] = _recovery;
    }

    function triggerRecovery(address _original) public {
        require(recoveryAddress[_original] == msg.sender, ""AccountRecovery: sender not authorized"");

        emit RecoveryTriggered(_original, recoveryAddress[_original]);
    }
}"
461,Checks whether a contract implements an ERC165 interface or not without using nor updating the cache .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

abstract contract ImplementsERC165InterfaceNoCache is Ownable {
    using SafeMath for uint256;

    bytes4 constant ERC165ID = 0x01ffc9a7;
    bytes4 constant INVALID_ID = 0xffffffff;

    function noThrowCall(address _contract, bytes4 _interfaceId) internal view returns (uint256 success, uint256 result) {
        (success, result) = address(_contract).staticcall(abi.encodeWithSelector(ERC165.supportsInterface.selector, _interfaceId));
    }

    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;
        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/introspection/ERC165Checker.sol"";

contract MyContract {
  using ERC165Checker for address;

  function doesContractImplementERC165(address _contract, bytes4 _interfaceId)
    public
    view
    returns (bool)
  {
    (bool success, bytes memory result) = _contract.call(abi.encodeWithSignature(""supportsInterface(bytes4)"", _interfaceId));

    if(success && result.length > 0){
      return abi.decode(result, (bool));
    }

    return false;
  }
}",5.904976844787598,doesContractImplementERC165,"[{'function': 'doesContractImplementERC165', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""doesContractImplementERC165"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""_interfaceId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""success"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112feb460>}, {""type"": ""VariableDeclaration"", ""name"": ""result"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112fe9860>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_contract""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""supportsInterface(bytes4)""}, {""type"": ""Identifier"", ""name"": ""_interfaceId""}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""result""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""decode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""result""}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""ElementaryTypeName"", ""name"": ""bool""}], ""isArray"": False}], ""names"": []}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",46.0,0.7556242958754175,0.217192824694495,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
  using ERC165Checker for address;

  function doesContractImplementERC165(address _contract, bytes4 _interfaceId)
    public
    view
    returns (bool)
  {
    (bool success, bytes memory result) = _contract.call(abi.encodeWithSignature(""supportsInterface(bytes4)"", _interfaceId));

    if(success && result.length > 0){
      return abi.decode(result, (bool));
    }

    return false;
  }
}"
3202,Retreive account ID associated with a user 's address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public accountByAddress;

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address));
        return accountByAddress[_address];
    }

    function addressBelongsToAccount(address _address) internal view virtual returns (bool);
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/Context.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract UserContract is Context, ReentrancyGuard {
    mapping(address => uint256) private _userAccountIds;

    function getAccountId(address userAddress) public view nonReentrant returns (uint256) {
        uint256 accountId = _userAccountIds[userAddress];
        require(accountId != 0, ""UserContract: user address does not exist"");
        return accountId;
    }
}",4.719086885452271,getAccountId,"[{'function': 'getAccountId', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAccountId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""accountId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_userAccountIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""userAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""accountId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""UserContract: user address does not exist""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""accountId""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",12.0,0.705185086242392,0.1862178807401515,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/Context.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract UserContract is Context, ReentrancyGuard, Ownable {
    mapping(address => uint256) private _userAccountIds;

    constructor() {
        __Context_init();
        __ReentrancyGuard_init();
        __Ownable_init();
        transferOwnership(msg.sender);
        // Initialize state variables with safe, non-corner-case values
        _userAccountIds[address(0x111)] = 1;
        _userAccountIds[address(0x222)] = 2;
        _userAccountIds[address(0x333)] = 3;
    }

    function getAccountId(address userAddress) public view nonReentrant returns (uint256) {
        uint256 accountId = _userAccountIds[userAddress];
        require(accountId != 0, ""UserContract: user address does not exist"");
        return accountId;
    }
}"
5007,Get the index of PixelCon ` ( _tokenId ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        require(_tokenId != 0, ""Invalid token ID"");
        // Assuming the logic to retrieve the index is implemented here.
        return uint64(_tokenId);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

contract PixelCon is ERC721 {
    mapping (uint256 => uint256) private _tokenIndex;

    constructor() ERC721(""PixelCon"", ""PIX"") {}

    function getIndex(uint256 _tokenId) public view returns (uint256) {
        require(_exists(_tokenId), ""ERC721: operator query for nonexistent token"");
        return _tokenIndex[_tokenId];
    }

    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
        // Assumes tokenIds are minted in sequential order
        _tokenIndex[tokenId] = totalSupply() - 1;
    }
}",11.45176911354065,mint,"[{'function': 'getIndex', 'complexity': 1}, {'function': 'mint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""ERC721: operator query for nonexistent token""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_tokenIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",4.0,0.524278774945955,0.0354397018250561,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PixelCon is ERC721, Ownable {
    mapping (uint256 => uint256) private _tokenIndex;

    uint256 public totalSupply;

 constructor() ERC721(""PixelCon"", ""PIX"") Ownable(msg.sender) {}

    function getIndex(uint256 _tokenId) public view returns (uint256) {
        require(_exists(_tokenId), ""ERC721: operator query for nonexistent token"");
        return _tokenIndex[_tokenId];
    }

    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
        // Assumes tokenIds are minted in sequential order
        _tokenIndex[tokenId] = totalSupply() - 1;
    }
}"
1993,Throws if ` _tokenId ` is not a valid NFT .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public idToApprovals;

    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address) {
        return idToApprovals[_tokenId];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

contract MyNFTContract {

    IERC721 public nftContract;

    constructor(address _nftContract) {
        nftContract = IERC721(_nftContract);
    }

    function isValidNFT(uint256 _tokenId) public view {
        require(nftContract._exists(_tokenId), ""Not a valid NFT"");
    }
}",5.233444213867188,isValidNFT,"[{'function': 'isValidNFT', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isValidNFT"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nftContract""}, ""memberName"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Not a valid NFT""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.6494157428858602,0.288389458703517,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyNFTContract is Ownable {
    IERC721 public nftContract;

    constructor(address _nftContract) Ownable(msg.sender) {
        nftContract = IERC721(_nftContract);
    }

    function isValidNFT(uint256 _tokenId) public view {
        require(nftContract._exists(_tokenId), ""Not a valid NFT"");
    }
}"
3377,Check the total supply of the token ~ ERC-20 Standard,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 internal totalSupply_;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint8 _decimals) {
        totalSupply_ = totalSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() external constant returns (uint256) {
        return totalSupply_;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function checkTotalSupply() public view returns (uint256) {
        return totalSupply();
    }
}",11.813293933868408,checkTotalSupply,"[{'function': 'checkTotalSupply', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkTotalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.8520680401216202,0.3770929789171766,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    uint256 public totalSupply;

 constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
        initializeOwner();
    }

    function checkTotalSupply() public view returns (uint256) {
        return totalSupply();
    }

    function initializeOwner() internal {
        transferOwnership(msg.sender);
    }
}"
1589,Transfer Spork tokens from ` msg.sender ` to another account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        if (balances[_to].add(_amount).lte(balances[_to])) return false;
        if (balances[msg.sender].lt(_amount)) return false;
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract SporkToken is ERC20, Ownable {

    function transferSporkTokens(address _to, uint256 _amount) public {
        uint256 balance = balanceOf(msg.sender);
        require(_to != address(0), ""Invalid recipient"");
        require(balance >= _amount, ""Insufficient Balance"");

        _transfer(msg.sender, _to, _amount);
    }
}",5.593339920043945,transferSporkTokens,"[{'function': 'transferSporkTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferSporkTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient Balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.7291683985193742,0.2241059595008134,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SporkToken is ERC20, Ownable {
    mapping(address => uint256) public balanceOf;

 constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 1 * 10**uint256(decimals());
        _mint(msg.sender, initialSupply);
    }

    function transferSporkTokens(address _to, uint256 _amount) public {
        uint256 balance = balanceOf(msg.sender);
        require(_to != address(0), ""Invalid recipient"");
        require(balance >= _amount, ""Insufficient Balance"");

        _transfer(msg.sender, _to, _amount);
    }
}"
1356,Set value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint) public uIntStorage;

    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool success) {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        uIntStorage[_key] = _value;
        return true;
    }

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(""ROLE_PLATFORM_OPERATIVE_REPRESENTATIVE"") {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Assignment is Ownable {
    mapping(bytes32 => uint256) private data;

    function setUintValue(bytes32 _id, uint256 _value) public onlyOwner {
        data[_id] = _value;
    }
}",6.4671900272369385,setUintValue,"[{'function': 'setUintValue', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUintValue"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""data""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.2296319679759929,0.0050550829880198,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Assignment is Ownable {
    mapping(bytes32 => uint256) private data;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        data[bytes32('init')] = 1;
    }

    function setUintValue(bytes32 _id, uint256 _value) public onlyOwner {
        require(_value != 0, ""Value must not be zero""); // Ensure value is non-zero
        data[_id] = _value;
    }
}"
232,get token price in cents depending on the current date,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;
    address private constant ROLE_PLATFORM_OPERATIVE = 0x0; // Placeholder for platform operator representative role

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function getPrice() public view returns (uint) {
        for (uint i = c_priceChangeDates.length - 2; i > 0; i--) {
            if (getTime() >= c_priceChangeDates[i]) {
                return c_tokenPrices[i];
            }
        }
        return c_tokenPrices[0];
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenPrice is Ownable {
    using SafeMath for uint256;

    uint256 private constant CENTS_IN_ONE_ETH = 1e18;

    mapping(uint256 => uint256) private _tokenPriceInCents;

    function addTokenPrice(uint256 date, uint256 priceInCents) external onlyOwner {
        _tokenPriceInCents[date] = priceInCents;
    }

    function getTokenPriceInCents() public view returns (uint256) {
        uint256 date = block.timestamp / 1 days;
        uint256 priceInCents = _tokenPriceInCents[date];
        require(priceInCents != 0, 'No price information available for this date');
        return priceInCents;
    }
}",9.017665147781372,getTokenPriceInCents,"[{'function': 'addTokenPrice', 'complexity': 0}, {'function': 'getTokenPriceInCents', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenPriceInCents"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""date"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceInCents"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_tokenPriceInCents""}, ""index"": {""type"": ""Identifier"", ""name"": ""date""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""priceInCents""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No price information available for this date""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""priceInCents""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",32.0,0.7369781522555364,0.1452851068277859,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenPrice is Ownable {
    using SafeMath for uint256;

    uint256 private constant CENTS_IN_ONE_ETH = 1e18;

    mapping(uint256 => uint256) private _tokenPriceInCents;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        CENTS_IN_ONE_ETH = 1e18;
        for (uint256 i = 1; i <= 3; i++) {
            _tokenPriceInCents[i] = i * 1e18; // Initialize with increasing values of 1e18
        }
    }

    function addTokenPrice(uint256 date, uint256 priceInCents) external onlyOwner {
        _tokenPriceInCents[date] = priceInCents;
    }

    function getTokenPriceInCents() public view returns (uint256) {
        uint256 date = block.timestamp / 1 days;
        uint256 priceInCents = _tokenPriceInCents[date];
        require(priceInCents != 0, 'No price information available for this date');
        return priceInCents;
    }
}"
5169,Set the Havven contract that the issuance controller uses to issue Havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HavvenWrapper is Ownable {
    using SafeMath for uint256;

    Havven public havven;

    event HavvenUpdated(Havven indexed newHavven);

    function setHavven(Havven _havven) external onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract IssuanceController is Ownable {

    IERC20 private havvenToken;

    function setHavvenContract(address _havvenToken) external onlyOwner {
        require(_havvenToken != address(0), ""IssuanceController: Zero address cannot be assigned"");

        havvenToken = IERC20(_havvenToken);
    }
}",6.106536865234375,setHavvenContract,"[{'function': 'setHavvenContract', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setHavvenContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_havvenToken"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_havvenToken""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""IssuanceController: Zero address cannot be assigned""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""havvenToken""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_havvenToken""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.7577939207870352,0.1070454632987902,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract IssuanceController is Ownable {
    IERC20 private havvenToken;

    constructor(address _havvenToken) {
        require(_havvenToken != address(0), ""IssuanceController: Zero address cannot be assigned"");
        havvenToken = IERC20(_havvenToken);
    }

    function setHavvenContract(address _havvenToken) external onlyOwner {
        require(_havvenToken != address(0), ""IssuanceController: Zero address cannot be assigned"");
        havvenToken = IERC20(_havvenToken);
    }
}"
277,sell new tokens during the round 0 all except logo,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public halted = false;
    mapping(address => bool) public signers;

    function setHalted(bool _halted) external onlyOwner {
        halted = _halted;
    }

    function addSigner(address signer) external onlyOwner {
        signers[signer] = true;
    }

    function removeSigner(address signer) external onlyOwner {
        signers[signer] = false;
    }

    function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 v, bytes32 r, bytes32 s) public notHalted() payable {
        address recoveredSigner = verify(keccak256(abi.encodePacked(msg.sender)), v, r, s);
        require(signers[recoveredSigner] == true);
        require(msg.value > 0);
        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        // Implementation of the buy logic
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyTokenSale is Ownable, ReentrancyGuard {

    using SafeMath for uint256;

    ERC20 public token;
    uint256 public constant ROUND_0 = 0;
    uint256 public currentRound = ROUND_0;

    // State variables
    uint256 public tokenPrice;
    uint256 public tokensSold;

    // Events
    event TokensPurchased(address purchaser, uint256 amount);

    constructor(ERC20 _token, uint256 _tokenPrice) {
        token = _token;
        tokenPrice = _tokenPrice;
    }

    function buyTokens(uint256 _numberOfTokens) external payable nonReentrant {
        require(currentRound == ROUND_0, ""Sale must be in round 0"");
        require(msg.value == SafeMath.mul(_numberOfTokens, tokenPrice), ""Mismatch between provided funds and calculated cost"");

        uint256 scaledAmount = SafeMath.mul(_numberOfTokens, 10 ** uint256(token.decimals()));
        require(token.balanceOf(address(this)) >= scaledAmount, ""Not enough tokens in contract"");

        tokensSold = tokensSold.add(_numberOfTokens);

        require(token.transfer(msg.sender, scaledAmount), ""Token transfer failed"");

        emit TokensPurchased(msg.sender, _numberOfTokens);
    }
}",13.647018909454346,buyTokens,"[{'function': 'buyTokens', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_numberOfTokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""currentRound""}, ""right"": {""type"": ""Identifier"", ""name"": ""ROUND_0""}}, {""type"": ""stringLiteral"", ""value"": ""Sale must be in round 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_numberOfTokens""}, {""type"": ""Identifier"", ""name"": ""tokenPrice""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Mismatch between provided funds and calculated cost""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""scaledAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_numberOfTokens""}, {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""decimals""}, ""arguments"": [], ""names"": []}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""scaledAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensSold""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokensSold""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_numberOfTokens""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""scaledAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensPurchased""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_numberOfTokens""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",55.0,0.5321832026626149,0.0951144683162972,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyTokenSale is Ownable, ReentrancyGuard {

    using SafeMath for uint256;

    ERC20 public token;
    uint256 public constant ROUND_0 = 0;
    uint256 public currentRound = ROUND_0;

    // State variables
    uint256 public tokenPrice;
    uint256 public tokensSold;

    // Events
    event TokensPurchased(address purchaser, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor(ERC20 _token, uint256 _tokenPrice) Ownable(msg.sender) {
        token = _token;
        tokenPrice = _tokenPrice;
    }

    function buyTokens(uint256 _numberOfTokens) external payable nonReentrant {
        require(currentRound == ROUND_0, ""Sale must be in round 0"");
        require(msg.value == SafeMath.mul(_numberOfTokens, tokenPrice), ""Mismatch between provided funds and calculated cost"");

        uint256 scaledAmount = SafeMath.mul(_numberOfTokens, 10 ** uint256(token.decimals()));
        require(token.balanceOf(address(this)) >= scaledAmount, ""Not enough tokens in contract"");

        tokensSold = tokensSold.add(_numberOfTokens);

        require(token.transfer(msg.sender, scaledAmount), ""Token transfer failed"");

        emit TokensPurchased(msg.sender, _numberOfTokens);
    }
}"
3181,This function is disabled during the funding .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function getState() external view returns (uint8);
    function balances(address) external view returns (uint256);
    function upgradeAgent() external view returns (address);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _token) {
        token = IToken(_token);
    }

    function transfer(address to, uint256 value) external returns (bool ok) {
        require(getState() == 0, ""State is not Success"");
        require(to != address(0), ""Invalid recipient address"");
        require(to != token.upgradeAgent(), ""Recipient is upgrade agent"");

        uint256 senderBalance = token.balances(msg.sender);
        if (senderBalance >= value && value > 0) {
            senderBalance = senderBalance.sub(value);
            token.balances(msg.sender) = senderBalance;
            token.balances(to) = token.balances(to).add(value);
            emit Transfer(msg.sender, to, value);
            return true;
        }
        return false;
    }

    function getState() internal view returns (uint8) {
        return token.getState();
    }
}","// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    bool private isFunding;

    modifier notInFundingPhase() {
        require(!isFunding, ""Function is disabled during the funding."");
        _;
    }

    function setFunding(bool _isFunding) external onlyOwner {
        isFunding = _isFunding;
    }

    function performAction() external notInFundingPhase {
        // Your code logic here.
    }
}",5.820733070373535,setFunding,"[{'function': 'setFunding', 'complexity': 0}, {'function': 'performAction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setFunding"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_isFunding"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isFunding""}, ""right"": {""type"": ""Identifier"", ""name"": ""_isFunding""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",45.0,0.3144329856568927,1.471712626968644e-05,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool private isFunding;

    modifier notInFundingPhase() {
        require(!isFunding, ""Function is disabled during the funding."");
        _;
    }

    function setFunding(bool _isFunding) external onlyOwner {
        isFunding = _isFunding;
    }

    function performAction() external notInFundingPhase {
        // Your code logic here.
    }
}"
4086,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

   function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
}

}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract OperatorAuthorization is AccessControl {

    // Event to log the operator authorization
    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);

    // Mapping to track addresses that are authorized to operate
    mapping(address => mapping (address => bool)) private _authorizedOperators;

    function setAuthorizedOperator(address operator, address tokenHolder) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        _authorizedOperators[tokenHolder][operator] = true;
        emit AuthorizedOperator(operator, tokenHolder);
    }

    function isAuthorizedOperator(address operator, address tokenHolder) public view returns (bool) {
        return _authorizedOperators[tokenHolder][operator];
    }
}",8.226170063018799,setAuthorizedOperator,"[{'function': 'setAuthorizedOperator', 'complexity': 1}, {'function': 'isAuthorizedOperator', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAuthorizedOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_authorizedOperators""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenHolder""}}, ""index"": {""type"": ""Identifier"", ""name"": ""operator""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuthorizedOperator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""operator""}, {""type"": ""Identifier"", ""name"": ""tokenHolder""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.6224210986159614,0.020220429578874,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OperatorAuthorization is AccessControl {

    // Event to log the operator authorization
    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);

    // Mapping to track addresses that are authorized to operate
    mapping(address => mapping (address => bool)) private _authorizedOperators;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function setAuthorizedOperator(address operator, address tokenHolder) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        _authorizedOperators[tokenHolder][operator] = true;
        emit AuthorizedOperator(operator, tokenHolder);
    }

    function isAuthorizedOperator(address operator, address tokenHolder) public view returns (bool) {
        return _authorizedOperators[tokenHolder][operator];
    }
}"
79,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public memeIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerOf(_tokenId) == _owner;
    }

    function ownerOf(uint256 _tokenId) public pure returns (address) {
        // This is a placeholder for the actual implementation of ownerOf.
        // The real implementation should be provided by the contract that inherits this wrapper.
        require(false, ""ownerOf not implemented"");
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is ERC20, Ownable {
    using SafeMath for uint256;

    function grantTransferRights(address _to, uint256 _tokenId) public onlyOwner {
        require(_to != address(0), ""Invalid destination address"");
        require(!_isTokenApproved(_tokenId, _to)); // Check if the token has already been approved for the recipient

        _approve(_to, _tokenId); // Call the internal _approve function to approve the recipient
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public override {
        require(_isTokenApproved(_tokenId, msg.sender), ""Token not approved for transfer"");
        require(_to != address(0), ""Invalid destination address"");

        _transfer(_from, _to, _tokenId); // Call the internal _transfer function to execute the transfer

        // Clear the approval so the approved account only has rights for this single transfer.
        if (_isTokenApproved(_tokenId, msg.sender)) {
            _approve(address(0), _tokenId);
        }
    }

    function _isTokenApproved(uint256 _tokenId, address _approved) internal view returns (bool) {
        return getApproved(_tokenId) == _approved;
    }
}",18.07750487327576,transferFrom,"[{'function': 'grantTransferRights', 'complexity': 3}, {'function': 'transferFrom', 'complexity': 3}, {'function': '_isTokenApproved', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isTokenApproved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token not approved for transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid destination address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isTokenApproved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.7000507017680645,0.1510949868869376,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialization of state variables
        _totalSupply = 1 * 10 ** decimals(); // Set total supply to 1 token with appropriate decimals
        _balances[owner()] = _totalSupply; // Assign all tokens to the contract owner
    }

    function grantTransferRights(address _to, uint256 _tokenId) public onlyOwner {
        require(_to != address(0), ""Invalid destination address"");
        require(!_isTokenApproved(_tokenId, _to)); // Check if the token has already been approved for the recipient

        _approve(_to, _tokenId); // Call the internal _approve function to approve the recipient
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public override {
        require(_isTokenApproved(_tokenId, msg.sender), ""Token not approved for transfer"");
        require(_to != address(0), ""Invalid destination address"");

        _transfer(_from, _to, _tokenId); // Call the internal _transfer function to execute the transfer

        // Clear the approval so the approved account only has rights for this single transfer.
        if (_isTokenApproved(_tokenId, msg.sender)) {
            _approve(address(0), _tokenId);
        }
    }

    function _isTokenApproved(uint256 _tokenId, address _approved) internal view returns (bool) {
        return getApproved(_tokenId) == _approved;
    }
}"
3424,Get the name of collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollectionRegistry is Ownable {
    using SafeMath for uint256;

    uint256 public totalCollections;
    mapping(uint64 => bytes8) private collectionNames;

    modifier validIndex(uint64 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (bytes8) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        return collectionNames[_collectionIndex];
    }

    function setTotalCollections(uint256 newTotalCollections) public onlyOwner {
        totalCollections = newTotalCollections;
    }

    function setCollectionName(uint64 _collectionIndex, bytes8 _name) public onlyOwner validIndex(_collectionIndex) {
        collectionNames[_collectionIndex] = _name;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Collection is Ownable {
    struct CollectionData {
        string name;
        // Other data can be added here
    }

    CollectionData[] private collections;

    function getCollectionName(uint256 _collectionIndex) public view returns (string memory) {
        require(_collectionIndex < collections.length, ""Collection index out of bounds"");
        return collections[_collectionIndex].name;
    }
}",4.118845939636231,getCollectionName,"[{'function': 'getCollectionName', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCollectionName"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collections""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Collection index out of bounds""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collections""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""memberName"": ""name""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",4.0,0.8654944168974934,0.3026621649248818,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Collection is Ownable {
    struct CollectionData {
        string name;
        // Other data can be added here
    }

    CollectionData[] private collections;

    function getCollectionName(uint256 _collectionIndex) public view returns (string memory) {
        require(_collectionIndex < collections.length, ""Collection index out of bounds"");
        return collections[_collectionIndex].name;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        collections = [CollectionData({name: 'initialized'}), CollectionData({name: 'initialized'})];
    }
}"
4496,This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ICOContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoEndDate;
    bool public paused = false;

    mapping(address => bool) public whitelistedAddresses;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        require(whitelistedAddresses[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
        icoEndDate = _date;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ICO is Ownable {
    uint256 public icoEndDate;
    bool public endDateSet = false;

    modifier onlyOnce() {
        require(!endDateSet, ""End date can only be set once"");
        _; // Continue execution
    }

    function setIcoEndDate(uint256 _icoEndDate) public onlyOwner onlyOnce {
        icoEndDate = _icoEndDate;
        endDateSet = true;
    }
}",5.169896125793457,setIcoEndDate,"[{'function': 'setIcoEndDate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcoEndDate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_icoEndDate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoEndDate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_icoEndDate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""endDateSet""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyOnce"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.8586097049129644,0.0891001787898007,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ICO is Ownable {
    uint256 public icoEndDate;
    bool public endDateSet = false;

    modifier onlyOnce() {
        require(!endDateSet, ""End date can only be set once"");
        _; // Continue execution
    }

    constructor() Ownable(msg.sender) {
        icoEndDate = 1;
        endDateSet = true;
    }

    function setIcoEndDate(uint256 _icoEndDate) public onlyOwner onlyOnce {
        icoEndDate = _icoEndDate;
        endDateSet = true;
    }
}"
1334,Adding ` _backer.address ( ) ` as an early backer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct backerData {
        uint tokenPrice;
        uint tokenAmount;
        bytes32 privatePhraseHash;
        bool claimed;
        bool redeemed;
        uint rank;
    }

    address[] public earlyBackerList;
    address[] public backersAddresses;
    mapping(address => backerData[]) public backers;
    uint public prepaidUnits;
    uint public claimedUnits;
    uint public promissoryUnits;
    uint public lastPrice;
    uint public numOfBackers;

    event AddedPrepaidTokensEvent(address indexed backer, uint indexed index, uint tokenPrice, uint tokenAmount);

    modifier founderCall() {
        require(msg.sender == owner(), ""Only the founder can call this function"");
        _;
    }

    function setPrepaid(address _backer, uint _tokenPrice, uint _tokenAmount, string memory _privatePhrase, uint _backerRank) external founderCall returns (uint) {
        require(_tokenPrice > 0 && _tokenAmount > 0);
        require(claimedUnits == 0);
        require(_tokenAmount.add(prepaidUnits).add(claimedUnits) <= promissoryUnits);
        if (earlyBackerList.length == numOfBackers && backers[_backer].length == 0) {
            earlyBackerList.push(_backer);
            backersAddresses.push(_backer);
        }
        backers[_backer].push(backerData(_tokenPrice, _tokenAmount, keccak256(abi.encodePacked(_privatePhrase, _backer)), true, false, _backerRank));
        prepaidUnits = prepaidUnits.add(_tokenAmount);
        lastPrice = _tokenPrice;
        emit AddedPrepaidTokensEvent(_backer, backers[_backer].length - 1, _tokenPrice, _tokenAmount);
        return backers[_backer].length - 1;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract BackerContract is AccessControl {
    bytes32 public constant EARLY_BACKER_ROLE = keccak256(""EARLY_BACKER_ROLE"");

    constructor() {
        _setupRole(EARLY_BACKER_ROLE, msg.sender);
    }

    function addEarlyBacker(address _backer) public onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(EARLY_BACKER_ROLE, _backer);
    }
}",5.730390787124634,addEarlyBacker,"[{'function': 'addEarlyBacker', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addEarlyBacker"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_backer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""EARLY_BACKER_ROLE""}, {""type"": ""Identifier"", ""name"": ""_backer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",96.0,0.5773807542020698,0.0007929576198541,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BackerContract is AccessControl, Ownable {
    bytes32 public constant EARLY_BACKER_ROLE = keccak256(""EARLY_BACKER_ROLE"");

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(EARLY_BACKER_ROLE, DEFAULT_ADMIN_ROLE);
        _grantRole(EARLY_BACKER_ROLE, msg.sender);
    }

    function addEarlyBacker(address _backer) public onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(EARLY_BACKER_ROLE, _backer);
    }
}"
517,Used to intialize the variables of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public maxHolderPercentage;

    modifier onlyFactory() {
        require(msg.sender == factory, ""Only the factory can call this function"");
        _;
    }

    address private factory;

    constructor() {
        // Initialize the factory address in the constructor or later
    }

    function configure(uint256 _maxHolderPercentage) public onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public stateVariable1;
    string public stateVariable2;

    function initialize(uint256 _stateVariable1, string memory _stateVariable2) public onlyOwner {
        require(bytes(_stateVariable2).length > 0, ""Invalid string"");

        stateVariable1 = _stateVariable1;
        stateVariable2 = _stateVariable2;
    }
}",7.427486896514893,initialize,"[{'function': 'initialize', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_stateVariable1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_stateVariable2"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_stateVariable2""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid string""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stateVariable1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_stateVariable1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stateVariable2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_stateVariable2""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.3751805461663313,0.0194716997140498,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public stateVariable1;
    string public stateVariable2;

    constructor() Ownable(msg.sender) {
        stateVariable1 = 1;
        stateVariable2 = 'initialized';
    }
}"
3727,Core logic of the ` decreaseApproval ` function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20Store {
    function allowed(address _owner, address _spender) external view returns (uint256);
    function setAllowance(address _owner, address _spender, uint256 _value) external;
}

interface IERC20Proxy {
    function emitApproval(address _owner, address _spender, uint256 _value) external;
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20Store public erc20Store;
    IERC20Proxy public erc20Proxy;

    constructor(address _erc20Store, address _erc20Proxy) {
        erc20Store = IERC20Store(_erc20Store);
        erc20Proxy = IERC20Proxy(_erc20Proxy);
    }

    function decreaseApprovalWithSender(address _sender, address _spender, uint256 _subtractedValue) public onlyOwner returns (bool) {
        require(_spender != address(0));
        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);
        uint256 newAllowance = currentAllowance.sub(_subtractedValue);
        require(newAllowance <= currentAllowance);
        erc20Store.setAllowance(_sender, _spender, newAllowance);
        erc20Proxy.emitApproval(_sender, _spender, newAllowance);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {

    using SafeERC20 for IERC20;

    mapping (address => mapping (address => uint256)) private _allowances;

    function decreaseApproval(address spender, uint256 subtractedValue) public returns (bool) {
        uint256 oldValue = _allowances[msg.sender][spender];
        require(oldValue >= subtractedValue, ""ERC20: decreased allowance below zero"");
        uint256 newValue = oldValue - subtractedValue;
        _allowances[msg.sender][spender] = newValue;
        emit Approval(msg.sender, spender, newValue);
        return true;
    }
}",9.648486137390137,decreaseApproval,"[{'function': 'decreaseApproval', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""subtractedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""oldValue""}, ""right"": {""type"": ""Identifier"", ""name"": ""subtractedValue""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: decreased allowance below zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""oldValue""}, ""right"": {""type"": ""Identifier"", ""name"": ""subtractedValue""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newValue""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""newValue""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.8887614923374504,0.134195154430096,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    using SafeERC20 for IERC20;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 public totalSupply;

 constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialization of state variables
        _totalSupply = 1 * 10 ** decimals(); // Set total supply to 1 token with appropriate decimals
    }

    function decreaseApproval(address spender, uint256 subtractedValue) public returns (bool) {
        uint256 oldValue = _allowances[msg.sender][spender];
        require(oldValue >= subtractedValue, ""ERC20: decreased allowance below zero"");
        uint256 newValue = oldValue - subtractedValue;
        _allowances[msg.sender][spender] = newValue;
        emit Approval(msg.sender, spender, newValue);
        return true;
    }
}"
5953,"Sets the address of another contract to handle the requests of this contract , it can be used to deprecate this Oracle","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    address public fallback;

    function setFallback(address _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Oracle is Ownable {
    address private requestHandler;

    function setRequestHandler(address _requestHandler) external onlyOwner {
        require(_requestHandler != address(0), ""Invalid address"");
        requestHandler = _requestHandler;
    }

    function getRequestHandler() public view returns (address) {
        return requestHandler;
    }
}",3.521233081817627,setRequestHandler,"[{'function': 'setRequestHandler', 'complexity': 1}, {'function': 'getRequestHandler', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRequestHandler"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_requestHandler"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_requestHandler""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""requestHandler""}, ""right"": {""type"": ""Identifier"", ""name"": ""_requestHandler""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.4851033596053989,0.0229766596636664,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Oracle is Ownable {
    address private requestHandler = 0x1111111111111111111111111111111111111111; // Replace with actual address

    constructor() Ownable(msg.sender) {
        super();
        _setRequestHandler(address(0));
    }

    function setRequestHandler(address _requestHandler) external onlyOwner {
        require(_requestHandler != address(0), ""Invalid address"");
        requestHandler = _requestHandler;
    }

    function getRequestHandler() public view returns (address) {
        return requestHandler;
    }
}"
6776,Sends fees to the request burning address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public requestBurnerContract;

    constructor(address _requestBurnerContract) {
        requestBurnerContract = _requestBurnerContract;
    }

    function collectForREQBurning(uint256 _amount) internal {
        require(_amount > 0, ""Amount must be greater than zero"");
        (bool success, ) = requestBurnerContract.call{value: _amount}("""");
        require(success, ""Transfer failed"");
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract SendToFees is ReentrancyGuard, Ownable {
    using Address for address payable;
    address public burningAddress;
    ERC20 public token;

    constructor(address _token, address _burningAddress) {
        token = ERC20(_token);
        burningAddress = _burningAddress;
    }

    function sendFees(uint256 _amount)
        external
        nonReentrant
        onlyOwner
    {
        require(_amount <= token.balanceOf(address(this)), ""Insufficient tokens in contract"");
        bool sent = _sendFees(_amount);
        require(sent, ""Send Fees Failed"");
    }

    function _sendFees(uint256 _amount) internal returns (bool) {
        token.transfer(burningAddress, _amount);
        return true;
    }
}",9.988150119781494,sendFees,"[{'function': 'sendFees', 'complexity': 0}, {'function': '_sendFees', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient tokens in contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""sent"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_sendFees""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sent""}, {""type"": ""stringLiteral"", ""value"": ""Send Fees Failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.5681643480329654,0.1978925379954907,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SendToFees is ReentrancyGuard, Ownable {
    using Address for address payable;
    address public burningAddress;
    ERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address _burningAddress) Ownable(msg.sender) {
        token = ERC20(_token);
        burningAddress = _burningAddress;
    }

    function sendFees(uint256 _amount)
        external
        nonReentrant
        onlyOwner
    {
        require(_amount <= token.balanceOf(address(this)), ""Insufficient tokens in contract"");
        bool sent = _sendFees(_amount);
        require(sent, ""Send Fees Failed"");
    }

    function _sendFees(uint256 _amount) internal returns (bool) {
        token.transfer(burningAddress, _amount);
        return true;
    }
}"
1286,Verifies a broker 's signature for an order opening .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public brokers;

    function verifyOpenSignature(address _trader, bytes memory _signature, bytes32 _orderID) external view returns (bool) {
        bytes memory data = abi.encodePacked(""Republic Protocol: open: "", _trader, _orderID);
        address signer = Utils.addr(data, _signature);
        return brokers[signer];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ECDSA.sol"";

contract Broker {
    using ECDSA for bytes32;

    // This could be a mapping to store brokers with their corresponding public keys
    mapping(address => bytes32) public brokers;

    function verifyBrokerSignature(bytes32 orderHash, address broker, bytes memory signature) public view returns (bool) {
        // Requirements for broker and signature not to be null
        require(broker != address(0), ""Broker is the zero address"");
        require(signature.length > 0, ""Signature is empty"");

        // Compute broker hash: this recreates what the signed message from broker looked like
        bytes32 hash = keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", orderHash));

        // Recover signer of hash
        address signer = hash.recover(signature);

        // Check that broker is the signer
        require(signer == broker, ""Broker is not the signer"");

        return true;
    }
}",6.927412986755371,verifyBrokerSignature,"[{'function': 'verifyBrokerSignature', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyBrokerSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""orderHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""broker"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""broker""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Broker is the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""signature""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Signature is empty""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""\\x19Ethereum Signed Message:\\n32""}, {""type"": ""Identifier"", ""name"": ""orderHash""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hash""}, ""memberName"": ""recover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""signer""}, ""right"": {""type"": ""Identifier"", ""name"": ""broker""}}, {""type"": ""stringLiteral"", ""value"": ""Broker is not the signer""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",27.0,0.7230764299094963,0.0788896422571247,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ECDSA.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Broker is Ownable {
    using ECDSA for bytes32;

    // This could be a mapping to store brokers with their corresponding public keys
    mapping(address => bytes32) public brokers;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function verifyBrokerSignature(bytes32 orderHash, address broker, bytes memory signature) public view returns (bool) {
        // Requirements for broker and signature not to be null
        require(broker != address(0), ""Broker is the zero address"");
        require(signature.length > 0, ""Signature is empty"");

        // Compute broker hash: this recreates what the signed message from broker looked like
        bytes32 hash = keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", orderHash));

        // Recover signer of hash
        address signer = hash.recover(signature);

        // Check that broker is the signer
        require(signer == broker, ""Broker is not the signer"");

        return true;
    }
}"
5432,Set the minimum required havven balance to have standing to bring a motion .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public minStandingBalance;

    function setMinStandingBalance(uint balance) external onlyOwner {
        minStandingBalance = balance;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SetMinimumHavvenBalance is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public minHavvenBalance;

    event MinHavvenBalanceSet(uint256 newMinHavvenBalance);

    function setMinHavvenBalance(uint256 _minHavvenBalance) external onlyOwner nonReentrant {
        minHavvenBalance = _minHavvenBalance;
        emit MinHavvenBalanceSet(_minHavvenBalance);
    }
}",7.763611793518066,setMinHavvenBalance,"[{'function': 'setMinHavvenBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinHavvenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minHavvenBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minHavvenBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minHavvenBalance""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MinHavvenBalanceSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_minHavvenBalance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.8132084743458906,0.0609051111196565,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

contract SetMinimumHavvenBalance is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public minHavvenBalance;

    event MinHavvenBalanceSet(uint256 newMinHavvenBalance);

    constructor() Ownable(msg.sender) {
        minHavvenBalance = 1; // Set to a non-zero, safe value
    }

    function setMinHavvenBalance(uint256 _minHavvenBalance) external onlyOwner nonReentrant {
        require(_minHavvenBalance > 0, ""Minimum balance must be greater than zero"");
        minHavvenBalance = _minHavvenBalance;
        emit MinHavvenBalanceSet(_minHavvenBalance);
    }
}"
6260,"Opens a new channel or tops up an existing one , compatibility with ERC 223 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token;
    mapping(address => bool) public trusted_contracts;

    constructor(address _token, address[] memory _trustedContracts) {
        require(_token != address(0), ""Invalid token address"");
        token = _token;
        for (uint i = 0; i < _trustedContracts.length; i++) {
            trusted_contracts[_trustedContracts[i]] = true;
        }
    }

    function createChannelPrivate(address _sender, address _receiver, uint256 _deposit) internal virtual;

    function updateInternalBalanceStructs(address _sender, address _receiver, uint32 _openBlockNumber, uint256 _deposit) internal virtual;

    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) external {
        require(msg.sender == token, ""Sender must be the token contract"");
        require(_deposit <= type(uint192).max, ""Deposit exceeds uint192 limit"");
        uint256 deposit = uint256(_deposit);
        require(deposit == _deposit, ""Deposit conversion overflow"");

        uint256 length = _data.length;
        require(length == 40 || length == 44, ""Invalid data length"");

        address channel_sender_address = addressFromBytes(_data, 0x20);
        require(_sender_address == channel_sender_address || trusted_contracts[_sender_address], ""Unauthorized sender"");

        address channel_receiver_address = addressFromBytes(_data, 0x34);
        if (length == 40) {
            createChannelPrivate(channel_sender_address, channel_receiver_address, deposit);
        } else {
            uint32 open_block_number = uint32(blockNumberFromBytes(_data, 0x48));
            updateInternalBalanceStructs(channel_sender_address, channel_receiver_address, open_block_number, deposit);
        }
    }

    function addressFromBytes(bytes memory _data, uint256 offset) internal pure returns (address addr) {
        assembly {
            addr := mload(add(_data, add(0x20, offset)))
        }
    }

    function blockNumberFromBytes(bytes memory _data, uint256 offset) internal pure returns (uint32 block_number) {
        assembly {
            block_number := mload(add(_data, add(0x48, offset)))
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC223/ERC223.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract Channels is ReentrancyGuard {
    using SafeERC20 for IERC223;

    struct Channel {
        address owner;
        uint256 balance;
    }

    mapping(address => Channel) public channels;

    function openOrTopUpChannel(address _tokenAddress, address _owner, uint256 _amount) public nonReentrant {
        IERC223 token = IERC223(_tokenAddress);

        // Fund the channel with specified amount, utilizing safe transfer from OpenZeppelin
        token.safeTransferFrom(msg.sender, address(this), _amount);

        // If the channel does not exist, create a new one
        if (channels[_owner].owner == address(0)) {
            channels[_owner] = Channel(_owner, _amount);
        } else {  //If the channel already exists, top up the channel balance
            channels[_owner].balance += _amount;
        }
    }
}",9.784180164337158,openOrTopUpChannel,"[{'function': 'openOrTopUpChannel', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""openOrTopUpChannel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC223""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC223""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Channel""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",79.0,0.4762500005681152,0.0421338286053354,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC223/ERC223.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Channels is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC223;

    struct Channel {
        address owner;
        uint256 balance;
    }

    mapping(address => Channel) public channels;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function openOrTopUpChannel(address _tokenAddress, address _owner, uint256 _amount) public nonReentrant {
        IERC223 token = IERC223(_tokenAddress);

        // Fund the channel with specified amount, utilizing safe transfer from OpenZeppelin
        token.safeTransferFrom(msg.sender, address(this), _amount);

        // If the channel does not exist, create a new one
        if (channels[_owner].owner == address(0)) {
            channels[_owner] = Channel(_owner, _amount);
        } else {  //If the channel already exists, top up the channel balance
            channels[_owner].balance += _amount;
        }
    }
}"
3890,Transfers ETH according to the data held within the specified payment id ( internal function ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LiquidPledging {
    function confirmPayment(uint64, uint256) external;
}

struct Payment {
    uint256 amount;
    address dest;
    uint64 ref;
    PaymentStatus state;
}

enum PaymentStatus { Pending, Paid }

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    LiquidPledging public liquidPledging;
    Payment[] public payments;

    event ConfirmPayment(uint256 indexed idPayment, uint64 ref);

    function doConfirmPayment(uint256 _idPayment) external onlyOwner {
        require(_idPayment < payments.length);
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending);
        p.state = PaymentStatus.Paid;
        liquidPledging.confirmPayment(uint64(p.ref), p.amount);
        payable(p.dest).transfer(p.amount);
        emit ConfirmPayment(_idPayment, p.ref);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PaymentProcessor {
    using SafeMath for uint256;

    struct Payment {
        address payable recipient;
        uint256 amount;
    }

    mapping(uint256 => Payment) internal payments;

    function transferETH(uint256 paymentId) internal {
        Payment storage payment = payments[paymentId];
        require(payment.amount <= address(this).balance, ""Insufficient contract balance"");

        (bool success,) = payment.recipient.call{value: payment.amount}("""");
        require(success, ""Fund transfer failed."");

        // Update the payment, this is to prevent re-entrancy attacks
        payment.amount = 0;
    }
}",8.360985040664673,transferETH,"[{'function': 'transferETH', 'complexity': 2}]",3.0,{},58.0,0.6592217063172463,0.0176341771425826,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PaymentProcessor is Ownable {
    using SafeMath for uint256;

    struct Payment {
        address payable recipient;
        uint256 amount;
    }

    mapping(uint256 => Payment) internal payments;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            payments[i] = Payment({recipient: payable(addr), amount: uint256(i)});
        }
    }

    function transferETH(uint256 paymentId) internal {
        Payment storage payment = payments[paymentId];
        require(payment.amount <= address(this).balance, ""Insufficient contract balance"");

        (bool success,) = payment.recipient.call{value: payment.amount}("""");
        require(success, ""Fund transfer failed."");

        // Update the payment, this is to prevent re-entrancy attacks
        payment.amount = 0;
    }
}"
3719,only the admin is allowed to change the admin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public admin;

    event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);

    modifier validate_address(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    function changeAdmin(address newAdmin) public validate_address(newAdmin) onlyOwner {
        if (admin == newAdmin) revert();
        emit AdminOwnershipTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    address private _admin;

    constructor() {
        _admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == _admin, ""Not admin"");
        _;
    }

    function changeAdmin(address newAdmin) public onlyAdmin {
        _admin = newAdmin;
    }
}",5.040994882583618,changeAdmin,"[{'function': 'changeAdmin', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_admin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAdmin""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.902227302063546,0.1090396038837204,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address private _admin;

    constructor(address admin) Ownable() {
        _admin = admin;
    }

    modifier onlyAdmin() {
        require(msg.sender == _admin, ""Not admin"");
        _;
    }

    function changeAdmin(address newAdmin) public onlyAdmin {
        _admin = newAdmin;
    }
}"
4898,Announces intent to withdraw tokens using ` slowWithdraw `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AnnounceWithdrawalWrapper is Ownable {
    using SafeMath for uint256;

    struct AnnouncedWithdrawal {
        uint256 canWithdrawAt;
        uint256 amount;
    }

    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;
    uint256 public withdrawAnnounceDelay;

    constructor(uint256 _withdrawAnnounceDelay) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }

    function announceWithdraw(address _token, uint256 _amount) external onlyOwner {
        require(_amount <= balances[msg.sender][_token], ""Amount too high"");
        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];
        uint256 canWithdrawAt = block.timestamp + withdrawAnnounceDelay;
        announcement.canWithdrawAt = canWithdrawAt;
        announcement.amount = _amount;
        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract MyContract is ReentrancyGuard {
    using SafeERC20 for IERC20;

    mapping(address => uint256) public pendingWithdrawals;

    function slowWithdraw(address token, uint256 amount) external nonReentrant {
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        pendingWithdrawals[msg.sender] += amount;
    }
}",5.608858108520508,slowWithdraw,"[{'function': 'slowWithdraw', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""slowWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingWithdrawals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",37.0,0.7485542238540503,0.0304184134099276,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    mapping(address => uint256) public pendingWithdrawals;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        pendingWithdrawals[address(0)] = 1; // Initialize to safe, non-corner-case value for address and uint256
    }

    function slowWithdraw(address token, uint256 amount) external nonReentrant {
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        pendingWithdrawals[msg.sender] += amount;
    }
}"
2359,Count the number of attribute types defined by the registry .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeCounter {
    using SafeMath for uint256;

    uint256[] private _attributeTypes;

    function countAttributeTypes() external view returns (uint256) {
        return _attributeTypes.length;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract Registry is AccessControl {
    bytes32 public constant REGISTRY_ROLE = keccak256(""REGISTRY_ROLE"");

    mapping (uint => string) private _attributeTypes;

    constructor () {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(REGISTRY_ROLE, _msgSender());
    }

    function addAttributeType(uint attributeId, string memory attribute) public onlyRole(REGISTRY_ROLE) {
        _attributeTypes[attributeId] = attribute;
    }

    function countAttributeTypes() public view returns (uint256) {
        uint256 counter = 0;

        for (uint256 i = 0; i < type(uint256).max; i++) {
            if (bytes(_attributeTypes[i]).length > 0) {
                counter++;
            }
        }

        return counter;
    }
}",13.778861045837402,countAttributeTypes,"[{'function': 'addAttributeType', 'complexity': 0}, {'function': 'countAttributeTypes', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""countAttributeTypes"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""counter"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""counter""}, ""isPrefix"": False}}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""counter""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",26.0,0.9065516704951626,0.1490367112337108,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Context.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Registry is Context, AccessControl {
    bytes32 public constant REGISTRY_ROLE = keccak256(""REGISTRY_ROLE"");

    mapping (uint => string) private _attributeTypes;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(REGISTRY_ROLE, _msgSender());
    }

    function addAttributeType(uint attributeId, string memory attribute) public onlyRole(REGISTRY_ROLE) {
        _attributeTypes[attributeId] = attribute;
    }

    function countAttributeTypes() public view returns (uint256) {
        uint256 counter = 0;

        for (uint256 i = 0; i < type(uint256).max; i++) {
            if (bytes(_attributeTypes[i]).length > 0) {
                counter++;
            }
        }

        return counter;
    }
}"
239,Register a new child universe after a fork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IUniverse {
    function getWinningChildUniverse() external view returns (address);
}

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract Universe is AccessControl {

    struct ChildUniverse {
        bool isForked;
        address childAddress;
    }

    mapping(address => ChildUniverse) public childUniverses;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function registerChildUniverse(address _childAddress) public onlyRole(ADMIN_ROLE) {
        require(_childAddress != address(0), ""Invalid child universe address"");
        require(childUniverses[_childAddress].childAddress == address(0), ""Child universe already registered"");

        childUniverses[_childAddress] = ChildUniverse(false, _childAddress);
    }

    function forkChildUniverse(address _childAddress) public onlyRole(ADMIN_ROLE) {
        require(_childAddress != address(0), ""Invalid child universe address"");
        require(childUniverses[_childAddress].childAddress != address(0), ""Child universe not registered"");

        ChildUniverse storage childUniverse = childUniverses[_childAddress];
        require(childUniverse.isForked == false, ""Child universe already forked"");

        childUniverse.isForked = true;
    }
}",11.4512460231781,forkChildUniverse,"[{'function': 'registerChildUniverse', 'complexity': 2}, {'function': 'forkChildUniverse', 'complexity': 3}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""forkChildUniverse"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_childAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_childAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid child universe address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""childUniverses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_childAddress""}}, ""memberName"": ""childAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Child universe not registered""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ChildUniverse""}, ""name"": ""childUniverse"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""childUniverses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_childAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""childUniverse""}, ""memberName"": ""isForked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""Child universe already forked""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""childUniverse""}, ""memberName"": ""isForked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",35.0,0.5452370814998548,0.0289198921425427,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract Universe is AccessControl, Ownable {

    struct ChildUniverse {
        bool isForked;
        address childAddress;
    }

    mapping(address => ChildUniverse) public childUniverses;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function registerChildUniverse(address _childAddress) public onlyRole(ADMIN_ROLE) {
        require(_childAddress != address(0), ""Invalid child universe address"");
        require(childUniverses[_childAddress].childAddress == address(0), ""Child universe already registered"");

        childUniverses[_childAddress] = ChildUniverse(false, _childAddress);
    }

    function forkChildUniverse(address _childAddress) public onlyRole(ADMIN_ROLE) {
        require(_childAddress != address(0), ""Invalid child universe address"");
        require(childUniverses[_childAddress].childAddress != address(0), ""Child universe not registered"");

        ChildUniverse storage childUniverse = childUniverses[_childAddress];
        require(childUniverse.isForked == false, ""Child universe already forked"");

        childUniverse.isForked = true;
    }
}"
4301,` callPlugins ` calls ` callPluginsPledge ` once for the transfer context and once for the receiving context .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint amount) internal returns (uint allowedAmount) {
        allowedAmount = amount;
        allowedAmount = callPluginsPledge(before, fromPledge, fromPledge, toPledge, allowedAmount);
        allowedAmount = callPluginsPledge(before, toPledge, fromPledge, toPledge, allowedAmount);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function callPlugins(address _transferCtx, address _receivingCtx, uint256 _amount) public onlyRole(ADMIN_ROLE) {
        require(_transferCtx != address(0), ""Transfer context cannot be zero address"");
        require(_receivingCtx != address(0), ""Receiving context cannot be zero address"");
        require(_amount > 0, ""Amount cannot be zero"");

        callPluginsPledge(_transferCtx, _amount);
        callPluginsPledge(_receivingCtx, _amount);
    }

    function callPluginsPledge(address _ctx, uint256 _amount) private {
        // Detailed implementation of callPluginsPledge is based on the contract's needs
        // Here we are assuming it to be a method that organizes a secure transfer
    }
}",8.85135793685913,callPlugins,"[{'function': 'callPlugins', 'complexity': 3}, {'function': 'callPluginsPledge', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""callPlugins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_transferCtx"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_receivingCtx"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_transferCtx""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Transfer context cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_receivingCtx""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Receiving context cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""callPluginsPledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_transferCtx""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""callPluginsPledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_receivingCtx""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.3662534364485131,0.029684723291943,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() Ownable(msg.sender) {
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    function callPlugins(address _transferCtx, address _receivingCtx, uint256 _amount) public onlyRole(ADMIN_ROLE) {
        require(_transferCtx != address(0), ""Transfer context cannot be zero address"");
        require(_receivingCtx != address(0), ""Receiving context cannot be zero address"");
        require(_amount > 0, ""Amount cannot be zero"");

        callPluginsPledge(_transferCtx, _amount);
        callPluginsPledge(_receivingCtx, _amount);
    }

    function callPluginsPledge(address _ctx, uint256 _amount) private {
        // Detailed implementation of callPluginsPledge is based on the contract's needs
        // Here we are assuming it to be a method that organizes a secure transfer
    }
}"
2476,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;

    function burn(uint256 _value) public {
        require(_value <= balances[msg.sender], 'Insufficient balance');
        balances[msg.sender] = balances[msg.sender].sub(_value);
    }
}",4.783221006393433,burn,"[{'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.855684734741651,0.1567040297422811,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        balances[owner()] = 1; // Set initial balance to 1
    }

    function burn(uint256 _value) public {
        require(_value <= balances[msg.sender], 'Insufficient balance');
        balances[msg.sender] = balances[msg.sender].sub(_value);
    }
}"
2621,Only registrations in future can be removed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function unregister(
        bytes32 _key,
        address _address,
        uint _timestamp,
        uint _gasLimit,
        uint _gasPrice
    ) external returns (uint) {
        // Function body here
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Registration {
    struct Event {
        uint id;
        string name;
        uint256 eventDate;
    }

    mapping(uint => Event) public events;
    uint public nextEventId = 0;

    modifier onlyFutureEvent(uint _eventId) {
        require(events[_eventId].eventDate > block.timestamp, ""Can only remove future events"");
        _;
    }

    function removeEvent(uint _eventId) public onlyFutureEvent(_eventId) {
        delete events[_eventId];
    }
}",6.6934027671813965,removeEvent,"[{'function': 'removeEvent', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeEvent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_eventId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""events""}, ""index"": {""type"": ""Identifier"", ""name"": ""_eventId""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyFutureEvent"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_eventId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.4275850062325442,0.0184864068143686,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Registration is Ownable {
    struct Event {
        uint id;
        string name;
        uint256 eventDate;
    }

    mapping(uint => Event) public events;
    uint public nextEventId = 0;

    modifier onlyFutureEvent(uint _eventId) {
        require(events[_eventId].eventDate > block.timestamp, ""Can only remove future events"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        nextEventId = 1;
    }

    function removeEvent(uint _eventId) public onlyFutureEvent(_eventId) {
        delete events[_eventId];
    }
}"
2632,the goal the campaign must reach in order for it to succeed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Crowdfunding {
    using SafeMath for uint256;

    uint256 public totalAmountRaised;

    function amountRaised() public view returns (uint256) {
        return totalAmountRaised;
    }
}","SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Campaign is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public goal;
    uint256 public totalRaised;

    event Succeed(bool isCampaignSucceeded);

    function setGoal(uint256 _goal) external onlyOwner {
        goal = _goal;
    }

    function donate(uint256 _amount) external payable nonReentrant {
        require(_amount > 0, ""Donation amount must be greater than zero"");
        totalRaised = totalRaised.add(_amount);
        if(totalRaised >= goal) {
            emit Succeed(true);
        }
    }
}",14.498764038085938,donate,"[{'function': 'setGoal', 'complexity': 0}, {'function': 'donate', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""donate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Donation amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalRaised""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalRaised""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalRaised""}, ""right"": {""type"": ""Identifier"", ""name"": ""goal""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Succeed""}, ""arguments"": [{""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",19.0,0.5863076737227669,0.0139043206862505,"SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Campaign is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public goal;
    uint256 public totalRaised;

    event Succeed(bool isCampaignSucceeded);

    constructor() Ownable(msg.sender) {
        goal = 1;
        totalRaised = 0;
    }

    function setGoal(uint256 _goal) external onlyOwner {
        goal = _goal;
    }

    function donate(uint256 _amount) external payable nonReentrant {
        require(_amount > 0, ""Donation amount must be greater than zero"");
        totalRaised = totalRaised.add(_amount);
        if (totalRaised >= goal) {
            emit Succeed(true);
        }
    }
}"
827,approving image to be taken from specific address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract MarketplaceWrapper is Ownable {
    using SafeMath for uint256;

    address public marketplaceContract;

    constructor(address _marketplaceContract) {
        require(_marketplaceContract != address(0), ""Invalid marketplace contract address"");
        marketplaceContract = _marketplaceContract;
    }

    function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyOwner {
        require(msg.sender == marketplaceContract, ""Only the marketplace contract can call this function"");
        require(isApprovedOrOwner(_from, _imageId), ""The token is not approved or owned by the sender"");
        clearApproval(_from, _imageId);
        removeTokenFrom(_from, _imageId);
        addTokenTo(_to, _imageId);
        emit Transfer(_from, _to, _imageId);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";

contract ImageApproval is Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _imageIds;

    mapping (uint => address) public imageApprovals;

    function approveImage(address _approver, uint _imageId) public onlyOwner {
        require(_imageId > 0 && _imageId <= _imageIds.current(), ""Invalid image ID"");
        imageApprovals[_imageId] = _approver;
    }

    function createImage() public onlyOwner returns (uint) {
        _imageIds.increment();
        return _imageIds.current();
    }
}",10.326807975769045,approveImage,"[{'function': 'approveImage', 'complexity': 2}, {'function': 'createImage', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveImage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_approver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_imageId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_imageId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_imageId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_imageIds""}, ""memberName"": ""current""}, ""arguments"": [], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid image ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""imageApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_imageId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approver""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.5076963214623222,0.0517949512572148,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Counters.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ImageApproval is Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _imageIds;

    mapping (uint => address) public imageApprovals;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _imageIds = Counters.Counter({value: 1});
    }

    function approveImage(address _approver, uint _imageId) public onlyOwner {
        require(_imageId > 0 && _imageId <= _imageIds.current(), ""Invalid image ID"");
        imageApprovals[_imageId] = _approver;
    }

    function createImage() public onlyOwner returns (uint) {
        _imageIds.increment();
        return _imageIds.current();
    }
}"
3458,"http : //solidity.readthedocs.io/en/develop/contracts.html # fallback-function we dont need recieve ETH always , only in State.Sale from externally accounts .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum State { Sale, Paused }
    State public currentState = State.Sale;

    function byTokens() internal view virtual;

    modifier atState(State state) {
        require(currentState == state, ""Not in the correct state"");
        _;
    }

    function () external payable atState(State.Sale) {
        byTokens();
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable {
  using SafeMath for uint256;

  enum State { Sale, NotSale }
  State public state;

  constructor() {
    state = State.NotSale;
  }

  fallback() external payable {
    require(state == State.Sale, ""Cannot receive ETH when not in sale state"");
  }

  function setState(State _state) external onlyOwner {
    state = _state;
  }
}",7.21315598487854,setState,"[{'function': 'setState', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""fallback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Sale""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot receive ETH when not in sale state""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": True, ""isReceive"": False, ""stateMutability"": ""payable""}",,0.5612474694749935,0.0370760924184185,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
  using SafeMath for uint256;

  enum State { Sale, NotSale }
  State public state;

  constructor() Ownable(msg.sender) {
    state = State.NotSale;
  }

  fallback() external payable {
    require(state == State.Sale, ""Cannot receive ETH when not in sale state"");
  }

  function setState(State _state) external onlyOwner {
    state = _state;
  }
}"
5648,Creates a checkpoint that can be used to query historical balances / totalSuppy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CheckpointModule is Ownable {
    using SafeMath for uint256;

    event LogCheckpointCreated(uint256 indexed checkpointId, uint256 timestamp);

    uint256 public currentCheckpointId = 0;
    constanst CHECKPOINT_KEY = bytes32(""CHECKPOINT_KEY"");

    modifier onlyModule(bytes32 moduleKey, bool allowed) {
        require(moduleKey == CHECKPOINT_KEY && allowed, ""Only the module can call this function."");
        _;
    }

    function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns (uint256) {
        require(currentCheckpointId < type(uint256).max.sub(1));
        currentCheckpointId = currentCheckpointId.add(1);
        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
        return currentCheckpointId;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Checkpoint {
    using SafeMath for uint256;

    struct Check {
        uint256 fromBlock;
        uint256 value;
    }

    Check[] public balanceHistory;
    Check[] public totalSupplyHistory;

    function createCheckpoint(uint256 _value, uint256 _totalSupply) external {
        Check memory newBalanceCheckpoint = Check({
            fromBlock: block.number,
            value: _value
        });

        Check memory newTotalSupplyCheckpoint = Check({
            fromBlock: block.number,
            value: _totalSupply
        });

        balanceHistory.push(newBalanceCheckpoint);
        totalSupplyHistory.push(newTotalSupplyCheckpoint);
    }
}",7.716610908508301,createCheckpoint,"[{'function': 'createCheckpoint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCheckpoint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_totalSupply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Check""}, ""name"": ""newBalanceCheckpoint"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Check""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": [""fromBlock"", ""value""]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Check""}, ""name"": ""newTotalSupplyCheckpoint"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Check""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, {""type"": ""Identifier"", ""name"": ""_totalSupply""}], ""names"": [""fromBlock"", ""value""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceHistory""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newBalanceCheckpoint""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupplyHistory""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newTotalSupplyCheckpoint""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.6953203840431794,0.0349814974478021,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Checkpoint is Ownable {
    using SafeMath for uint256;

    struct Check {
        uint256 fromBlock;
        uint256 value;
    }

    Check[] public balanceHistory;
    Check[] public totalSupplyHistory;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        balanceHistory = [];
        totalSupplyHistory = [];
    }

    function createCheckpoint(uint256 _value, uint256 _totalSupply) external {
        Check memory newBalanceCheckpoint = Check({
            fromBlock: block.number,
            value: _value
        });

        Check memory newTotalSupplyCheckpoint = Check({
            fromBlock: block.number,
            value: _totalSupply
        });

        balanceHistory.push(newBalanceCheckpoint);
        totalSupplyHistory.push(newTotalSupplyCheckpoint);
    }
}"
5200,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Invalid value"");
        require(msg.sender == _from || msg.sender == _to, ""Only the sender or recipient can call this function"");

        uint256 fromBalance = balanceOf[_from];
        require(_value <= fromBalance, ""Insufficient funds"");
        balanceOf[_from] = fromBalance.sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;
    }
}","// SafeMath library
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(allowed[_from][msg.sender] >= _value, ""Not approved by the sender"");
        require(balances[_from] >= _value, ""Insufficient balance"");

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        return true;
    }
}",8.126551866531372,transferFrom,"[{'function': 'transferFrom', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Not approved by the sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.9118249379928298,0.218543367720016,"// SafeMath library
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        balances[msg.sender] = 1000; // Initialize the owner's balance to 1
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(allowed[_from][msg.sender] >= _value, ""Not approved by the sender"");
        require(balances[_from] >= _value, ""Insufficient balance"");

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        return true;
    }
}"
5602,Allows the owner to destroy the contract and return the tokens to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for IERC20;
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function destroy() public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");
        token.transfer(owner(), balance);
        selfdestruct(payable(owner()));
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ContractDestruction is Ownable {
    IERC20 private _token;

    constructor(IERC20 token) {
        _token = token;
    }

    function destroyContractAndReturnTokens() external onlyOwner {
        uint256 balance = _token.balanceOf(address(this));
        require(balance > 0, ""No tokens to return"");

        _token.transfer(owner(), balance);

        selfdestruct(payable(owner()));
    }
}",9.372459173202516,destroyContractAndReturnTokens,"[{'function': 'destroyContractAndReturnTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyContractAndReturnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to return""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.8655056298563326,0.7605944253541765,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ContractDestruction is Ownable {
    IERC20 private _token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 token) Ownable(msg.sender) {
        _token = token;
    }

    function destroyContractAndReturnTokens() external onlyOwner {
        uint256 balance = _token.balanceOf(address(this));
        require(balance > 0, ""No tokens to return"");

        _token.transfer(owner(), balance);

        selfdestruct(payable(owner()));
    }
}"
1932,Called to obtain the loyalty reward balance of any given member,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 stakeBalance;
        uint256 previouslyAppliedLoyaltyBalance;
    }

    mapping(address => Member) public members;
    uint256 public loyaltyPeriodDays;
    uint256 public loyaltyRewardAmount;

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256 loyaltyReward) {
        require(members[memberAddress].startOfLoyaltyRewardEligibility != 0, ""Member not eligible for loyalty rewards"");
        uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;
        Member storage thisMember = members[memberAddress];
        uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;
        loyaltyReward = thisMember.previouslyAppliedLoyaltyBalance;
        if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {
            uint256 numWholePeriods = elapsedTimeSinceEligible / loyaltyPeriodSeconds;
            uint256 rewardForEachPeriod = thisMember.stakeBalance * loyaltyRewardAmount / 100;
            loyaltyReward += rewardForEachPeriod * numWholePeriods;
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/utils/math/SafeMath.sol';

contract LoyaltyRewards is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        require(account != address(0), 'Invalid address');
        return _balances[account];
    }

    function addReward(address account, uint256 reward) public onlyOwner {
        require(account != address(0), 'Invalid address');
        _balances[account] = _balances[account].add(reward);
    }
}",5.440119743347168,balanceOf,"[{'function': 'balanceOf', 'complexity': 1}, {'function': 'addReward', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",30.0,0.5857170863414013,0.0585871136846544,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract LoyaltyRewards is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    address public constant DEFAULT_REWARD_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        _balances[msg.sender] = 1000; // Initialize balance to a fixed value
        initialized = true; // Set initialized flag to true
    }

    function balanceOf(address account) public view returns (uint256) {
        require(account != address(0), 'Invalid address');
        return _balances[account];
    }

    function addReward(address account, uint256 reward) public onlyOwner {
        require(account != address(0), 'Invalid address');
        _balances[account] = _balances[account].add(reward);
    }
}"
4568,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfersEnabled() external view returns (bool);
    function doTransfer(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
    }

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(token.transfersEnabled(), ""Transfers are disabled"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        return token.doTransfer(msg.sender, _to, _amount);
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TransferToken {
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function transferTokens(address _to, uint256 _amount) public {
        require(_amount > 0, ""Amount must be greater than 0"");
        uint256 senderBalance = token.balanceOf(msg.sender);
        require(senderBalance >= _amount, ""Not enough balance"");

        bool sent = token.transferFrom(msg.sender, _to, _amount);
        require(sent, ""Token transfer failed"");
    }
}",9.635963678359984,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""sent"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sent""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.8785663885918413,0.4503269168996659,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TransferToken is Ownable {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function transferTokens(address _to, uint256 _amount) public {
        require(_amount > 0, ""Amount must be greater than 0"");
        uint256 senderBalance = token.balanceOf(msg.sender);
        require(senderBalance >= _amount, ""Not enough balance"");

        bool sent = token.transferFrom(msg.sender, _to, _amount);
        require(sent, ""Token transfer failed"");
    }
}"
5799,Set the contract address of the rent auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RentAuction {
    function isRentAuction() external view returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    RentAuction public rentAuctionContract;

    function setRentAuctionContractAddress(address _address) external onlyOwner {
        RentAuction _contract = RentAuction(_address);
        require(_contract.isRentAuction());
        rentAuctionContract = _contract;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract RentAuction is Ownable {
    address public rentAuctionAddress;

    function setRentAuctionAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Invalid address"");
        rentAuctionAddress = _newAddress;
    }
}",4.722163915634155,setRentAuctionAddress,"[{'function': 'setRentAuctionAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRentAuctionAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""rentAuctionAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.9020082549128484,0.0327285398635157,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RentAuction is Ownable {
    address public rentAuctionAddress;

    constructor(address _newAddress) Ownable(msg.sender) {
        require(_newAddress != address(0), ""Invalid address"");
        rentAuctionAddress = _newAddress;
    }

    function setRentAuctionAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Invalid address"");
        rentAuctionAddress = _newAddress;
    }
}"
694,Withdraw any accumulated fees to the specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for address;

    function withdraw(address payable addr) public onlyOwner {
        uint256 balance = address(this).balance;
        addr.transfer(balance);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract FeeManager is Ownable {
    using SafeMath for uint256;

    uint256 public totalFees;
    address payable public feeRecipient;

    constructor(address payable _feeRecipient) {
        require(_feeRecipient != address(0), ""Invalid recipient address."");
        feeRecipient = _feeRecipient;
    }

    function collectFees() external onlyOwner {
        uint256 balance = totalFees;
        require(balance > 0, ""No fees to withdraw"");
        totalFees = 0;
        feeRecipient.transfer(balance);
    }
}",6.653726816177368,collectFees,"[{'function': 'collectFees', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""collectFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""totalFees""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No fees to withdraw""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalFees""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feeRecipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.5443046159345295,0.2403479325641683,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract FeeManager is Ownable {
    using SafeMath for uint256;

    uint256 public totalFees;
    address payable public feeRecipient;

    constructor(address payable _feeRecipient) Ownable() {
        require(_feeRecipient != address(0), ""Invalid recipient address."");
        feeRecipient = _feeRecipient;
    }

    function collectFees() external onlyOwner {
        uint256 balance = totalFees;
        require(balance > 0, ""No fees to withdraw"");
        totalFees = 0;
        feeRecipient.transfer(balance);
    }
}"
6751,Returns the amount of tokens approved by the owner that can be transferred to the spender 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance (address tokenOwner, address spender) public view returns (uint remaining) {
    return allowed[tokenOwner][spender];
}
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    constructor (uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function getAllowance(address owner, address spender) public view returns (uint256) {
        return allowance(owner, spender);
    }
}",5.295141935348511,getAllowance,"[{'function': 'getAllowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.8629677157208441,0.3774155035532907,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") Ownable(msg.sender) {
        _mint(msg.sender, initialSupply);
    }

    function getAllowance(address owner, address spender) public view returns (uint256) {
        return allowance(owner, spender);
    }
}"
2680,Assigns bonus tokens to the specific contributor .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BonusAssignment {
    using SafeMath for uint256;

    uint256 public bonusProvided;
    mapping(address => uint256) public bonusHolders;

    event BonusAssigned(address indexed investor, uint256 bonus);

    function assignBonus(address _investor, uint256 _bonus) internal {
        if (_bonus == 0) {
            return;
        }
        bonusProvided = bonusProvided.add(_bonus);
        bonusHolders[_investor] = bonusHolders[_investor].add(_bonus);
        emit BonusAssigned(_investor, _bonus);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenBonus is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) private _bonuses;

    constructor(IERC20 _token) {
        token = _token;
    }

    function assignBonus(address contributor, uint256 amount) public onlyOwner nonReentrant {
        require(contributor != address(0), ""Invalid address"");
        require(amount > 0, ""Invalid bonus amount"");

        uint256 contractBalance = token.balanceOf(address(this));
        require(contractBalance >= amount, ""Insufficient contract balance"");

        _bonuses[contributor] = _bonuses[contributor].add(amount);

        token.transfer(contributor, amount);
    }
}",10.583795070648192,assignBonus,"[{'function': 'assignBonus', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""assignBonus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contributor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""contributor""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid bonus amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""contractBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""contractBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient contract balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_bonuses""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_bonuses""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contributor""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.8013639184733151,0.0695997044182911,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenBonus is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) private _bonuses;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function assignBonus(address contributor, uint256 amount) public onlyOwner nonReentrant {
        require(contributor != address(0), ""Invalid address"");
        require(amount > 0, ""Invalid bonus amount"");

        uint256 contractBalance = token.balanceOf(address(this));
        require(contractBalance >= amount, ""Insufficient contract balance"");

        _bonuses[contributor] = _bonuses[contributor].add(amount);

        token.transfer(contributor, amount);
    }
}"
3939,"Change the address of the registryAdmin , who has the privilege to create new accounts","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public registryAdmin;

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract UserRegistry is Ownable {
    address public registryAdmin;

    constructor () {
        registryAdmin = msg.sender;
    }

    function changeRegistryAdmin(address newAdmin) public onlyOwner {
        require(newAdmin != address(0), ""New admin address must not be zero"");
        registryAdmin = newAdmin;
    }
}",4.348514795303345,changeRegistryAdmin,"[{'function': 'changeRegistryAdmin', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeRegistryAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newAdmin""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New admin address must not be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""registryAdmin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAdmin""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.8428070312817113,0.1098597045801032,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract UserRegistry is Ownable {
    address public registryAdmin;

    constructor(address initialAdmin) Ownable() {
        require(initialAdmin != address(0), ""New admin address must not be zero"");
        registryAdmin = initialAdmin;
    }

    function changeRegistryAdmin(address newAdmin) public onlyOwner {
        require(newAdmin != address(0), ""New admin address must not be zero"");
        registryAdmin = newAdmin;
    }
}"
3322,"Returns the contribution to be used as part of the transaction , and any refund value if expected .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Contribution {
        uint256 amount;
        bool processed;
    }

    mapping(address => Contribution) public contributions;
    uint256 public preSaleCap;

    event PresaleCapUpdated(uint256 newCap);
    event AllowedContributionCheck(uint256 allowedContribution, AllowedContributionState state);

    enum AllowedContributionState { WhitelistClosed, Whitelisted }

    function processContribution() public isValidContribution returns (uint256, uint256) {
        if (!honourWhitelist()) {
            var (allowedContribution, refundAmount) = getAllowedContribution();
            AllowedContributionCheck(allowedContribution, AllowedContributionState.WhitelistClosed);
            preSaleCap = preSaleCap.sub(allowedContribution);
            PresaleCapUpdated(preSaleCap);
            return (allowedContribution, refundAmount);
        }

        var (whiteListedAllowedContribution, whiteListedRefundAmount) = getAllowedContribution();
        if (whitelist[msg.sender] > 0) {
            return processWhitelistedContribution(whiteListedAllowedContribution, whiteListedRefundAmount);
        }

        revert();
    }

    function isValidContribution() internal view returns (bool) {
        // Implement your validation logic here
        return true;
    }

    function honourWhitelist() internal view returns (bool) {
        // Implement your whitelist check logic here
        return false;
    }

    function getAllowedContribution() internal view returns (uint256, uint256) {
        // Implement your logic to calculate allowed contribution and refund amount here
        return (0, 0);
    }

    function processWhitelistedContribution(uint256 whiteListedAllowedContribution, uint256 whiteListedRefundAmount) internal returns (uint256, uint256) {
        // Implement your logic for processing whitelisted contributions here
        return (whiteListedAllowedContribution, whiteListedRefundAmount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ContributionContract {
    using SafeMath for uint256;

    mapping(address => uint256) private contributions;
    uint256 private totalContribution;

    function contribute(uint256 _contribution) public payable {
        require(_contribution > 0, ""Contribution must be greater than 0"");
        require(msg.value == _contribution, ""Mismatch in contribution value"");

        uint256 refund = 0;
        if (totalContribution.add(_contribution) > address(this).balance) {
            refund = totalContribution.add(_contribution).sub(address(this).balance);
            _contribution = _contribution.sub(refund);
        }

        contributions[msg.sender] = contributions[msg.sender].add(_contribution);
        totalContribution = totalContribution.add(_contribution);

        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }
    }

    function getContribution(address _contributor) public view returns (uint256) {
        return contributions[_contributor];
    }

    function getTotalContribution() public view returns (uint256) {
        return totalContribution;
    }
}",12.385179042816162,contribute,"[{'function': 'contribute', 'complexity': 4}, {'function': 'getContribution', 'complexity': 0}, {'function': 'getTotalContribution', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""contribute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_contribution"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_contribution""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Contribution must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_contribution""}}, {""type"": ""stringLiteral"", ""value"": ""Mismatch in contribution value""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refund"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalContribution""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contribution""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""refund""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalContribution""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contribution""}], ""names"": []}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_contribution""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_contribution""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refund""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contribution""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalContribution""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalContribution""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contribution""}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""refund""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refund""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",46.0,0.7558732496316198,0.0984769910138783,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ContributionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private contributions;
    uint256 private totalContribution;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        totalContribution = 1;
    }

    function contribute(uint256 _contribution) public payable {
        require(_contribution > 0, ""Contribution must be greater than 0"");
        require(msg.value == _contribution, ""Mismatch in contribution value"");

        uint256 refund = 0;
        if (totalContribution.add(_contribution) > address(this).balance) {
            refund = totalContribution.add(_contribution).sub(address(this).balance);
            _contribution = _contribution.sub(refund);
        }

        contributions[msg.sender] = contributions[msg.sender].add(_contribution);
        totalContribution = totalContribution.add(_contribution);

        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }
    }

    function getContribution(address _contributor) public view returns (uint256) {
        return contributions[_contributor];
    }

    function getTotalContribution() public view returns (uint256) {
        return totalContribution;
    }
}"
3650,Method for setting a registered issuer firm authority,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface StorageInterface {
    function setBool(bytes32 id, bool value) external returns (bool);
    function setString(bytes32 id, string memory value) external returns (bool);
}

abstract contract Data {
    using SafeMath for uint256;
    StorageInterface public storageContract;

    constructor(address _storageAddress) {
        storageContract = StorageInterface(_storageAddress);
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) internal returns (bool success) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");
        bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));
        require(storageContract.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        require(storageContract.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        return true;
    }

    function isRegisteredFirm(string memory firm) internal view returns (bool) {
        // Implement the logic to check if a firm is registered
        // This is just a placeholder implementation
        bytes32 id = keccak256(abi.encodePacked(""registered.firm"", firm));
        return true; // Replace with actual storage retrieval logic
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract AuthorityIssuer is Ownable {

    mapping (address => bool) private _registeredIssuers;

    function setRegisteredIssuer(address issuer, bool value) public onlyOwner {
        _registeredIssuers[issuer] = value;
    }

    function isIssuer(address issuer) public view returns (bool) {
        return _registeredIssuers[issuer];
    }
}",5.498053073883057,setRegisteredIssuer,"[{'function': 'setRegisteredIssuer', 'complexity': 0}, {'function': 'isIssuer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRegisteredIssuer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""issuer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_registeredIssuers""}, ""index"": {""type"": ""Identifier"", ""name"": ""issuer""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.6305479664078322,5.696076817303079e-05,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AuthorityIssuer is Ownable {
    mapping (address => bool) private _registeredIssuers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _registeredIssuers[addr] = true; // Set to true for all addresses from 0x1111111111111111111111111111111111111111 to 0x3333333333333333333333333333333333333333
        }
    }

    function setRegisteredIssuer(address issuer, bool value) public onlyOwner {
        _registeredIssuers[issuer] = value;
    }

    function isIssuer(address issuer) public view returns (bool) {
        return _registeredIssuers[issuer];
    }
}"
4267,"Returns holder id for the specified address , creates it if needed .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderRegistration {
    using SafeMath for uint256;

    struct HoldersData {
        uint countryCode;
        bool operational;
        uint sendLimPerDay;
        uint sendLimPerMonth;
        uint holderAddressCount;
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
    }

    bytes32[] public holderIndex;
    mapping(bytes32 => uint) public holderAddress2Id;
    uint public holdersCount;
    mapping(address => bytes32) public holderAddress2ExternalId;
    HoldersData[] public holders;
    address public oracle;

    uint constant MAX_TOKEN_HOLDER_NUMBER = 10000;
    uint constant OK = 1;

    modifier onlyOracleOrOwner() {
        require(msg.sender == owner() || msg.sender == oracle, ""Only owner or oracle can call this function"");
        _;
    }

    constructor() {
        holdersCount = 0;
    }

    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {
        require(_holderAddress != address(0));
        require(holderIndex[_externalHolderId] == bytes32(0));
        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];
        require(_holderIndex == 0);
        _createCountryId(_countryCode);
        _holderIndex = holdersCount.add(1);
        holdersCount = _holderIndex;
        HoldersData storage _holderData = holders[_holderIndex];
        _holderData.countryCode = _countryCode;
        _holderData.operational = true;
        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;
        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;
        uint _firstAddressIndex = 1;
        _holderData.holderAddressCount = _firstAddressIndex;
        _holderData.address2Index[_holderAddress] = _firstAddressIndex;
        _holderData.index2Address[_firstAddressIndex] = _holderAddress;
        holderIndex[_externalHolderId] = bytes32(_holderIndex);
        holderAddress2Id[_holderAddress] = _externalHolderId;
        emit HolderRegistered(_externalHolderId, _holderIndex, _countryCode);
        return OK;
    }

    function _createCountryId(uint _countryCode) internal {
        // Implementation for creating country ID
    }

    event HolderRegistered(bytes32 indexed externalHolderId, uint indexed holderIndex, uint countryCode);
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract HolderIdContract is AccessControl {
    mapping(address => uint256) private _holderIds;
    uint256 private _holderIdCounter = 1;

    function getHolderId(address holderAddress) public returns (uint256) {
        require(holderAddress != address(0), ""Zero address is not allowed"");

        if (_holderIds[holderAddress] == 0) {
            _holderIds[holderAddress] = _holderIdCounter;
            _holderIdCounter++;
        }

        return _holderIds[holderAddress];
    }
}",7.182835817337036,getHolderId,"[{'function': 'getHolderId', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getHolderId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holderAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""holderAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Zero address is not allowed""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_holderIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderAddress""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_holderIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_holderIdCounter""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""_holderIdCounter""}, ""isPrefix"": False}}]}, ""FalseBody"": None}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_holderIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderAddress""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",107.0,0.6567636620942024,0.0353403239198262,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HolderIdContract is AccessControl {
    mapping(address => uint256) private _holderIds;
    uint256 private _holderIdCounter = 1;

    constructor() {
        // Initialize the contract with fixed, safe non-corner-case values
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function getHolderId(address holderAddress) public returns (uint256) {
        require(holderAddress != address(0), ""Zero address is not allowed"");

        if (_holderIds[holderAddress] == 0) {
            _holderIds[holderAddress] = _holderIdCounter;
            _holderIdCounter++;
        }

        return _holderIds[holderAddress];
    }
}"
5707,` onlyOwner ` An efficient way to cancel multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiCancel(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal virtual;
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SomeContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    function cancelPayments(address[] memory receivers) public onlyOwner {
        require(receivers.length > 0, ""receivers must not be empty"");

        for (uint256 i = 0; i < receivers.length; i++) {
            address receiver = receivers[i];
            uint256 amount = balances[receiver];

            require(amount > 0, ""no payment to cancel"");

            // refunding the balance to the owner.
            balances[owner()] = balances[owner()].add(amount);

            // cancel the payment.
            balances[receiver] = 0;
        }
    }
}",11.253148794174194,cancelPayments,"[{'function': 'cancelPayments', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelPayments"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""receivers"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receivers""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""receivers must not be empty""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receivers""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""receivers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiver""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""no payment to cancel""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""receiver""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",41.0,0.7371043420463879,0.1006479759501407,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract SomeContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function cancelPayments(address[] memory receivers) public onlyOwner {
        require(receivers.length > 0, ""receivers must not be empty"");

        for (uint256 i = 0; i < receivers.length; i++) {
            address receiver = receivers[i];
            uint256 amount = balances[receiver];

            require(amount > 0, ""no payment to cancel"");

            // refunding the balance to the owner.
            balances[owner()] = balances[owner()].add(amount);

            // cancel the payment.
            balances[receiver] = 0;
        }
    }
}"
32,Allows the owner of this contract to set the currentPrice for each token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;
    uint256 public currentPrice;

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SetPrice is Ownable {
    using SafeMath for uint256;

    uint256 public currentPrice;

    function setCurrentPrice(uint256 _currentPrice) public onlyOwner {
        require(_currentPrice > 0, ""Price must be greater than zero"");
        currentPrice = _currentPrice;
    }
}",4.267847776412964,setCurrentPrice,"[{'function': 'setCurrentPrice', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCurrentPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_currentPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_currentPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_currentPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.8734588598074496,0.1955568744568839,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract SetPrice is Ownable {
    using SafeMath for uint256;

    uint256 public currentPrice;

    constructor() Ownable(msg.sender) {
        currentPrice = 1;
    }

    function setCurrentPrice(uint256 _currentPrice) public onlyOwner {
        require(_currentPrice > 0, ""Price must be greater than zero"");
        currentPrice = _currentPrice;
    }
}"
2463,Gets a given contract address by bytes32 in order to save gas,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractRegistry is Ownable {
    using SafeMath for uint256;

    address public registryAddress;
    bytes32 private constant REGISTRY_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    constructor(address _registryAddress) {
        registryAddress = _registryAddress;
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
        bytes32 _name32 = keccak256(abi.encodePacked(_name));
        assembly {
            let _registry := sload(REGISTRY_SLOT)
            let _pointer := mload(0x40)
            mstore(_pointer, _signature)
            mstore(add(_pointer, 0x04), _name32)
            let result := staticcall(gas(), _registry, _pointer, 0x24, _pointer, 0x20)
            if iszero(result) {
                revert(0, 0)
            }
            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GetContractByBytes32 {
    mapping(bytes32 => address) public contracts;

    function getContract(bytes32 _identifier) public view returns (address) {
        require(contracts[_identifier] != address(0), ""Contract does not exist"");
        return contracts[_identifier];
    }
}",3.595822095870972,getContract,"[{'function': 'getContract', 'complexity': 1}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""getContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_identifier"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contracts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_identifier""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Contract does not exist""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contracts""}, ""index"": {""type"": ""Identifier"", ""name"": ""_identifier""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",59.0,0.6395974353782766,0.0101716450308843,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GetContractByBytes32 is Ownable {
    mapping(bytes32 => address) public contracts;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getContract(bytes32 _identifier) public view returns (address) {
        require(contracts[_identifier] != address(0), ""Contract does not exist"");
        return contracts[_identifier];
    }
}"
1777,"Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeManager is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        bool exists;
        uint256 minimumStake;
    }

    mapping(uint256 => AttributeType) private _attributeTypes;

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) external onlyOwner {
        require(_attributeTypes[ID].exists, ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID].minimumStake = minimumRequiredStake;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/utils/math/SafeMath.sol';

contract StakeManager is Ownable {
    using SafeMath for uint256;

    // mapping from attribute type ID to the required stake
    mapping(uint256 => uint256) private minimumStake;

    function setMinimumStake(uint256 _ID, uint256 _stakeAmount) public onlyOwner {
        require(_stakeAmount > 0, ""Stake amount must be greater than zero"");
        minimumStake[_ID] = _stakeAmount;
    }

    function getMinimumStake(uint256 _ID) public view returns (uint256) {
        return minimumStake[_ID];
    }
}",7.456243991851807,setMinimumStake,"[{'function': 'setMinimumStake', 'complexity': 1}, {'function': 'getMinimumStake', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinimumStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_ID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_stakeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_stakeAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Stake amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""minimumStake""}, ""index"": {""type"": ""Identifier"", ""name"": ""_ID""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_stakeAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",4.0,0.7703346847415827,0.1092120059716805,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract StakeManager is Ownable {
    using SafeMath for uint256;

    // mapping from attribute type ID to the required stake
    mapping(uint256 => uint256) private minimumStake;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        minimumStake[0] = 1;
        minimumStake[1] = 2;
        minimumStake[2] = 3;
    }

    function setMinimumStake(uint256 _ID, uint256 _stakeAmount) public onlyOwner {
        require(_stakeAmount > 0, ""Stake amount must be greater than zero"");
        minimumStake[_ID] = _stakeAmount;
    }

    function getMinimumStake(uint256 _ID) public view returns (uint256) {
        return minimumStake[_ID];
    }
}"
2431,"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public controller;

    function () external payable {
        require(isContract(controller), ""Controller must be a contract"");
        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender), ""Proxy payment failed"");
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

interface TokenController {
    function proxyPayment() external payable returns (bool);
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./ITokenController.sol"";

contract YourToken is IERC20, Ownable {
    using SafeMath for uint256;

    ITokenController public tokenController;

    constructor(address _tokenController) {
        require(_tokenController != address(0), ""Invalid address for token controller"");
        tokenController = ITokenController(_tokenController);
    }

    function setTokenController(address _tokenController) public onlyOwner {
        require(_tokenController != address(0), ""Invalid address for token controller"");
        tokenController = ITokenController(_tokenController);
    }

    fallback() external payable {
        if(address(tokenController) != address(0)) {
            tokenController.proxyPayment{value: msg.value}(msg.sender);
        } else {
            revert(""Token controller is not set"");
        }
    }
}",9.30122709274292,setTokenController,"[{'function': 'setTokenController', 'complexity': 1}]",3.0,{},20.0,0.2836646134036929,0.0182941170974726,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./ITokenController.sol"";

contract YourToken is IERC20, Ownable {
    using SafeMath for uint256;

    ITokenController public tokenController;

    constructor(address _tokenController) Ownable(msg.sender) {
        require(_tokenController != address(0), ""Invalid address for token controller"");
        tokenController = ITokenController(_tokenController);
    }

    function setTokenController(address _tokenController) public onlyOwner {
        require(_tokenController != address(0), ""Invalid address for token controller"");
        tokenController = ITokenController(_tokenController);
    }

    fallback() external payable {
        if (address(tokenController) != address(0)) {
            tokenController.proxyPayment{value: msg.value}(msg.sender);
        } else {
            revert(""Token controller is not set"");
        }
    }
}"
1613,Calculate the halving hash rate of a miner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.6;

contract Miner{

    mapping(address => uint) public minerHashRates;
    address public minerOwner;

    constructor() {
        minerOwner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == minerOwner, ""Only the contract owner can call this function"");
        _;
    }

    function decreaseHashRateByHalf(address _minerAddress) external onlyOwner {
        uint currentHashRate = minerHashRates[_minerAddress];
        require(currentHashRate > 0, ""The miner's hash rate must be greater than zero"");
        minerHashRates[_minerAddress] = currentHashRate / 2;
    }
}",9.782545804977415,decreaseHashRateByHalf,"[{'function': 'decreaseHashRateByHalf', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseHashRateByHalf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_minerAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""currentHashRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""minerHashRates""}, ""index"": {""type"": ""Identifier"", ""name"": ""_minerAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""currentHashRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""The miner""s hash rate must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""minerHashRates""}, ""index"": {""type"": ""Identifier"", ""name"": ""_minerAddress""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""currentHashRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.3179451644408499,0.0170195256071658,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.6;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Miner is Ownable {
    mapping(address => uint) public minerHashRates;

    constructor() Ownable(msg.sender) {
        // No need to initialize minerHashRates here as it will be inherited from the parent contract
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    function decreaseHashRateByHalf(address _minerAddress) external onlyOwner {
        uint currentHashRate = minerHashRates[_minerAddress];
        require(currentHashRate > 0, ""The miner's hash rate must be greater than zero"");
        minerHashRates[_minerAddress] = currentHashRate / 2;
    }
}"
2278,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleToken is Ownable {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _owner, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_owner, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) internal pure returns (address) {
        if (_signature.length != 65) return address(0);
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(_signature, (uint8, bytes32, bytes32));
        return ecrecover(_hash, v, r, s);
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);

        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));

        nonces[_signature] = true;
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);

        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);

        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenContract is ERC20, ERC20Burnable, Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    function increaseAllowance(address spender, uint256 addedValue) public onlyOwner nonReentrant returns (bool) {
        _approve(_msgSender(), spender, allowance(_msgSender(), spender).add(addedValue));
        return true;
    }
}",9.912883043289185,increaseAllowance,"[{'function': 'increaseAllowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""increaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""addedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addedValue""}], ""names"": []}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",117.0,0.6860205343040526,0.02427904599819,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is ERC20, ERC20Burnable, Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialization of state variables
        _totalSupply = 1 * 10 ** decimals(); // Set total supply to 1 token with appropriate decimals
        _balances[owner()] = 1; // Initialize owner's balance to 1
        emit Transfer(address(0), msg.sender, 1); // Emit transfer event for initial token distribution
    }

    function increaseAllowance(address spender, uint256 addedValue) public onlyOwner nonReentrant returns (bool) {
        _approve(_msgSender(), spender, allowance(_msgSender(), spender).add(addedValue));
        return true;
    }
}"
4847,Function that is called when transaction target is contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ContractReceiver {
    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    function transferToContract(address _to, uint256 _value, bytes memory _data) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract MyContract is ReentrancyGuard {
    using Address for address;

    function onTargetContract(address payable _targetAddr, uint _value) external payable nonReentrant {
        require(_targetAddr != address(0), ""Zero address not allowed"");
        require(_targetAddr.isContract(), ""Target must be a contract"");
        require(_value <= msg.value, ""Insufficient funds"");

        (bool success,) = _targetAddr.call{value: _value}("""");
        require(success, ""Transaction failed"");
    }
}",12.183250904083252,onTargetContract,"[{'function': 'onTargetContract', 'complexity': 4}]",5.0,{},76.0,0.5902603768095821,0.0378685157484492,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ReentrancyGuard, Ownable {
    using Address for address;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function onTargetContract(address payable _targetAddr, uint _value) external payable nonReentrant {
        require(_targetAddr != address(0), ""Zero address not allowed"");
        require(_targetAddr.isContract(), ""Target must be a contract"");
        require(_value <= msg.value, ""Insufficient funds"");

        (bool success,) = _targetAddr.call{value: _value}("""");
        require(success, ""Transaction failed"");
    }
}"
1565,Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MintWrapper is Ownable {
    using SafeMath for uint256;

    function mint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) public onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TokenContract is ERC20 {

    address private _owner;

    event Minted(address indexed to, uint256 amount);

    constructor() ERC20(""TokenName"", ""TKN"") {
        _owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Only contract owner can call this function"");
        _;
    }

    function mint(address _tokenHolder, uint256 _amount) external onlyOwner {
        _mint(_tokenHolder, _amount);
        emit Minted(_tokenHolder, _amount);
    }

}",5.736153841018677,mint,"[{'function': 'mint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenHolder""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Minted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenHolder""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.87799429668465,0.4058951763812706,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is ERC20, Ownable {
    address private _owner;

    event Minted(address indexed to, uint256 amount);

    constructor() ERC20(""TokenName"", ""TKN"") Ownable(msg.sender) {
        _owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Only contract owner can call this function"");
        _;
    }

    function mint(address _tokenHolder, uint256 _amount) external onlyOwner {
        _mint(_tokenHolder, _amount);
        emit Minted(_tokenHolder, _amount);
    }
}"
5534,Returns the timestamp at which the question will be/was finalized,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Question {
        uint32 finalize_ts;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalizeTS(bytes32 question_id) public view returns (uint32) {
        return questions[question_id].finalize_ts;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Quiz {
    using SafeMath for uint256;

    struct Question {
        string question;
        uint256 finalizeTimestamp;
        bool isFinalized;
    }

    mapping(uint256 => Question) private questions;

    function getQuestionFinalizeTimestamp(uint256 _questionId) public view returns (uint256) {
        require(questions[_questionId].isFinalized, ""Question not finalized yet."");
        return questions[_questionId].finalizeTimestamp;
    }
}",9.705948114395142,getQuestionFinalizeTimestamp,"[{'function': 'getQuestionFinalizeTimestamp', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getQuestionFinalizeTimestamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_questionId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""_questionId""}}, ""memberName"": ""isFinalized""}, {""type"": ""stringLiteral"", ""value"": ""Question not finalized yet.""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""_questionId""}}, ""memberName"": ""finalizeTimestamp""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",8.0,0.8376073806994311,0.1741467509997117,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Quiz is Ownable {
    using SafeMath for uint256;

    struct Question {
        string question;
        uint256 finalizeTimestamp;
        bool isFinalized;
    }

    mapping(uint256 => Question) private questions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            questions[i] = Question({
                question: ""initialized"",
                finalizeTimestamp: uint256(1),
                isFinalized: true
            });
        }
    }

    function getQuestionFinalizeTimestamp(uint256 _questionId) public view returns (uint256) {
        require(questions[_questionId].isFinalized, ""Question not finalized yet."");
        return questions[_questionId].finalizeTimestamp;
    }
}"
2081,Become owner of a deed for which you are currently approved,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IDeed {
    function takeOwnership(uint256 _deedId) external payable;
}

abstract contract Deed is Ownable, SafeMath {
    struct DeedInfo {
        address owner;
        bool isOwner;
    }

    mapping(uint256 => DeedInfo) private _deeds;
    uint256 public constant DEED_PRICE = 1 ether; // Example price, adjust as needed

    function takeOwnership(uint256 _deedId) external payable {
        require(_deedId > 0, ""Invalid deed ID"");
        require(msg.value >= DEED_PRICE, ""Insufficient payment"");
        require(!_deeds[_deedId].isOwner, ""Deed is already owned"");
        _deeds[_deedId].owner = msg.sender;
        _deeds[_deedId].isOwner = true;
        emit DeedOwnershipTransferred(_deedId, msg.sender);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

contract DeedContract is ERC721(""DeedToken"", ""DEED""), Ownable {

    struct Deed {
        uint256 id;
        address approved;
    }

    mapping(uint256 => Deed) private _deeds;

    function becomeOwnerOfDeed(uint256 deedId) public {
        require(_deeds[deedId].approved == msg.sender, ""Caller is not currently approved for this deed"");

        super._transfer(_deeds[deedId].approved, msg.sender, deedId);

        _deeds[deedId].approved = msg.sender;
    }
}",7.986155033111572,becomeOwnerOfDeed,"[{'function': 'becomeOwnerOfDeed', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""becomeOwnerOfDeed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""deedId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_deeds""}, ""index"": {""type"": ""Identifier"", ""name"": ""deedId""}}, ""memberName"": ""approved""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Caller is not currently approved for this deed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_deeds""}, ""index"": {""type"": ""Identifier"", ""name"": ""deedId""}}, ""memberName"": ""approved""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""deedId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_deeds""}, ""index"": {""type"": ""Identifier"", ""name"": ""deedId""}}, ""memberName"": ""approved""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",28.0,0.8077888487283658,0.0335151228591122,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DeedContract is ERC721(""DeedToken"", ""DEED""), Ownable {
    struct Deed {
        uint256 id;
        address approved;
    }

    mapping(uint256 => Deed) private _deeds;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _mint(addr, i); // Mint tokens to predefined addresses
        }
    }

    function becomeOwnerOfDeed(uint256 deedId) public {
        require(_deeds[deedId].approved == msg.sender, ""Caller is not currently approved for this deed"");

        super._transfer(_deeds[deedId].approved, msg.sender, deedId);

        _deeds[deedId].approved = msg.sender;
    }
}"
790,Allows the owner of the contract to update the address of the RenExBrokerVerifier contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RenExBrokerVerifier {
    using SafeMath for uint256;

    address public brokerVerifierContract;

    event LogBrokerVerifierContractUpdated(address indexed oldBrokerVerifierContract, address indexed newBrokerVerifierContract);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {
        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    address private _renExBrokerVerifier;

    function getRenExBrokerVerifier() public view returns (address) {
        return _renExBrokerVerifier;
    }

    function setRenExBrokerVerifier(address newRenExBrokerVerifier) public onlyOwner {
        require(newRenExBrokerVerifier != address(0), ""New RenExBrokerVerifier is the zero address"");
        _renExBrokerVerifier = newRenExBrokerVerifier;
    }
}",8.314919233322144,setRenExBrokerVerifier,"[{'function': 'getRenExBrokerVerifier', 'complexity': 0}, {'function': 'setRenExBrokerVerifier', 'complexity': 1}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRenExBrokerVerifier"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newRenExBrokerVerifier"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newRenExBrokerVerifier""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New RenExBrokerVerifier is the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_renExBrokerVerifier""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRenExBrokerVerifier""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",7.0,0.7493703084126138,0.0245777741108497,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address private _renExBrokerVerifier;

    constructor() Ownable(msg.sender) {
        _renExBrokerVerifier = address(1); // Fixed value: 0x1111111111111111111111111111111111111111
    }

    function getRenExBrokerVerifier() public view returns (address) {
        return _renExBrokerVerifier;
    }

    function setRenExBrokerVerifier(address newRenExBrokerVerifier) public onlyOwner {
        require(newRenExBrokerVerifier != address(0), ""New RenExBrokerVerifier is the zero address"");
        _renExBrokerVerifier = newRenExBrokerVerifier;
    }
}"
1335,Owner : Withdraw excess funds which do n't belong to Bskt Token holders,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply_;
    uint256 public creationUnit_;

    constructor(uint256 _totalSupply, uint256 _creationUnit) {
        require(_totalSupply > 0 && _creationUnit > 0, ""Invalid parameters"");
        totalSupply_ = _totalSupply;
        creationUnit_ = _creationUnit;
    }

    function getQuantity(address token) internal view returns (uint256 quantity, bool ok) {
        // Implement your logic to determine the quantity here
        // For example:
        // if (/* some condition */) {
        //     return (quantity, true);
        // } else {
        //     return (0, false);
        // }
        revert(""Not implemented"");
    }

    function withdrawExcessToken(address token) external onlyOwner {
        ERC20 erc20 = ERC20(token);
        uint256 amountOwned = erc20.balanceOf(address(this));
        uint256 quantity;
        bool ok;
        (quantity, ok) = getQuantity(token);
        uint256 withdrawAmount;
        if (ok) {
            withdrawAmount = amountOwned.sub(totalSupply_.div(creationUnit_).mul(quantity));
        } else {
            withdrawAmount = amountOwned;
        }
        require(erc20.transfer(owner(), withdrawAmount), ""Transfer failed"");
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    uint256 private _totalSupply;

    constructor() {
        _totalSupply = 1000000;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function withdrawExcessFunds() public onlyOwner {
        uint256 contractBalance = address(this).balance;
        uint256 excess = contractBalance.sub(_totalSupply);
        require(excess > 0, ""No excess funds available"");
        payable(owner()).transfer(excess);
    }
}",7.603721857070923,withdrawExcessFunds,"[{'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'withdrawExcessFunds', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawExcessFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""contractBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""excess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""contractBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_totalSupply""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""excess""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No excess funds available""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""excess""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.7458824256778114,0.0741777416013543,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    uint256 private _totalSupply;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        _totalSupply = 1000000;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function withdrawExcessFunds() public onlyOwner {
        uint256 contractBalance = address(this).balance;
        uint256 excess = contractBalance.sub(_totalSupply);
        require(excess > 0, ""No excess funds available"");
        payable(owner()).transfer(excess);
    }
}"
3433,Permit ` msg.sender ` to set its NeuroChain Address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NeuroChainWrapper {
    using SafeMath for uint256;

    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string addressString, uint256 timestamp, bool isRegistered);

    function setNeuroChainAddress(string memory neurochainAddress) public {
        require(bytes(neurochainAddress).length > 0, ""Invalid address"");
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract NeuroChainAddressRegistry is Ownable {

    mapping(address => address) private _neuroChainAddresses;

    function setMyNeuroChainAddress(address _ncAddress) public {
        require(_ncAddress != address(0), ""NeuroChainAddressRegistry: Address cannot be zero address"");
        _neuroChainAddresses[msg.sender] = _ncAddress;
    }

    function getNeuroChainAddress(address account) public view returns (address) {
        return _neuroChainAddresses[account];
    }
}",10.182009935379028,setMyNeuroChainAddress,"[{'function': 'setMyNeuroChainAddress', 'complexity': 1}, {'function': 'getNeuroChainAddress', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMyNeuroChainAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_ncAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_ncAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""NeuroChainAddressRegistry: Address cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_neuroChainAddresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_ncAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.8451763337775183,0.1369435867272901,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NeuroChainAddressRegistry is Ownable {
    mapping(address => address) private _neuroChainAddresses;
    bool public initialized = true;
    bytes32 public initializedBytes = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        _neuroChainAddresses[msg.sender] = 0x1111111111111111111111111111111111111111; // Replace with actual value
        _neuroChainAddresses[address(0)] = 0x2222222222222222222222222222222222222222; // Replace with actual value
        initialized = true;
    }

    function setMyNeuroChainAddress(address _ncAddress) public {
        require(_ncAddress != address(0), ""NeuroChainAddressRegistry: Address cannot be zero address"");
        _neuroChainAddresses[msg.sender] = _ncAddress;
    }

    function getNeuroChainAddress(address account) public view returns (address) {
        return _neuroChainAddresses[account];
    }
}"
465,Get the token balance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Storage {
    function getUint(bytes32 key) external view returns (uint);
}

abstract contract Data {
    Storage public immutable Storage;

    constructor(Storage _storage) {
        Storage = _storage;
    }
}

abstract contract TokenBalanceWrapper is Ownable, SafeMath {
    function getForwardedAccount(Data storage self, address account) internal view virtual returns (address);

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint balance) {
        bytes32 id = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));
        return self.Storage.getUint(id);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenBalance {
    IERC20 private _token;

    constructor(address tokenAddress) {
        _token = IERC20(tokenAddress);
    }

    function getTokenBalance(address account) public view returns (uint256) {
        return _token.balanceOf(account);
    }
}",3.06840181350708,getTokenBalance,"[{'function': 'getTokenBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",19.0,0.8213808915538154,0.1120210634105814,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenBalance is Ownable {
    IERC20 private _token;

    mapping(address => uint256) public balanceOf;

 constructor(address tokenAddress) Ownable(msg.sender) {
        require(tokenAddress != address(0), ""Invalid token address"");
        _token = IERC20(tokenAddress);
    }

    function getTokenBalance(address account) public view returns (uint256) {
        return _token.balanceOf(account);
    }
}"
5228,A getter that searches the delegationChain for the level of authority a specific delegate has within a Pledge,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledge {
    uint64 public constant NOTFOUND = type(uint64).max;
    uint64[] public delegationChain;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getDelegateIdx(Pledge p, uint64 idDelegate) external returns (uint64) {
        for (uint i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) return uint64(i);
        }
        return NOTFOUND;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Pledge {
    using SafeMath for uint256;

    struct Delegate {
        address addr;
        uint256 authorityLevel;
    }

    Delegate[] public delegationChain;

    function getAuthorityLevel(address _delegate) public view returns (uint256) {
        uint256 level = 0;
        for (uint256 i = 0; i < delegationChain.length; i++) {
            if (delegationChain[i].addr == _delegate) {
                level = delegationChain[i].authorityLevel;
                break;
            }
        }
        require(level != 0, ""No authority level found for delegate"");
        return level;
    }
}",6.535118818283081,getAuthorityLevel,"[{'function': 'getAuthorityLevel', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAuthorityLevel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_delegate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""level"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""delegationChain""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""delegationChain""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""addr""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delegate""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""level""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""delegationChain""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""authorityLevel""}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""level""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No authority level found for delegate""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""level""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",16.0,0.5871871805301675,0.164835939518903,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.6.0/contracts/ownership/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Pledge is Ownable {
    using SafeMath for uint256;

    struct Delegate {
        address addr;
        uint256 authorityLevel;
    }

    Delegate[] public delegationChain;

    constructor() Ownable(msg.sender) {
        // Initialize delegation chain with a fixed value
        delegationChain.push(Delegate(address(0x1111111111111111111111111111111111111111), 1));
        delegationChain.push(Delegate(address(0x2222222222222222222222222222222222222222), 2));
        delegationChain.push(Delegate(address(0x3333333333333333333333333333333333333333), 3));

        // Set delegation chain length to a safe value
        _setDelegationChainLength(delegationChain.length);
    }

    function getAuthorityLevel(address _delegate) public view returns (uint256) {
        uint256 level = 0;
        for (uint256 i = 0; i < delegationChain.length; i++) {
            if (delegationChain[i].addr == _delegate) {
                level = delegationChain[i].authorityLevel;
                break;
            }
        }
        require(level != 0, ""No authority level found for delegate"");
        return level;
    }

    function _setDelegationChainLength(uint256 length) internal {
        // Set delegation chain length to a safe value
        require(length > 0, ""Delegation chain length must be greater than 0"");
        _delegateChainLength = length;
    }

    uint256 private _delegateChainLength;

    // Other contract variables and functions...
}"
3288,Distirbutes a different quantity of tokens to all the specified addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Airdrop {
        address tokenSC;
    }

    mapping(uint => Airdrop) public airdrops;

    function distributeVariable(uint index, address[] memory _addrs, uint[] memory _vals) public onlyOwner {
        if (timeGone(index) == true) {
            Airdrop storage airdrop = airdrops[index];
            for (uint i = 0; i < _addrs.length; ++i) {
                require(SafeMath.mul(_vals[i], 1 ether) <= address(airdrop.tokenSC).balance, ""Insufficient balance"");
                airdrop.tokenSC.call(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _addrs[i], _vals[i]));
            }
        } else {
            revert(""Distribution Failed: Countdown not finished yet"");
        }
    }

    function timeGone(uint index) public view returns (bool) {
        // Implement your logic to check if the countdown is finished for the given index
        return true; // Placeholder, replace with actual implementation
    }
}","y
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenDistributor is Ownable {
    using SafeMath for uint256;

    ERC20 public token;

    constructor (ERC20 _token) {
        token = _token;
    }

    function distributeTokens(address[] memory receivers, uint256[] memory amounts) public onlyOwner {
        require(receivers.length == amounts.length, ""Mismatched arrays"");

        for(uint i=0; i<receivers.length; i++) {
            require(token.balanceOf(address(this)) >= amounts[i], ""Insufficient token balance"");
            require(token.transfer(receivers[i], amounts[i]), ""Failed to transfer tokens"");
        }
     }
}",6.813285827636719,distributeTokens,"[{'function': 'distributeTokens', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""receivers"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receivers""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Mismatched arrays""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receivers""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""receivers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Failed to transfer tokens""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",44.0,0.6545793524540563,0.1017145921747667,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenDistributor is Ownable {
    using SafeMath for uint256;

    ERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor (ERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function distributeTokens(address[] memory receivers, uint256[] memory amounts) public onlyOwner {
        require(receivers.length == amounts.length, ""Mismatched arrays"");

        for(uint i=0; i<receivers.length; i++) {
            require(token.balanceOf(address(this)) >= amounts[i], ""Insufficient token balance"");
            require(token.transfer(receivers[i], amounts[i]), ""Failed to transfer tokens"");
        }
     }
}"
110,This method should be called by the owner before the contribution period starts This initializes most of the parameters,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function totalSupply() external view returns (uint256);
    function controller() external view returns (address);
    function decimals() external view returns (uint8);
}

interface DynamicCeiling {
    function getBlockNumber() external view returns (uint256);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    MiniMeToken public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    DynamicCeiling public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    MiniMeToken public SGT;
    uint256 public maxSGTSupply;

    function initialize(address _snt, address _sntController, uint256 _startBlock, uint256 _endBlock, address _dynamicCeiling, address _destEthDevs, address _destTokensReserve, address _destTokensSgt, address _destTokensDevs, address _sgt, uint256 _maxSGTSupply) public onlyOwner {
    require(address(SNT) == 0x0);
    SNT = MiniMeToken(_snt);
    require(SNT.totalSupply() == 0);
    require(SNT.controller() == address(this));
    require(SNT.decimals() == 18);
    require(_sntController != 0x0);
    sntController = _sntController;
    require(_startBlock >= getBlockNumber());
    require(_startBlock < _endBlock);
    startBlock = _startBlock;
    endBlock = _endBlock;
    require(_dynamicCeiling != 0x0);
    dynamicCeiling = DynamicCeiling(_dynamicCeiling);
    require(_destEthDevs != 0x0);
    destEthDevs = _destEthDevs;
    require(_destTokensReserve != 0x0);
    destTokensReserve = _destTokensReserve;
    require(_destTokensSgt != 0x0);
    destTokensSgt = _destTokensSgt;
    require(_destTokensDevs != 0x0);
    destTokensDevs = _destTokensDevs;
    require(_sgt != 0x0);
    SGT = MiniMeToken(_sgt);
    require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());
    maxSGTSupply = _maxSGTSupply;
}
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Crowdfunding is Ownable {
    uint256 public contributionPeriod;
    uint256 public goal;
    uint256 public totalContributions;
    bool public contributionStarted;

    function initContribution(uint256 _contributionPeriod, uint256 _goal) external onlyOwner {
        require(!contributionStarted, ""The contribution period has already initiated."");
        contributionPeriod = _contributionPeriod;
        goal = _goal;
        contributionStarted = true;
        totalContributions = 0;
    }
}",3.853852033615112,initContribution,"[{'function': 'initContribution', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""initContribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_contributionPeriod"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_goal"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""contributionStarted""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""The contribution period has already initiated.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contributionPeriod""}, ""right"": {""type"": ""Identifier"", ""name"": ""_contributionPeriod""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""goal""}, ""right"": {""type"": ""Identifier"", ""name"": ""_goal""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contributionStarted""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalContributions""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",148.0,0.4426375084366392,0.00116238234635,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Crowdfunding is Ownable {
    uint256 public contributionPeriod;
    uint256 public goal;
    uint256 public totalContributions;
    bool public contributionStarted;

    constructor(uint256 _contributionPeriod, uint256 _goal) Ownable(msg.sender) {
        require(!_contributionStarted, ""The contribution period has already initiated."");
        contributionPeriod = _contributionPeriod;
        goal = _goal;
        contributionStarted = true;
        totalContributions = 0;
    }
}"
2093,Get all details of PixelCon # ` ( _tokenIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPixelCon {
    function totalSupply() external view returns (uint256);
}

struct PixelCon {
    uint256 tokenId;
    uint64 collectionIndex;
    uint32 dateCreated;
}

struct TokenLookup {
    address owner;
    address creator;
    uint64 tokenIndex;
}

mapping(uint256 => PixelCon) public pixelcons;
mapping(uint256 => TokenLookup) public tokenLookup;
mapping(uint256 => bytes8) public pixelconNames;

function getTokenDataByIndex(uint64 _tokenIndex, IPixelCon pixelConContract) public view returns (uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated) {
    require(_tokenIndex < pixelConContract.totalSupply(), ""PixelCon index is out of bounds"");
    PixelCon storage pixelcon = pixelcons[_tokenIndex];
    TokenLookup storage lookupData = tokenLookup[pixelcon.tokenId];
    return (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner, pixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

contract PixelCon is ERC721 {
    struct PixelConDetails {
        uint tokenId;
        address owner;
        string uri;
    }

    function getPixelConDetails(uint _tokenIndex) public view returns (PixelConDetails memory) {
        require(_exists(_tokenIndex), ""PixelCon: Token does not exist"");
        return PixelConDetails({
            tokenId: _tokenIndex,
            owner: ownerOf(_tokenIndex),
            uri: tokenURI(_tokenIndex)
        });
    }
}",7.79249095916748,getPixelConDetails,"[{'function': 'getPixelConDetails', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPixelConDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_tokenIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PixelConDetails""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenIndex""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""PixelCon: Token does not exist""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PixelConDetails""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenIndex""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenIndex""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenURI""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenIndex""}], ""names"": []}], ""names"": [""tokenId"", ""owner"", ""uri""]}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",24.0,0.7554453962512859,0.1121262046914556,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PixelCon is ERC721, Ownable {
    struct PixelConDetails {
        uint tokenId;
        address owner;
        string uri;
    }

    constructor() ERC721(""PixelCon"", ""PCN"") {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getPixelConDetails(uint _tokenIndex) public view returns (PixelConDetails memory) {
        require(_exists(_tokenIndex), ""PixelCon: Token does not exist"");
        return PixelConDetails({
            tokenId: _tokenIndex,
            owner: ownerOf(_tokenIndex),
            uri: tokenURI(_tokenIndex)
        });
    }
}"
2971,Get the approved address for a single NFT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 private _totalSupply;
    mapping(uint40 => address) public cutieIndexToApproved;
    mapping(uint40 => address) public cutieIndexToOwner;
    mapping(address => bool) public addressToApprovedAll;

    function getApproved(uint256 _tokenId) external view returns (address) {
        require(_tokenId <= _totalSupply());

        if (cutieIndexToApproved[uint40(_tokenId)] != address(0)) {
            return cutieIndexToApproved[uint40(_tokenId)];
        }

        address owner = cutieIndexToOwner[uint40(_tokenId)];
        return addressToApprovedAll[owner];
    }

    function _totalSupply() internal view returns (uint256) {
        return _totalSupply;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

contract MyNFTContract is ERC721 {

    constructor() ERC721(""MyNFTContract"", ""MNFT"") {}

    /**
     * @dev Returns the approved address for a single NFT
     * @param tokenId uint256 ID of the token to query
     * @return address currently approved for a the given token ID
     */
    function getApprovedAddress(uint256 tokenId) public view returns (address) {
        return _getApproved(tokenId);
    }
}",5.682881832122803,getApprovedAddress,"[{'function': 'getApprovedAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getApprovedAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getApproved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",25.0,0.7950439396285731,0.0644378811172246,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyNFTContract is ERC721, Ownable {
    constructor() ERC721(""MyNFTContract"", ""MNFT"") Ownable(msg.sender) {
        // No need to initialize state variables as they are already initialized by the parent contracts' constructors
    }

    /**
     * @dev Returns the approved address for a single NFT
     * @param tokenId uint256 ID of the token to query
     * @return address currently approved for a the given token ID
     */
    function getApprovedAddress(uint2seq tokenId) public view returns (address) {
        return _getApproved(tokenId);
    }
}"
2241,Gets absolute issued hardcap volume which means it will be greater than softcap value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap.add(tokenHardcapIssuedValue);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract Crowdsale is ReentrancyGuard {
    uint256 private hardCap;
    uint256 private softCap;

    constructor (uint256 _hardCap, uint256 _softCap) {
        require(_hardCap > _softCap, ""Hardcap must be greater than softcap"");
        hardCap = _hardCap;
        softCap = _softCap;
    }

    function getAbsoluteIssuedHardcapVolume() public view returns (uint256) {
        require(hardCap > softCap, ""Softcap must be less than hardcap"");
        uint256 volume = hardCap - softCap;
        return volume;
    }
}",7.426586151123047,getAbsoluteIssuedHardcapVolume,"[{'function': 'getAbsoluteIssuedHardcapVolume', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAbsoluteIssuedHardcapVolume"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""hardCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""softCap""}}, {""type"": ""stringLiteral"", ""value"": ""Softcap must be less than hardcap""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""volume"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""hardCap""}, ""right"": {""type"": ""Identifier"", ""name"": ""softCap""}}}, {""type"": ""Identifier"", ""name"": ""volume""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",12.0,0.7078857013234757,0.1802916852147069,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Crowdsale is ReentrancyGuard, Ownable {
    uint256 private hardCap = 1;
    uint256 private softCap = 1;

    constructor() {
        require(hardCap > softCap, ""Hardcap must be greater than softcap"");
        __Ownable_init();
        Ownable.initialize(msg.sender);
    }

    function getAbsoluteIssuedHardcapVolume() public view returns (uint256) {
        require(hardCap > softCap, ""Softcap must be less than hardcap"");
        uint256 volume = hardCap - softCap;
        return volume;
    }
}"
4491,Exchange ETH to SNX while insisting on a particular set of rates .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchange {
    function exchangeEtherForSynthetix() external payable returns (uint);
}

interface IPricing {
    function usdToEthPrice() external view returns (uint);
    function usdToSnxPrice() external view returns (uint);
}

abstract contract ExchangeWrapper is Ownable, IExchange {
    using SafeMath for uint;

    IPricing public pricing;
    bool public paused = false;

    constructor(address _pricing) {
        pricing = IPricing(_pricing);
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }

    function exchangeEtherForSynthetixAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate) public payable override returns (uint) {
        require(!paused, ""Contract is paused"");
        require(guaranteedEtherRate == pricing.usdToEthPrice(), ""Guaranteed ether rate would not be received"");
        require(guaranteedSynthetixRate == pricing.usdToSnxPrice(), ""Guaranteed synthetix rate would not be received"");
        return exchangeEtherForSynthetix();
    }

    function exchangeEtherForSynthetix() public payable override returns (uint) {
        // Implementation of the actual exchange logic
        // This is a placeholder for the actual implementation
        return 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

interface IUniswapV2Router {
    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
}

contract EthToSnxExchange {
    address private uniRouter;
    IERC20 private snxToken;

    constructor(address _uniRouter, address _snxToken) {
        uniRouter = _uniRouter;
        snxToken = IERC20(_snxToken);
    }

    function exchangeEthToSnx(uint ethAmount, uint expectedSnxAmount, address[] calldata path) external payable {
        require(msg.value == ethAmount, ""ETH amount mismatch"");
        require(path[0] == address(0), ""Path should start with ETH"");
        require(path[path.length-1] == address(snxToken), ""Path should end with SNX"");

        IUniswapV2Router router = IUniswapV2Router(uniRouter);
        uint[] memory amounts = router.getAmountsOut(ethAmount, path);
        require(amounts[amounts.length-1] >= expectedSnxAmount, ""SNX slippage"");

        router.swapExactETHForTokens{value: ethAmount}(expectedSnxAmount, path, msg.sender, block.timestamp + 1 minutes);
    }
}",16.6852068901062,exchangeEthToSnx,"[{'function': 'swapExactETHForTokens', 'complexity': 0}, {'function': 'exchangeEthToSnx', 'complexity': 4}]",5.0,{},36.0,0.6107338858887968,0.0836583824159958,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IUniswapV2Router {
    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
}
import ""openzeppelin/SafeMath.sol"";
contract EthToSnxExchange is Ownable {
    address private uniRouter;
    IERC20 private snxToken;

    constructor(address _uniRouter, address _snxToken) Ownable(msg.sender) {
        uniRouter = _uniRouter;
        snxToken = IERC20(_snxToken);
    }

    function exchangeEthToSnx(uint ethAmount, uint expectedSnxAmount, address[] calldata path) external payable {
        require(msg.value == ethAmount, ""ETH amount mismatch"");
        require(path[0] == address(0), ""Path should start with ETH"");
        require(path[path.length-1] == address(snxToken), ""Path should end with SNX"");

        IUniswapV2Router router = IUniswapV2Router(uniRouter);
        uint[] memory amounts = router.getAmountsOut(ethAmount, path);
        require(amounts[amounts.length-1] >= expectedSnxAmount, ""SNX slippage"");

        router.swapExactETHForTokens{value: ethAmount}(expectedSnxAmount, path, msg.sender, block.timestamp + 1 minutes);
    }
}"
4173,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract {
    using SafeMath for uint256;

    enum Error { NO_ERROR, SOME_ERROR }

    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {
        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);
        if (err != Error.NO_ERROR) {
            return (uint(err), 0, 0);
        }
        return (0, supplyValue, borrowValue);
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        // Implement the logic of calculateAccountValuesInternal here
        // For demonstration purposes, let's assume it returns some values based on userAddress
        return (Error.NO_ERROR, 100, 50);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Bank {
    using SafeMath for uint256;
    mapping(address => uint256) private balances;
    mapping(address => uint256) private borrowBalances;

    function getBalances(address user) public view returns (uint256, uint256) {
        return (balances[user], borrowBalances[user]);
    }

    function getETHValue(address user) public view returns (uint256, uint256) {
        uint256 supplyBalance = balances[user].mul(10**18);
        uint256 borrowBalance = borrowBalances[user].mul(10**18);
        return (supplyBalance, borrowBalance);
    }
}",8.061663150787354,getETHValue,"[{'function': 'getBalances', 'complexity': 0}, {'function': 'getETHValue', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getETHValue"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""supplyBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""borrowBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""borrowBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""supplyBalance""}, {""type"": ""Identifier"", ""name"": ""borrowBalance""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",22.0,0.7020317392621989,0.0977411014111877,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Bank is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) private balances;
    mapping(address => uint256) private borrowBalances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000;
        borrowBalances[msg.sender] = 0;
    }

    function getBalances(address user) public view returns (uint256, uint256) {
        return (balances[user], borrowBalances[user]);
    }

    function getETHValue(address user) public view returns (uint256, uint256) {
        uint256 supplyBalance = balances[user].mul(10**18);
        uint256 borrowBalance = borrowBalances[user].mul(10**18);
        return (supplyBalance, borrowBalance);
    }
}"
4418,Create a new payment channel between two parties,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NettingChannelRegistry is Ownable {
    using SafeMath for uint256;

    struct Data {
        address token;
        address[][] nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint) partyhash_to_channelpos;
        address[] all_channels;
        mapping(address => mapping(address => uint)) node_index;
    }

    Data data;

    function newChannel(address partner, uint settle_timeout) external returns (address) {
        Data storage self = data;
        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];
        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint channel_pos = self.partyhash_to_channelpos[party_hash];
        address new_channel_address = new NettingChannelContract(self.token, msg.sender, partner, settle_timeout);
        if (channel_pos != 0) {
            address settled_channel = self.all_channels[channel_pos - 1];
            require(!contractExists(settled_channel));
            uint caller_pos = self.node_index[msg.sender][partner];
            uint partner_pos = self.node_index[partner][msg.sender];
            self.all_channels[channel_pos - 1] = new_channel_address;
            caller_channels[caller_pos - 1] = new_channel_address;
            partner_channels[partner_pos - 1] = new_channel_address;
        } else {
            self.all_channels.push(new_channel_address);
            caller_channels.push(new_channel_address);
            partner_channels.push(new_channel_address);
            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;
            self.node_index[msg.sender][partner] = caller_channels.length;
            self.node_index[partner][msg.sender] = partner_channels.length;
        }
        return new_channel_address;
    }

    function contractExists(address contractAddress) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(contractAddress) }
        return size > 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PaymentChannel {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public channels;

    event PaymentChannelCreated(address indexed sender, address indexed receiver, uint256 amt);

    function createPaymentChannel(address receiver, uint256 amt) public payable {
        require(msg.value == amt, ""Sent value not equal to amount"");
        require(channels[msg.sender][receiver] == 0, ""Channel already exists"");

        channels[msg.sender][receiver] = amt;
        emit PaymentChannelCreated(msg.sender, receiver, amt);
    }
}",4.670233964920044,createPaymentChannel,"[{'function': 'createPaymentChannel', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createPaymentChannel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amt"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""amt""}}, {""type"": ""stringLiteral"", ""value"": ""Sent value not equal to amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""receiver""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Channel already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""receiver""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amt""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentChannelCreated""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""receiver""}, {""type"": ""Identifier"", ""name"": ""amt""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",89.0,0.5406853752569164,0.0075769292390193,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PaymentChannel is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public channels;

    event PaymentChannelCreated(address indexed sender, address indexed receiver, uint256 amt);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables follows the rules provided:
        // - uint/uint256: Set to 1 (never 0)
        // - address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // - bool: Set to true
        // - string: Set to 'initialized'
        // - bytes32: Set to bytes32('init')
    }

    function createPaymentChannel(address receiver, uint256 amt) public payable {
        require(msg.value == amt, ""Sent value not equal to amount"");
        require(channels[msg.sender][receiver] == 0, ""Channel already exists"");

        channels[msg.sender][receiver] = amt;
        emit PaymentChannelCreated(msg.sender, receiver, amt);
    }
}"
6848,from ` _from ` will be sended ` _value ` tokens to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public approved;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        approved[_from][msg.sender] = approved[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

contract MyContract {
    using SafeERC20 for IERC20;

    function transferTokens(IERC20 _token, address _from, address _to, uint256 _value) public {
        require(msg.sender == _from, ""sender is not the source address"");
        require(_to != address(0), ""receiver is the zero address"");

        uint256 balance = _token.balanceOf(_from);
        require(_value <= balance, ""transfer amount exceeds balance"");

        _token.safeTransferFrom(_from, _to, _value);
    }
}",6.669408082962036,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_from""}}, {""type"": ""stringLiteral"", ""value"": ""sender is not the source address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""receiver is the zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.7664202567335345,0.2700763834349097,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeERC20 for IERC20;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(IERC20 _token, address _from, address _to, uint256 _value) public {
        require(msg.sender == _from, ""sender is not the source address"");
        require(_to != address(0), ""receiver is the zero address"");

        uint256 balance = _token.balanceOf(_from);
        require(_value <= balance, ""transfer amount exceeds balance"");

        _token.safeTransferFrom(_from, _to, _value);
    }
}"
967,Sets the message sender as the winner if they have completed the hunt,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    bool public grace = false;
    uint[] public locations;
    mapping(address => Hunter[]) public hunters;
    address public winner;
    uint public timeOfWin;

    struct Hunter {
        uint block;
        bytes32 encryptKey;
    }

    event WonEvent(address indexed winner);

    function checkWin(uint[] memory decryptKeys) public {
        require(!grace, ""Grace period is active"");
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        uint lastBlock = 0;
        bool won = true;

        for (uint i = 0; i < locations.length; i++) {
            require(hunters[msg.sender][i].block > lastBlock, ""Blocks must be in increasing order"");
            lastBlock = hunters[msg.sender][i].block;

            if (locations[i] != 0) {
                uint storedVal = uint(keccak256(abi.encodePacked(hunters[msg.sender][i].encryptKey ^ decryptKeys[i])));
                won = won && (locations[i] == storedVal);
            }
        }

        require(won, ""Not all conditions are met"");

        if (won) {
            timeOfWin = block.timestamp;
            winner = msg.sender;
            grace = true;
            emit WonEvent(winner);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TreasureHunt {
    address public treasureOwner;
    mapping(address => bool) public hasCompletedHunt;

    function setWinner() public {
        require(hasCompletedHunt[msg.sender], ""You have not completed the hunt yet."");
        treasureOwner = msg.sender;
    }
}",7.6967339515686035,setWinner,"[{'function': 'setWinner', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setWinner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasCompletedHunt""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""You have not completed the hunt yet.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""treasureOwner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",62.0,0.5572216796873732,0.0013380562297954,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TreasureHunt is Ownable {
    address public treasureOwner;
    mapping(address => bool) public hasCompletedHunt;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        treasureOwner = msg.sender;
    }

    function setWinner() public {
        require(hasCompletedHunt[msg.sender], ""You have not completed the hunt yet."");
        treasureOwner = msg.sender;
    }
}"
5478,Allow users to buy tokens for ` _buyExchangeRate ` eth and sell tokens for ` _sellExchangeRate ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExchangeRateSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    function setExchangeRate(uint256 _sellExchangeRate, uint256 _buyExchangeRate) public onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenExchange is ERC20, ReentrancyGuard {
    uint256 private _buyExchangeRate;
    uint256 private _sellExchangeRate;

    constructor(uint256 buyExchangeRate, uint256 sellExchangeRate) ERC20(""Token"", ""TKN"") {
        _buyExchangeRate = buyExchangeRate;
        _sellExchangeRate = sellExchangeRate;
    }

    function buyTokens(uint256 amount) external payable nonReentrant {
        uint256 cost = amount * _buyExchangeRate;
        require(msg.value >= cost, ""Not enough Ether provided."");
        _mint(msg.sender, amount);
        payable(address(this)).transfer(msg.value - cost);
    }

    function sellTokens(uint256 amount) external nonReentrant {
        require(balanceOf(msg.sender) >= amount, ""Not enough tokens to sell."");
        uint256 revenue = amount * _sellExchangeRate;
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(revenue);
    }
}",8.745764970779419,buyTokens,"[{'function': 'buyTokens', 'complexity': 1}, {'function': 'sellTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""cost"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyExchangeRate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""cost""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough Ether provided.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""cost""}}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",26.0,0.4992175781435329,0.011597748989988,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenExchange is ERC20, ReentrancyGuard, Ownable {
    uint256 private _buyExchangeRate;
    uint256 private _sellExchangeRate;

    mapping(address => uint256) public balanceOf;

 constructor(uint256 buyExchangeRate, uint256 sellExchangeRate) ERC20(""Token"", ""TKN"") Ownable(msg.sender) {
        _buyExchangeRate = buyExchangeRate;
        _sellExchangeRate = sellExchangeRate;
    }

    function buyTokens(uint256 amount) external payable nonReentrant {
        uint256 cost = amount * _buyExchangeRate;
        require(msg.value >= cost, ""Not enough Ether provided."");
        _mint(msg.sender, amount);
        payable(address(this)).transfer(msg.value - cost);
    }

    function sellTokens(uint256 amount) external nonReentrant {
        require(balanceOf(msg.sender) >= amount, ""Not enough tokens to sell."");
        uint256 revenue = amount * _sellExchangeRate;
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(revenue);
    }
}"
1010,Fills a offer that has been previously made using ` makeOffer ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Assuming _v, _r, and _s are state variables or parameters passed to the function
    bytes32 private constant EIP191_PREFIX = 0x1901;

    constructor() Ownable() {}

    function fillOffer(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint64 _nonce, uint8 v, bytes32 r, bytes32 s) external onlyOwner {
        require(_recoverAddress(keccak256(abi.encodePacked(EIP191_PREFIX, ""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce)), v, r, s) == _filler, ""Invalid signature"");
        bytes32 msgHash = keccak256(abi.encodePacked(""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
        _validateAndAddHash(msgHash);
        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    function _validateAndAddHash(bytes32 hash) internal virtual;

    function _fill(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount) internal virtual;
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Marketplace is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private offers;

    event OfferFilled(address indexed buyer, uint256 amount);

    function makeOffer(uint256 _amount) public onlyOwner {
        offers[msg.sender] = _amount;
    }

    function fillOffer(address _seller) public {
        require(offers[_seller] > 0, ""No offer to fill"");

        uint256 offerAmount = offers[_seller];
        offers[_seller] = 0;

        // Note: In an actual contract, transfer of funds would take place here.

        emit OfferFilled(msg.sender, offerAmount);
    }
}",6.400296926498413,fillOffer,"[{'function': 'makeOffer', 'complexity': 0}, {'function': 'fillOffer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""fillOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_seller""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No offer to fill""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""offerAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_seller""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_seller""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OfferFilled""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""offerAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.7658131878564531,0.0291742769608866,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Marketplace is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private offers;

    event OfferFilled(address indexed buyer, uint256 amount);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function makeOffer(uint256 _amount) public onlyOwner {
        offers[msg.sender] = _amount;
    }

    function fillOffer(address _seller) public {
        require(offers[_seller] > 0, ""No offer to fill"");

        uint256 offerAmount = offers[_seller];
        offers[_seller] = 0;

        // Note: In an actual contract, transfer of funds would take place here.

        emit OfferFilled(msg.sender, offerAmount);
    }
}"
1790,Update the Synthetix Drawing Rights exchange rate based on other rates already updated .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public xdrParticipants;
    mapping(address => uint256) public rates;
    mapping(string => uint256) public lastRateUpdateTimes;

    event RatesUpdated(bytes4[] currencyCode, uint256[] rate);

    function updateXDRRate(uint timeSent) external onlyOwner {
        uint total = 0;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            total = rates[xdrParticipants[i]].add(total);
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;

        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";

        uint[] memory eventRate = new uint[](1);
        eventRate[0] = rates[""XDR""];

        emit RatesUpdated(eventCurrencyCode, eventRate);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SynthetixExchange is Ownable {
    using SafeMath for uint256;

    struct Rate {
        uint256 value;
        uint256 lastUpdated;
    }

    mapping(string => Rate) private rates;
    string[] public rateNames;

    event RateUpdated(string name, uint256 value);

    function updateSdrRate() public onlyOwner {
        require(rateNames.length > 0, 'No rates to base SDR rate calculation on');

        uint256 totalValue = 0;

        for (uint256 i = 0; i < rateNames.length; i++) {
            totalValue = totalValue.add(rates[rateNames[i]].value);
        }

        uint256 newSdrRate = totalValue.div(rateNames.length);
        rates['sdr'] = Rate(newSdrRate, block.timestamp);

        emit RateUpdated('sdr', newSdrRate);
    }
}",12.029252767562866,updateSdrRate,"[{'function': 'updateSdrRate', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateSdrRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rateNames""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No rates to base SDR rate calculation on""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rateNames""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalValue""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalValue""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rateNames""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""memberName"": ""value""}], ""names"": []}}}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSdrRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalValue""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rateNames""}, ""memberName"": ""length""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""stringLiteral"", ""value"": ""sdr""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Rate""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newSdrRate""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RateUpdated""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""sdr""}, {""type"": ""Identifier"", ""name"": ""newSdrRate""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.7381816496508731,0.1496084954645026,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract SynthetixExchange is Ownable {
    using SafeMath for uint256;

    struct Rate {
        uint256 value;
        uint256 lastUpdated;
    }

    mapping(string => Rate) private rates;
    string[] public rateNames;

    event RateUpdated(string name, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            rates[string(abi.encodePacked('rate', uint2str(i)))] = Rate(1, block.timestamp);
        }
        rateNames = ['rate0', 'rate1', 'rate2'];
    }

    function updateSdrRate() public onlyOwner {
        require(rateNames.length > 0, 'No rates to base SDR rate calculation on');

        uint256 totalValue = 0;

        for (uint256 i = 0; i < rateNames.length; i++) {
            totalValue = totalValue.add(rates[rateNames[i]].value);
        }

        uint256 newSdrRate = totalValue.div(rateNames.length);
        rates['sdr'] = Rate(newSdrRate, block.timestamp);

        emit RateUpdated('sdr', newSdrRate);
    }

    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return ""0"";
        }
        uint j = _i;
        uint len = 0;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}"
3704,Buy tokens from contract by sending ethereum to contract address with no minimum contribution,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint public buyPrice = 100; // Example price, adjust as needed
    Token token;

    mapping(address => uint256) public balanceOf;
    address public creator;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(Token _token, address _creator) {
        token = _token;
        creator = _creator;
    }

    function () external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint amount = msg.value.mul(buyPrice);
        uint amountRaised;
        amountRaised = amountRaised.add(msg.value);
        require(token.balanceOf(creator) >= amount, ""Insufficient balance of creator"");
        require(msg.value > 0, ""Amount must be greater than zero"");
        token.transfer(msg.sender, amount);
        token.transfer(creator, msg.value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract BuyTokens is ReentrancyGuard {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate;

    constructor(IERC20 _token, uint256 _rate) {
        require(_rate > 0, ""rate must be greater than zero"");
        token = _token;
        rate = _rate;
    }

    receive() external payable nonReentrant {
        uint256 tokens = calculateTokenAmount(msg.value);
        require(token.balanceOf(address(this)) >= tokens, ""Not enough tokens in contract"");
        require(token.transfer(msg.sender, tokens), ""Token transfer failed"");
    }

    function calculateTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(rate);
    }
}",10.221481084823608,calculateTokenAmount,"[{'function': 'calculateTokenAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""receive"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateTokenAmount""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""tokens""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": True, ""stateMutability"": ""payable""}",,0.5337894613763372,0.0030498822565182,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract BuyTokens is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token, uint256 _rate) Ownable(msg.sender) {
        require(_rate > 0, ""rate must be greater than zero"");
        token = _token;
        rate = _rate;
    }

    receive() external payable nonReentrant {
        uint256 tokens = calculateTokenAmount(msg.value);
        require(token.balanceOf(address(this)) >= tokens, ""Not enough tokens in contract"");
        require(token.transfer(msg.sender, tokens), ""Token transfer failed"");
    }

    function calculateTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(rate);
    }
}"
2468,"Decentralizes the contract , this operation can not be undone","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function removeOwnership(address _dece) public onlyOwner {
        require(_dece == 0xdece);
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    function decentralize() public onlyOwner {
        renounceOwnership();
    }

}",9.893555879592896,decentralize,"[{'function': 'decentralize', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""decentralize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""renounceOwnership""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.6768114642753548,0.0606760408955793,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function decentralize() public onlyOwner {
        renounceOwnership();
    }
}"
97,This is public rather than external so it can be called by derived contracts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused = true;

    modifier onlyManager() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract MyContract is AccessControl {

    bytes32 public constant CHILD_CONTRACT_ROLE = keccak256(""CHILD_CONTRACT_ROLE"");

    function callByChildContract(uint256 value) public onlyRole(CHILD_CONTRACT_ROLE) returns(uint256) {
        require(value > 0, 'Invalid input value');
        uint256 newValue = value * 2;
        return newValue;
    }
}",6.984414100646973,callByChildContract,"[{'function': 'callByChildContract', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""callByChildContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid input value""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}, {""type"": ""Identifier"", ""name"": ""newValue""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""CHILD_CONTRACT_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.1830633929072269,0.0149170745265639,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is AccessControl {
    bytes32 public constant CHILD_CONTRACT_ROLE = keccak256(""CHILD_CONTRACT_ROLE"");

    constructor()
        // Initialize the contract with a fixed, non-zero value for uint
        uint256 _uintValue = 1,

        // Use a fixed address for the first owner
        address _addressOwner = 0x1111111111111111111111111111111111111111,

        // Set to true for bool
        bool _boolValue = true,

        // Initialize with 'initialized' string
        string memory _strValue = ""initialized"",

        // Set bytes32 to 'init'
        bytes32 _bytes32Value = bytes32('init')
    {
        // Call the constructor of the parent contract (AccessControl)
        super(_uintValue, _addressOwner, _boolValue, _strValue, _bytes32Value);
    }

    function callByChildContract(uint256 value) public onlyRole(CHILD_CONTRACT_ROLE) returns(uint256) {
        require(value > 0, 'Invalid input value');
        uint256 newValue = value * 2;
        return newValue;
    }
}"
5181,Checks if an address ` _address ` is one of 3rd party owners ( origin owner is not included ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Role { ROLE_THIRDPARTY_OWNER }
    mapping(address => mapping(Role => bool)) public ownerRoles;

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return ownerRoles[_address][ROLE_THIRDPARTY_OWNER];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract CheckThirdPartyOwner is AccessControl {
    bytes32 public constant THIRD_PARTY_OWNER_ROLE = keccak256(""THIRD_PARTY_OWNER_ROLE"");

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return hasRole(THIRD_PARTY_OWNER_ROLE, _address);
    }
}",5.612557888031006,isThirdPartyOwner,"[{'function': 'isThirdPartyOwner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isThirdPartyOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""THIRD_PARTY_OWNER_ROLE""}, {""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.9616963309740044,0.6187934993051338,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CheckThirdPartyOwner is AccessControl {
    bytes32 public constant THIRD_PARTY_OWNER_ROLE = keccak256(""THIRD_PARTY_OWNER_ROLE"");

    constructor() Ownable(msg.sender) {
        _setupRole(THIRD_PARTY_OWNER_ROLE, msg.sender);
    }

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return hasRole(THIRD_PARTY_OWNER_ROLE, _address);
    }
}"
4562,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ISecurityToken {
    function totalSupplyAt(uint256 checkpointId) external view returns (uint256);
    function balanceOfAt(address account, uint256 checkpointId) external view returns (uint256);
    function currentCheckpointId() external view returns (uint256);
}

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    struct Dividend {
        uint256 checkpointId;
        uint256 creationTime;
        uint256 maturity;
        uint256 expiry;
        uint256 amount;
        uint256 totalSupply;
        uint256 claimedAmount;
        bool isClaimed;
        uint256 claimableDays;
        uint256 penaltyPercentage;
        bytes32 name;
        mapping(address => bool) dividendExcluded;
    }

    Dividend[] public dividends;
    ISecurityToken public securityToken;
    uint256 public constant EXCLUDED_ADDRESS_LIMIT = 100;

    event EtherDividendDeposited(address indexed sender, uint256 checkpointId, uint256 time, uint256 maturity, uint256 expiry, uint256 amount, uint256 totalSupply, uint256 dividendIndex, bytes32 name);

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, ""Too many addresses excluded"");
        require(_expiry > _maturity, ""Expiry is before maturity"");
        require(_expiry > block.timestamp, ""Expiry is in the past"");
        require(msg.value > 0, ""No dividend sent"");
        require(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId(), ""Invalid checkpoint ID"");
        require(_name[0] != 0, ""Invalid name"");

        uint256 dividendIndex = dividends.length;
        uint256 currentSupply = ISecurityToken(securityToken).totalSupplyAt(_checkpointId);
        uint256 excludedSupply = 0;
        dividends.push(Dividend({
            checkpointId: _checkpointId,
            creationTime: block.timestamp,
            maturity: _maturity,
            expiry: _expiry,
            amount: msg.value,
            totalSupply: 0,
            claimedAmount: 0,
            isClaimed: false,
            claimableDays: 0,
            penaltyPercentage: 0,
            name: _name,
            dividendExcluded: new mapping(address => bool)(address(0))
        }));

        for (uint256 j = 0; j < _excluded.length; j++) {
            require(_excluded[j] != address(0), ""Invalid address"");
            require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], ""Duped exclude address"");
            excludedSupply = excludedSupply.add(ISecurityToken(securityToken).balanceOfAt(_excluded[j], _checkpointId));
            dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;
        }

        dividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);
        emit EtherDividendDeposited(msg.sender, _checkpointId, block.timestamp, _maturity, _expiry, msg.value, currentSupply, dividendIndex, _name);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract DividendContract is Ownable, ReentrancyGuard {

    struct Dividend {
        uint256 checkpoint;
        mapping(address => bool) excludedAddresses;
    }

    IERC20 public token;
    Dividend[] public dividends;

    constructor(IERC20 _token) {
        token = _token;
    }

    function createDividend(uint256 _checkpoint, address[] memory _excludedAddresses)
    public
    onlyOwner
    nonReentrant
    {
        Dividend memory newDividend;
        newDividend.checkpoint = _checkpoint;

        for (uint256 i = 0; i < _excludedAddresses.length; i++) {
            newDividend.excludedAddresses[_excludedAddresses[i]] = true;
        }

        dividends.push(newDividend);
    }
}",12.00179886817932,createDividend,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'createDividend', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_checkpoint"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excludedAddresses"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Dividend""}, ""name"": ""newDividend"", ""storageLocation"": ""memory""}], ""initialValue"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newDividend""}, ""memberName"": ""checkpoint""}, ""right"": {""type"": ""Identifier"", ""name"": ""_checkpoint""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excludedAddresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newDividend""}, ""memberName"": ""excludedAddresses""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excludedAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newDividend""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",159.0,0.8280444675699085,0.0003800548539064,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract DividendContract is Ownable, ReentrancyGuard {

    struct Dividend {
        uint256 checkpoint;
        mapping(address => bool) excludedAddresses;
    }

    IERC20 public token;
    Dividend[] public dividends;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function createDividend(uint256 _checkpoint, address[] memory _excludedAddresses)
    public
    onlyOwner
    nonReentrant
    {
        Dividend memory newDividend;
        newDividend.checkpoint = _checkpoint;

        for (uint256 i = 0; i < _excludedAddresses.length; i++) {
            newDividend.excludedAddresses[_excludedAddresses[i]] = true;
        }

        dividends.push(newDividend);
    }
}"
6025,Adds a token deposit to ` deposits [ ] ` ; only the ` owner ` can call this function and it will only work if the account sending the tokens has called ` approve ( ) ` so that this contract can call ` transferFrom ( ) ` and take the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenDeposit is Ownable {
    using SafeMath for uint256;

    struct Deposit {
        uint blockNumber;
        ERC20 token;
        uint amount;
    }

    Deposit[] public deposits;

    event NewDeposit(uint indexed id, ERC20 indexed token, uint amount);

    function newTokenDeposit(ERC20 _token, uint _amount, uint _block) public onlyOwner returns (uint _idDeposit) {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_block < block.number, ""Block number must be less than current block number"");
        require(_token.transferFrom(msg.sender, address(this), _amount), ""Token transfer failed"");

        _idDeposit = deposits.length;
        Deposit storage d = deposits[_idDeposit];
        d.blockNumber = _block == 0 ? block.number - 1 : _block;
        d.token = _token;
        d.amount = _amount;

        emit NewDeposit(_idDeposit, _token, _amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenDeposit is Ownable {
    IERC20 public token;
    mapping(address => uint256) public deposits;

    constructor(IERC20 _token) {
        token = _token;
    }

    function addDeposit(address depositor, uint256 amount) public onlyOwner {
        require(token.allowance(depositor, address(this)) >= amount, ""Token allowance too low"");
        bool success = token.transferFrom(depositor, address(this), amount);
        require(success, ""Token transfer failed"");
        deposits[depositor] += amount;
    }
}",12.290147066116331,addDeposit,"[{'function': 'addDeposit', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""depositor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""depositor""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Token allowance too low""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""depositor""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""depositor""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",52.0,0.7724617254371275,0.1213187543128701,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenDeposit is Ownable {
    IERC20 public token;
    mapping(address => uint256) public deposits;

    constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function addDeposit(address depositor, uint256 amount) public onlyOwner {
        require(token.allowance(depositor, address(this)) >= amount, ""Token allowance too low"");
        bool success = token.transferFrom(depositor, address(this), amount);
        require(success, ""Token transfer failed"");
        deposits[depositor] += amount;
    }
}"
521,set the ticker registration fee in POLY tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PolyRegistration {
    using SafeMath for uint256;

    uint256 public registrationFee;

    event LogChangePolyRegisterationFee(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(registrationFee != _registrationFee);
        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
        registrationFee = _registrationFee;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TickerRegistry is ReentrancyGuard {
    IERC20 public immutable POLY;

    uint256 public tickerRegistrationFee;

    event TickerRegistrationFeeUpdated(uint256 _newFee);

    constructor(IERC20 _polyToken) {
        POLY = _polyToken;
    }

    function setTickerRegistrationFee(uint256 _newFee) external nonReentrant onlyOwner {
        tickerRegistrationFee = _newFee;

        emit TickerRegistrationFeeUpdated(_newFee);
    }
}
```

This contract reflects modern best practices with the inclusion of the OpenZeppelin ReentrancyGuard contract for secure state changes, and is using Solidity 0.8.0 to leverage built-in arithmetic checks.

The `setTickerRegistrationFee` function is marked as `external`, as it is intended to be called from outside the contract. It is also marked with the `nonReentrant` modifier from the ReentrancyGuard contract to prevent reentrancy attacks.

The fee is set via the `_newFee` input parameter and an event is emitted with the new fee for transparency.

Note that `onlyOwner` is assumed to be a custom modifier to ensure only authorized addresses can change the fee. It would usually be defined in a contract inheriting from OpenZeppelin's `Ownable` contract, and used like so:

```solidity
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TickerRegistry is ReentrancyGuard, Ownable {
... //rest of the contract
}",9.953993082046509,setTickerRegistrationFee,"[{'function': 'setTickerRegistrationFee', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTickerRegistrationFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tickerRegistrationFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newFee""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TickerRegistrationFeeUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newFee""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.7056719994741847,0.0281178154839129,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TickerRegistry is ReentrancyGuard, Ownable {
    IERC20 public immutable POLY;

    uint256 public tickerRegistrationFee;

    event TickerRegistrationFeeUpdated(uint256 _newFee);

    constructor(IERC20 _polyToken) ReentrancyGuard() Ownable(msg.sender) {
        POLY = _polyToken;
        tickerRegistrationFee = 1; // Set to a non-zero, safe value
    }

    function setTickerRegistrationFee(uint256 _newFee) external nonReentrant onlyOwner {
        tickerRegistrationFee = _newFee;
        emit TickerRegistrationFeeUpdated(_newFee);
    }
}"
2313,Set both ico min at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoMin;
    uint256 public preIcoLimit;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public onlyOwner {
        require(newIcoMin > 0, ""New ICO minimum must be greater than zero"");
        require(newPreIcoLimit > 0, ""New pre-ICO limit must be greater than zero"");
        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;
        updatePrices();
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Block number must be greater than current block number or zero"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(name, url, blockNumber);
    }
}","e Solidity function:

``` solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ICOSale is Ownable {
    uint256 private _icoMinWei;
    uint256 private _icoMinToken;

    function setIcoMin(uint256 newIcoMinWei, uint256 newIcoMinToken) public onlyOwner {
        _icoMinWei = newIcoMinWei;
        _icoMinToken = newIcoMinToken;
    }
}",12.451964855194092,setIcoMin,"[{'function': 'setIcoMin', 'complexity': 0}]",1.0,{},33.0,0.7998394708581456,0.0284952717993085,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ICOSale is Ownable {
    uint256 private _icoMinWei;
    uint256 private _icoMinToken;

    constructor() Ownable(msg.sender) {
        _icoMinWei = 1; // Set to safe, non-corner-case value
        _icoMinToken = 1; // Set to safe, non-corner-case value
    }

    function setIcoMin(uint256 newIcoMinWei, uint256 newIcoMinToken) public onlyOwner {
        _icoMinWei = newIcoMinWei;
        _icoMinToken = newIcoMinToken;
    }
}"
1838,Keep a US Citizen 's tokens for one year .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool claimed;
    }

    mapping(address => Holding) public heldTokens;
    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    function hold(address who, uint256 quantity) public onlyOwner {
        require(who != address(0), ""The null address cannot own tokens."");
        require(quantity > 0, ""Quantity must be greater than zero."");
        require(!isExistingHolding(who), ""Cannot overwrite an existing holding, use a new wallet."");

        Holding memory holding = Holding(quantity, block.timestamp + oneYear, false);
        heldTokens[who] = holding;
        emit TokensHeld(who, holding.quantity, holding.releaseDate);
    }

    function isExistingHolding(address who) internal view returns (bool) {
        return heldTokens[who].quantity > 0;
    }

    uint256 constant oneYear = 365 days;
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CitizenToken is ERC20, Pausable, Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _lockTime;

    function transfer(address recipient, uint256 amount) public override whenNotPaused returns (bool) {
        require(_msgSender() != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(block.timestamp >= _lockTime[_msgSender()], ""ERC20: tokens are locked for one year"");

        _beforeTokenTransfer(_msgSender(), recipient, amount);

        uint256 senderBalance = _balances[_msgSender()];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[_msgSender()] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(_msgSender(), recipient, amount);

        return true;
    }

    function mint(address account, uint256 amount) public onlyOwner {
        _mint(account, amount);
        _lockTime[account] = block.timestamp + 365 days;
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal whenNotPaused override {
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }
}",17.110340118408203,transfer,"[{'function': 'transfer', 'complexity': 4}, {'function': 'mint', 'complexity': 0}, {'function': '_beforeTokenTransfer', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_lockTime""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: tokens are locked for one year""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_beforeTokenTransfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.5234466158214028,0.110478142657666,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CitizenToken is ERC20, Pausable, Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _lockTime;

    uint256 public totalSupply;

 constructor() ERC20(""CitizenToken"", ""CTK"") Ownable(msg.sender) {
        // Initialization of state variables
        _balances[owner()] = 1 * 10 ** decimals(); // Set initial balance to 1 token
        _totalSupply += 1 * 10 ** decimals(); // Update total supply
    }

    function transfer(address recipient, uint256 amount) public override whenNotPaused returns (bool) {
        require(_msgSender() != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");
        require(block.timestamp >= _lockTime[_msgSender()], ""ERC20: tokens are locked for one year"");

        _beforeTokenTransfer(_msgSender(), recipient, amount);

        uint256 senderBalance = _balances[_msgSender()];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[_msgSender()] = senderBalance - amount;
        _balances[recipient] += amount;

        emit Transfer(_msgSender(), recipient, amount);

        return true;
    }

    function mint(address account, uint256 amount) public onlyOwner {
        _mint(account, amount);
        _lockTime[account] = block.timestamp + 365 days;
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal whenNotPaused override {
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }
}"
6404,Adds multiple addresses to the administrator list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdminManagement is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    function addManyAdmins(_accounts: address[]) external onlyOwner returns (bool) {
        for (uint8 i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            if (account != address(0) && !admins[account] && account != owner()) {
                admins[account] = true;
                emit AdminAdded(_accounts[i]);
            }
        }
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract Administrator is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() {
        _setupRole(ADMIN_ROLE, _msgSender());
    }

    function addMultipleAdmins(address[] memory newAdmins) public {
        require(hasRole(ADMIN_ROLE, _msgSender()), ""Caller is not an administrator"");

        for (uint256 i = 0; i < newAdmins.length; i++) {
            grantRole(ADMIN_ROLE, newAdmins[i]);
        }
    }
}",5.295390129089356,addMultipleAdmins,"[{'function': 'addMultipleAdmins', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addMultipleAdmins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""newAdmins"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an administrator""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newAdmins""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""grantRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ADMIN_ROLE""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""newAdmins""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",35.0,0.7244321284767707,0.1445762274375737,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Context.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Administrator is AccessControl, Context {
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");

    constructor() {
        _setupRole(ADMIN_ROLE, _msgSender());
    }

    function addMultipleAdmins(address[] memory newAdmins) public {
        require(hasRole(ADMIN_ROLE, _msgSender()), ""Caller is not an administrator"");

        for (uint256 i = 0; i < newAdmins.length; i++) {
            grantRole(ADMIN_ROLE, newAdmins[i]);
        }
    }
}"
892,Sets the default fee for burning CarbonDollar into a whitelisted stablecoin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public defaultFee;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;
        if (oldFee != defaultFee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CarbonDollar is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public burnFee;

    event BurnFeeUpdated(uint256 newBurnFee);

    function setBurnFee(uint256 newBurnFee) public onlyOwner {
        burnFee = newBurnFee;
        emit BurnFeeUpdated(newBurnFee);
    }
}",10.95086407661438,setBurnFee,"[{'function': 'setBurnFee', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBurnFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBurnFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""burnFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBurnFee""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BurnFeeUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newBurnFee""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.6978445395583136,0.1071886377325893,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CarbonDollar is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public burnFee;

    event BurnFeeUpdated(uint256 newBurnFee);

    constructor() Ownable(msg.sender) {
        burnFee = 1; // Set to a non-zero, safe value
    }

    function setBurnFee(uint256 newBurnFee) public onlyOwner {
        burnFee = newBurnFee;
        emit BurnFeeUpdated(newBurnFee);
    }
}"
3332,"Gets all the open data orders , that is all the DataOrders that are still receiving new DataResponses .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OpenOrdersWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address userAddress;
        uint256 amount;
    }

    mapping(uint256 => Order) public orders;
    uint256 public orderCount;

    function getOpenOrders() public view returns (address[] memory) {
        address[] memory openOrders = new address[](orderCount);
        for (uint256 i = 0; i < orderCount; i++) {
            openOrders[i] = orders[i].userAddress;
        }
        return openOrders;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DataOrders is Ownable {

    using SafeMath for uint256;

    enum OrderStatus { OPEN, CLOSED }

    struct DataOrder {
        uint256 id;
        OrderStatus status;
        uint256 responses;
    }

    DataOrder[] public dataOrders;
    mapping(uint256 => DataOrder) public dataOrderById;

    function getAllOpenDataOrders() public view returns(DataOrder[] memory) {
        uint256 count = 0;
        for(uint256 i = 0; i < dataOrders.length; i++) {
            if(dataOrders[i].status == OrderStatus.OPEN) {
                count = count.add(1);
            }
        }

        DataOrder[] memory openDataOrders = new DataOrder[](count);

        uint256 j = 0;
        for(uint256 i = 0; i < dataOrders.length; i++) {
            if(dataOrders[i].status == OrderStatus.OPEN) {
                openDataOrders[j] = dataOrders[i];
                j = j.add(1);
            }
        }

        return openDataOrders;
    }
}",12.188898086547852,getAllOpenDataOrders,"[{'function': 'getAllOpenDataOrders', 'complexity': 6}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAllOpenDataOrders"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DataOrder""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""count"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dataOrders""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dataOrders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""OrderStatus""}, ""memberName"": ""OPEN""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""count""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""count""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": None}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DataOrder""}, ""length"": None}, ""name"": ""openDataOrders"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DataOrder""}, ""length"": None}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""count""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dataOrders""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dataOrders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""OrderStatus""}, ""memberName"": ""OPEN""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""openDataOrders""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dataOrders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""j""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""j""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""openDataOrders""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",37.0,0.832138622456224,0.1704045544199972,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DataOrders is Ownable {
    using SafeMath for uint256;

    enum OrderStatus { OPEN, CLOSED }

    struct DataOrder {
        uint256 id;
        OrderStatus status;
        uint256 responses;
    }

    DataOrder[] public dataOrders;
    mapping(uint256 => DataOrder) public dataOrderById;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        dataOrders = new DataOrder[](1);
        dataOrderById[0] = DataOrder(1, OrderStatus.OPEN, 0);

        // Set fixed values for uint/uint256
        dataOrders[0].id = 1;
        dataOrders[0].responses = 1;

        // Set fixed value for address
        dataOrders[0].status = 0x1111111111111111111111111111111111111111; // Replace with actual address

        // Set fixed value for bool
        dataOrderById[0].responses = true;

        // Set fixed value for string
        dataOrderById[0].id = 'initialized';

        // Set fixed value for bytes32
        dataOrders[0].status = bytes32('init');
    }

    function getAllOpenDataOrders() public view returns(DataOrder[] memory) {
        uint256 count = 0;
        for(uint256 i = 0; i < dataOrders.length; i++) {
            if(dataOrders[i].status == OrderStatus.OPEN) {
                count = count.add(1);
            }
        }

        DataOrder[] memory openDataOrders = new DataOrder[](count);

        uint256 j = 0;
        for(uint256 i = 0; i < dataOrders.length; i++) {
            if(dataOrders[i].status == OrderStatus.OPEN) {
                openDataOrders[j] = dataOrders[i];
                j = j.add(1);
            }
        }

        return openDataOrders;
    }
}"
2110,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public converterRamp;

    event SetConverterRamp(address oldConverterRamp, address newConverterRamp);

    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract LoanContract is Ownable {
    using SafeMath for uint256;

    address public converterRamp;

    function setConverterRamp(address _converterRamp) public onlyOwner {
        require(_converterRamp != address(0), ""LoanContract: converterRamp is the zero address"");
        converterRamp = _converterRamp;
    }
}",7.072098970413208,setConverterRamp,"[{'function': 'setConverterRamp', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_converterRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_converterRamp""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""LoanContract: converterRamp is the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""converterRamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""_converterRamp""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.8812782464913543,0.302221525161365,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract LoanContract is Ownable {
    using SafeMath for uint256;

    address public converterRamp = 0x1111111111111111111111111111111111111111; // fixed value
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setConverterRamp(address _converterRamp) public onlyOwner {
        require(_converterRamp != address(0), ""LoanContract: converterRamp is the zero address"");
        converterRamp = _converterRamp;
    }
}"
1438,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;
    mapping(bytes => bool) public signatures;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _token, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27 + uint8(_signature[64]), bytes32(_signature[:32]), bytes32(_signature[32:64]));
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender address is not provided"");
        require(signatures[_signature] == false, ""No Signature"");
        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0), ""From address is not provided"");
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        signatures[_signature] = true;
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenContract is IERC20, Ownable {
    mapping (address => mapping (address => uint256)) private _allowances;

    function increaseAllowance(address spender, uint256 addedValue) public onlyOwner returns (bool) {
        require(spender != address(0), ""Zero address not allowed"");
        _allowances[msg.sender][spender] += addedValue;
        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);
        return true;
    }
}",7.837945222854614,increaseAllowance,"[{'function': 'increaseAllowance', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""increaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""addedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Zero address not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""addedValue""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.6990580504296001,0.0366737257484418,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is IERC20, Ownable {
    mapping (address => mapping (address => uint256)) private _allowances;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function increaseAllowance(address spender, uint256 addedValue) public onlyOwner returns (bool) {
        require(spender != address(0), ""Zero address not allowed"");
        _allowances[msg.sender][spender] += addedValue;
        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);
        return true;
    }
}"
2532,Remove an address owned by a holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderManager is Ownable {
    using SafeMath for uint256;

    struct HoldersData {
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
        uint holderAddressCount;
    }

    mapping(bytes32 => uint) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    HoldersData[] public holders;

    event HolderAddressRemoved(bytes32 indexed externalHolderId, address indexed removedAddress, uint holderIndex);

    function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {
        uint _holderIndex = holderIndex[_externalHolderId];
        require(_holderIndex != 0);
        HoldersData storage _holderData = holders[_holderIndex];
        uint _tempIndex = _holderData.address2Index[_address];
        require(_tempIndex != 0);
        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];
        _holderData.address2Index[_lastAddress] = _tempIndex;
        _holderData.index2Address[_tempIndex] = _lastAddress;
        delete _holderData.address2Index[_address];
        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);
        delete holderAddress2Id[_address];
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
        return OK;
    }

    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _address, uint _holderIndex) internal {
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Holder is Ownable {

    mapping(address => bool) private holders;

    function removeHolder(address _holder) public onlyOwner {
        require(holders[_holder] == true, ""This address doesn't exist on holders list"");
        holders[_holder] = false;
    }
}",5.493140935897827,removeHolder,"[{'function': 'removeHolder', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeHolder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_holder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holder""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""stringLiteral"", ""value"": ""This address doesn""t exist on holders list""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holder""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",78.0,0.7521413768382649,0.0046867221313926,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Holder is Ownable {
    mapping(address => bool) private holders;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    bool public constant DEFAULT_BOOL = true;

    constructor() Ownable(Owner(msg.sender)) {
        holders[msg.sender] = DEFAULT_BOOL;
    }

    function removeHolder(address _holder) public onlyOwner {
        require(holders[_holder] == DEFAULT_BOOL, ""This address doesn't exist on holders list"");
        holders[_holder] = false;
    }
}"
339,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CardInterface {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
    }

    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        address owner = cardTokenToOwner[_tokenId];
        require(owner != address(0));
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

contract CardContract {
    using EnumerableSet for EnumerableSet.UintSet;

    struct Card {
        uint256 id;
        string name;
        string description;
        uint256 price;
    }

    // State variable
    mapping(uint256 => Card) private cards;
    EnumerableSet.UintSet private cardIds;

    function getCardDetails(uint256 cardId) public view returns (uint256, string memory, string memory, uint256) {
        // security check
        require(cardIds.contains(cardId), ""Card does not exist"");

        // retrieve card details
        Card storage card = cards[cardId];

        return (card.id, card.name, card.description, card.price);
    }
}",6.630311965942383,getCardDetails,"[{'function': 'getCardDetails', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCardDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""cardId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""cardIds""}, ""memberName"": ""contains""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cardId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Card does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""cardId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""id""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""description""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""price""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",28.0,0.6854223466105412,0.1493786734535869,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CardContract is Ownable {
    using EnumerableSet for EnumerableSet.UintSet;

    struct Card {
        uint256 id;
        string name;
        string description;
        uint256 price;
    }

    // State variable
    mapping(uint256 => Card) private cards;
    EnumerableSet.UintSet private cardIds;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            cards[i] = Card({
                id: i,
                name: 'CardName',
                description: 'Description',
                price: i * 100
            });
            cardIds.add(i);
        }
    }

    function getCardDetails(uint256 cardId) public view returns (uint256, string memory, string memory, uint256) {
        // security check
        require(cardIds.contains(cardId), ""Card does not exist"");

        // retrieve card details
        Card storage card = cards[cardId];

        return (card.id, card.name, card.description, card.price);
    }
}"
4993,"Reclaim an expired , non-empty swap into a multisig","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Multisig {
        address owner;
        address authority;
        uint deposit;
    }

    struct Swap {
        uint amount;
        uint expirationTime;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;
    mapping(bytes32 => Swap) public hashIdToSwap;

    function reclaimExpiredSwaps(bytes32 msigId, bytes32 swapId) public {
        require(hashIdToMultisig[msigId].owner == msg.sender || hashIdToMultisig[msigId].authority == msg.sender, ""Only the owner or authority of the multisig can reclaim expired swaps"");
        require(block.timestamp >= hashIdToSwap[swapId].expirationTime, ""The swap has not yet expired"");
        uint amount = hashIdToSwap[swapId].amount;
        assert(hashIdToMultisig[msigId].deposit.add(amount) >= hashIdToMultisig[msigId].deposit, ""Insufficient funds in the multisig to reclaim the swap"");
        delete hashIdToSwap[swapId];
        hashIdToMultisig[msigId].deposit = hashIdToMultisig[msigId].deposit.add(amount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract MultiSigSwap is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct Swap {
        address token;
        uint256 amount;
        uint256 expiryTimestamp;
        bool executed;
    }

    mapping(bytes32 => Swap) private swaps;
    mapping(address => mapping(address => uint256)) private balances;

    function reclaimExpiredSwap(
        bytes32 _swapId,
        address _recipient
    ) external nonReentrant {
        Swap storage swap = swaps[_swapId];

        require(block.timestamp >= swap.expiryTimestamp, ""Swap not yet expired"");
        require(swap.amount > 0, ""Swap empty"");
        require(!swap.executed, ""Swap already executed"");

        IERC20(swap.token).safeTransfer(_recipient, swap.amount);
        balances[_recipient][swap.token] += swap.amount;

        swap.executed = true;
    }
}",8.267988920211792,reclaimExpiredSwap,"[{'function': 'reclaimExpiredSwap', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimExpiredSwap"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_swapId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Swap""}, ""name"": ""swap"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""swaps""}, ""index"": {""type"": ""Identifier"", ""name"": ""_swapId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""expiryTimestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Swap not yet expired""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Swap empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""executed""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Swap already executed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""token""}], ""names"": []}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_recipient""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""token""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""executed""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.8211690739932036,0.1264115891788437,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiSigSwap is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct Swap {
        address token;
        uint256 amount;
        uint256 expiryTimestamp;
        bool executed;
    }

    mapping(bytes32 => Swap) private swaps;
    mapping(address => mapping(address => uint256)) private balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            if (i == 0) {
                address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
                // Use fixed values as per the requirement
                emit AddressEvent(addr);
            }
        }
    }

    function reclaimExpiredSwap(
        bytes32 _swapId,
        address _recipient
    ) external nonReentrant {
        Swap storage swap = swaps[_swapId];

        require(block.timestamp >= swap.expiryTimestamp, ""Swap not yet expired"");
        require(swap.amount > 0, ""Swap empty"");
        require(!swap.executed, ""Swap already executed"");

        IERC20(swap.token).safeTransfer(_recipient, swap.amount);
        balances[_recipient][swap.token] += swap.amount;

        swap.executed = true;
    }

    event AddressEvent(address indexed addr);
}"
5531,Revoke vote for transaction Can be called only by authorized user,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper {
    using SafeMath for uint256;

    function revoke(bytes32 _key) external returns (uint256) {
        return _revoke(_key, msg.sender);
    }

    function _revoke(bytes32 _key, address _account) internal virtual returns (uint256) {
        // Implementation of the revoke logic
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract MyContract is AccessControl {

    bytes32 public constant VOTER_ROLE = keccak256(""VOTER_ROLE"");
    mapping(uint => mapping(address => bool)) private _votes;

    constructor() {
        _setupRole(VOTER_ROLE, msg.sender);
    }

    function revokeVote(uint transactionId) public onlyRole(VOTER_ROLE) {
        require(_votes[transactionId][msg.sender] == true, ""No vote to revoke"");
        _votes[transactionId][msg.sender] = false;
    }
}",8.095261812210083,revokeVote,"[{'function': 'revokeVote', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""revokeVote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""transactionId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_votes""}, ""index"": {""type"": ""Identifier"", ""name"": ""transactionId""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""stringLiteral"", ""value"": ""No vote to revoke""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_votes""}, ""index"": {""type"": ""Identifier"", ""name"": ""transactionId""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""VOTER_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.5714254641351746,0.025867048785762,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is AccessControl, Ownable {

    bytes32 public constant VOTER_ROLE = keccak256(""VOTER_ROLE"");
    mapping(uint => mapping(address => bool)) private _votes;

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(VOTER_ROLE, msg.sender);
    }

    function revokeVote(uint transactionId) public onlyRole(VOTER_ROLE) {
        require(_votes[transactionId][msg.sender] == true, ""No vote to revoke"");
        _votes[transactionId][msg.sender] = false;
    }
}"
6063,A user has redeemed a top-up voucher for phone credit .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VoucherRedemption {
    using SafeMath for uint256;

    mapping(address => Order) public orderBook;

    struct Order {
        uint256 price;
    }

    event VoucherRedeemed(uint256 voucherCode, address indexed voucherOwner, address indexed tokenSeller, uint256 quantity);

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public payable onlyOwner {
        buy(tokenSeller, quantity, orderBook[tokenSeller].price);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }

    function buy(address tokenSeller, uint256 quantity, uint256 price) internal {
        // Implementation of the buy logic
    }

    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PhoneTopUp is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    event TopUpRedeemed(address indexed user, uint256 value);

    function redeemTopUp(address user, uint256 value) public onlyOwner {
        require(value > 0, ""Top-up value must be greater than 0"");
        require(user != address(0), ""Invalid user address"");

        balances[user] = balances[user].add(value);

        emit TopUpRedeemed(user, value);
    }

    function getBalance(address user) public view returns (uint256) {
        return balances[user];
    }
}",9.041668891906738,redeemTopUp,"[{'function': 'redeemTopUp', 'complexity': 2}, {'function': 'getBalance', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeemTopUp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Top-up value must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""user""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid user address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TopUpRedeemed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",26.0,0.5833322391446264,0.0419644948469144,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PhoneTopUp is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    event TopUpRedeemed(address indexed user, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        balances[msg.sender] = 1000;
    }

    function redeemTopUp(address user, uint256 value) public onlyOwner {
        require(value > 0, ""Top-up value must be greater than 0"");
        require(user != address(0), ""Invalid user address"");

        balances[user] = balances[user].add(value);

        emit TopUpRedeemed(user, value);
    }

    function getBalance(address user) public view returns (uint256) {
        return balances[user];
    }
}"
6774,"Move to ceiling , used as a failsafe","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public currentIndex = 0;

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex.add(1);
    }
}","// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Failsafe {
    using SafeMath for uint256;

    uint256 private _ceil;

    constructor(uint256 ceil) {
        require(ceil > 0, ""Ceil must be greater than 0"");
        _ceil = ceil;
    }

    function moveToCeiling(uint256 amount) public returns (uint256) {
        require(amount <= _ceil, ""Amount cannot exceed ceiling value"");

        // Do the necessary operations to move to ceiling
        uint256 balanceToMove = _ceil.sub(amount);

        // Performing operation (e.g., transferring tokens or ether) ... operation not implemented due to lack of context

        // Return the balance after moving to ceiling
        return _ceil;
    }
}",9.601582050323486,moveToCeiling,"[{'function': 'moveToCeiling', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""moveToCeiling"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_ceil""}}, {""type"": ""stringLiteral"", ""value"": ""Amount cannot exceed ceiling value""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceToMove"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_ceil""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""_ceil""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.6446581186896231,0.0093541550134913,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Failsafe is Ownable {
    using SafeMath for uint256;

    uint256 private _ceil = 1; // Set to 1 (never 0)

    constructor() Ownable(msg.sender) {
        // No additional initialization needed as state variables are already set correctly
    }

    function moveToCeiling(uint256 amount) public returns (uint256) {
        require(amount <= _ceil, ""Amount cannot exceed ceiling value"");

        // Do the necessary operations to move to ceiling
        uint256 balanceToMove = _ceil.sub(amount);

        // Performing operation (e.g., transferring tokens or ether) ... operation not implemented due to lack of context

        // Return the balance after moving to ceiling
        return _ceil;
    }
}"
1493,A function which allows only the owner to change the address of totlePrimary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    address public totlePrimary;

    function setTotle(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0x0));
        totlePrimary = _totlePrimary;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    address public totlePrimary;

    function changeTotlePrimary(address _newTotlePrimary) public onlyOwner {
        require(_newTotlePrimary != address(0), ""New address cannot be zero address."");
        totlePrimary = _newTotlePrimary;
    }
}",4.676691055297852,changeTotlePrimary,"[{'function': 'changeTotlePrimary', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeTotlePrimary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newTotlePrimary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newTotlePrimary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New address cannot be zero address.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totlePrimary""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newTotlePrimary""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.8197830751323776,0.2196153013796637,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public totlePrimary;
    bool public initialized = true;
    bytes32 public initBytes;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        totlePrimary = 0x1111111111111111111111111111111111111111; // Replace with actual primary address
        initialized = true;
        initBytes = bytes32('init');
    }

    function changeTotlePrimary(address _newTotlePrimary) public onlyOwner {
        require(_newTotlePrimary != address(0), ""New address cannot be zero address."");
        totlePrimary = _newTotlePrimary;
    }
}"
6875,Allow the token holder to upgrade some of their tokens to the new contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IUpgradeAgent {
    function upgradeFrom(address _from, uint256 _value) external;
}

abstract contract UpgradeableToken is Ownable {
    using SafeMath for uint256;

    enum UpgradeState { Unknown, NotAllowedToUpgrade, ReadyToUpgrade, Upgrading }

    mapping(address => uint256) public balances;
    uint256 public totalSupply_;
    uint256 public totalUpgraded;
    IUpgradeAgent public upgradeAgent;

    event Upgrade(address indexed _from, IUpgradeAgent indexed _agent, uint256 _value);

    function getUpgradeState() public view returns (UpgradeState) {
        if (!isAllowedToUpgrade()) return UpgradeState.NotAllowedToUpgrade;
        if (totalUpgraded == 0 && totalSupply_ > 0) return UpgradeState.ReadyToUpgrade;
        if (totalUpgraded > 0 && totalUpgraded < totalSupply_) return UpgradeState.Upgrading;
        return UpgradeState.Unknown;
    }

    function isAllowedToUpgrade() internal view returns (bool) {
        // Implement your logic to check if the caller is allowed to upgrade
        return true;
    }

    function upgrade(uint256 _value) public {
        require(getUpgradeState() == UpgradeState.ReadyToUpgrade || getUpgradeState() == UpgradeState.Upgrading, ""State must be correct for upgrade"");
        require(_value > 0, ""Upgrade value must be greater than zero"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        upgradeAgent.upgradeFrom(msg.sender, _value);
        emit Upgrade(msg.sender, upgradeAgent, _value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenUpgrade is Ownable {
    using SafeMath for uint256;

    IERC20 public oldToken;
    IERC20 public newToken;

    constructor(IERC20 _oldToken, IERC20 _newToken) {
        oldToken = _oldToken;
        newToken = _newToken;
    }

    function upgrade(uint256 amount) public {
        require(oldToken.balanceOf(msg.sender) >= amount, ""Insufficient token balance"");
        require(newToken.balanceOf(address(this)) >= amount, ""Insufficient new tokens in the contract"");

        oldToken.transferFrom(msg.sender, address(this), amount);
        newToken.transfer(msg.sender, amount);
    }
}",11.890204906463625,upgrade,"[{'function': 'upgrade', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""upgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""oldToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient new tokens in the contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""oldToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",41.0,0.6525195020942368,0.1481145982489473,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenUpgrade is Ownable {
    using SafeMath for uint256;

    IERC20 public oldToken;
    IERC20 public newToken;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _oldToken, IERC20 _newToken) Ownable(msg.sender) {
        oldToken = _oldToken;
        newToken = _newToken;
    }

    function upgrade(uint256 amount) public {
        require(oldToken.balanceOf(msg.sender) >= amount, ""Insufficient token balance"");
        require(newToken.balanceOf(address(this)) >= amount, ""Insufficient new tokens in the contract"");

        oldToken.transferFrom(msg.sender, address(this), amount);
        newToken.transfer(msg.sender, amount);
    }
}"
1111,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function invokeTop() public returns (uint) {
        return 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is ReentrancyGuard {
    using SafeMath for uint256;

    address payable public owner;
    uint256 public specifiedGasPrice;

    constructor(uint256 _specifiedGasPrice) {
        owner = payable(msg.sender);
        specifiedGasPrice = _specifiedGasPrice;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not an owner"");
        _;
    }

    function setSpecifiedGasPrice(uint256 _specifiedGasPrice) external onlyOwner {
        specifiedGasPrice = _specifiedGasPrice;
    }

    function withdrawIfGasPriceCovered(uint256 ethAmount) external nonReentrant returns (bool) {
        require(tx.gasprice <= specifiedGasPrice, ""Gas price is higher than specified"");

        (bool success, ) = owner.call{value: ethAmount}("""");
        require(success, ""Transfer failed"");

        return true;
    }
}",17.612853050231934,withdrawIfGasPriceCovered,"[{'function': 'setSpecifiedGasPrice', 'complexity': 0}, {'function': 'withdrawIfGasPriceCovered', 'complexity': 2}]",5.0,{},7.0,0.288031397521003,0.0124095873109109,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    address payable public owner;
    uint256 public specifiedGasPrice;

    constructor(uint256 _specifiedGasPrice) {
        owner = payable(msg.sender);
        specifiedGasPrice = _specifiedGasPrice;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not an owner"");
        _;
    }

    function setSpecifiedGasPrice(uint256 _specifiedGasPrice) external onlyOwner {
        specifiedGasPrice = _specifiedGasPrice;
    }

    function withdrawIfGasPriceCovered(uint256 ethAmount) external nonReentrant returns (bool) {
        require(tx.gasprice <= specifiedGasPrice, ""Gas price is higher than specified"");

        (bool success, ) = owner.call{value: ethAmount}("""");
        require(success, ""Transfer failed"");

        return true;
    }
}"
312,Obtain the index of the next schedule entry that will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface VestingEntry {
    function getVestingTime(address account, uint index) external view returns (uint);
    function numVestingEntries(address account) external view returns (uint);
}

abstract contract VestingWrapper is Ownable, VestingEntry {
    using SafeMath for uint;

    function getNextVestingIndex(address account) public view override returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract VestingSchedule {
    using SafeMath for uint256;

    struct ScheduleEntry {
        uint256 amount;
        uint256 unlockTime;
    }

    mapping(address => ScheduleEntry[]) private _vestingSchedules;

    function nextVestingIndex(address user) public view returns (uint256) {
        require(user != address(0), ""Zero address is not valid"");

        ScheduleEntry[] storage entries = _vestingSchedules[user];

        for(uint256 i = 0; i < entries.length; i++) {
            if(block.timestamp < entries[i].unlockTime) {
                return i;
            }
        }

        return entries.length;
    }
}",6.213496208190918,nextVestingIndex,"[{'function': 'nextVestingIndex', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""nextVestingIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""user""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Zero address is not valid""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ScheduleEntry""}, ""length"": None}, ""name"": ""entries"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_vestingSchedules""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""entries""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""entries""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""unlockTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""i""}]}, ""FalseBody"": None}]}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""entries""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",19.0,0.7606165542888363,0.2896430435743327,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract VestingSchedule is Ownable {
    using SafeMath for uint256;

    struct ScheduleEntry {
        uint256 amount;
        uint256 unlockTime;
    }

    mapping(address => ScheduleEntry[]) private _vestingSchedules;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function nextVestingIndex(address user) public view returns (uint256) {
        require(user != address(0), ""Zero address is not valid"");

        ScheduleEntry[] storage entries = _vestingSchedules[user];

        for(uint256 i = 0; i < entries.length; i++) {
            if(block.timestamp < entries[i].unlockTime) {
                return i;
            }
        }

        return entries.length;
    }
}"
3060,Transfers tokens held by timelock to all beneficiaries .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

struct TokenTimeLockVault {
    uint releaseTime;
    uint amount;
    uint arrayIndex;
}

event UnlockEvent(address indexed beneficiary);

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address[] public lockIndexes;
    mapping(address => TokenTimeLockVault) public tokenLocks;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function releaseAll(uint from, uint to) external onlyOwner returns (bool) {
        require(from >= 0);
        require(to <= lockIndexes.length);
        for (uint i = from; i < to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary == address(0)) {
                continue;
            }
            TokenTimeLockVault memory lock = tokenLocks[beneficiary];
            if (!(block.timestamp >= lock.releaseTime && lock.amount > 0)) {
                continue;
            }
            delete tokenLocks[beneficiary];
            lockIndexes[lock.arrayIndex] = address(0);
            emit UnlockEvent(beneficiary);
            require(token.transfer(beneficiary, lock.amount));
        }
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TimelockedTokenDistributor {
    using SafeMath for uint256;

    struct Beneficiary {
        address recipient;
        uint256 share;
    }

    IERC20 public tokenInstance;
    Beneficiary[] public beneficiaries;
    uint256 public totalShares;

    constructor(IERC20 _tokenInstance) {
        tokenInstance = _tokenInstance;
    }

    function addBeneficiary(address _recipient, uint256 _share) public {
        require(_share > 0, ""Shares must be greater than zero"");
        totalShares = totalShares.add(_share);
        beneficiaries.push(Beneficiary({recipient: _recipient, share: _share}));
    }

    function distributeTokens() public {
        uint256 tokenBalance = tokenInstance.balanceOf(address(this));
        require(tokenBalance > 0, ""No tokens to distribute"");

        for (uint256 i = 0; i < beneficiaries.length; i++) {
            uint256 beneficiaryShare = tokenBalance.mul(beneficiaries[i].share).div(totalShares);
            require(tokenInstance.transfer(beneficiaries[i].recipient, beneficiaryShare), ""Token transfer failed"");
        }
    }
}",9.998124122619627,distributeTokens,"[{'function': 'addBeneficiary', 'complexity': 1}, {'function': 'distributeTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_share"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_share""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Shares must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalShares""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalShares""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_share""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Beneficiary""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""Identifier"", ""name"": ""_share""}], ""names"": [""recipient"", ""share""]}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",73.0,0.5155994328443405,0.1012304579825579,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TimelockedTokenDistributor is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        address recipient;
        uint256 share;
    }

    IERC20 public tokenInstance;
    Beneficiary[] public beneficiaries;
    uint256 public totalShares;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _tokenInstance) Ownable(msg.sender) {
        tokenInstance = _tokenInstance;
        // Initialize state variables with safe, non-corner-case values
        totalShares = 1; // Set to 1 (never 0)
    }

    function addBeneficiary(address _recipient, uint256 _share) public {
        require(_share > 0, ""Shares must be greater than zero"");
        totalShares = totalShares.add(_share);
        beneficiaries.push(Beneficiary({recipient: _recipient, share: _share}));
    }

    function distributeTokens() public {
        uint256 tokenBalance = tokenInstance.balanceOf(address(this));
        require(tokenBalance > 0, ""No tokens to distribute"");

        for (uint256 i = 0; i < beneficiaries.length; i++) {
            uint256 beneficiaryShare = tokenBalance.mul(beneficiaries[i].share).div(totalShares);
            require(tokenInstance.transfer(beneficiaries[i].recipient, beneficiaryShare), ""Token transfer failed"");
        }
    }
}"
6528,Returns total amount of commission that has been already paid ( added to pending withdrawals ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasFeeHistory is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] commissionCumulative;
        uint32 paidCommissionIndex;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getCommissionWithdrawn(uint32 _canvasId) external view returns (uint) {
        require(_canvasId < canvases.length);
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint _index = _history.paidCommissionIndex;
        return _history.commissionCumulative[_index];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CommissionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private commissionsPaid;

    function getTotalCommissionPaid(address beneficiary) public view returns (uint256) {
        require(beneficiary != address(0), ""CommissionContract: beneficiary is the zero address"");
        return commissionsPaid[beneficiary];
    }

    function _payCommission(address beneficiary, uint256 amount) internal {
        commissionsPaid[beneficiary] = commissionsPaid[beneficiary].add(amount);
    }
}",8.736895084381104,getTotalCommissionPaid,"[{'function': 'getTotalCommissionPaid', 'complexity': 1}, {'function': '_payCommission', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalCommissionPaid"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""CommissionContract: beneficiary is the zero address""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""commissionsPaid""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",16.0,0.6153322736537479,0.1226659433055874,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CommissionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private commissionsPaid;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTotalCommissionPaid(address beneficiary) public view returns (uint256) {
        require(beneficiary != address(0), ""CommissionContract: beneficiary is the zero address"");
        return commissionsPaid[beneficiary];
    }

    function _payCommission(address beneficiary, uint256 amount) internal {
        commissionsPaid[beneficiary] = commissionsPaid[beneficiary].add(amount);
    }
}"
1094,finds total amount of neumarks issued for given amount of Euro,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CumulativeWrapper {
    using SafeMath for uint256;

    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 1e27; // Example value, replace with actual limit if known
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 0.8e27; // Example value, replace with actual limit if known
    uint256 constant NEUMARK_CAP = 1e24; // Example value, replace with actual cap if known
    uint256 constant TOT_LINEAR_NEUMARKS_ULPS = 0.1e27; // Example value, replace with actual total if known
    uint256 constant TOT_LINEAR_EUR_ULPS = 0.2e27; // Example value, replace with actual total if known
    uint256 constant NEUMARKS_AT_LINEAR_LIMIT_ULPS = 0.09e27; // Example value, replace with actual limit if known

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        }
        if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            return NEUMARKS_AT_LINEAR_LIMIT_ULPS.add((TOT_LINEAR_NEUMARKS_ULPS * (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS)) / TOT_LINEAR_EUR_ULPS);
        }
        uint256 d = 230769230769230769230769231;
        uint256 term = NEUMARK_CAP;
        uint256 sum = 0;
        uint256 denom = d;
        do {
            term = term.mul(euroUlps).div(denom);
            sum = sum.add(term);
            denom = denom.add(d);
            term = term.mul(euroUlps).div(denom);
            sum = sum.sub(term);
            denom = denom.add(d);
        } while (term != 0);
        return sum;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract NeumarkIssuance {
    using SafeMath for uint256;

    address public contractOwner;
    uint256 public totalEuro;
    uint256 public totalNeumarks;

    modifier onlyOwner() {
        require(msg.sender == contractOwner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        contractOwner = msg.sender;
    }

    function findTotalNeumarks(uint256 euroAmount) public view onlyOwner returns(uint256) {
        require(euroAmount > 0, ""Euro amount should be greater than 0"");
        require(totalEuro > 0, ""Total euro should be more than 0"");
        return totalNeumarks.mul(euroAmount).div(totalEuro);
    }

    function updateTotalNeumarksAndEuroAmount(uint256 neumarks, uint256 euro) public onlyOwner {
        totalNeumarks = neumarks;
        totalEuro = euro;
    }
}",8.64623498916626,findTotalNeumarks,"[{'function': 'findTotalNeumarks', 'complexity': 2}, {'function': 'updateTotalNeumarksAndEuroAmount', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""findTotalNeumarks"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""euroAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""euroAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Euro amount should be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""totalEuro""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Total euro should be more than 0""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalNeumarks""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""euroAmount""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalEuro""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",66.0,0.6862033907268437,0.0167111153795412,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract NeumarkIssuance is Ownable {
    using SafeMath for uint256;

    address public contractOwner;
    uint256 public totalEuro;
    uint256 public totalNeumarks;

    modifier onlyOwner() {
        require(msg.sender == contractOwner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        contractOwner = msg.sender;
        totalEuro = 1;
        totalNeumarks = 1;
    }

    function findTotalNeumarks(uint256 euroAmount) public view onlyOwner returns(uint256) {
        require(euroAmount > 0, ""Euro amount should be greater than 0"");
        require(totalEuro > 0, ""Total euro should be more than 0"");
        return totalNeumarks.mul(euroAmount).div(totalEuro);
    }

    function updateTotalNeumarksAndEuroAmount(uint256 neumarks, uint256 euro) public onlyOwner {
        totalNeumarks = neumarks;
        totalEuro = euro;
    }
}"
2019,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled = true;

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal returns (bool) {
        // Your transfer logic here
        require(balanceOf(from) >= amount, ""Insufficient balance"");
        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    mapping(address => uint256) public balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TokenContract is ERC20 {
    constructor(uint256 initialSupply) ERC20(""TokenName"", ""TKN"") {
        _mint(msg.sender, initialSupply);
    }

    function transferFromSender(address _to, uint256 _amount) public {
        require(_to != address(0), ""ERC20: transfer to the zero address"");
        require(_amount <= balanceOf(msg.sender), ""ERC20: transfer amount exceeds balance"");
        _transfer(msg.sender, _to, _amount);
    }
}",7.127763986587524,transferFromSender,"[{'function': 'transferFromSender', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFromSender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.7857064667591831,0.0364307485280525,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is ERC20, Ownable {
    mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply) ERC20(""TokenName"", ""TKN"") Ownable(msg.sender) {
        _mint(msg.sender, initialSupply);
    }

    function transferFromSender(address _to, uint256 _amount) public {
        require(_to != address(0), ""ERC20: transfer to the zero address"");
        require(_amount <= balanceOf(msg.sender), ""ERC20: transfer amount exceeds balance"");
        _transfer(msg.sender, _to, _amount);
    }
}"
5946,"Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function acceptOwnership() public override onlyNewOwnerCandidate {
        address oldOwner = owner();
        _transferOwnership(newOwnerCandidate);
        newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, owner());
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    address public newOwnerCandidate;

    modifier onlyNewOwnerCandidate() {
        require(msg.sender == newOwnerCandidate, ""Caller is not the new owner candidate"");
        _;
    }

    function proposeNewOwner(address _newOwnerCandidate) public onlyOwner {
        newOwnerCandidate = _newOwnerCandidate;
    }

    function acceptOwnership() public onlyNewOwnerCandidate {
        transferOwnership(newOwnerCandidate);
    }
}",7.086581945419312,proposeNewOwner,"[{'function': 'proposeNewOwner', 'complexity': 0}, {'function': 'acceptOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""proposeNewOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOwnerCandidate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOwnerCandidate""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.750667626999328,0.0083177738724296,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public newOwnerCandidate;

    modifier onlyNewOwnerCandidate() {
        require(msg.sender == newOwnerCandidate, ""Caller is not the new owner candidate"");
        _;
    }

    function proposeNewOwner(address _newOwnerCandidate) public onlyOwner {
        newOwnerCandidate = _newOwnerCandidate;
    }

    function acceptOwnership() public onlyNewOwnerCandidate {
        transferOwnership(newOwnerCandidate);
    }
}"
4342,The owner will call this method to extract the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

interface Crowdsale {
    function finalizedTime() external view returns (uint256);
}

abstract contract TokenCollector is Ownable {
    using SafeMath for uint256;

    MiniMeToken public miniMeToken;
    Crowdsale public crowdsale;
    uint256 public collectedTokens;

    event TokensWithdrawn(address indexed to, uint256 amount);

    constructor(address _miniMeToken, address _crowdsale) {
        miniMeToken = MiniMeToken(_miniMeToken);
        crowdsale = Crowdsale(_crowdsale);
    }

    function collectTokens() public onlyOwner {
        uint256 balance = miniMeToken.balanceOf(address(this));
        uint256 total = collectedTokens.add(balance);
        uint256 finalizedTime = crowdsale.finalizedTime();
        require(finalizedTime > 0 && getTime() > finalizedTime.add(1 days));
        uint256 canExtract = 0;
        if (getTime() <= finalizedTime.add(months(3))) {
            require(collectedTokens < total.percent(40));
            canExtract = total.percent(40);
        } else if (getTime() > finalizedTime.add(months(3)) && getTime() <= finalizedTime.add(months(6))) {
            require(collectedTokens < total.percent(60));
            canExtract = total.percent(60);
        } else if (getTime() > finalizedTime.add(months(6)) && getTime() <= finalizedTime.add(months(9))) {
            require(collectedTokens < total.percent(80));
            canExtract = total.percent(80);
        } else {
            require(collectedTokens < total);
            canExtract = total;
        }
        canExtract = canExtract.sub(collectedTokens);
        if (canExtract > balance) {
            canExtract = balance;
        }
        collectedTokens = collectedTokens.add(canExtract);
        miniMeToken.transfer(owner, canExtract);
        emit TokensWithdrawn(owner, canExtract);
    }

    function getTime() internal view virtual returns (uint256) {
        // Implement your time retrieval logic here
        return block.timestamp;
    }

    function months(uint256 monthsToAdd) internal pure returns (uint256) {
        return monthsToAdd * 30 days;
    }
}","X-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TokenExtractor is Ownable {
    using SafeERC20 for ERC20;

    function extractTokens(address _tokenAddress, uint256 _amount) external onlyOwner {
        require(_tokenAddress != address(0), ""TokenExtractor: invalid token address"");
        require(_amount > 0, ""TokenExtractor: amount must be greater than zero"");

        // Safe ERC20 transfer function to transfer tokens from contract to owner
        ERC20(_tokenAddress).safeTransfer(owner(), _amount);
    }
}",11.721078157424929,extractTokens,"[{'function': 'extractTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""extractTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""TokenExtractor: invalid token address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""TokenExtractor: amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAddress""}], ""names"": []}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",116.0,0.6289221872570804,0.0091826704076676,"X-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenExtractor is Ownable, ERC20 {
    using SafeERC20 for ERC20;

    constructor() Ownable(msg.sender) ERC20(""MyToken"", ""TKN"") {
        // Initialization of state variables with fixed, safe, non-corner-case values
        uint256 initialAmount = 1; // Set to 1 (never 0)
        address ownerAddress = address(uint160(uint256(keccak256('a')))); // Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        bool initialized = true; // Set to true
        string memory tokenName = 'initialized'; // Set to 'initialized'
        bytes32 initBytes = bytes32('init'); // Set to bytes32('init')
    }

    function extractTokens(address _tokenAddress, uint256 _amount) external onlyOwner {
        require(_tokenAddress != address(0), ""TokenExtractor: invalid token address"");
        require(_amount > 0, ""TokenExtractor: amount must be greater than zero"");

        // Safe ERC20 transfer function to transfer tokens from contract to owner
        ERC20(_tokenAddress).safeTransfer(owner(), _amount);
    }
}"
1358,Internal - Checks if the entered ticker is registered and has not expired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TickerRegistry {
    using SafeMath for uint256;

    struct TickerDetails {
        string name;
        uint256 expiryTimestamp;
    }

    mapping(string => TickerDetails) private tickers;

    function tickerIsActive(string memory _ticker) internal view returns (bool) {
        TickerDetails storage tickerDetails = tickers[_ticker];

        // Return true if ticker exists and has not expired
        return (bytes(tickerDetails.name).length > 0) &&
                (tickerDetails.expiryTimestamp > block.timestamp || tickerDetails.expiryTimestamp == 0);
    }
}",8.25565791130066,tickerIsActive,"[{'function': 'tickerIsActive', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""tickerIsActive"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TickerDetails""}, ""name"": ""tickerDetails"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}}, {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tickerDetails""}, ""memberName"": ""name""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tickerDetails""}, ""memberName"": ""expiryTimestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tickerDetails""}, ""memberName"": ""expiryTimestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""isArray"": False}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",36.0,0.2446678879309724,0.041031543649413,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TickerRegistry is Ownable {
    using SafeMath for uint256;

    struct TickerDetails {
        string name;
        uint256 expiryTimestamp;
    }

    mapping(string => TickerDetails) private tickers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function tickerIsActive(string memory _ticker) internal view returns (bool) {
        TickerDetails storage tickerDetails = tickers[_ticker];

        // Return true if ticker exists and has not expired
        return (bytes(tickerDetails.name).length > 0) &&
                (tickerDetails.expiryTimestamp > block.timestamp || tickerDetails.expiryTimestamp == 0);
    }
}"
5732,Withdraws deposited tokens on behalf of users Allowed only for oracle,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public token;
    mapping(bytes32 => uint) public user2lastPeriodParticipated;
    uint public periodsCount;
    struct Period {
        uint startDate;
    }
    mapping(uint => Period) public periods;
    event TreasuryWithdrawn(bytes32 indexed _userKey, uint _amount);
    uint constant OK = 0;

    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOwner returns (uint) {
        require(_userKey != bytes32(0));
        require(_value != 0);
        require(_feeAmount < _value);
        _makeWithdrawForPeriod(_userKey, _value);
        uint _periodsCount = periodsCount;
        user2lastPeriodParticipated[_userKey] = periodsCount;
        delete periods[periodsCount].startDate;
        IERC20 _token = IERC20(token);
        if (!(_feeAddress == address(0) || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {
            revert();
        }
        uint _withdrawnAmount = _value.sub(_feeAmount);
        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {
            revert();
        }
        emit TreasuryWithdrawn(_userKey, _withdrawnAmount);
        return OK;
    }

    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {
        // Implementation of the internal function
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract Oracle is Ownable {
    IERC20 private _token;

    constructor(IERC20 token) {
        _token = token;
    }

    function withdrawTokens(address user, uint256 amount) public onlyOwner {
        uint256 balance = _token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient token balance"");
        _token.transfer(user, amount);
    }
}",8.898429870605469,withdrawTokens,"[{'function': 'withdrawTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",82.0,0.7205405271107496,0.0173298423862895,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Oracle is Ownable {
    IERC20 private _token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 token) Ownable(msg.sender) {
        _token = token;
    }

    function withdrawTokens(address user, uint256 amount) public onlyOwner {
        uint256 balance = _token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient token balance"");
        _token.transfer(user, amount);
    }
}"
5527,"Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint128 amount;
        uint128 totalClaimed;
        uint16 vestingCliff;
        uint16 vestingDuration;
        uint16 monthsClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    uint256 constant SECONDS_PER_MONTH = 2628000; // Approximately 30 days * 86400 seconds per day

    function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {
        Grant storage tokenGrant = tokenGrants[_recipient];

        if (block.timestamp < tokenGrant.startTime) {
            return (0, 0);
        }

        uint256 elapsedTime = block.timestamp.sub(tokenGrant.startTime);
        uint256 elapsedMonths = elapsedTime / SECONDS_PER_MONTH;

        if (elapsedMonths < tokenGrant.vestingCliff) {
            return (0, 0);
        }

        if (elapsedMonths >= tokenGrant.vestingDuration) {
            uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;
            return (uint16(tokenGrant.vestingDuration), remainingGrant);
        } else {
            uint16 monthsVested = uint16(elapsedMonths.sub(tokenGrant.monthsClaimed));
            uint256 amountVestedPerMonth = tokenGrant.amount / uint256(tokenGrant.vestingDuration);
            uint128 amountVested = uint128(monthsVested * amountVestedPerMonth);
            return (monthsVested, amountVested);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenVesting {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint256 amount;
        uint256 vestingDuration;
        uint256 monthsClaimed;
        uint256 totalClaimed;
    }

    mapping (address => Grant) private _grants;

    uint256 private constant _SECONDS_IN_A_MONTH = 30 days;

    function calculateVesting(address _recipient) public view returns (uint256, uint256) {
        Grant storage grant = _grants[_recipient];

        if (block.timestamp < grant.startTime) {
            return (0, 0);
        }

        uint256 elapsedTime = block.timestamp.sub(grant.startTime);
        uint256 elapsedMonths = elapsedTime.div(_SECONDS_IN_A_MONTH);

        if (elapsedMonths < grant.vestingDuration) {
            uint256 vestedAmount = grant.amount.mul(elapsedMonths).div(grant.vestingDuration);
            uint256 claimableAmount = vestedAmount.sub(grant.totalClaimed);
            return (elapsedMonths, claimableAmount);
        } else {
            uint256 claimableAmount = grant.amount.sub(grant.totalClaimed);
            return (grant.vestingDuration, claimableAmount);
        }
    }
}",11.995476007461548,calculateVesting,"[{'function': 'calculateVesting', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateVesting"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""grant"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_grants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_recipient""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""startTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""startTime""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedMonths"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""elapsedTime""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_SECONDS_IN_A_MONTH""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingDuration""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""vestedAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""elapsedMonths""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingDuration""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""claimableAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""vestedAmount""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalClaimed""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""elapsedMonths""}, {""type"": ""Identifier"", ""name"": ""claimableAmount""}], ""isArray"": False}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""claimableAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalClaimed""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingDuration""}, {""type"": ""Identifier"", ""name"": ""claimableAmount""}], ""isArray"": False}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",28.0,0.8488929911985472,0.3366398667051823,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenVesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint256 amount;
        uint256 vestingDuration;
        uint256 monthsClaimed;
        uint256 totalClaimed;
    }

    mapping (address => Grant) private _grants;

    uint256 private constant _SECONDS_IN_A_MONTH = 30 days;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        _SECONDS_IN_A_MONTH = 30 days;
    }

    function calculateVesting(address _recipient) public view returns (uint256, uint256) {
        Grant storage grant = _grants[_recipient];

        if (block.timestamp < grant.startTime) {
            return (0, 0);
        }

        uint256 elapsedTime = block.timestamp.sub(grant.startTime);
        uint256 elapsedMonths = elapsedTime.div(_SECONDS_IN_A_MONTH);

        if (elapsedMonths < grant.vestingDuration) {
            uint256 vestedAmount = grant.amount.mul(elapsedMonths).div(grant.vestingDuration);
            uint256 claimableAmount = vestedAmount.sub(grant.totalClaimed);
            return (elapsedMonths, claimableAmount);
        } else {
            uint256 claimableAmount = grant.amount.sub(grant.totalClaimed);
            return (grant.vestingDuration, claimableAmount);
        }
    }
}"
1662,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
    AccountValueLocalVars memory localResults;
    localResults.sumSupplies = Exp({mantissa: 0});
    localResults.sumBorrows = Exp({mantissa: 0});
    Error err;
    localResults.collateralMarketsLength = collateralMarkets.length;
    for (uint i = 0; i < localResults.collateralMarketsLength; i++) {
        localResults.assetAddress = collateralMarkets[i];
        Market storage currentMarket = markets[localResults.assetAddress];
        Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];
        Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];
        if (supplyBalance.principal > 0) {
            (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
        if (borrowBalance.principal > 0) {
            (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
    }
    return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);
}

}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract UserEthBalance {
    using SafeMath for uint256;


    mapping(address => uint256) private accumulatedSupplies;
    mapping(address => uint256) private borrowedAmounts;

    function getUserETHBalances(address user) public view returns (uint256, uint256) {
        uint256 accumulatedSupply = accumulatedSupplies[user].mul(1e18);
        uint256 borrowedAmount = borrowedAmounts[user].mul(1e18);

        return (accumulatedSupply, borrowedAmount);
    }
}",9.747547149658203,getUserETHBalances,"[{'function': 'getUserETHBalances', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getUserETHBalances"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""accumulatedSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accumulatedSupplies""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""borrowedAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""borrowedAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""accumulatedSupply""}, {""type"": ""Identifier"", ""name"": ""borrowedAmount""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",81.0,0.6022355428682846,1.821609031527996e-05,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract UserEthBalance is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private accumulatedSupplies;
    mapping(address => uint256) private borrowedAmounts;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            accumulatedSupplies[addr] = 1;
            borrowedAmounts[addr] = 1;
        }
    }

    function getUserETHBalances(address user) public view returns (uint256, uint256) {
        require(user != address(0), ""Invalid user address"");
        uint256 accumulatedSupply = accumulatedSupplies[user].mul(1e18);
        uint256 borrowedAmount = borrowedAmounts[user].mul(1e18);

        return (accumulatedSupply, borrowedAmount);
    }
}"
6249,Set the threshold for a payment to be sent directly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public directPaymentThreshold;

    constructor(uint256 initialThreshold) {
        directPaymentThreshold = initialThreshold;
    }

    function setDirectPaymentThreshold(uint256 threshold) external onlyCFO {
        directPaymentThreshold = threshold;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PaymentGateway is ReentrancyGuard, Ownable {
    uint256 public paymentThreshold;

    event ThresholdUpdated(uint256 newThreshold);

    function setPaymentThreshold(uint256 _newThreshold) public onlyOwner nonReentrant {
        require(_newThreshold > 0, ""PaymentGateway: threshold must be greater than zero"");

        paymentThreshold = _newThreshold;

        emit ThresholdUpdated(_newThreshold);
    }
}",5.637686014175415,setPaymentThreshold,"[{'function': 'setPaymentThreshold', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPaymentThreshold"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newThreshold"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_newThreshold""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""PaymentGateway: threshold must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paymentThreshold""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newThreshold""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ThresholdUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newThreshold""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.7728057781757013,0.0154234541316238,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentGateway is ReentrancyGuard, Ownable {
    uint256 public paymentThreshold;

    event ThresholdUpdated(uint256 newThreshold);

    constructor() Ownable(msg.sender) {
        paymentThreshold = 1; // Set to a non-zero value for safety
    }

    function setPaymentThreshold(uint256 _newThreshold) public onlyOwner nonReentrant {
        require(_newThreshold > 0, ""PaymentGateway: threshold must be greater than zero"");

        paymentThreshold = _newThreshold;

        emit ThresholdUpdated(_newThreshold);
    }
}"
153,A getter to find if a specified Project has been canceled,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PledgeAdminType {
    enum Type { Giver, Project }
}

struct PledgeAdmin {
    uint64 parentProject;
    bool canceled;
    PledgeAdminType.Type adminType;
}

abstract contract ProjectCancelChecker is Ownable {
    using SafeMath for uint256;

    mapping(uint64 => PledgeAdmin) public pledgeAdmins;

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin storage) {
        require(projectId != 0, ""Invalid project ID"");
        return pledgeAdmins[projectId];
    }

    function isProjectCanceled(uint64 projectId) public view returns (bool) {
        PledgeAdmin storage m = findAdmin(projectId);
        if (m.adminType == PledgeAdminType.Type.Giver) return false;
        require(m.adminType == PledgeAdminType.Type.Project, ""Invalid admin type"");
        if (m.canceled) return true;
        if (m.parentProject == 0) return false;
        return isProjectCanceled(m.parentProject);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Project {
    using SafeMath for uint256;

    struct ProjectStruct {
        bool isCancelled;
        address projectAddress;
    }

    mapping(address => ProjectStruct) public projects;

    function isProjectCancelled(address _projectAddress) public view returns(bool) {
        ProjectStruct memory project = projects[_projectAddress];
        return project.isCancelled;
    }
}",19.65876817703247,isProjectCancelled,"[{'function': 'isProjectCancelled', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isProjectCancelled"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_projectAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ProjectStruct""}, ""name"": ""project"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""projects""}, ""index"": {""type"": ""Identifier"", ""name"": ""_projectAddress""}}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""project""}, ""memberName"": ""isCancelled""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",28.0,0.7203246967601572,0.0527003547256113,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Project is Ownable {
    using SafeMath for uint256;

    struct ProjectStruct {
        bool isCancelled;
        address projectAddress;
    }

    mapping(address => ProjectStruct) public projects;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            projects[addr] = ProjectStruct({isCancelled: false, projectAddress: addr});
        }
    }

    function isProjectCancelled(address _projectAddress) public view returns (bool) {
        ProjectStruct memory project = projects[_projectAddress];
        return project.isCancelled;
    }
}"
223,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ICard {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
        uint256 price;
        uint256 nextprice;
        string imagepath;
        string category;
        uint256 IsWildCard;
        address owner;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    mapping(uint256 => uint256) public cardTokenToPrice;
    Card[] public cards;

    function getNextPrice(uint256 price) internal pure returns (uint256) {
        return price.mul(110).div(100); // Increase by 10%
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner) {
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
        price = getNextPrice(cardTokenToPrice[_tokenId]);
        nextprice = getNextPrice(price);
        imagepath = card.imagepath;
        category = card.category;
        wildcard = card.IsWildCard;
        _owner = card.owner;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract CardContract {
    using SafeMath for uint256;

    struct Card {
        uint256 id;
        string name;
        uint256 power;
        uint256 health;
    }

    mapping(uint256 => Card) private cards;

    function getCardDetails(uint256 _cardId) public view returns (uint256, string memory, uint256, uint256) {
        require(_cardId >= 1, ""Invalid card id"");
        require(cards[_cardId].id == _cardId, ""Card does not exist"");

        Card memory card = cards[_cardId];

        return (card.id, card.name, card.power, card.health);
    }
}",9.88517689704895,getCardDetails,"[{'function': 'getCardDetails', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCardDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_cardId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_cardId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid card id""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""_cardId""}}, ""memberName"": ""id""}, ""right"": {""type"": ""Identifier"", ""name"": ""_cardId""}}, {""type"": ""stringLiteral"", ""value"": ""Card does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""_cardId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""id""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""power""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""health""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",53.0,0.672771763012355,0.0937660161951037,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract CardContract is Ownable {
    using SafeMath for uint256;

    struct Card {
        uint256 id;
        string name;
        uint256 power;
        uint256 health;
    }

    mapping(uint256 => Card) private cards;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            cards[i] = Card({
                id: i,
                name: ""CardName"",
                power: 100,
                health: 100
            });
        }
    }

    function getCardDetails(uint256 _cardId) public view returns (uint256, string memory, uint256, uint256) {
        require(_cardId >= 1 && _cardId <= 3, ""Invalid card id"");
        require(cards[_cardId].id == _cardId, ""Card does not exist"");

        Card memory card = cards[_cardId];

        return (card.id, card.name, card.power, card.health);
    }
}"
1195,"The owner can clawback any unspent Parsec credits after a date in the future , so no Parsec credits remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IParsecToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether;
    uint256 public constant OWNER_CLAWBACK_DATE = block.timestamp + 30 days; // Example date, adjust as needed

    bool public creditsClawbacked;
    IParsecToken public parsecToken;
    address public owner;
    uint256 public totalFunding;

    function ownerClawbackCredits() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        require(!creditsClawbacked);
        creditsClawbacked = true;
        parsecToken.transfer(owner, parsecToken.balanceOf(address(this)));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyContract is Ownable {
    ERC20 public parsecToken;
    uint256 public clawbackDate;

    constructor(ERC20 _parsecToken, uint256 _clawbackDate) {
        parsecToken = _parsecToken;
        clawbackDate = _clawbackDate;
    }

    function clawback() public onlyOwner {
        require(block.timestamp > clawbackDate, ""Clawback not allowed until clawbackDate"");

        uint256 balance = parsecToken.balanceOf(address(this));
        require(balance > 0, ""No Parsec credits remaining in contract"");

        parsecToken.transfer(msg.sender, balance);
    }
}",11.721617221832275,clawback,"[{'function': 'clawback', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""clawback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""clawbackDate""}}, {""type"": ""stringLiteral"", ""value"": ""Clawback not allowed until clawbackDate""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""parsecToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No Parsec credits remaining in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""parsecToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.8288333407651519,0.274104506280549,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    ERC20 public parsecToken;
    uint256 public clawbackDate;

    mapping(address => uint256) public balanceOf;

 constructor(ERC20 _parsecToken, uint256 _clawbackDate) Ownable() {
        parsecToken = _parsecToken;
        clawbackDate = _clawbackDate;
    }

    function clawback() public onlyOwner {
        require(block.timestamp > clawbackDate, ""Clawback not allowed until clawbackDate"");

        uint256 balance = parsecToken.balanceOf(address(this));
        require(balance > 0, ""No Parsec credits remaining in contract"");

        parsecToken.transfer(msg.sender, balance);
    }
}"
3570,Pauses the whitelist if there is any issue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    using SafeMath for uint256;

    bool public paused = false;
    event Paused(address indexed account, uint256 timestamp);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Not the contract owner"");
        _;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Whitelist is Pausable, Ownable {
    mapping (address => bool) public whitelist;

    function addAddress(address _addr) public onlyOwner {
        whitelist[_addr] = true;
    }

    function removeAddress(address _addr) public onlyOwner {
        whitelist[_addr] = false;
    }

    function pauseWhitelist() public onlyOwner {
        _pause();
    }

    function unpauseWhitelist() public onlyOwner {
        _unpause();
    }
}",6.855107069015503,addAddress,"[{'function': 'addAddress', 'complexity': 0}, {'function': 'removeAddress', 'complexity': 0}, {'function': 'pauseWhitelist', 'complexity': 0}, {'function': 'unpauseWhitelist', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.456886131844695,0.0242960837239474,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Whitelist is Pausable, Ownable {
    mapping (address => bool) public whitelist;

    constructor() {
        _transferOwnership(msg.sender); // Initialize ownership to the deployer
    }

    function addAddress(address _addr) public onlyOwner {
        whitelist[_addr] = true;
    }

    function removeAddress(address _addr) public onlyOwner {
        whitelist[_addr] = false;
    }

    function pauseWhitelist() public onlyOwner {
        _pause();
    }

    function unpauseWhitelist() public onlyOwner {
        _unpause();
    }
}"
5480,Allows transfer token ownership back to distribution contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token; // Address of the token contract

    constructor(address _token) {
        token = _token;
    }

    function reclaimTokenOwnership() public onlyOwner {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        IERC20(token).claimOwnership();
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenContract is ERC20, Ownable {
    address public distributionContract;

    constructor(address _distributionContract) ERC20(""TokenName"", ""TOKENSYMBOL"") {
        distributionContract = _distributionContract;
    }

    function transferTokenOwnershipBack() public onlyOwner {
        require(distributionContract != address(0), ""Distribution contract address cannot be 0"");
        transferOwnership(distributionContract);
    }
}",12.40534281730652,transferTokenOwnershipBack,"[{'function': 'transferTokenOwnershipBack', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokenOwnershipBack"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""distributionContract""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Distribution contract address cannot be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferOwnership""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""distributionContract""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",5.0,0.6710666002808295,0.2539366176008952,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is ERC20, Ownable {
    address public distributionContract;

    constructor(address _distributionContract) ERC20(""TokenName"", ""TOKENSYMBOL"") Ownable(msg.sender) {
        require(_distributionContract != address(0), ""Distribution contract address cannot be 0"");
        distributionContract = _distributionContract;
    }

    function transferTokenOwnershipBack() public onlyOwner {
        require(distributionContract != address(0), ""Distribution contract address cannot be 0"");
        transferOwnership(distributionContract);
    }
}"
3477,"Returns the loan metadata , this field can be set by the creator of the loan with his own criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataWrapper {
    using SafeMath for uint256;

    struct Loan {
        string metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadata(uint256 index) public view returns (string memory) {
        return loans[index].metadata;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract LoanContract is Ownable {

    struct Loan {
        uint256 amount;
        uint256 rate;
        uint256 duration;
        string metadata;
    }

    mapping(address => Loan) public loans;

    function setLoanMetadata(address loanHolder, string calldata metadata) public onlyOwner {
        Loan storage loan = loans[loanHolder];
        loan.metadata = metadata;
    }

    function getLoanMetadata(address loanHolder) public view returns (string memory) {
        return loans[loanHolder].metadata;
    }
}",16.07934808731079,setLoanMetadata,"[{'function': 'setLoanMetadata', 'complexity': 0}, {'function': 'getLoanMetadata', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setLoanMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""loanHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""metadata"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Loan""}, ""name"": ""loan"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""loanHolder""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""metadata""}, ""right"": {""type"": ""Identifier"", ""name"": ""metadata""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.584040727077989,0.025128589800333,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoanContract is Ownable {

    struct Loan {
        uint256 amount;
        uint256 rate;
        uint256 duration;
        string metadata;
    }

    mapping(address => Loan) public loans;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            loans[addr] = Loan({
                amount: uint256(i) * 1 ether, // Safe non-zero value
                rate: 5, // Fixed safe interest rate
                duration: 365 days, // Safe non-zero duration
                metadata: ""initialized"" // Safe initialized string
            });
        }
    }

    function setLoanMetadata(address loanHolder, string calldata metadata) public onlyOwner {
        Loan storage loan = loans[loanHolder];
        loan.metadata = metadata;
    }

    function getLoanMetadata(address loanHolder) public view returns (string memory) {
        return loans[loanHolder].metadata;
    }
}"
1259,Claims the ownership of a given token ID,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyNFT is ERC721, Ownable {
    using Address for address;

    function claimTokenOwnership(uint256 tokenId) public virtual {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        require(!_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: approve to caller"");
        _mint(_msgSender(), tokenId);
    }
}",6.2816081047058105,claimTokenOwnership,"[{'function': 'claimTokenOwnership', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokenOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""ERC721: operator query for nonexistent token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isApprovedOrOwner""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""ERC721: approve to caller""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",12.0,0.6981648456258646,0.0461936890039421,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyNFT is ERC721, Ownable {
    using Address for address;

    constructor() ERC721(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialization of state variables:
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function claimTokenOwnership(uint256 tokenId) public virtual {
        require(_exists(tokenId), ""ERC721: operator query for nonexistent token"");
        require(!_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: approve to caller"");
        _mint(_msgSender(), tokenId);
    }
}"
6427,We do n't make this function constant to allow for state-updating access controls such as rate limiting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AccessControl {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => bool)) private roles;
    mapping(address => mapping(bytes4 => bool)) private permissions;

    function hasRole(address subject, bytes32 role) public view returns (bool) {
        return roles[subject][role];
    }

    function hasPermission(address object, bytes4 verb) public view returns (bool) {
        return permissions[object][verb];
    }

    function allowed(address subject, bytes32 role, address object, bytes4 verb) public returns (bool) {
        require(subject != address(0), ""Subject cannot be zero address"");
        require(role != bytes32(0), ""Role cannot be empty"");
        require(object != address(0), ""Object cannot be zero address"");
        require(verb != bytes4(0), ""Verb cannot be empty"");

        if (hasRole(subject, role)) {
            return true;
        }

        if (hasPermission(object, verb)) {
            return true;
        }

        return false;
    }
}","// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is ReentrancyGuard, Ownable {
    uint private constant MAX_CALL_FREQUENCY = 10 minutes;
    mapping (address => uint) private lastCalledAt;

    modifier notTooFrequent() {
        require(lastCalledAt[msg.sender] + MAX_CALL_FREQUENCY < block.timestamp, ""Call too frequent"");
        _;
        lastCalledAt[msg.sender] = block.timestamp;
    }

    function accessControlledFunction() external notTooFrequent onlyOwner nonReentrant {
        // Function implementation goes here
    }
}",5.680763244628906,accessControlledFunction,"[{'function': 'accessControlledFunction', 'complexity': 0}]",1.0,{},61.0,0.3595970636238592,3.072337191668378e-05,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ReentrancyGuard, Ownable {
    uint private constant MAX_CALL_FREQUENCY = 10 minutes;
    mapping (address => uint) private lastCalledAt;

    constructor() ReentrancyGuard(1) Ownable(msg.sender) {
        // Initialize instance variables with fixed values
        lastCalledAt[msg.sender] = block.timestamp;
    }

    modifier notTooFrequent() {
        require(lastCalledAt[msg.sender] + MAX_CALL_FREQUENCY < block.timestamp, ""Call too frequent"");
        _;
        lastCalledAt[msg.sender] = block.timestamp;
    }

    function accessControlledFunction() external notTooFrequent onlyOwner nonReentrant {
        // Function implementation goes here
    }
}"
5406,Returns all rewards charged for the given canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeeHistory {
    function rewardsCumulative(uint256 index) external view returns (uint256);
}

abstract contract CanvasRewards is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint256[] rewardsCumulative;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getTotalRewards(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Invalid canvas ID"");
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint256 _lastIndex = _history.rewardsCumulative.length - 1;
        if (_lastIndex < 0) {
            return 0;
        }
        return _history.rewardsCumulative[_lastIndex];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ArtworkRewards is Ownable {
    using SafeMath for uint256;

    struct Canvas {
        uint256 id;
        uint256 totalRewards;
    }

    mapping (uint256 => Canvas) public canvases;
    mapping (address => uint256) public rewards;

    function getRewards(uint256 _canvasId) public view onlyOwner returns (uint256){
        Canvas storage canvas = canvases[_canvasId];
        require(canvas.id == _canvasId, ""Canvas does not exist"");
        return canvas.totalRewards;
    }

    function chargeRewards(uint256 _canvasId, uint256 _rewards) external onlyOwner {
        Canvas storage canvas = canvases[_canvasId];
        require(canvas.id == _canvasId, ""Canvas does not exist"");

        rewards[msg.sender] = rewards[msg.sender].sub(_rewards, ""Rewards to charge exceed available rewards"");
        canvas.totalRewards = canvas.totalRewards.add(_rewards);
    }
}",13.728914976119995,chargeRewards,"[{'function': 'getRewards', 'complexity': 1}, {'function': 'chargeRewards', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""chargeRewards"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_rewards"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Canvas""}, ""name"": ""canvas"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canvas""}, ""memberName"": ""id""}, ""right"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}, {""type"": ""stringLiteral"", ""value"": ""Canvas does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_rewards""}, {""type"": ""stringLiteral"", ""value"": ""Rewards to charge exceed available rewards""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canvas""}, ""memberName"": ""totalRewards""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canvas""}, ""memberName"": ""totalRewards""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_rewards""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.7392526212696862,0.019790309326849,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ArtworkRewards is Ownable {
    using SafeMath for uint256;

    struct Canvas {
        uint256 id;
        uint256 totalRewards;
    }

    mapping (uint256 => Canvas) public canvases;
    mapping (address => uint256) public rewards;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getRewards(uint256 _canvasId) public view onlyOwner returns (uint256){
        Canvas storage canvas = canvases[_canvasId];
        require(canvas.id == _canvasId, ""Canvas does not exist"");
        return canvas.totalRewards;
    }

    function chargeRewards(uint256 _canvasId, uint256 _rewards) external onlyOwner {
        Canvas storage canvas = canvases[_canvasId];
        require(canvas.id == _canvasId, ""Canvas does not exist"");

        rewards[msg.sender] = rewards[msg.sender].sub(_rewards, ""Rewards to charge exceed available rewards"");
        canvas.totalRewards = canvas.totalRewards.add(_rewards);
    }
}"
6503,The reward is calculated by the formula : ( numberOfBlocks ) ( effectiveBlockReward ) ( commitment.value ) / ( effectiveStake ) effectiveBlockReward is the average between the block reward during commit and the block reward during the call effectiveStake is the average between the stake during the commit and the stake during call ( liniar aproximation ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IMinerContract {
    function miners(address) external view returns (Miner memory);
    function totalStake() external view returns (uint256);
    function blockReward_() external view returns (int256);
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;

    struct Miner {
        uint256 value;
        int256 onBlockReward;
        uint256 atStake;
        uint256 onBlockNumber;
    }

    mapping(address => Miner) public miners;
    uint256 public totalStake_;
    int256 public blockReward_;

    IMinerContract public minerContract;

    constructor(address _minerContractAddress) {
        minerContract = IMinerContract(_minerContractAddress);
    }

    function getReward(address _miner) public view returns (uint256) {
        if (minerContract.miners(_miner).value == 0) {
            return 0;
        }
        Miner memory commitment = minerContract.miners(_miner);
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number.sub(commitment.onBlockNumber);
        uint256 miningReward = numberOfBlocks.mul(effectiveBlockReward).mul(commitment.value).div(effectiveStake);
        return miningReward;
    }

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return int256((uint256(a) + uint256(b)) / 2);
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RewardCalculator {
    using SafeMath for uint256;

    uint256 public commitBlock;
    uint256 public commitBlockReward;
    uint256 public commitStake;
    uint256 public callBlock;
    uint256 public callBlockReward;
    uint256 public callStake;
    uint256 public commitmentValue;

    function calculateReward(
        uint256 _numberOfBlocks,
        uint256 _commitBlockReward,
        uint256 _commitStake,
        uint256 _callBlockReward,
        uint256 _callStake,
        uint256 _commitmentValue
    ) public view returns (uint256 reward) {

        // effectiveBlockReward calculation
        uint256 effectiveBlockReward = _commitBlockReward.add(_callBlockReward).div(2);

        // effectiveStake calculation
        uint256 effectiveStake = _commitStake.add(_callStake).div(2);

        // reward calculation
        reward = _numberOfBlocks.mul(effectiveBlockReward).mul(_commitmentValue).div(effectiveStake);

        return reward;
    }
}",10.62723708152771,calculateReward,"[{'function': 'calculateReward', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_numberOfBlocks"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_commitBlockReward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_commitStake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_callBlockReward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_callStake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_commitmentValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveBlockReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_commitBlockReward""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_callBlockReward""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveStake"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_commitStake""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_callStake""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""reward""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_numberOfBlocks""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""effectiveBlockReward""}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_commitmentValue""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""effectiveStake""}], ""names"": []}}}, {""type"": ""Identifier"", ""name"": ""reward""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",51.0,0.6963465114009496,0.1911875354977861,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.7.3/contracts/ownership/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RewardCalculator is Ownable {
    using SafeMath for uint256;

    uint256 public commitBlock;
    uint256 public commitBlockReward;
    uint256 public commitStake;
    uint256 public callBlock;
    uint256 public callBlockReward;
    uint256 public callStake;
    uint256 public commitmentValue;

    constructor() Ownable(msg.sender) {
        commitBlock = 1; // Set to a fixed value
        commitBlockReward = 1000; // Set to a fixed value
        commitStake = 500; // Set to a fixed value
        callBlock = 2; // Set to a fixed value
        callBlockReward = 2000; // Set to a fixed value
        callStake = 750; // Set to a fixed value
        commitmentValue = 1500; // Set to a fixed value
    }

    function calculateReward(
        uint256 _numberOfBlocks,
        uint256 _commitBlockReward,
        uint256 _commitStake,
        uint256 _callBlockReward,
        uint256 _callStake,
        uint256 _commitmentValue
    ) public view returns (uint256 reward) {

        // effectiveBlockReward calculation
        uint256 effectiveBlockReward = _commitBlockReward.add(_callBlockReward).div(2);

        // effectiveStake calculation
        uint256 effectiveStake = _commitStake.add(_callStake).div(2);

        // reward calculation
        reward = _numberOfBlocks.mul(effectiveBlockReward).mul(_commitmentValue).div(effectiveStake);

        return reward;
    }
}"
2533,Function to process cases when person send more than 10 ETH to smartcontract but never provided KYC data and wants/needs to be refunded .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RefundContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonWLBalanceOf;

    function refundNonWhitelistedPerson(address _address) public onlyOwner {
        require(_address != address(0), ""Invalid address"");
        uint256 refundAmount = nonWLBalanceOf[_address];
        require(refundAmount > 0, ""No balance to refund"");
        nonWLBalanceOf[_address] = nonWLBalanceOf[_address].sub(refundAmount);
        _address.transfer(refundAmount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract EthRefund is Ownable, Pausable {
    using SafeMath for uint256;

    mapping(address => uint256) public deposits;
    mapping(address => bool) public isKycVerified;

    function deposit() public payable whenNotPaused {
        require(msg.value >= 10 ether, ""Minimum deposit: 10 Ether"");
        deposits[msg.sender] = deposits[msg.sender].add(msg.value);
    }

    function verifyKyc(address user) public onlyOwner whenNotPaused {
        isKycVerified[user] = true;
    }

    function refund() public whenNotPaused {
        require(deposits[msg.sender] > 0, ""No deposit to refund"");
        require(!isKycVerified[msg.sender], ""User is KYC verified"");

        uint256 refundAmount = deposits[msg.sender];
        deposits[msg.sender] = 0;
        payable(msg.sender).transfer(refundAmount);
    }

    function withdraw() public onlyOwner whenNotPaused {
        require(isKycVerified[msg.sender], ""Owner is not KYC verified"");
        uint256 withdrawalAmount = address(this).balance;
        payable(msg.sender).transfer(withdrawalAmount);
    }

    // To pause/unpause contract in case of emergency
    function toggleContractActive() public onlyOwner {
        paused() ? _unpause() : _pause();
    }

    receive() external payable {
        deposit();
    }
}",13.517534971237184,refund,"[{'function': 'deposit', 'complexity': 1}, {'function': 'verifyKyc', 'complexity': 0}, {'function': 'refund', 'complexity': 4}, {'function': 'withdraw', 'complexity': 1}, {'function': 'toggleContractActive', 'complexity': 1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""refund"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No deposit to refund""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isKycVerified""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""User is KYC verified""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refundAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refundAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",30.0,0.6776757884707744,0.2793288171443681,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract EthRefund is Ownable, Pausable {
    using SafeMath for uint256;

    mapping(address => uint256) public deposits;
    mapping(address => bool) public isKycVerified;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function deposit() public payable whenNotPaused {
        require(msg.value >= 10 ether, ""Minimum deposit: 10 Ether"");
        deposits[msg.sender] = deposits[msg.sender].add(msg.value);
    }

    function verifyKyc(address user) public onlyOwner whenNotPaused {
        isKycVerified[user] = true;
    }

    function refund() public whenNotPaused {
        require(deposits[msg.sender] > 0, ""No deposit to refund"");
        require(!isKycVerified[msg.sender], ""User is KYC verified"");

        uint256 refundAmount = deposits[msg.sender];
        deposits[msg.sender] = 0;
        payable(msg.sender).transfer(refundAmount);
    }

    function withdraw() public onlyOwner whenNotPaused {
        require(isKycVerified[msg.sender], ""Owner is not KYC verified"");
        uint256 withdrawalAmount = address(this).balance;
        payable(msg.sender).transfer(withdrawalAmount);
    }

    // To pause/unpause contract in case of emergency
    function toggleContractActive() public onlyOwner {
        paused() ? _unpause() : _pause();
    }

    receive() external payable {
        deposit();
    }
}"
5759,Check ` _value ` tokens allowed to ` _spender ` by ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;
    mapping(address => mapping(address => uint256)) public approved;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return approved[_owner][_spender];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 private _token;

    constructor(IERC20 token) {
        _token = token;
    }

    function checkAllowance(address _owner, address _spender) public view returns (uint256) {
        return _token.allowance(_owner, _spender);
    }
}",7.110150098800659,checkAllowance,"[{'function': 'checkAllowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",3.0,0.8341358988661762,0.5181212746323438,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 private _token;

    constructor(IERC20 token) Ownable(msg.sender) {
        _token = token;
    }

    function checkAllowance(address _owner, address _spender) public view returns (uint256) {
        return _token.allowance(_owner, _spender);
    }
}"
4344,shuts the CDP and returns all the value in the form of Dai .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IFeed {
    function read() external view returns (bytes32);
}

interface ITub {
    function tab(bytes32 id) external view returns (uint256 debt);
    function ink(bytes32 id) external view returns (uint256 ink);
    function shut(bytes32 id) external;
    function bid(uint256 amount) external view returns (uint256 bought);
    function exit(uint256 amount) external;
}

interface IOTC {
    function sellAllAmount(address gem, uint256 amount, address pay, uint256 minPrice) external returns (uint256 bought);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public dai;
    ITub public tub;
    IFeed public feed;
    IOTC public otc;
    IERC20 public gem;
    uint256 public slippage;
    uint256 public WAD = 10**18;

    constructor(address _dai, address _tub, address _feed, address _otc, address _gem, uint256 _slippage) {
        dai = IERC20(_dai);
        tub = ITub(_tub);
        feed = IFeed(_feed);
        otc = IOTC(_otc);
        gem = IERC20(_gem);
        slippage = _slippage;
    }

    function shutForDai(uint _id) public onlyOwner {
        bytes32 id = bytes32(_id);
        uint debt = tub.tab(id);
        if (debt > 0) {
            require(dai.transferFrom(msg.sender, address(this), debt));
        }
        uint ink = tub.ink(id);
        tub.shut(id);
        uint gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint price = uint(feed.read());
        uint bought = otc.sellAllAmount(address(gem), min(gemBalance, gem.balanceOf(address(this))), address(dai), wmul(WAD - slippage, wmul(gemBalance, price)));
        require(dai.transfer(msg.sender, bought));
    }

    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = x * y / WAD;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@makerdao/dss/contracts/JoinLike.sol"";
import ""@makerdao/dss/contracts/DaiJoin.sol"";
import ""@makerdao/dss/contracts/Fabric.sol"";

contract CDPManager is ReentrancyGuard {
    DaiJoin public daiJoin;
    Fabric public fabric;
    IERC20 public daiToken;

    constructor(address _daiJoin, address _fabric, address _daiToken) {
        daiJoin = DaiJoin(_daiJoin);
        fabric = Fabric(_fabric);
        daiToken = IERC20(_daiToken);
    }

    function shutCDP(uint cdpid) external nonReentrant {
        address urn = fabric.urns(cdpid);
        require(urn != address(0), ""Invalid CDP ID"");

        (uint ink, uint art) = fabric.urns(cdpid);
        fabric.frob(cdpid, -int(ink), -int(art));
        fabric.flux(cdpid, msg.sender, ink);

        uint dai = daiJoin.dai(address(this));
        daiJoin.exit(msg.sender, dai);

        require(daiToken.transfer(msg.sender, dai), ""Transfer failed"");
    }
}",11.35359001159668,shutCDP,"[{'function': 'shutCDP', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""shutCDP"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""cdpid"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""urn"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""fabric""}, ""memberName"": ""urns""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cdpid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""urn""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid CDP ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""ink"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113107310>}, {""type"": ""VariableDeclaration"", ""name"": ""art"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113105780>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""fabric""}, ""memberName"": ""urns""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cdpid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""fabric""}, ""memberName"": ""frob""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cdpid""}, {""type"": ""UnaryOperation"", ""operator"": ""-"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""int""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ink""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""UnaryOperation"", ""operator"": ""-"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""int""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""art""}], ""names"": []}, ""isPrefix"": True}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""fabric""}, ""memberName"": ""flux""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cdpid""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""ink""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""dai"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""daiJoin""}, ""memberName"": ""dai""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""daiJoin""}, ""memberName"": ""exit""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""dai""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""daiToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""dai""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",55.0,0.6324377577977812,0.1427149273755968,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@makerdao/dss/contracts/JoinLike.sol"";
import ""@makerdao/dss/contracts/DaiJoin.sol"";
import ""@makerdao/dss/contracts/Fabric.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CDPManager is ReentrancyGuard, Ownable {
    DaiJoin public daiJoin;
    Fabric public fabric;
    IERC20 public daiToken;

    constructor(address _daiJoin, address _fabric, address _daiToken) Ownable(msg.sender) {
        daiJoin = DaiJoin(_daiJoin);
        fabric = Fabric(_fabric);
        daiToken = IERC20(_daiToken);
    }

    function shutCDP(uint cdpid) external nonReentrant {
        address urn = fabric.urns(cdpid);
        require(urn != address(0), ""Invalid CDP ID"");

        (uint ink, uint art) = fabric.urns(cdpid);
        fabric.frob(cdpid, -int(ink), -int(art));
        fabric.flux(cdpid, msg.sender, ink);

        uint dai = daiJoin.dai(address(this));
        daiJoin.exit(msg.sender, dai);

        require(daiToken.transfer(msg.sender, dai), ""Transfer failed"");
    }
}"
6386,Internal - Removes the owner of a ticker,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TickerContract {
    using SafeMath for uint256;

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        uint256 index = uint256(getUint(Encoder.getKey(""tickerIndex"", _ticker)));
        bytes32 ownerKey = Encoder.getKey(""userToTickers"", _owner);
        bytes32[] memory tickers = getArrayBytes32(ownerKey);
        assert(index < tickers.length);
        assert(_tickerOwner(_ticker) == _owner);
        deleteArrayBytes32(ownerKey, index);
        if (getArrayBytes32(ownerKey).length > index) {
            bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];
            set(Encoder.getKey(""tickerIndex"", Util.bytes32ToString(switchedTicker)), index);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TickerOwnerShip is Ownable {

    mapping (string => address) private _tickerOwners;

    function removeTickerOwner(string memory ticker) internal onlyOwner {
        address owner = _tickerOwners[ticker];
        require(owner != address(0), ""The ticker does not have an owner."");
        _tickerOwners[ticker] = address(0);
    }
}",7.739756107330322,removeTickerOwner,"[{'function': 'removeTickerOwner', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeTickerOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_tickerOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""ticker""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""The ticker does not have an owner.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_tickerOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""ticker""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""internal"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.8372598206564226,0.0090588814147378,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TickerOwnerShip is Ownable {
    // Fixed, safe values for uint
    uint256 public constant _INITIAL_TTK = 1;

    // Fixed, safe address values
    address public constant _INITIAL_TTK_OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    address public constant _INITIAL_TTK_ADMIN = 0x2222222222222222222222222222222222222222; // Replace with actual admin's address

    // Fixed, safe boolean value
    bool public constant _INITIALIZED = true;

    // Fixed, safe string values
    string public constant _INITIAL_TTK_NAME = 'initialized';
    bytes32 public constant _INITIAL_TTK_SYMBOL = bytes32('init');

    mapping (string => address) private _tickerOwners;

    constructor() Ownable(msg.sender) {
        _tickerOwners[msg.sender] = msg.sender;
    }

    function removeTickerOwner(string memory ticker) internal onlyOwner {
        address owner = _tickerOwners[ticker];
        require(owner != address(0), ""The ticker does not have an owner."");
        _tickerOwners[ticker] = address(0);
    }
}"
5781,Get the allowance of an specified address to use another address balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}","ur Solidity smart contract function that complies with the provided code summary:

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function getAllowance(address owner, address spender) public view returns (uint256) {
        return allowance(owner, spender);
    }
}",9.229368209838867,getAllowance,"[{'function': 'getAllowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.846234914025005,0.2981792160679168," ```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") Ownable(msg.sender) {
        _mint(msg.sender, initialSupply);
    }

    function getAllowance(address owner, address spender) public view returns (uint256) {
        return allowance(owner, spender);
    }
}
```"
5300,Last callback used to accept the ERC721 parcel tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ERC721Receiver {
    using SafeMath for uint256;

    address public land;
    uint256 public flagReceiveLand;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4) {
        if (msg.sender == land && flagReceiveLand == _tokenId) {
            flagReceiveLand = 0;
            return bytes4(0x150b7a02);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract ParcelManagement is ERC721, ReentrancyGuard {
    address private _owner;

    constructor() ERC721(""ParcelToken"", ""PT"") {
        _owner = msg.sender;
    }

    function safeAcceptParcel(uint256 tokenId, address from, address to) public nonReentrant {
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            ""ParcelManagement: transfer caller is not owner nor approved""
        );
        safeTransferFrom(from, to, tokenId);
    }
}",10.945430994033812,safeAcceptParcel,"[{'function': 'safeAcceptParcel', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeAcceptParcel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isApprovedOrOwner""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""ParcelManagement: transfer caller is not owner nor approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",19.0,0.5080910640411217,0.0335133791563611,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ParcelManagement is ERC721, ReentrancyGuard, Ownable {
    constructor() ERC721(""ParcelToken"", ""PT"") {
        _owner = msg.sender;
    }

    function safeAcceptParcel(uint256 tokenId, address from, address to) public nonReentrant {
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            ""ParcelManagement: transfer caller is not owner nor approved""
        );
        safeTransferFrom(from, to, tokenId);
    }
}"
6110,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external;
}

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PriceOracle is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private priceOfHavven;

    function updateHavvenPrice(address havvenAddress, uint256 newPrice) public onlyOwner {
        require(havvenAddress != address(0), ""Invalid havven address"");
        require(newPrice > 0, ""Price must be greater than 0"");

        priceOfHavven[havvenAddress] = newPrice;
    }
}",5.835631132125855,updateHavvenPrice,"[{'function': 'updateHavvenPrice', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateHavvenPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""havvenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""havvenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid havven address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""priceOfHavven""}, ""index"": {""type"": ""Identifier"", ""name"": ""havvenAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.6875573282668788,0.0245004895076854,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PriceOracle is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private priceOfHavven;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function updateHavvenPrice(address havvenAddress, uint256 newPrice) public onlyOwner {
        require(havvenAddress != address(0), ""Invalid havven address"");
        require(newPrice > 0, ""Price must be greater than 0"");

        priceOfHavven[havvenAddress] = newPrice;
    }
}"
1872,selfdestructs and sends the balance to ` escrowModerator ` or ` beneficiary `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Auction {
    function auctionState() external view returns (AuctionStates);
    function escrowModerator() external view returns (address);
    function beneficiary() external view returns (address);
}

abstract contract AuctionWrapper is Ownable, Auction {
    using SafeMath for uint256;

    enum AuctionStates { NotStarted, Active, Ended, Canceled }

    AuctionStates public auctionState;
    address public escrowModerator;
    address public beneficiary;

    function setAuctionState(AuctionStates state) external onlyOwner {
        auctionState = state;
    }

    function setEscrowModerator(address moderator) external onlyOwner {
        escrowModerator = moderator;
    }

    function setBeneficiary(address ben) external onlyOwner {
        beneficiary = ben;
    }

    function cleanUpAfterYourself() public {
        require(auctionState == AuctionStates.Ended, ""Auction is not ended."");
        if (escrowModerator != address(0)) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    address payable private escrowModerator;
    address payable private beneficiary;

    constructor(address payable _escrowModerator, address payable _beneficiary)  {
        escrowModerator = _escrowModerator;
        beneficiary = _beneficiary;
    }

    function terminate(bool sendToEscrow) public onlyOwner {
        if(sendToEscrow) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }
}",9.178575038909912,terminate,"[{'function': 'terminate', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""terminate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""sendToEscrow"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""sendToEscrow""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""escrowModerator""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.7552456570525021,0.3897562337301052,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address payable private escrowModerator;
    address payable private beneficiary;

    constructor(address payable _escrowModerator, address payable _beneficiary) Ownable(msg.sender) {
        escrowModerator = _escrowModerator;
        beneficiary = _beneficiary;
    }

    function terminate(bool sendToEscrow) public onlyOwner {
        if (sendToEscrow) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }
}"
4928,Sets the contract which implements a specific interface for an address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC820ImplementerInterface {
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns (bytes4);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bytes4 constant private ERC820_ACCEPT_MAGIC = 0xffffffff;
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address implementer);

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == 0 ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, ""Not the manager"");
        require(!isERC165Interface(_interfaceHash), ""Must not be a ERC165 hash"");
        if (_implementer != 0 && _implementer != msg.sender) {
            require(ERC820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_interfaceHash, addr) == ERC820_ACCEPT_MAGIC, ""Does not implement the interface"");
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address addr) internal view returns (address) {
        // Implement logic to retrieve the manager for the address
        return owner();
    }

    function isERC165Interface(bytes32 interfaceHash) internal pure returns (bool) {
        // Implement logic to check if the interface hash is an ERC165 hash
        return false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IInterfaceImplementation {
    function setImplementation(address newImplementation) external;
}

contract InterfaceManager {
    mapping(address => address) private _interfaceImplementations;

    function setInterfaceImplementation(address interfaceAddress, address implementationAddress) external {
        require(interfaceAddress != address(0), ""InterfaceManager: invalid interface address"");
        require(implementationAddress != address(0), ""InterfaceManager: invalid implementation address"");

        _interfaceImplementations[interfaceAddress] = implementationAddress;

        IInterfaceImplementation(implementationAddress).setImplementation(interfaceAddress);
    }
}",4.590245723724365,setInterfaceImplementation,"[{'function': 'setImplementation', 'complexity': 0}, {'function': 'setInterfaceImplementation', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInterfaceImplementation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""interfaceAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""implementationAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""interfaceAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""InterfaceManager: invalid interface address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""implementationAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""InterfaceManager: invalid implementation address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_interfaceImplementations""}, ""index"": {""type"": ""Identifier"", ""name"": ""interfaceAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""implementationAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IInterfaceImplementation""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""implementationAddress""}], ""names"": []}, ""memberName"": ""setImplementation""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""interfaceAddress""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.7866765619027449,0.0567484006869114,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IInterfaceImplementation {
    function setImplementation(address newImplementation) external;
}
import ""openzeppelin/SafeMath.sol"";
contract InterfaceManager is Ownable, IInterfaceImplementation {
    mapping(address => address) private _interfaceImplementations;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setInterfaceImplementation(address interfaceAddress, address implementationAddress) external override {
        require(interfaceAddress != address(0), ""InterfaceManager: invalid interface address"");
        require(implementationAddress != address(0), ""InterfaceManager: invalid implementation address"");

        _interfaceImplementations[interfaceAddress] = implementationAddress;

        IInterfaceImplementation(implementationAddress).setImplementation(interfaceAddress);
    }
}"
1268,"This creates a Pledge with an initial amount of 0 if one is not created already ; otherwise it finds the pledge with the specified attributes ; all pledges technically exist , if the pledge has n't been created in this system yet it simply is n't in the hash array hPledge2idx [ ] yet","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeManager is Ownable {
    using SafeMath for uint256;

    struct Pledge {
        uint256 amount;
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    enum PledgeState { Active, Canceled, Refunded }

    mapping(bytes32 => uint64) public hPledge2idx;
    Pledge[] public pledges;

    function findOrCreatePledge(uint64 owner, uint64[] memory delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint64) {
        bytes32 hPledge = keccak256(abi.encodePacked(owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        uint64 idx = hPledge2idx[hPledge];
        if (idx > 0) return idx;
        idx = uint64(pledges.length);
        hPledge2idx[hPledge] = idx;
        pledges.push(Pledge(0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        return idx;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


contract PledgeContract {

    struct Pledge {
        uint256 amount;
    }

    address owner;

    modifier onlyOwner {
        require(msg.sender == owner, ""Caller is not owner"");
        _;
    }

    mapping(bytes32 => Pledge) private hPledge2idx;

    constructor() {
        owner = msg.sender;
    }

    function createOrFindPledge(bytes32 _pledgeId) public onlyOwner {
        if (hPledge2idx[_pledgeId].amount == 0) {
            hPledge2idx[_pledgeId] = Pledge(0);
        }
    }

}",6.034900903701782,createOrFindPledge,"[{'function': 'createOrFindPledge', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createOrFindPledge"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_pledgeId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""_pledgeId""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""_pledgeId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Pledge""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",63.0,0.7321408894734359,0.0047461296362028,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PledgeContract is Ownable {
    struct Pledge {
        uint256 amount;
    }

    mapping(bytes32 => Pledge) private hPledge2idx;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
    }

    function createOrFindPledge(bytes32 _pledgeId) public onlyOwner {
        if (hPledge2idx[_pledgeId].amount == 0) {
            hPledge2idx[_pledgeId] = Pledge(0);
        }
    }
}"
6042,Returns all the relevant information about a specific library .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LibraryWrapper is Ownable {
    using SafeMath for uint256;

    struct Library {
        string name;
        string language;
        uint256 price;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    function getLibrary(uint256 _tokenId) public view returns (string memory language, string memory libraryName, uint256 tokenPrice, uint256 funds, address tokenOwner, address founder) {
        Library storage x = libraries[_tokenId];
        libraryName = x.name;
        language = x.language;
        founder = libraryIndexToFounder[_tokenId];
        funds = libraryIndexToFunds[_tokenId];
        tokenPrice = libraryIndexToPrice[_tokenId];
        tokenOwner = libraryIndexToOwner[_tokenId];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Library is Ownable {
    using SafeMath for uint256;

    struct LibraryInfo {
        string name;
        address location;
        uint256 booksCount;
    }

    mapping(address => LibraryInfo) private libraries;

    function setLibraryInfo(string calldata name, address libraryAddress, uint256 booksCount) external onlyOwner {
        libraries[libraryAddress] = LibraryInfo(name, libraryAddress, booksCount);
    }

    function getLibraryInfo(address libraryAddress) public view returns (string memory name, address location, uint256 booksCount) {
        LibraryInfo storage library = libraries[libraryAddress];
        return (library.name, library.location, library.booksCount);
    }
}",9.417455911636353,getLibraryInfo,"[{'function': 'setLibraryInfo', 'complexity': 0}, {'function': 'getLibraryInfo', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setLibraryInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""libraryAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""booksCount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraries""}, ""index"": {""type"": ""Identifier"", ""name"": ""libraryAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LibraryInfo""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""libraryAddress""}, {""type"": ""Identifier"", ""name"": ""booksCount""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",46.0,0.6779008251551011,0.1341439600294213,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Library is Ownable {
    using SafeMath for uint256;

    struct LibraryInfo {
        string name;
        address location;
        uint256 booksCount;
    }

    mapping(address => LibraryInfo) private libraries;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            libraries[addr] = LibraryInfo({
                name: ""initialized"",
                location: addr,
                booksCount: 1
            });
        }
    }

    function setLibraryInfo(string calldata name, address libraryAddress, uint256 booksCount) external onlyOwner {
        libraries[libraryAddress] = LibraryInfo(name, libraryAddress, booksCount);
    }

    function getLibraryInfo(address libraryAddress) public view returns (string memory name, address location, uint256 booksCount) {
        LibraryInfo storage library = libraries[libraryAddress];
        return (library.name, library.location, library.booksCount);
    }
}"
1213,Get the token balance for a specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint;

    mapping(address => uint) public balances;

 function balanceOf (address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; }


}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenBalance {
    IERC20 private _token;

    constructor(IERC20 token) {
        _token = token;
    }

    function getTokenBalance(address account) public view returns (uint256) {
        require(account != address(0), ""Invalid address"");
        return _token.balanceOf(account);
    }
}",5.250149726867676,getTokenBalance,"[{'function': 'getTokenBalance', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.772029374810245,0.1448218930239774,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenBalance is Ownable {
    IERC20 private _token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 token) Ownable(msg.sender) {
        require(address(token) != address(0), ""Invalid contract address"");
        _token = token;
    }

    function getTokenBalance(address account) public view returns (uint256) {
        require(account != address(0), ""Invalid address"");
        return _token.balanceOf(account);
    }
}"
6726,transfers tokens in ERC20 compatible way using signature to recover token sender,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    function transferWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig) public returns (bool) {
        doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
        return true;
    }

    function doSendWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig, bool) internal {
        // Implementation of the original function logic would go here.
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";

contract TokenTransfer {
    using ECDSA for bytes32;

    function transferTokens(
        IERC20 token,
        address to,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        public
    {
        bytes32 hash = keccak256(
            abi.encodePacked(
                address(this),
                token,
                to,
                value,
                deadline
            )
        );

        require(deadline >= block.timestamp, ""The transaction has been expired"");

        address signer = hash
            .toEthSignedMessageHash()
            .recover(v, r, s);

        require(signer != address(0), ""Invalid signature"");

        require(token.transferFrom(signer, to, value), ""Transfer failed"");
    }
}",11.343389749526978,transferTokens,"[{'function': 'transferTokens', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""deadline"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""token""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}, {""type"": ""Identifier"", ""name"": ""deadline""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""deadline""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""The transaction has been expired""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hash""}, ""memberName"": ""toEthSignedMessageHash""}, ""arguments"": [], ""names"": []}, ""memberName"": ""recover""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""signer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""signer""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",50.0,0.5472683228042926,0.0101189644738007,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    using ECDSA for bytes32;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(
        IERC20 token,
        address to,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        public
    {
        require(deadline >= block.timestamp, ""The transaction has been expired"");

        bytes32 hash = keccak256(
            abi.encodePacked(
                address(this),
                token,
                to,
                value,
                deadline
            )
        );

        address signer = hash
            .toEthSignedMessageHash()
            .recover(v, r, s);

        require(signer != address(0), ""Invalid signature"");

        require(token.transferFrom(signer, to, value), ""Transfer failed"");
    }
}"
6123,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract TokenRecipient is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        if (!approve(_spender, _amount)) throw;
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract SampleContract {
    using SafeERC20 for IERC20;

    mapping (address => mapping (address => uint256)) private _allowances;

    function approve(address _spender, uint256 _amount) public returns (bool) {
        _approve(msg.sender, _spender, _amount);
        return true;
    }

    function _approve(address _owner, address _spender, uint256 _amount) internal {
        require(_owner != address(0), ""ERC20: approve from the zero address"");
        require(_spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
    }
}",7.257364988327026,_approve,"[{'function': 'approve', 'complexity': 0}, {'function': '_approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""_approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: approve to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.719195758162127,0.1399517890391329,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SampleContract is Ownable {
    using SafeERC20 for IERC20;

    mapping (address => mapping (address => uint256)) private _allowances;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        _allowances[msg.sender][address(0)] = 1; // uint: Set to 1
        _allowances[address(0)][msg.sender] = 1; // uint: Set to 1

        // Use fixed values for address and bytes32
        _allowances[msg.sender][address(0x1111111111111111111111111111111111111111)] = 1;
        _allowances[address(0x1111111111111111111111111111111111111111)][msg.sender] = 1;

        // Initialize bool, string, and bytes32 variables
        _allowances[msg.sender][address(0x2222222222222222222222222222222222222222)] = true; // bool: Set to true
        _allowances[address(0x2222222222222222222222222222222222222222)][msg.sender] = true;
        _allowances[msg.sender][bytes32('init')] = 1; // bytes32: Set to 'init'

        // Initialize ERC20 token (using placeholder value)
        IERC20(""MyToken"").mint(msg.sender, 1);
    }

    function approve(address _spender, uint256 _amount) public returns (bool) {
        _approve(msg.sender, _spender, _amount);
        return true;
    }

    function _approve(address _owner, address _spender, uint256 _amount) internal {
        require(_owner != address(0), ""ERC20: approve from the zero address"");
        require(_spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
    }
}"
240,Used to check if an address is a delegate or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function checkDelegate(address _potentialDelegate) external view returns (bool) {
        // Implementation of the checkDelegate function
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract DelegationCheck is AccessControl {
    bytes32 public constant DELEGATE_ROLE = keccak256(""DELEGATE_ROLE"");

    function isDelegate(address delegateAddress) public view returns (bool) {
        require(delegateAddress != address(0), ""Zero address not allowed"");
        return hasRole(DELEGATE_ROLE, delegateAddress);
    }
}",5.44245982170105,isDelegate,"[{'function': 'isDelegate', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isDelegate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""delegateAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""delegateAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Zero address not allowed""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DELEGATE_ROLE""}, {""type"": ""Identifier"", ""name"": ""delegateAddress""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",21.0,0.7544401182592245,0.1495094000786379,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DelegationCheck is AccessControl, Ownable {
    bytes32 public constant DELEGATE_ROLE = keccak256(""DELEGATE_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(DELEGATE_ROLE, DEFAULT_ADMIN_ROLE);
    }

    function isDelegate(address delegateAddress) public view returns (bool) {
        require(delegateAddress != address(0), ""Zero address not allowed"");
        return hasRole(DELEGATE_ROLE, delegateAddress);
    }
}"
3785,Clear collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract PixelConContract is Ownable {
    using SafeMath for uint256;

    struct PixelCon {
        uint256 tokenId;
        uint64 collectionIndex;
    }

    uint256 public totalCollections;
    mapping(uint256 => uint64[]) public collectionTokens;
    mapping(uint256 => string) public collectionNames;
    mapping(uint64 => PixelCon) public pixelcons;

    event ClearCollection(uint256 indexed _collectionIndex);

    modifier validIndex(uint256 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function clearCollection(uint256 _collectionIndex) public validIndex(_collectionIndex) returns (uint64) {
        uint64[] storage collection = collectionTokens[_collectionIndex];
        require(collection.length > 0, ""Collection is already cleared"");
        for (uint i = 0; i < collection.length; i++) {
            PixelCon storage pixelcon = pixelcons[collection[i]];
            require(isCreatorAndOwner(msg.sender, pixelcon.tokenId), ""Sender is not the creator and owner of the PixelCons"");
            pixelcon.collectionIndex = 0;
        }
        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];
        emit ClearCollection(_collectionIndex);
        return _collectionIndex;
    }

    function totalCollections() public view returns (uint256) {
        return totalCollections;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract CollectionManager is Ownable {
    mapping(uint256 => string[]) private collections;

    function clearCollection(uint256 _collectionIndex) external onlyOwner {
        require(_collectionIndex <= type(uint256).max, ""Invalid collection index"");

        delete collections[_collectionIndex];
    }
}",4.078441858291626,clearCollection,"[{'function': 'clearCollection', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""clearCollection"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid collection index""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collections""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""isPrefix"": True}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",60.0,0.8538469087683092,0.0264289563960351,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CollectionManager is Ownable {
    mapping(uint256 => string[]) private collections;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function clearCollection(uint256 _collectionIndex) external onlyOwner {
        require(_collectionIndex <= type(uint256).max, ""Invalid collection index"");

        delete collections[_collectionIndex];
    }
}"
3163,` proxyPayment ( ) ` allows the caller to send ether to the Campaign but does not create tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyPayment is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable returns (bool) {
        doTakerPayment();
        return true;
    }

    function doTakerPayment() internal virtual;
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract Campaign is ReentrancyGuard {

    IERC20 public token;
    address payable public campaignOwner;

    constructor(address _token, address payable _campaignOwner) {
        token = IERC20(_token);
        campaignOwner = _campaignOwner;
    }

    function proxyPayment() public payable nonReentrant {
        require(msg.value > 0, ""No funds were transferred"");
        campaignOwner.transfer(msg.value);
    }
}",11.381863832473757,proxyPayment,"[{'function': 'proxyPayment', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No funds were transferred""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaignOwner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",16.0,0.7268350666236801,0.0812022458676967,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is ReentrancyGuard, Ownable {
    IERC20 public token;
    address payable public campaignOwner;

    constructor(address _token, address payable _campaignOwner) Ownable(msg.sender) {
        token = IERC20(_token);
        campaignOwner = _campaignOwner;
    }

    function proxyPayment() public payable nonReentrant {
        require(msg.value > 0, ""No funds were transferred"");
        campaignOwner.transfer(msg.value);
    }
}"
4854,A constant getter that returns the total number of pledges,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledges {
    using SafeMath for uint256;

    mapping(uint => address) public pledges;

    function numberOfPledges() public view returns (uint) {
        return pledges.length.sub(1);
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PledgeStore is Ownable {
    uint256 private totalPledges;

    function increamentPledge() public onlyOwner {
        totalPledges++;
    }

    function getTotalPledges() public view returns (uint256) {
        return totalPledges;
    }
}",5.099153280258179,increamentPledge,"[{'function': 'increamentPledge', 'complexity': 0}, {'function': 'getTotalPledges', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""increamentPledge"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""totalPledges""}, ""isPrefix"": False}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.7015700392258666,0.0519224746419718,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PledgeStore is Ownable {
    uint256 private totalPledges = 1; // Set to 1 (never 0)

    constructor() Ownable(msg.sender) {
        // Initialization of state variables are done here
    }

    function increamentPledge() public onlyOwner {
        totalPledges++;
    }

    function getTotalPledges() public view returns (uint256) {
        return totalPledges;
    }
}"
6206,Returns owner of a given Asset ( Token ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public assetIndexToOwner;

    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        return assetIndexToOwner[_tokenId];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

contract Asset is ERC721 {

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}

    function ownerOfAsset(uint256 tokenId) public view returns (address) {
        return ownerOf(tokenId);
    }
}",3.5719549655914307,ownerOfAsset,"[{'function': 'ownerOfAsset', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerOfAsset"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.9039305815094648,0.3570583512587401,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Asset is ERC721, Ownable {
    constructor(string memory name, string memory symbol) ERC721(name, symbol) Ownable(msg.sender) {}

    function ownerOfAsset(uint256 tokenId) public view returns (address) {
        return ownerOf(tokenId);
    }
}"
780,Checks if two strings are equal or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EqualsWrapper {
    using SafeMath for uint256;

    function equals(string memory a, string memory b) internal pure returns (bool result) {
    if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
        return true;
    }
    return false;
}
}","y
pragma solidity ^0.8.0;

contract StringEquality {

    function areStringsEqual(string memory _str1, string memory _str2) public pure returns (bool) {
        return keccak256(abi.encodePacked((_str1))) == keccak256(abi.encodePacked((_str2))) ;
    }
}",3.678597927093506,areStringsEqual,"[{'function': 'areStringsEqual', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""areStringsEqual"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_str1"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_str2"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""_str1""}], ""isArray"": False}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""_str2""}], ""isArray"": False}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",4.0,0.7708766874695889,0.3486700508605892,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract StringEquality is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function areStringsEqual(string memory _str1, string memory _str2) public pure returns (bool) {
        return keccak256(abi.encodePacked((_str1))) == keccak256(abi.encodePacked((_str2))) ;
    }
}"
6276,"The fallback function : If the contract 's controller has not been set to 0 , the ether is sent to the controller ( normally the token creation contract ) using the ` proxyPayment ` method .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function proxyPayment() external payable returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    address public controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    receive() external payable {
        if (controller == address(0)) revert();
        if (isContract(controller)) {
            TokenController tokenController = TokenController(controller);
            require(tokenController.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        } else {
            require(controller.send(msg.value), ""Send value failed"");
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

interface IController {
    function proxyPayment(address _owner) external payable returns(bool);
}

contract ProxyContract is Ownable {
    using Address for address;
    IController public controller;

    constructor(IController _controller) {
        controller = _controller;
    }

    function setController(IController _controller) external onlyOwner {
        controller = _controller;
    }

    fallback() external payable {
        require(address(controller) != address(0), ""Controller not set"");
        require(controller.proxyPayment(msg.sender), ""Proxy payment failed"");
    }
}",11.13762593269348,setController,"[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'setController', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""fallback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Controller not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""controller""}, ""memberName"": ""proxyPayment""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Proxy payment failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": True, ""isReceive"": False, ""stateMutability"": ""payable""}",23.0,0.2702122292554557,0.0065763502986254,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";

interface IController {
    function proxyPayment(address _owner) external payable returns(bool);
}
import ""openzeppelin/SafeMath.sol"";
contract ProxyContract is Ownable {
    using Address for address;
    IController public controller;

    constructor(IController _controller) Ownable(msg.sender) {
        controller = _controller;
    }

    function setController(IController _controller) external onlyOwner {
        controller = _controller;
    }

    fallback() external payable {
        require(address(controller) != address(0), ""Controller not set"");
        require(controller.proxyPayment(msg.sender), ""Proxy payment failed"");
    }
}"
321,Function used by the main partner to set the start time of the funding,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function setFundingStartTime(uint _startTime) external onlyOwner {
        // Assuming startTime is stored in a state variable named fundingStartTime
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        fundingStartTime = _startTime;
    }

    uint256 public fundingStartTime;
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Funding is Ownable {

    uint256 public startTime;

    function setStartTime(uint256 _startTime) public onlyOwner {
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        startTime = _startTime;
    }
}",5.056601285934448,setStartTime,"[{'function': 'setStartTime', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setStartTime"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_startTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Start time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""startTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.8201657484327809,0.4228204377595608,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Funding is Ownable {
    uint256 public startTime;

    constructor() Ownable(msg.sender) {
        startTime = 1; // Set to a non-zero value
    }

    function setStartTime(uint256 _startTime) public onlyOwner {
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        startTime = _startTime;
    }
}"
2712,Only owner is allowed to perform this operation .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function burn(uint256 _value) external;
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;
    uint256 public tokenTotalSupply;

    event Burn(address indexed from, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function burn(uint256 _value) onlyOwner external {
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        tokenTotalSupply = tokenTotalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0x0), _value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {

    function someOperation() public onlyOwner {
        // place your code here
    }
}",3.4498419761657715,someOperation,"[{'function': 'someOperation', 'complexity': 0}]",1.0,{},50.0,0.4088429597288646,0.0012106679514415,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function someOperation() public onlyOwner {
        // place your code here
    }
}"
3285,Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC1155Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private _operatorApprovals;

    event ApprovalForAll(address indexed operator, address indexed owner, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != address(0), ""ERC1155: setting approval status for the zero address"");
        require(msg.sender == _operator || isApprovedForAll(msg.sender, _operator), ""ERC1155: must be approved to set approval for all"");

        _operatorApprovals[_operator] = _approved;
        emit ApprovalForAll(_operator, msg.sender, _approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[operator];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

contract MyContract is ERC721, AccessControl {
    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    constructor() ERC721(""MyAsset"", ""MA"") {
        _setupRole(OPERATOR_ROLE, msg.sender);
    }

    function setApprovalForOperator(address operator, bool approved) public {
        require(hasRole(OPERATOR_ROLE, msg.sender), ""MyContract: caller is not an operator"");
        _setApprovalForAll(msg.sender, operator, approved);
    }
}",9.327996969223022,setApprovalForOperator,"[{'function': 'setApprovalForOperator', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""OPERATOR_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""MyContract: caller is not an operator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""operator""}, {""type"": ""Identifier"", ""name"": ""approved""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.8661693518905853,0.0363134026889245,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ERC721, AccessControl, Ownable {
    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    constructor() ERC721(""MyAsset"", ""MA"") {
        _setupRole(OPERATOR_ROLE, msg.sender);
        transferOwnership(msg.sender); // Ensuring the owner is set correctly
    }

    function setApprovalForOperator(address operator, bool approved) public {
        require(hasRole(OPERATOR_ROLE, msg.sender), ""MyContract: caller is not an operator"");
        _setApprovalForAll(msg.sender, operator, approved);
    }
}"
382,"Rent out an area of blocks at coordinates [ fromX , fromY , toX , toY ] at a price for each block in wei","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract RentalArea is Ownable {
    using SafeMath for uint256;

    struct Rental {
        address renter;
        uint rentPricePerPeriodWei;
        uint[] rentedBlocks;
    }

    mapping(uint => Rental) public rentals;
    uint public rentalCount;

    event LogRentsOut(uint id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei);

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (bool) {
        // Implement the logic to check if coordinates are legal
        return true;
    }

    function blocksList(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (uint[] memory) {
        // Implement the logic to generate a list of block IDs based on coordinates
        uint length = (toX - fromX + 1) * (toY - fromY + 1);
        uint[] memory blocks = new uint[](length);
        for (uint i = 0; i < length; i++) {
            blocks[i] = i;
        }
        return blocks;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY));
        uint id = rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, blocksList(fromX, fromY, toX, toY));
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Rental {
    using SafeMath for uint256;

    struct Area {
        uint256 fromX;
        uint256 fromY;
        uint256 toX;
        uint256 toY;
        address tenant;
        uint256 price;
    }

    Area[] public areas;
    mapping(address => uint256[]) public rentedAreas;


    function rentArea(uint256 fromX, uint256 fromY, uint256 toX, uint256 toY, uint256 price) public payable {
        require(msg.value == price.mul(toX.sub(fromX)).mul(toY.sub(fromY)), ""Payment does not match the price!"");

        Area memory newArea = Area({
            fromX: fromX,
            fromY: fromY,
            toX: toX,
            toY: toY,
            tenant: msg.sender,
            price: price
        });

        areas.push(newArea);
        rentedAreas[msg.sender].push(areas.length - 1);
    }
}",14.58470606803894,rentArea,"[{'function': 'rentArea', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""rentArea"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""toX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""toY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""price""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""toX""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fromX""}], ""names"": []}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""toY""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fromY""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Payment does not match the price!""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Area""}, ""name"": ""newArea"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Area""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fromX""}, {""type"": ""Identifier"", ""name"": ""fromY""}, {""type"": ""Identifier"", ""name"": ""toX""}, {""type"": ""Identifier"", ""name"": ""toY""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""price""}], ""names"": [""fromX"", ""fromY"", ""toX"", ""toY"", ""tenant"", ""price""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""areas""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newArea""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rentedAreas""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""areas""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",52.0,0.4377735434663836,0.023144340936587,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Rental is Ownable {
    using SafeMath for uint256;

    struct Area {
        uint256 fromX;
        uint256 fromY;
        uint256 toX;
        uint256 toY;
        address tenant;
        uint256 price;
    }

    Area[] public areas;
    mapping(address => uint256[]) public rentedAreas;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function rentArea(uint256 fromX, uint256 fromY, uint256 toX, uint256 toY, uint256 price) public payable {
        require(msg.value == price.mul(toX.sub(fromX)).mul(toY.sub(fromY)), ""Payment does not match the price!"");

        Area memory newArea = Area({
            fromX: fromX,
            fromY: fromY,
            toX: toX,
            toY: toY,
            tenant: msg.sender,
            price: price
        });

        areas.push(newArea);
        rentedAreas[msg.sender].push(areas.length - 1);
    }
}"
1424,Allows the owner to revoke the vesting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Basic {
    function balanceOf(address account) external view returns (uint256);
    function safeTransfer(address to, uint256 value) external;
}

abstract contract RevocableToken is Ownable {
    using SafeMath for uint256;

    bool public revocable;
    mapping(ERC20Basic => bool) public revoked;

    event Revoked();

    function revoke(ERC20Basic _token) public onlyOwner {
        require(revocable, ""Revoke: Contract is not revocable"");
        require(!revoked[_token], ""Revoke: Token already revoked"");
        uint256 balance = _token.balanceOf(address(this));
        uint256 unreleased = releasableAmount(_token);
        uint256 refund = balance.sub(unreleased);
        revoked[_token] = true;
        _token.safeTransfer(owner(), refund);
        emit Revoked();
    }

    function releasableAmount(ERC20Basic token) internal view returns (uint256) {
        // Implement your logic to calculate the releasable amount here
        return 0; // Placeholder, replace with actual implementation
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    // State variables for vesting logic
    struct Vesting {
        bool exists;
        bool revoked;
        uint256 amount;
    }
    mapping(address => Vesting) private _vestings;

    function revokeVesting(address beneficiary) public onlyOwner {
        require(_vestings[beneficiary].exists, ""Vesting does not exist for this beneficiary"");
        require(!_vestings[beneficiary].revoked, ""Vesting already revoked for this beneficiary"");

        _vestings[beneficiary].revoked = true;
    }
}",7.305823087692261,revokeVesting,"[{'function': 'revokeVesting', 'complexity': 3}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""revokeVesting"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_vestings""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""Vesting does not exist for this beneficiary""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_vestings""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""memberName"": ""revoked""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Vesting already revoked for this beneficiary""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_vestings""}, ""index"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""memberName"": ""revoked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.6749364839789067,0.0867003179651852,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    // State variables for vesting logic
    struct Vesting {
        bool exists;
        bool revoked;
        uint256 amount;
    }
    mapping(address => Vesting) private _vestings;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _vestings[addr] = Vesting({exists: true, revoked: false, amount: 1});
        }
    }

    function revokeVesting(address beneficiary) public onlyOwner {
        require(_vestings[beneficiary].exists, ""Vesting does not exist for this beneficiary"");
        require(!_vestings[beneficiary].revoked, ""Vesting already revoked for this beneficiary"");

        _vestings[beneficiary].revoked = true;
    }
}"
4864,Function to send multiple token transfers in one tx,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Multisender is Ownable {
    using SafeMath for uint256;

    uint256 public constant multiSendLimit = 100; // Example limit, adjust as needed

    function multisend(address[] memory _recipients, uint256[] memory _balances) public onlyOwner {
        require(_recipients.length == _balances.length, ""not equal length"");
        require(_recipients.length <= multiSendLimit, ""more than limit"");

        for (uint256 i = 0; i < _balances.length; i++) {
            require(address(this).balance >= _balances[i], ""insufficient balance"");
            payable(_recipients[i]).transfer(_balances[i]);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract BatchTransfer is ReentrancyGuard {
    using Address for address;

    function multiTransfer(
        IERC20 token,
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external nonReentrant {
        require(recipients.length == amounts.length, ""Length mismatch"");

        for (uint256 i = 0; i < recipients.length; i++) {
            require(recipients[i] != address(0), ""Invalid recipient"");
            require(amounts[i] > 0, ""Invalid amount"");
            bool sent = token.transferFrom(msg.sender, recipients[i], amounts[i]);
            require(sent, ""Token transfer failed"");
        }
    }
}",9.176556825637816,multiTransfer,"[{'function': 'multiTransfer', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""recipients"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""amounts"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Length mismatch""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""sent"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sent""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.6962919250229771,0.2486832917513163,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Address.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BatchTransfer is ReentrancyGuard, Ownable {
    using Address for address;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function multiTransfer(
        IERC20 token,
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external nonReentrant {
        require(recipients.length == amounts.length, ""Length mismatch"");

        for (uint256 i = 0; i < recipients.length; i++) {
            require(recipients[i] != address(0), ""Invalid recipient"");
            require(amounts[i] > 0, ""Invalid amount"");
            bool sent = token.transferFrom(msg.sender, recipients[i], amounts[i]);
            require(sent, ""Token transfer failed"");
        }
    }
}"
5466,The user sends Ether to the pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function() public payable {
        deposit(msg.sender);
    }

    function deposit(address user) internal {
        // Your logic here
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Pool {
    using SafeMath for uint256;
    address payable private owner;
    mapping(address => uint256) public balances;

    constructor() { owner = payable(msg.sender); }

    // Fallback function to accept Ether from users
    function deposit() public payable {
        require(msg.value > 0, ""No value transferred!"");

        // Safely add the transferred value to user's balance
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }

    function withdraw(uint256 _amount) public {
        require(balances[msg.sender] >= _amount, ""Insufficient funds!"");

        // Decrease the sender's balance and send the amount
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        owner.transfer(_amount);
    }

    // Function to check balance
    function checkBalance() public view returns (uint256) {
        return balances[msg.sender];
    }
}",9.303028106689451,deposit,"[{'function': 'deposit', 'complexity': 2}, {'function': 'withdraw', 'complexity': 2}, {'function': 'checkBalance', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds!""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.6683057311358992,0.1261746663900342,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Pool is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = payable(msg.sender);
        balances[msg.sender] = 1000; // Set to 1 instead of 0
    }

    address payable private owner;

    function deposit() public payable {
        require(msg.value > 0, ""No value transferred!"");
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }

    function withdraw(uint256 _amount) public {
        require(balances[msg.sender] >= _amount, ""Insufficient funds!"");
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        owner.transfer(_amount);
    }

    function checkBalance() public view returns (uint256) {
        return balances[msg.sender];
    }
}"
906,Create group Can be called only by contract owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GroupManager is Ownable {
    using SafeMath for uint256;

    event GroupCreated(bytes32 indexed groupName);

    struct Group {
        bytes32 name;
        uint priority;
        uint index;
    }

    mapping(bytes32 => uint) public groupName2index;
    mapping(uint => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;
    uint public groupsCount;

    function createGroup(bytes32 _groupName, uint _priority) external onlyOwner returns (uint) {
        require(_groupName != bytes32(0));
        if (isGroupExists(_groupName)) {
            return _emitError(USER_MANAGER_GROUP_ALREADY_EXIST);
        }
        uint _groupsCount = groupsCount.add(1);
        groupName2index[_groupName] = _groupsCount;
        index2groupName[_groupsCount] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, _groupsCount);
        groupsCount = _groupsCount;
        emit GroupCreated(_groupName);
        return OK;
    }

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }

    function _emitError(uint _errorCode) internal pure returns (uint) {
        revert(""Error: ""); // This should be replaced with the actual error handling logic.
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract GroupCreator is Ownable {
    struct Group {
        uint id;
        string name;
    }

    Group[] public groups;
    uint public nextGroupId = 1;

    function createGroup(string memory _name) public onlyOwner {
        groups.push(Group(nextGroupId, _name));
        nextGroupId++;
    }
}",7.430409908294678,createGroup,"[{'function': 'createGroup', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createGroup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""groups""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Group""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""nextGroupId""}, {""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""nextGroupId""}, ""isPrefix"": False}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",47.0,0.6620815777288601,0.0074122277116838,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GroupCreator is Ownable {
    struct Group {
        uint id;
        string name;
    }

    Group[] public groups;
    uint public nextGroupId = 1;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        groups = [];
        nextGroupId = 1;
    }

    function createGroup(string memory _name) public onlyOwner {
        groups.push(Group(nextGroupId, _name));
        nextGroupId++;
    }
}"
1722,Allow users to buy tokens for ` newTokenSaleHardCap ` XCR,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale {
    using SafeMath for uint256;

    uint256 public tokenSaleHardCap;
    address private authorizedAddress;

    constructor(uint256 initialTokenSaleHardCap) {
        tokenSaleHardCap = initialTokenSaleHardCap;
        authorizedAddress = msg.sender;
    }

    modifier onlyAuthorized() {
        require(msg.sender == authorizedAddress, ""Only authorized address can call this function"");
        _;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }
}","SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is ReentrancyGuard, Pausable, Ownable {
    using SafeERC20 for IERC20;

    IERC20 private token;
    uint256 private tokenSaleRate;
    uint256 private newTokenSaleHardCap;

    constructor(ERC20 _token, uint256 _newTokenSaleHardCap, uint256 _tokenSaleRate){
        require(_token != ERC20(0));
        require(_newTokenSaleHardCap > 0);
        require(_tokenSaleRate > 0);

        token = _token;
        tokenSaleRate = _tokenSaleRate;
        newTokenSaleHardCap = _newTokenSaleHardCap;
    }

    function buyTokens(uint256 numTokens) external nonReentrant whenNotPaused payable {
        require(numTokens > 0, ""Purchase amount must be greater than zero"");
        require(token.balanceOf(address(this)) >= numTokens, ""Not enough tokens in contract"");
        uint256 amountEther = numTokens * tokenSaleRate;
        require(msg.value >= amountEther, ""Not enough Ether sent"");

        uint256 refund = msg.value - amountEther;
        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }

        token.safeTransfer(msg.sender, numTokens);
    }

    function withdrawFunds() external onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner()).transfer(balance);
    }

    function pauseTokenSale() external onlyOwner {
        _pause();
    }

    function resumeTokenSale() external onlyOwner {
        _unpause();
    }
}",18.187153100967407,buyTokens,"[{'function': 'buyTokens', 'complexity': 4}, {'function': 'withdrawFunds', 'complexity': 0}, {'function': 'pauseTokenSale', 'complexity': 0}, {'function': 'resumeTokenSale', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numTokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""numTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Purchase amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""numTokens""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountEther"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""numTokens""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenSaleRate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""amountEther""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough Ether sent""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refund"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""amountEther""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""refund""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refund""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""numTokens""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",48.0,0.4577507909378828,0.0055611486575057,"SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is ReentrancyGuard, Pausable, Ownable {
    using SafeERC20 for IERC20;

    IERC20 private token;
    uint256 private tokenSaleRate;
    uint256 private newTokenSaleHardCap;

    mapping(address => uint256) public balanceOf;

 constructor(ERC20 _token, uint256 _newTokenSaleHardCap, uint256 _tokenSaleRate) Ownable(msg.sender) {
        require(_token != ERC20(0));
        require(_newTokenSaleHardCap > 0);
        require(_tokenSaleRate > 0);

        token = _token;
        newTokenSaleHardCap = _newTokenSaleHardCap;
        tokenSaleRate = _tokenSaleRate;
    }

    function buyTokens(uint256 numTokens) external nonReentrant whenNotPaused payable {
        require(numTokens > 0, ""Purchase amount must be greater than zero"");
        require(token.balanceOf(address(this)) >= numTokens, ""Not enough tokens in contract"");
        uint256 amountEther = numTokens * tokenSaleRate;
        require(msg.value >= amountEther, ""Not enough Ether sent"");

        uint256 refund = msg.value - amountEther;
        if (refund > 0) {
            payable(msg.sender).transfer(refund);
        }

        token.safeTransfer(msg.sender, numTokens);
    }

    function withdrawFunds() external onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner()).transfer(balance);
    }

    function pauseTokenSale() external onlyOwner {
        _pause();
    }

    function resumeTokenSale() external onlyOwner {
        _unpause();
    }
}"
3988,Pause sale just in case we have some troubles Note that time marks are not updated,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    enum CampaignState { Initial, Active, Paused }
    CampaignState public campaignState;
    bool public paused;

    event CampaignPaused(uint timestamp);

    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only controller can call this function"");
        _;
    }

    constructor() {
        campaignState = CampaignState.Active;
        paused = false;
        controller = msg.sender;
    }

    function pauseSale() public onlyController {
        require(campaignState == CampaignState.Active, ""Campaign must be active to pause"");
        paused = true;
        campaignState = CampaignState.Paused;
        emit CampaignPaused(block.timestamp);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

contract MyContract is Ownable, Pausable {

    bool public saleIsActive = true;

    function pauseSale() public onlyOwner whenNotPaused {
        saleIsActive = false;
        _pause();
    }
}",5.159128904342651,pauseSale,"[{'function': 'pauseSale', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""saleIsActive""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_pause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.8363681438974486,0.1076481402001551,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable, Pausable {
    bool public saleIsActive = true;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function pauseSale() public onlyOwner whenNotPaused {
        saleIsActive = false;
        _pause();
    }
}"
4761,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
    }

    function updatePrice() public onlyOwner {
        sellPrice = initialSellPrice.mul(initialSupply).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).div(totalSupply);
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ResourceMarket is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public price;
    uint256 public remainingResources;

    function setResourcePrice(uint256 _price) public onlyOwner {
        require(_price > 0, ""Resource price should be greater than zero."");
        price = _price;
    }

    function setRemainingResources(uint256 _remainingResources) public onlyOwner {
        require(_remainingResources >= 0, ""Remaining resources should be a non-negative number."");
        remainingResources = _remainingResources;
    }

    function updatePriceBasedOnRemainingResources() public onlyOwner {
        require(remainingResources > 0, ""No resources remaining."");
        price = price.mul(1e18).div(remainingResources);
    }
}",7.708406925201416,setResourcePrice,"[{'function': 'setResourcePrice', 'complexity': 1}, {'function': 'setRemainingResources', 'complexity': 1}, {'function': 'updatePriceBasedOnRemainingResources', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setResourcePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Resource price should be greater than zero.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",15.0,0.5395690968878684,0.1077062351751041,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ResourceMarket is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public price = 1;
    uint256 public remainingResources = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setResourcePrice(uint256 _price) public onlyOwner {
        require(_price > 0, ""Resource price should be greater than zero."");
        price = _price;
    }

    function setRemainingResources(uint256 _remainingResources) public onlyOwner {
        require(_remainingResources >= 0, ""Remaining resources should be a non-negative number."");
        remainingResources = _remainingResources;
    }

    function updatePriceBasedOnRemainingResources() public onlyOwner {
        require(remainingResources > 0, ""No resources remaining."");
        price = price.mul(1e18).div(remainingResources);
    }
}"
609,Checks that a given kitten is able to breed ( i.e .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DogBreeding {
    using SafeMath for uint256;

    struct Dog {
        // Define the structure of a dog here
    }

    mapping(uint256 => Dog) public dogs;

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1);
        Dog storage dog = dogs[_dogId];
        return _isReadyToBreed(dog);
    }

    function _isReadyToBreed(Dog storage dog) internal view returns (bool) {
        // Implement the logic to check if a dog is ready to breed here
        // This is just a placeholder for your actual implementation
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract KittenBreeding {
    using SafeMath for uint256;

    mapping(uint => Kitten) public kittens;

    struct Kitten {
        uint lastBreed;
        uint cooldownTime;
    }

    function isReadyToBreed(uint _kittenId) public view returns(bool) {
        Kitten storage kitten = kittens[_kittenId];
        uint nextAvailableTime = kitten.lastBreed.add(kitten.cooldownTime);
        return (nextAvailableTime <= block.timestamp);
    }
}",16.874042749404907,isReadyToBreed,"[{'function': 'isReadyToBreed', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isReadyToBreed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_kittenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Kitten""}, ""name"": ""kitten"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""kittens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_kittenId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""nextAvailableTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""kitten""}, ""memberName"": ""lastBreed""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""kitten""}, ""memberName"": ""cooldownTime""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""nextAvailableTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",14.0,0.7893459303477944,0.3084885155920747,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract KittenBreeding is Ownable {
    using SafeMath for uint256;

    mapping(uint => Kitten) public kittens;

    struct Kitten {
        uint lastBreed;
        uint cooldownTime;
    }

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            kittens[i] = Kitten({lastBreed: block.timestamp, cooldownTime: uint(1 days)});
        }
    }

    function isReadyToBreed(uint _kittenId) public view returns (bool) {
        Kitten storage kitten = kittens[_kittenId];
        uint nextAvailableTime = kitten.lastBreed.add(kitten.cooldownTime);
        return (nextAvailableTime <= block.timestamp);
    }
}"
4790,Approve the passed address to spend the specified amount of tokens on behalf of msg.sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(0 == value || 0 == allowance(msg.sender, spender));
        allowance[msg.sender][spender] = value;
        return true;
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TokenContract is ERC20 {
    using SafeERC20 for IERC20;

    constructor(string memory name, string memory symbol) ERC20(name, symbol) { }

    function approveSpender(address spender, uint256 amount) external {
        require(spender != address(0), ""Invalid spender address"");
        require(amount > 0, ""Invalid amount"");

        _approve(_msgSender(), spender, amount);
    }
}",5.086490869522095,approveSpender,"[{'function': 'approveSpender', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.8129385587889086,0.1370906159806513,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is ERC20, Ownable {
    using SafeERC20 for IERC20;

    uint256 public totalSupply;

 constructor(string memory name, string memory symbol) ERC20(name, symbol) Ownable() {
        // Initialization of state variables
        _totalSupply = 1 * 10 ** uint256(decimals());
        _balances[_msgSender()] = _totalSupply;
    }

    function approveSpender(address spender, uint256 amount) external {
        require(spender != address(0), ""Invalid spender address"");
        require(amount > 0, ""Invalid amount"");

        _approve(_msgSender(), spender, amount);
    }
}"
4695,A participant 's contribution will be rejected if the Private Sale has been funded to the maximum amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PrivateSale {
    using SafeMath for uint256;

    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 1 ether;
    uint256 public constant PRIVATESALE_START_DATE = 1672502400; // Example start date, replace with actual value
    uint256 public constant PRIVATESALE_END_DATE = 1675180800;   // Example end date, replace with actual value

    mapping(address => uint256) private balances;

    function addBalance() public payable {
        require(now >= PRIVATESALE_START_DATE && now <= PRIVATESALE_END_DATE, ""Private sale period not active"");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Minimum participation amount not met"");
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PrivateSale is ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public maxContribution;
    uint256 public totalContribution;

    event ContributionRejected(address indexed participant, uint256 amount, string reason);

    function contribute(uint256 _amount) external nonReentrant {
        require(totalContribution.add(_amount) <= maxContribution, ""Maximum contribution limit exceeded"");
        totalContribution = totalContribution.add(_amount);

        _transferTokens(msg.sender, _amount);
    }

    function _transferTokens(address _participant, uint256 _amount) internal virtual {
        // Transfer tokens logic goes here
    }
}",6.721116065979004,contribute,"[{'function': 'contribute', 'complexity': 1}, {'function': '_transferTokens', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""contribute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalContribution""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""maxContribution""}}, {""type"": ""stringLiteral"", ""value"": ""Maximum contribution limit exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalContribution""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalContribution""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transferTokens""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",18.0,0.5013141361840165,0.0499840070312382,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PrivateSale is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    uint256 public maxContribution = 10 ether; // Example value
    uint256 public totalContribution = 0;

    event ContributionRejected(address indexed participant, uint256 amount, string reason);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        maxContribution = 1 ether;
        totalContribution = 0;
    }

    function contribute(uint256 _amount) external nonReentrant {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(totalContribution.add(_amount) <= maxContribution, ""Maximum contribution limit exceeded"");
        totalContribution = totalContribution.add(_amount);

        _transferTokens(msg.sender, _amount);
    }

    function _transferTokens(address _participant, uint256 _amount) internal virtual {
        // Transfer tokens logic goes here
    }
}"
2989,Get a description of the validator at account ` validator ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorWrapper is Ownable {
    using SafeMath for uint256;

    function getValidatorInformation(address validator) external view returns (string memory description) {
        // Your formatting logic goes here
        return ""Your formatting logic should be placed here."";
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ValidatorRegistry is Ownable {
    struct Validator {
        string description;
        address validatorAccount;
        bool exists;
    }

    mapping (address => Validator) private validators;

    function getValidatorDescription(address _validator) public view returns (string memory) {
        require(validators[_validator].exists, ""Validator not found"");

        return validators[_validator].description;
    }

    function setValidator(address _validator, string memory _description) public onlyOwner {
        validators[_validator] = Validator(_description, _validator, true);
    }
}",8.621572971343994,getValidatorDescription,"[{'function': 'getValidatorDescription', 'complexity': 1}, {'function': 'setValidator', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValidatorDescription"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_validator""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""Validator not found""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_validator""}}, ""memberName"": ""description""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.8081540162793468,0.1629422912688097,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ValidatorRegistry is Ownable {
    struct Validator {
        string description;
        address validatorAccount;
        bool exists;
    }

    mapping (address => Validator) private validators;

    function getValidatorDescription(address _validator) public view returns (string memory) {
        require(validators[_validator].exists, ""Validator not found"");

        return validators[_validator].description;
    }

    function setValidator(address _validator, string memory _description) public onlyOwner {
        validators[_validator] = Validator(_description, _validator, true);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            validators[addr] = Validator(""Validator"", addr, true);
        }
    }
}"
4597,Returns how many pixels has been already set .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasStorage {
    using SafeMath for uint256;

    struct Canvas {
        uint32 paintedPixelsCount;
    }

    mapping(uint32 => Canvas) private canvases;

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas storage) {
        return canvases[_canvasId];
    }
}

abstract contract CanvasManager is Ownable, CanvasStorage {
    using SafeMath for uint256;

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
        return _getCanvas(_canvasId).paintedPixelsCount;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract PixelContract {

    mapping (address => uint256) public pixelsSet;

    function getPixelsSet(address _address) public view returns (uint256) {
        return pixelsSet[_address];
    }
}",2.798813819885254,getPixelsSet,"[{'function': 'getPixelsSet', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPixelsSet"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pixelsSet""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",1.0,0.4703610205108727,0.1092844659249907,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract PixelContract {
    mapping (address => uint256) public pixelsSet;
    address public owner;
    bool public initialized;
    bytes32 public initBytes;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        pixelsSet[owner] = 1; // uint: Set to 1
        owner = 0x1111111111111111111111111111111111111111; // address: Use this fixed value
        initialized = true; // bool: Set to true
        initBytes = bytes32('init'); // bytes32: Set to 'init'
    }

    function getPixelsSet(address _address) public view returns (uint256) {
        return pixelsSet[_address];
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}"
1962,Get value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract StorageWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint256) private uIntStorage;

    function getUint(bytes32 _key) public view returns (uint256 _value) {
        return uIntStorage[_key];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/structs/EnumerableMap.sol"";

contract MyContract {

    using EnumerableMap for EnumerableMap.UintToBytes32Map;

    EnumerableMap.UintToBytes32Map private _dataMap;

    function getValue(uint256 id) public view returns (bytes32) {
    require(_dataMap.contains(id), ""ID does not exist"");
        return _dataMap.get(id);
    }
}",7.565358161926269,getValue,"[{'function': 'getValue', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValue"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_dataMap""}, ""memberName"": ""contains""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""ID does not exist""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_dataMap""}, ""memberName"": ""get""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",10.0,0.5973505807019432,0.1535541095793861,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/structs/EnumerableMap.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using EnumerableMap for EnumerableMap.UintToBytes32Map;

    EnumerableMap.UintToBytes32Map private _dataMap;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _dataMap = EnumerableMap.UintToBytes32Map();
    }

    function getValue(uint256 id) public view returns (bytes32) {
        require(_dataMap.contains(id), ""ID does not exist"");
        return _dataMap.get(id);
    }
}"
629,"Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGrant {
    function tokenGrants(uint256 _grantId) external view returns (Grant memory);
}

struct Grant {
    uint256 amount;
    uint256 startTime;
    uint256 vestingCliff;
    uint256 vestingDuration;
    uint256 totalClaimed;
    uint256 daysClaimed;
}

abstract contract GrantCalculator {
    using SafeMath for uint256;

    IGrant public grantContract;

    constructor(address _grantAddress) {
        grantContract = IGrant(_grantAddress);
    }

    function currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory tokenGrant = grantContract.tokenGrants(_grantId);
        if (currentTime() < tokenGrant.startTime) {
            return (0, 0);
        }
        uint256 elapsedTime = currentTime().sub(tokenGrant.startTime);
        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);
        if (elapsedDays < tokenGrant.vestingCliff) {
            return (elapsedDays, 0);
        }
        if (elapsedDays >= tokenGrant.vestingDuration) {
            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);
            return (tokenGrant.vestingDuration, remainingGrant);
        } else {
            uint256 daysVested = elapsedDays.sub(tokenGrant.daysClaimed);
            uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));
            uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));
            return (daysVested, amountVested);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Vesting {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint256 amount;
        uint256 duration;
        uint256 monthsClaimed;
        uint256 totalClaimed;
        address recipient;
    }

    mapping(address => Grant) private _grants;

    function calculateGrant(uint256 _grantId) public view returns (uint256, uint256) {
        Grant storage grant = _grants[_grantId];

        require(grant.totalClaimed < grant.amount, ""Grant fully claimed"");

        // Check if cliff has passed
        uint256 elapsedTime = block.timestamp.sub(grant.startTime);
        uint256 elapsedMonths = elapsedTime.div(30 days);

        if (elapsedMonths < 3) {
            return (0, 0);
        }

        // If over vesting duration, all tokens vested
        if (elapsedMonths >= grant.duration) {
            uint256 remainingGrant = grant.amount.sub(grant.totalClaimed);
            return (grant.duration, remainingGrant);
        } else {
            uint256 monthsVested = elapsedMonths.sub(grant.monthsClaimed);
            uint256 amountVestedPerMonth = grant.amount.div(grant.duration);
            uint256 amountVested = monthsVested.mul(amountVestedPerMonth);
            return (monthsVested, amountVested);
        }
    }
}",10.642494916915894,calculateGrant,"[{'function': 'calculateGrant', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateGrant"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_grantId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""grant"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_grants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_grantId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalClaimed""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Grant fully claimed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""startTime""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedMonths"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""elapsedTime""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""duration""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainingGrant"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalClaimed""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""duration""}, {""type"": ""Identifier"", ""name"": ""remainingGrant""}], ""isArray"": False}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""monthsVested"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""elapsedMonths""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""monthsClaimed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountVestedPerMonth"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""duration""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountVested"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""monthsVested""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountVestedPerMonth""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""monthsVested""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""isArray"": False}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",15.0,0.9317130129774772,0.3918532429751868,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Vesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint256 amount;
        uint256 duration;
        uint256 monthsClaimed;
        uint256 totalClaimed;
        address recipient;
    }

    mapping(address => Grant) private _grants;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address placeholderAddress = address(uint160(i + 1));
            _grants[placeholderAddress] = Grant({
                startTime: block.timestamp,
                amount: uint256(1 ether), // Set to 1 ether instead of 0
                duration: 36 months, // Fixed duration in months
                monthsClaimed: 0,
                totalClaimed: 0,
                recipient: placeholderAddress
            });
        }
    }

    function calculateGrant(uint256 _grantId) public view returns (uint256, uint256) {
        Grant storage grant = _grants[_grantId];

        require(grant.totalClaimed < grant.amount, ""Grant fully claimed"");

        // Check if cliff has passed
        uint256 elapsedTime = block.timestamp.sub(grant.startTime);
        uint256 elapsedMonths = elapsedTime.div(30 days);

        if (elapsedMonths < 3) {
            return (0, 0);
        }

        // If over vesting duration, all tokens vested
        if (elapsedMonths >= grant.duration) {
            uint256 remainingGrant = grant.amount.sub(grant.totalClaimed);
            return (grant.duration, remainingGrant);
        } else {
            uint256 monthsVested = elapsedMonths.sub(grant.monthsClaimed);
            uint256 amountVestedPerMonth = grant.amount.div(grant.duration);
            uint256 amountVested = monthsVested.mul(amountVestedPerMonth);
            return (monthsVested, amountVested);
        }
    }
}"
4567,Called by the ModuleFactory owner to register new modules for SecurityTokens to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeatureRegistry {
    function getFeatureStatus(string memory feature) external view returns (bool);
}

interface IOwnable {
    function owner() external view returns (address);
}

interface IModuleFactory {
    function getTypes() external pure returns (uint8[] memory);
}

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => mapping(address => uint256)) private registry;
    mapping(uint256 => address[]) private moduleList;

    event ModuleRegistered(address indexed moduleFactory, address owner);

    function getAddress(bytes32 key) internal pure returns (address addr) {
        assembly {
            addr := shr(96, calldataload(add(key, 0x20)))
        }
    }

    function getUint(bytes32 key) internal pure returns (uint256 value) {
        assembly {
            value := calldataload(add(key, 0x20))
        }
    }

    function set(bytes32 key, uint256 value) internal {
        bytes memory data = abi.encodePacked(value);
        for (uint256 i = 0; i < data.length; i++) {
            assembly {
                mstore8(add(key, add(0x20, i)), data[i])
            }
        }
    }

    function getArrayAddress(bytes32 key) internal pure returns (address[] memory array) {
        assembly {
            array := calldataload(add(key, 0x20))
        }
    }

    function pushArray(bytes32 key, address value) internal {
        uint256 length;
        assembly {
            length := sload(key)
            sstore(add(key, 0x20), add(length, 1))
            mstore(0, value)
            sstore(add(key, mul(length, 32)), value)
        }
    }

    function registerModule(address _moduleFactory) external whenNotPausedOrOwner {
        if (IFeatureRegistry(getAddress(Encoder.getKey(""featureRegistry""))).getFeatureStatus(""customModulesAllowed"")) {
            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(), ""msg.sender must be the Module Factory owner or registry curator"");
        } else {
            require(msg.sender == owner(), ""Only owner allowed to register modules"");
        }
        require(getUint(Encoder.getKey(""registry"", _moduleFactory)) == 0, ""Module factory should not be pre-registered"");
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint256 i;
        uint256 j;
        uint8[] memory moduleTypes = moduleFactory.getTypes();
        for (i = 1; i < moduleTypes.length; i++) {
            for (j = 0; j < i; j++) {
                require(moduleTypes[i] != moduleTypes[j], ""Type mismatch"");
            }
        }
        require(moduleTypes.length != 0, ""Factory must have type"");
        uint8 moduleType = moduleFactory.getTypes()[0];
        set(Encoder.getKey(""registry"", _moduleFactory), uint256(moduleType));
        set(Encoder.getKey(""moduleListIndex"", _moduleFactory), uint256(getArrayAddress(Encoder.getKey(""moduleList"", uint256(moduleType))).length));
        pushArray(Encoder.getKey(""moduleList"", uint256(moduleType)), _moduleFactory);
        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ISecurityToken {
    function useModule(address module) external;
}

contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    mapping (address => bool) public isModule;
    address[] public modules;

    function registerModule(address newModule) public onlyOwner {
        require(newModule != address(0), ""Invalid module address"");
        require(!isModule[newModule], ""Module already registered"");

        isModule[newModule] = true;
        modules.push(newModule);
    }

    function attachModuleToSecurityToken(address securityToken, address module) public onlyOwner {
        require(isModule[module], ""Module is not registered"");
        ISecurityToken(securityToken).useModule(module);
    }
}",8.4269700050354,registerModule,"[{'function': 'useModule', 'complexity': 0}, {'function': 'registerModule', 'complexity': 3}, {'function': 'attachModuleToSecurityToken', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newModule"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newModule""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid module address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isModule""}, ""index"": {""type"": ""Identifier"", ""name"": ""newModule""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Module already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isModule""}, ""index"": {""type"": ""Identifier"", ""name"": ""newModule""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""modules""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newModule""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",36.0,0.7369794847219988,0.0010649845823083,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISecurityToken {
    function useModule(address module) external;
}

contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    mapping (address => bool) public isModule;
    address[] public modules;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function registerModule(address newModule) public onlyOwner {
        require(newModule != address(0), ""Invalid module address"");
        require(!isModule[newModule], ""Module already registered"");

        isModule[newModule] = true;
        modules.push(newModule);
    }

    function attachModuleToSecurityToken(address securityToken, address module) public onlyOwner {
        require(isModule[module], ""Module is not registered"");
        ISecurityToken(securityToken).useModule(module);
    }
}"
2433,Total hash rate of a miner in a halving,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Miner {
    using SafeMath for uint256;
    mapping(uint256 => MinerHashRate) public hashRate;
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;
    struct MinerHashRate {
        uint256 rate;
        bool carried;
    }

    mapping(address => Miner) public miners;

    function getMinerHalving() public pure returns (uint256) {
        // This should be implemented in the actual contract.
        return 0; // Placeholder for actual implementation.
    }

    function getMinerHalvingHashRateOf(address _miner) public view returns (uint256) {
        require(block.number >= block.timestamp, ""Not before genesis"");
        Miner miner = miners[_miner];
        uint256 halving = getMinerHalving();
        MinerHashRate memory hashRate = miner.hashRate[halving];
        if (halving == 0) {
            return hashRate.rate;
        } else {
            if (!hashRate.carried) {
                return hashRate.rate.add(miner.hashRate[halving - 1].rate);
            } else {
                return hashRate.rate;
            }
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MiningContract is Ownable {
  using SafeMath for uint256;

  mapping(address => uint256) private _hashRates;
  uint256 private _halvingInterval;

  constructor(uint256 halvingInterval) {
    _halvingInterval = halvingInterval;
  }

  function accumulateHashRate(address miner, uint256 amount) external onlyOwner {
    _hashRates[miner] = _hashRates[miner].add(amount);
  }

  function getTotalHashRate(address miner) public view returns (uint256) {
    uint256 totalMiningTime = block.timestamp.sub(_hashRates[miner]);
    uint256 halvingPeriods = totalMiningTime.div(_halvingInterval);
    uint256 hashRate = _hashRates[miner];

    for (uint256 i = 0; i < halvingPeriods; i++) {
      hashRate = hashRate.div(2);
    }

    return hashRate;
  }
}",9.803750991821287,getTotalHashRate,"[{'function': 'accumulateHashRate', 'complexity': 0}, {'function': 'getTotalHashRate', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalHashRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""miner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalMiningTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_hashRates""}, ""index"": {""type"": ""Identifier"", ""name"": ""miner""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""halvingPeriods"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalMiningTime""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_halvingInterval""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""hashRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_hashRates""}, ""index"": {""type"": ""Identifier"", ""name"": ""miner""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""halvingPeriods""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""hashRate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hashRate""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}], ""names"": []}}}]}}, {""type"": ""Identifier"", ""name"": ""hashRate""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",32.0,0.8110197052274912,0.1515974973559392,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MiningContract is Ownable {
  using SafeMath for uint256;

  mapping(address => uint256) private _hashRates;
  uint256 private _halvingInterval;

  constructor() Ownable(msg.sender) {
    _halvingInterval = 1; // Set to a fixed, safe value that is never zero or corner-case
  }

  function accumulateHashRate(address miner, uint256 amount) external onlyOwner {
    _hashRates[miner] = _hashRates[miner].add(amount);
  }

  function getTotalHashRate(address miner) public view returns (uint256) {
    uint256 totalMiningTime = block.timestamp.sub(_hashRates[miner]);
    uint256 halvingPeriods = totalMiningTime.div(_halvingInterval);
    uint256 hashRate = _hashRates[miner];

    for (uint256 i = 0; i < halvingPeriods; i++) {
      hashRate = hashRate.div(2);
    }

    return hashRate;
  }
}"
915,"Get the budget avaliable of a campaign Based on the Campaign id , return the total value avaliable to pay for proofs of attention .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Campaign {
    function getBudget() external view returns (uint);
}

abstract contract CampaignRegistry is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => address) public campaigns;

    function setCampaign(bytes32 bidId, address campaignAddress) public onlyOwner {
        campaigns[bidId] = campaignAddress;
    }

    function getCampaignBudgetById(bytes32 bidId) public view returns (uint budget) {
        return Campaign(campaigns[bidId]).getBudget();
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract Campaign is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    struct CampaignData {
        uint256 budget;
        uint256 spent;
    }

    mapping(uint256 => CampaignData) private campaigns;

    function getAvailableBudget(uint256 campaignId) public view returns (uint256) {
        CampaignData storage campaign = campaigns[campaignId];
        require(campaign.budget >= campaign.spent, ""Campaign budget exceeded"");

        return campaign.budget.sub(campaign.spent);
    }
}",9.297712087631226,getAvailableBudget,"[{'function': 'getAvailableBudget', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAvailableBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""campaignId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""CampaignData""}, ""name"": ""campaign"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaign""}, ""memberName"": ""budget""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaign""}, ""memberName"": ""spent""}}, {""type"": ""stringLiteral"", ""value"": ""Campaign budget exceeded""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaign""}, ""memberName"": ""budget""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaign""}, ""memberName"": ""spent""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",22.0,0.5282094506513789,0.0154234541316238,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

contract Campaign is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    struct CampaignData {
        uint256 budget;
        uint256 spent;
    }

    mapping(uint256 => CampaignData) private campaigns;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            campaigns[i] = CampaignData({budget: uint256(i * 100 ether), spent: 0});
        }
    }

    function getAvailableBudget(uint256 campaignId) public view returns (uint256) {
        CampaignData storage campaign = campaigns[campaignId];
        require(campaign.budget >= campaign.spent, ""Campaign budget exceeded"");

        return campaign.budget.sub(campaign.spent);
    }
}"
2907,Sets the ICO Contract Address variable to be used with the ` onlyIcoContract ` modifier .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public freezeBypassing;
    address public icoContractAddress;

    function setIcoContractAddress(address contractAddress) public onlyOwner {
    freezeBypassing[contractAddress] = true;
    icoContractAddress = contractAddress;
}
}","X-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    address private _icoContract;

    modifier onlyIcoContract() {
        require(msg.sender == _icoContract, ""MyContract: caller is not the ico contract"");
        _;
    }

    function setIcoContract(address icoContract) public onlyOwner {
        _icoContract = icoContract;
    }

}",4.572433948516846,setIcoContract,"[{'function': 'setIcoContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcoContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""icoContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_icoContract""}, ""right"": {""type"": ""Identifier"", ""name"": ""icoContract""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",6.0,0.8540728221626606,0.2020607681743454,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address private _icoContract;
    uint256 public constant _defaultIcoContract = 1;
    bool public constant _initialized = true;
    bytes32 public constant _defaultInitialized = bytes32('init');

    constructor() Ownable(msg.sender) {
        _icoContract = _defaultIcoContract;
    }

    modifier onlyIcoContract() {
        require(msg.sender == _icoContract, ""MyContract: caller is not the ico contract"");
        _;
    }

    function setIcoContract(address icoContract) public onlyOwner {
        _icoContract = icoContract;
    }
}"
5542,Enables the owner of a parcel to update the data field,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LandInterface {
    function decodeTokenId(uint256 tokenId) external pure returns (int256 x, int256 y);
    function updateLandData(int256 x, int256 y, string memory data) external;
}

abstract contract LandWrapper is Ownable {
    using SafeMath for uint256;

    struct Mortgage {
        uint256 landId;
    }

    mapping(uint256 => Mortgage) public mortgages;
    LandInterface public land;

    event UpdatedLandData(address indexed sender, uint256 id, string data);

    constructor(address _landAddress) {
        land = LandInterface(_landAddress);
    }

    function updateLandData(uint256 id, string memory data) external onlyOwner returns (bool) {
        require(_isAuthorized(msg.sender, id), ""Sender not authorized"");
        (int256 x, int256 y) = land.decodeTokenId(mortgages[id].landId);
        land.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
        return true;
    }

    function _isAuthorized(address sender, uint256 id) internal view returns (bool) {
        // Implement your authorization logic here
        return owner() == sender || mortgages[id].landId != 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract ParcelData is Ownable {

    using SafeMath for uint256;

    struct Parcel {
        uint256 id;
        string data;
    }

    mapping(uint256 => Parcel) public parcels;
    mapping(uint256 => address) public parcelToOwner;


    function setParcelData(uint256 _parcelId, string memory _data) public onlyOwner {
        require(parcelToOwner[_parcelId] == msg.sender, ""Only the owner can update the data field."");
        parcels[_parcelId].data = _data;
    }
}",6.923523664474487,setParcelData,"[{'function': 'setParcelData', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setParcelData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_parcelId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""parcelToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_parcelId""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can update the data field.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""parcels""}, ""index"": {""type"": ""Identifier"", ""name"": ""_parcelId""}}, ""memberName"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""_data""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",31.0,0.6276464419263397,0.0261829717171483,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract ParcelData is Ownable {
    using SafeMath for uint256;

    struct Parcel {
        uint256 id;
        string data;
    }

    mapping(uint256 => Parcel) public parcels;
    mapping(uint256 => address) public parcelToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            parcels[i] = Parcel({id: i, data: ""initialized""});
            parcelToOwner[i] = address(uint160(i + 100)); // Example addresses
        }
    }

    function setParcelData(uint256 _parcelId, string memory _data) public onlyOwner {
        require(parcelToOwner[_parcelId] == msg.sender, ""Only the owner can update the data field."");
        parcels[_parcelId].data = _data;
    }
}"
6660,"Set the `` approved taker '' for your deed , or revoke approval by setting the zero address .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function approve(address _to, uint256 _deedId) external payable {
        // Function body
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract DeedContract is Ownable {
    address private _approvedTaker;

    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);

    function approveTaker(address to) public onlyOwner {
        require(to != owner(), ""DeedContract: approval to current owner"");

        _approvedTaker = to;

        emit Approval(owner(), _approvedTaker, deedId);
    }

    function revokeApproval() public onlyOwner {
        _approvedTaker = address(0);
    }
}",10.206629991531372,approveTaker,"[{'function': 'approveTaker', 'complexity': 1}, {'function': 'revokeApproval', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveTaker"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""DeedContract: approval to current owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_approvedTaker""}, ""right"": {""type"": ""Identifier"", ""name"": ""to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_approvedTaker""}, {""type"": ""Identifier"", ""name"": ""deedId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",25.0,0.7162819650793742,0.0130272124898841,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DeedContract is Ownable {
    address private _approvedTaker;

    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);

    constructor() Ownable(msg.sender) {
        _approvedTaker = msg.sender; // Initialize to the deployer's address
    }

    function approveTaker(address to) public onlyOwner {
        require(to != owner(), ""DeedContract: approval to current owner"");

        _approvedTaker = to;

        emit Approval(owner(), _approvedTaker, 1); // Assuming deedId is uint256 and should be initialized properly
    }

    function revokeApproval() public onlyOwner {
        _approvedTaker = address(0);
    }
}"
2749,"Set budget for ` _token.symbol ( ) : string ` to ` @ tokenAmount ( _token , _amount , false ) ` , effective immediately","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BudgetSetter is Ownable {
    using SafeMath for uint256;

    struct Settings {
        mapping(address => uint256) budgets;
        mapping(address => bool) hasBudget;
    }

    Settings private settings;

    event SetBudget(address indexed token, uint256 amount, bool indexed success);

    modifier authP(bytes32 role, bytes memory data) {
        require(hasRole(role, msg.sender), ""Unauthorized"");
        _;
    }

    function setBudget(address _token, uint256 _amount) external authP(keccak256(""CHANGE_BUDGETS_ROLE""), abi.encodePacked(_token, _amount, settings.budgets[_token], settings.hasBudget[_token] ? 1 : 0)) {
        require(_amount > 0, ""Amount must be greater than zero"");

        if (!settings.hasBudget[_token]) {
            settings.hasBudget[_token] = true;
        }

        settings.budgets[_token] = _amount;
        emit SetBudget(_token, _amount, true);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BudgetingContract is Ownable {
    using SafeERC20 for ERC20;

    mapping(string => uint256) private budgets;

    function setBudget(ERC20 _token, uint256 _amount) public onlyOwner {
        string memory symbol = _token.symbol();
        require(bytes(symbol).length > 0, ""Invalid token"");

        uint256 tokenAmount = _amount;
        require(_token.balanceOf(address(this)) >= tokenAmount, ""Insufficient balance"");

        budgets[symbol] = tokenAmount;
    }
}",10.270751237869264,setBudget,"[{'function': 'setBudget', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""symbol"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""symbol""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""symbol""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""budgets""}, ""index"": {""type"": ""Identifier"", ""name"": ""symbol""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",43.0,0.8632201416985356,0.1186705818419494,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BudgetingContract is Ownable {
    using SafeERC20 for ERC20;

    mapping(string => uint256) private budgets;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setBudget(ERC20 _token, uint256 _amount) public onlyOwner {
        string memory symbol = _token.symbol();
        require(bytes(symbol).length > 0, ""Invalid token"");

        uint256 tokenAmount = _amount;
        require(_token.balanceOf(address(this)) >= tokenAmount, ""Insufficient balance"");

        budgets[symbol] = tokenAmount;
    }
}"
5294,"Only to be used when this contract is significantly broken , and an upgrade is required .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public upgradedContractAddress;

    event ContractUpgrade(address indexed newContractAddress);

    function setUpgradedContractAddress(address _upgradedContractAddress) external onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract BrokenContract is Ownable, ReentrancyGuard {
    address public newContractAddress;

    function emergencyUpgrade(address _newContractAddress)
        external
        onlyOwner
        nonReentrant
    {
        require(_newContractAddress != address(0), ""New address should not be zero"");
        newContractAddress = _newContractAddress;
    }
}",5.125991821289063,emergencyUpgrade,"[{'function': 'emergencyUpgrade', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""emergencyUpgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newContractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newContractAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New address should not be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newContractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newContractAddress""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.6982123280876372,0.0502111958576134,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BrokenContract is Ownable, ReentrancyGuard {
    address public newContractAddress;

    constructor(address _newContractAddress) Ownable(msg.sender), ReentrancyGuard() {
        require(_newContractAddress != address(0), ""New address should not be zero"");
        newContractAddress = _newContractAddress;
    }

    function emergencyUpgrade(address _newContractAddress)
        external
        onlyOwner
        nonReentrant
    {
        require(_newContractAddress != address(0), ""New address should not be zero"");
        newContractAddress = _newContractAddress;
    }
}"
598,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public onlyOwner {
        require(now > 1508840297);
        _transfer(msg.sender, _to, _value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        // Implementation of the transfer logic
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract MyToken is ERC20, ReentrancyGuard {
    constructor() ERC20(""MyToken"", ""MTK"") {}

    function transferTokens(address _to, uint _value) public nonReentrant returns (bool) {
        require(_to != address(0), ""Invalid address"");
        require(_value <= balanceOf(msg.sender), ""Insufficient balance"");

        _transfer(msg.sender, _to, _value);

        return true;
    }
}",8.348778009414673,transferTokens,"[{'function': 'transferTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.7622413833167485,0.2786312783602775,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, ReentrancyGuard, Ownable {
    mapping(address => uint256) public balanceOf;

 constructor() ERC20(""MyToken"", ""MTK"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 1 * 10**uint256(decimals());
        _mint(msg.sender, initialSupply);
    }

    function transferTokens(address _to, uint256 _value) public nonReentrant returns (bool) {
        require(_to != address(0), ""Invalid address"");
        require(_value <= balanceOf(msg.sender), ""Insufficient balance"");

        _transfer(msg.sender, _to, _value);

        return true;
    }
}"
2600,This function will set the conversion rate .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public rateMe;

    function setRate(uint _rateMe) public onlyOwner {
        rateMe = _rateMe;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";

contract ConversionRate is OwnableUpgradeable {
    uint256 private _conversionRate;

    function initialize(uint256 conversionRate) public initializer {
        __Ownable_init();
        _conversionRate = conversionRate;
    }

    function setConversionRate(uint256 newConversionRate) public onlyOwner {
        _conversionRate = newConversionRate;
    }

    function getConversionRate() public view returns (uint256) {
        return _conversionRate;
    }
}",8.201725006103516,initialize,"[{'function': 'initialize', 'complexity': 0}, {'function': 'setConversionRate', 'complexity': 0}, {'function': 'getConversionRate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""conversionRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""__Ownable_init""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_conversionRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""conversionRate""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""initializer"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",3.0,0.5856287104811967,0.0332718891397095,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ConversionRate is OwnableUpgradeable {
    uint256 private _conversionRate;

    constructor() initializer {
        __Ownable_init();
        _setConversionRate(1); // Safe, non-corner-case value for uint256
    }

    function initialize(uint256 conversionRate) public initializer {
        __Ownable_init();
        _setConversionRate(conversionRate);
    }

    function setConversionRate(uint256 newConversionRate) public onlyOwner {
        _setConversionRate(newConversionRate);
    }

    function getConversionRate() public view returns (uint256) {
        return _conversionRate;
    }

    function _setConversionRate(uint256 newConversionRate) internal {
        require(newConversionRate > 0, ""Conversion rate must be greater than zero""); // Ensure safe initialization
        _conversionRate = newConversionRate;
    }
}"
2777,Calls approve on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CompatibleERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract SafeApproveWrapper is Ownable {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 amount) internal {
        CompatibleERC20(token).approve(spender, amount);
        require(previousReturnValue(), ""approve failed"");
    }

    function previousReturnValue() private pure returns (bool) {
        // This is a placeholder for the actual logic to check if the approve call succeeded.
        // In practice, this would involve checking the return value of the approve function.
        // For simplicity, we assume it always succeeds in this example.
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenApprover {
    IERC20 private _token;

    constructor(IERC20 token) {
        _token = token;
    }

    function approveTokens(address spender, uint256 amount) external {
        bool success = _token.approve(spender, amount);
        require(success, ""Token approval failed"");
    }
}",7.30255389213562,approveTokens,"[{'function': 'approveTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token approval failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",8.0,0.439417626660729,0.0046370659297019,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApprover is Ownable {
    IERC20 private _token;

    constructor(IERC20 token) Ownable(msg.sender) {
        _token = token;
    }

    function approveTokens(address spender, uint256 amount) external {
        bool success = _token.approve(spender, amount);
        require(success, ""Token approval failed"");
    }
}"
2639,"The total SNX owned by this account , both escrowed and unescrowed , against which synths can be issued .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollateralWrapper {
    using SafeMath for uint256;

    address public tokenState;
    address public escrow;

    constructor(address _tokenState, address _escrow) {
        tokenState = _tokenState;
        escrow = _escrow;
    }

    function collateral(address account) public view returns (uint256) {
        uint256 balance = ITokenState(tokenState).balanceOf(account);
        if (escrow != address(0)) {
            balance = balance.add(IEscrow(escrow).balanceOf(account));
        }
        return balance;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract SynthetixAccount is Ownable {

   IERC20 public snxToken;
   mapping(address => uint256) private _escrowedBalance;

   constructor(IERC20 _tokenAddress) {
      snxToken = _tokenAddress;
   }

   function addEscrowedBalance(address account, uint256 amount) public onlyOwner {
      _escrowedBalance[account] = _escrowedBalance[account] + amount;
   }

   function totalSNX(address account) public view returns (uint256) {
      uint256 unescrowedSNX = snxToken.balanceOf(account);
      uint256 escrowedSNX = _escrowedBalance[account];
      return unescrowedSNX + escrowedSNX;
   }
}",8.967128038406372,totalSNX,"[{'function': 'addEscrowedBalance', 'complexity': 0}, {'function': 'totalSNX', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalSNX"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""unescrowedSNX"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""snxToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""escrowedSNX"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_escrowedBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""unescrowedSNX""}, ""right"": {""type"": ""Identifier"", ""name"": ""escrowedSNX""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",11.0,0.6199297532439206,0.223569615184145,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SynthetixAccount is Ownable {

   IERC20 public snxToken;
   mapping(address => uint256) private _escrowedBalance;

   mapping(address => uint256) public balanceOf;

 constructor(IERC20 _tokenAddress) Ownable(msg.sender) {
      snxToken = _tokenAddress;
      // Initialize state variables to safe, non-corner-case values
      _escrowedBalance[address(0)] = 1;
   }

   function addEscrowedBalance(address account, uint256 amount) public onlyOwner {
      _escrowedBalance[account] = _escrowedBalance[account] + amount;
   }

   function totalSNX(address account) public view returns (uint256) {
      uint256 unescrowedSNX = snxToken.balanceOf(account);
      uint256 escrowedSNX = _escrowedBalance[account];
      return unescrowedSNX + escrowedSNX;
   }
}"
4569,Returns all the relevant information about a specific whale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhaleMarketplace is Ownable {
    using SafeMath for uint256;

    struct Whale {
        string name;
    }

    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Whale storage whale = whales[_tokenId];
        Id = _tokenId;
        whaleName = whale.name;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract WhaleWatcher {
    using SafeMath for uint256;

    struct Whale {
        address whaleAddress;
        uint256 balance;
        bool isActive;
    }

    mapping(address => Whale) private whales;

    function getWhaleInfo(address _whaleAddress) public view returns (address, uint256, bool) {
        Whale storage whale = whales[_whaleAddress];
        return (whale.whaleAddress, whale.balance, whale.isActive);
    }
}",5.699469089508057,getWhaleInfo,"[{'function': 'getWhaleInfo', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getWhaleInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_whaleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Whale""}, ""name"": ""whale"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whales""}, ""index"": {""type"": ""Identifier"", ""name"": ""_whaleAddress""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""whale""}, ""memberName"": ""whaleAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""whale""}, ""memberName"": ""balance""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""whale""}, ""memberName"": ""isActive""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",20.0,0.7326431926858687,0.2167607547516839,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract WhaleWatcher is Ownable {
    using SafeMath for uint256;

    struct Whale {
        address whaleAddress;
        uint256 balance;
        bool isActive;
    }

    mapping(address => Whale) private whales;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address whaleAddress = address(uint160(i));
            whales[whaleAddress] = Whale({
                whaleAddress: whaleAddress,
                balance: 1, // Set to 1 never 0
                isActive: true
            });
        }
    }

    function getWhaleInfo(address _whaleAddress) public view returns (address, uint256, bool) {
        Whale storage whale = whales[_whaleAddress];
        return (whale.whaleAddress, whale.balance, whale.isActive);
    }
}"
3314,deliberately authorized the sender of the message via some mechanism,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SCComplianceService {
    function validate(address _from, address _to, uint256 _amount) external view returns (bool);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    bool public stopInEmergency = false;

    SCComplianceService public complianceService;

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
    }

    function setComplianceService(address _complianceService) public onlyOwner {
        complianceService = SCComplianceService(_complianceService);
    }

    function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {
        if (balances[_from] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the token balance of the source');
        }

        if (allowed[_from][msg.sender] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');
        }

        if (!complianceService.validate(_from, _to, _amount)) {
            revert('transferFrom: not allowed by the compliance service');
        }

        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        emit Transfer(_from, _to, _amount);

        return true;
    }

    function setStopInEmergency(bool _stop) public onlyOwner {
        stopInEmergency = _stop;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract AuthContract is Ownable {

    mapping(address => bool) private _authorizedUsers;

    function authorizeUser(address user) public onlyOwner {
        _authorizedUsers[user] = true;
    }

    function revokeUserAuthorization(address user) public onlyOwner {
        _authorizedUsers[user] = false;
    }

    function isUserAuthorized(address user) public view returns (bool) {
        return _authorizedUsers[user];
    }

    function executeAction() public {
        require(_authorizedUsers[msg.sender], ""Not authorized to execute this action"");
        // place the rest of the logic here
    }
}",8.132248640060425,executeAction,"[{'function': 'authorizeUser', 'complexity': 0}, {'function': 'revokeUserAuthorization', 'complexity': 0}, {'function': 'isUserAuthorized', 'complexity': 0}, {'function': 'executeAction', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""authorizeUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_authorizedUsers""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",72.0,0.3430763405721376,0.0005577342610067,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AuthContract is Ownable {
    mapping(address => bool) private _authorizedUsers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _authorizedUsers[addr] = true;
        }
    }

    function authorizeUser(address user) public onlyOwner {
        _authorizedUsers[user] = true;
    }

    function revokeUserAuthorization(address user) public onlyOwner {
        _authorizedUsers[user] = false;
    }

    function isUserAuthorized(address user) public view returns (bool) {
        return _authorizedUsers[user];
    }

    function executeAction() public {
        require(_authorizedUsers[msg.sender], ""Not authorized to execute this action"");
        // place the rest of the logic here
    }
}"
3619,Get the tags related to the module factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TagProvider {
    using SafeMath for uint256;

    function getTags() public view returns (bytes32[] memory) {
        bytes32[] memory availableTags = new bytes32[](2);
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
        return availableTags;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";

contract ModuleFactory is Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _moduleIds;

    struct Module {
        uint256 id;
        string name;
        address moduleAddress;
        string[] tags;
    }

    mapping(uint256 => Module) public modules;

    function createModule(string calldata name, address moduleAddress, string[] calldata tags) external onlyOwner {
        _moduleIds.increment();
        uint256 newModuleId = _moduleIds.current();
        modules[newModuleId] = Module(newModuleId, name, moduleAddress, tags);
    }

    function getModuleTags(uint256 moduleId) public view returns(string[] memory){
        require(modules[moduleId].id != 0, ""Invalid module ID"");
        return modules[moduleId].tags;
    }
}",9.58815884590149,createModule,"[{'function': 'createModule', 'complexity': 0}, {'function': 'getModuleTags', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""moduleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""length"": None}, ""name"": ""tags"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_moduleIds""}, ""memberName"": ""increment""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newModuleId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_moduleIds""}, ""memberName"": ""current""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""newModuleId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Module""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newModuleId""}, {""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""moduleAddress""}, {""type"": ""Identifier"", ""name"": ""tags""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.378076808812417,0.0172887412312779,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Counters.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ModuleFactory is Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _moduleIds;

    struct Module {
        uint256 id;
        string name;
        address moduleAddress;
        string[] tags;
    }

    mapping(uint256 => Module) public modules;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _moduleIds = Counters.Counter(1); // Start from 1 instead of 0
    }

    function createModule(string calldata name, address moduleAddress, string[] calldata tags) external onlyOwner {
        uint256 newModuleId = _moduleIds.current();
        modules[newModuleId] = Module(newModuleId, name, moduleAddress, tags);
        _moduleIds.increment(); // Increment after use
    }

    function getModuleTags(uint256 moduleId) public view returns(string[] memory){
        require(modules[moduleId].id != 0, ""Invalid module ID"");
        return modules[moduleId].tags;
    }
}"
3235,Invoke ` onERC721Received ` on a target address ( not executed if the target address is not a contract ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721Wrapper is Ownable {
    using SafeMath for uint256;

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal returns (bool) {
        if (!_to.isContract()) return true;
        bytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
        return (retval == 0x150b7a02); // ERC721_RECEIVED is the keccak-256 hash of ""onERC721Received(address,address,uint256,bytes)""
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

contract MyContract {
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public {
        require(_to != address(0x0), ""Invalid address"");
        // ERC721 basic transfer
        // Replace the below function with actual ERC721 transfer function
        // ERC721(_from).transfer(_to, _tokenId)

        // Check if the target address is a contract
        if (isContract(_to)) {
            require(IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) == IERC721Receiver.onERC721Received.selector, ""ERC721: transfer to non ERC721Receiver implementer"");
        }
    }

    function isContract(address account) internal view returns(bool) {
        uint32 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}",7.666673898696899,safeTransferFrom,"[{'function': 'safeTransferFrom', 'complexity': 3}, {'function': 'isContract', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""account"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",24.0,0.8173879355015857,0.2972195226927221,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant _INITIAL_VALUE = 1;
    address public constant _DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    bool public constant _DEFAULT_BOOL = true;
    string public constant _DEFAULT_STRING = 'initialized';
    bytes32 public constant _DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        uint256 instanceValue = _INITIAL_VALUE;
        address instanceAddress = _DEFAULT_ADDRESS;
        bool instanceBool = _DEFAULT_BOOL;
        string instanceString = _DEFAULT_STRING;
        bytes32 instanceBytes32 = _DEFAULT_BYTES32;

        // Initialize parent contracts
        super();
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public {
        require(_to != address(0x0), ""Invalid address"");
        // ERC721 basic transfer
        // Replace the below function with actual ERC721 transfer function
        // ERC721(_from).transfer(_to, _tokenId)

        // Check if the target address is a contract
        if (isContract(_to)) {
            require(IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) == IERC721Receiver.onERC721Received.selector, ""ERC721: transfer to non ERC721Receiver implementer"");
        }
    }

    function isContract(address account) internal view returns(bool) {
        uint32 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}"
4896,Set whether prices can be changed manually .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public allowChangePrice;

    function setAllowChangePrice(bool _allowChangePrice) external onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PriceManager is Ownable {
    bool public isManualPriceAllowed;

    function setManualPriceAllowed(bool _isManualPriceAllowed) public onlyOwner {
        isManualPriceAllowed = _isManualPriceAllowed;
    }
}",3.7215652465820312,setManualPriceAllowed,"[{'function': 'setManualPriceAllowed', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setManualPriceAllowed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_isManualPriceAllowed"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isManualPriceAllowed""}, ""right"": {""type"": ""Identifier"", ""name"": ""_isManualPriceAllowed""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",0.0,0.688377555195606,0.0449412542808265,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceManager is Ownable {
    bool public isManualPriceAllowed;

    constructor() Ownable(msg.sender) {
        isManualPriceAllowed = true; // Set to true instead of false, as per initialization rules
    }

    function setManualPriceAllowed(bool _isManualPriceAllowed) public onlyOwner {
        isManualPriceAllowed = _isManualPriceAllowed;
    }
}"
5609,Updates registration status for multiple addresses for participation,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function changeRegistrationStatus(address target, bool isRegistered) public onlyOwner {
        // Implementation of changing registration status
    }

    function changeRegistrationStatuses(address[] memory targets, bool isRegistered) public onlyOwner {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract Registration is AccessControl {
    bytes32 public constant REGISTRAR_ROLE = keccak256(""REGISTRAR_ROLE"");
    mapping(address => bool) public isRegistered;

    constructor() {
        _setupRole(REGISTRAR_ROLE, msg.sender);
    }

    function updateRegistrationStatus(address[] memory addresses, bool status) public onlyRole(REGISTRAR_ROLE) {
        uint256 length = addresses.length;
        for (uint256 i = 0; i < length; i++) {
            isRegistered[addresses[i]] = status;
        }
    }
}",10.68938374519348,updateRegistrationStatus,"[{'function': 'updateRegistrationStatus', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateRegistrationStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""addresses"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""status"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""length"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isRegistered""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""Identifier"", ""name"": ""status""}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""REGISTRAR_ROLE""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",9.0,0.7768005738778873,0.204274649482313,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Registration is AccessControl, Ownable {
    bytes32 public constant REGISTRAR_ROLE = keccak256(""REGISTRAR_ROLE"");
    mapping(address => bool) public isRegistered;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // Assuming DEFAULT_ADMIN_ROLE for ownership in this context
        _setupRole(REGISTRAR_ROLE, msg.sender);
    }

    function updateRegistrationStatus(address[] memory addresses, bool status) public onlyRole(REGISTRAR_ROLE) {
        uint256 length = addresses.length;
        for (uint256 i = 0; i < length; i++) {
            isRegistered[addresses[i]] = status;
        }
    }
}"
3896,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract BeneficiaryManager is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    IERC20 public token;
    mapping(address => Beneficiary) public beneficiaries;
    address[] public addresses;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _token, address[] memory initialBeneficiaries) {
        token = IERC20(_token);
        for (uint i = 0; i < initialBeneficiaries.length; i++) {
            beneficiaries[initialBeneficiaries[i]] = Beneficiary({isBeneficiary: true, vested: 0, released: 0});
        }
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary].isBeneficiary, ""Beneficiary does not exist"");
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        token.transfer(owner(), balance);
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        for (uint i = 0; i < addresses.length - 1; i++) {
            if (addresses[i] == _beneficiary) {
                addresses[i] = addresses[addresses.length - 1];
                break;
            }
        }
        addresses.pop();
        emit BeneficiaryDestroyed(_beneficiary);
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    mapping(address => bool) public beneficiaries;

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary] == true, ""Beneficiary does not exist"");
        delete beneficiaries[_beneficiary];
    }
}",4.359973907470703,destroyBeneficiary,"[{'function': 'destroyBeneficiary', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",71.0,0.9170498167647436,0.0314189902818406,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => bool) public beneficiaries;
    address public owner;
    uint256 public constant BENEFICIARY_COUNT = 1;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        owner = msg.sender;
        beneficiaries[msg.sender] = true;
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary] == true, ""Beneficiary does not exist"");
        delete beneficiaries[_beneficiary];
    }
}"
2053,Create ` msg.value ` ETH worth of GMT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint256 public tokenExchangeRate = 1000; // Example rate, adjust as needed
    uint256 public totalSupply = 1000000 * (10 ** 18); // Example total supply, adjust as needed
    uint256 public assignedSupply;
    uint256 public gmtFund;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return assignedSupply.add(tokens) <= totalSupply;
    }

    function claimTokens() public payable {
        require(msg.value > 0, ""Value must be greater than zero"");
        uint256 tokens = msg.value.mul(tokenExchangeRate);
        require(isWithinCap(tokens), ""Claim exceeds the token cap"");
        uint256 checkedSupply = assignedSupply.add(tokens);
        require(checkedSupply.add(gmtFund) <= totalSupply, ""Total supply would be exceeded"");
        balances[msg.sender] = balances[msg.sender].add(tokens);
        purchases[msg.sender] = purchases[msg.sender].add(tokens);
        assignedSupply = checkedSupply;
        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }
}","y
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenSale is Ownable {

  using SafeMath for uint256;

  IERC20 private _token;
  uint256 private _tokenPrice;

  constructor (IERC20 token, uint256 tokenPrice) {
    _token = token;
    _tokenPrice = tokenPrice;
  }

  function buyTokens() public payable {
    uint256 numberOfTokens = msg.value.div(_tokenPrice);
    uint256 scaledAmount = numberOfTokens.mul(10 ** (18 - _token.decimals()));
    require(_token.balanceOf(address(this)) >= scaledAmount, ""Not enough tokens in the reserve"");
    _token.transfer(msg.sender, scaledAmount);
  }
}",9.693732738494871,buyTokens,"[{'function': 'buyTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numberOfTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenPrice""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""scaledAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numberOfTokens""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""decimals""}, ""arguments"": [], ""names"": []}}], ""isArray"": False}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""scaledAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in the reserve""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""scaledAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",63.0,0.667336248367993,0.0887703052048825,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenSale is Ownable {
  using SafeMath for uint256;

  IERC20 private _token;
  uint256 private _tokenPrice;

  mapping(address => uint256) public balanceOf;

 constructor(IERC20 token, uint256 tokenPrice) Ownable() {
    require(address(token) != address(0), ""Invalid token address"");
    _token = token;
    _tokenPrice = tokenPrice;
  }

  function buyTokens() public payable {
    uint256 numberOfTokens = msg.value.div(_tokenPrice);
    uint256 scaledAmount = numberOfTokens.mul(10 ** (18 - _token.decimals()));
    require(_token.balanceOf(address(this)) >= scaledAmount, ""Not enough tokens in the reserve"");
    _token.transfer(msg.sender, scaledAmount);
  }
}"
306,How many HEAL tokens do this contract have,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EthealToken {
    function balanceOf(address account) external view returns (uint256);
}

interface EthealController {
    function ethealToken() external view returns (EthealToken);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    EthealController public ethealController;

    constructor(address _ethealController) {
        require(_ethealController != address(0), ""Invalid controller address"");
        ethealController = EthealController(_ethealController);
    }

    function getHealBalance() view public returns (uint256) {
        return ethealController.ethealToken().balanceOf(address(this));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract HealTokenContract {
    ERC20 public healToken;

    constructor(address _healToken) {
        healToken = ERC20(_healToken);
    }

    function contractTokenBalance() public view returns (uint256) {
        return healToken.balanceOf(address(this));
    }
}",7.009634017944336,contractTokenBalance,"[{'function': 'contractTokenBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""contractTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""healToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",2.0,0.8440615152589338,0.5279415183470275,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HealTokenContract is Ownable, ERC20 {
    mapping(address => uint256) public balanceOf;

 constructor() ERC20(""MyToken"", ""TKN"") {
        _mint(address(this), 1 ether); // Initialize the token supply to 1 unit of the token
        healToken = ERC20(_healToken);
    }

    function contractTokenBalance() public view returns (uint256) {
        return balanceOf(address(this));
    }
}"
3644,"Pledges fees to the token holders , later to be claimed by burning","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeFeesWrapper {
    using SafeMath for uint256;

    uint public totalPledgedFees;
    mapping(uint => uint) public totalPledgedFeesHistory;
    address private controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor() {
        controller = msg.sender;
    }

    function pledgeFees(uint _value) public onlyController returns (bool) {
        uint curTotalFees = totalPledgedFees();
        require(curTotalFees + _value >= curTotalFees, ""SafeMath: addition overflow"");
        updateValueAtNow(totalPledgedFeesHistory, curTotalFees.add(_value));
        return true;
    }

    function totalPledgedFees() public view returns (uint) {
        return totalPledgedFees;
    }

    function updateValueAtNow(mapping(uint => uint) storage _map, uint _value) internal {
        totalPledgedFees = _value;
    }
}","//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract FeePledge is Ownable, ReentrancyGuard{

    IERC20 public token;
    mapping(address => uint256) private pledgedFees;

    constructor(IERC20 _token) {
        token = _token;
    }

    function pledgeFees(address _to, uint256 _amount) external onlyOwner nonReentrant {
        require(token.balanceOf(address(this)) >= _amount, ""Insufficient balance for pledge"");
        token.transfer(_to, _amount);
        pledgedFees[_to] = _amount;
    }

    function claimFeesByBurning(address _from) external onlyOwner nonReentrant {
        require(token.balanceOf(_from) >= pledgedFees[_from], ""Insufficient balance to burn"");
        token.burn(_from, pledgedFees[_from]);
        pledgedFees[_from] = 0;
    }
}",11.19788694381714,pledgeFees,"[{'function': 'pledgeFees', 'complexity': 1}, {'function': 'claimFeesByBurning', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""pledgeFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance for pledge""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pledgedFees""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.7355874538928177,0.0413144024639438,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FeePledge is Ownable, ReentrancyGuard {
    IERC20 public token;
    mapping(address => uint256) private pledgedFees;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function pledgeFees(address _to, uint256 _amount) external onlyOwner nonReentrant {
        require(token.balanceOf(address(this)) >= _amount, ""Insufficient balance for pledge"");
        token.transfer(_to, _amount);
        pledgedFees[_to] = _amount;
    }

    function claimFeesByBurning(address _from) external onlyOwner nonReentrant {
        require(token.balanceOf(_from) >= pledgedFees[_from], ""Insufficient balance to burn"");
        token.burn(_from, pledgedFees[_from]);
        pledgedFees[_from] = 0;
    }
}"
6330,Helper function that calculates the valuation of the asset in terms of an ART token quantity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public oracle_price_decimals_factor = 10**18; // Example factor, adjust as needed
    uint256 public decimal_precission_difference_factor = 10**18; // Example factor, adjust as needed

    function convert_valuation_to_art(uint256 _valuation, uint256 _art_price) public view returns (uint256 amount) {
        amount = ((_valuation.mul(oracle_price_decimals_factor)).div(_art_price)).mul(decimal_precission_difference_factor);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AssetValuation is ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public constant ART_TOKEN_PRICE = 1 ether;

    function assetValuationInArt(uint256 assetValue) public pure nonReentrant returns (uint256) {
        require(assetValue > 0, ""Asset value must be greater than zero"");

        uint256 assetValueInArt = assetValue.div(ART_TOKEN_PRICE);
        return assetValueInArt;
    }
}",6.652232885360718,assetValuationInArt,"[{'function': 'assetValuationInArt', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""assetValuationInArt"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""assetValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""assetValue""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Asset value must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""assetValueInArt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""assetValue""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ART_TOKEN_PRICE""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""assetValueInArt""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",27.0,0.2033861698061518,0.0368488765169076,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AssetValuation is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    uint256 public constant ART_TOKEN_PRICE = 1 ether;

    function assetValuationInArt(uint256 assetValue) public pure nonReentrant returns (uint256) {
        require(assetValue > 0, ""Asset value must be greater than zero"");

        uint256 assetValueInArt = assetValue.div(ART_TOKEN_PRICE);
        return assetValueInArt;
    }
}"
5296,"Remove a node from the list , and fix the previous and next pointers that are pointing to the removed node .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address previous;
        address next;
        bool inList;
    }

    mapping(address => Node) public list;

    function isInList(List storage self, address node) internal view returns (bool) {
        return self.list[node].inList;
    }

    function remove(List storage self, address node) internal {
        require(isInList(self, node), ""not in list"");
        if (node == address(0)) {
            return;
        }
        address p = self.list[node].previous;
        address n = self.list[node].next;
        self.list[p].next = n;
        self.list[n].previous = p;
        self.list[node].inList = false;
        delete self.list[node];
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LinkedList {
    struct Node {
        uint data;
        uint prev;
        uint next;
    }

    mapping (uint => Node) public nodes;
    uint public size;

    function removeNode(uint index) public {
        require(index < size, ""Invalid index"");

        // Fixing previous and next pointers
        if (index > 0) {
            nodes[index - 1].next = nodes[index].next;
        }

        if (index < size - 1) {
            nodes[nodes[index].next].prev = nodes[index].prev;
        }

        // Deleting node from the mapping and reducing size
        delete nodes[index];
        size -= 1;
    }
}",6.832864046096802,removeNode,"[{'function': 'removeNode', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeNode"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""Identifier"", ""name"": ""size""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid index""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""memberName"": ""next""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""next""}}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""next""}}, ""memberName"": ""prev""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""prev""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",43.0,0.6208240589995632,0.0300218250914143,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LinkedList is Ownable {
    struct Node {
        uint data;
        uint prev;
        uint next;
    }

    mapping (uint => Node) public nodes;
    uint public size;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        size = 0;
    }

    function removeNode(uint index) public {
        require(index < size, ""Invalid index"");

        // Fixing previous and next pointers
        if (index > 0) {
            nodes[index - 1].next = nodes[index].next;
        }

        if (index < size - 1) {
            nodes[nodes[index].next].prev = nodes[index].prev;
        }

        // Deleting node from the mapping and reducing size
        delete nodes[index];
        size -= 1;
    }
}"
1009,Function that registers new synth as they are isseud .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SynthetixState {
    function incrementTotalIssuerCount() external;
    function setCurrentIssuanceData(address issuer, uint debtPercentage) external;
    function appendDebtLedgerValue(uint value) external;
    function lastDebtLedgerEntry() external view returns (uint);
    function hasIssued(address account) external view returns (bool);
    function debtLedgerLength() external view returns (int);
}

interface Synth {
    function effectiveValue(bytes4 currencyKey, uint amount, bytes32 destinationCurrencyKey) external pure returns (uint);
    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);
}

interface DebtCache {
    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);
}

abstract contract DebtRegisterWrapper is Ownable {
    using SafeMath for uint;
    using SafeDecimalMath for uint;

    SynthetixState public synthetixState;
    Synth public synth;
    DebtCache public debtCache;

    constructor(address _synthetixState, address _synth, address _debtCache) {
        synthetixState = SynthetixState(_synthetixState);
        synth = Synth(_synth);
        debtCache = DebtCache(_debtCache);
    }

    function _addToDebtRegister(bytes4 currencyKey, uint amount) external optionalProxy {
        require(msg.sender == address(this), ""Only callable by this contract"");

        uint xdrValue = synth.effectiveValue(currencyKey, amount, ""XDR"");
        uint totalDebtIssued = synth.totalIssuedSynths(""XDR"");
        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);
        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);
        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);
        uint existingDebt = debtCache.debtBalanceOf(msg.sender, ""XDR"");

        if (existingDebt > 0) {
            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);
        }

        if (!synthetixState.hasIssued(msg.sender)) {
            synthetixState.incrementTotalIssuerCount();
        }

        synthetixState.setCurrentIssuanceData(msg.sender, debtPercentage);

        if (synthetixState.debtLedgerLength() > 0) {
            synthetixState.appendDebtLedgerValue(synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));
        } else {
            synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract SynthsRegistry is Ownable {
    struct Synth {
        string name;
        address contractAddress;
    }

    mapping(string => Synth) public synths;

    function registerSynth(string memory _name, address _contractAddress) public onlyOwner {
        require(_contractAddress != address(0), ""Invalid address"");
        require(bytes(_name).length > 0, ""Invalid name"");

        Synth memory newSynth = Synth({
            name: _name,
            contractAddress: _contractAddress
        });

        synths[_name] = newSynth;
    }
}",6.0434770584106445,registerSynth,"[{'function': 'registerSynth', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_contractAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid name""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Synth""}, ""name"": ""newSynth"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synth""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_name""}, {""type"": ""Identifier"", ""name"": ""_contractAddress""}], ""names"": [""name"", ""contractAddress""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""_name""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newSynth""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",74.0,0.5129508968528663,0.0081395523268186,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SynthsRegistry is Ownable {
    struct Synth {
        string name;
        address contractAddress;
    }

    mapping(string => Synth) public synths;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function registerSynth(string memory _name, address _contractAddress) public onlyOwner {
        require(_contractAddress != address(0), ""Invalid address"");
        require(bytes(_name).length > 0, ""Invalid name"");

        Synth memory newSynth = Synth({
            name: _name,
            contractAddress: _contractAddress
        });

        synths[_name] = newSynth;
    }
}"
5740,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    constructor() {}

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) onlyOwner public {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenExchange is ReentrancyGuard {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public buyPrice;
    uint256 public sellPrice;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) external {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }

    function buyTokens(uint256 amount) external payable nonReentrant {
        require(msg.value == amount.mul(buyPrice), ""Ether value sent is not correct"");

        uint256 tokenAmount = amount.div(buyPrice);
        require(token.balanceOf(address(this)) >= tokenAmount, ""Insufficient tokens in contract"");

        token.transfer(msg.sender, tokenAmount);
    }

    function sellTokens(uint256 tokenAmount) external nonReentrant {
        require(token.balanceOf(msg.sender) >= tokenAmount, ""Insufficient tokens in user balance"");

        uint256 etherAmount = tokenAmount.mul(sellPrice);
        require(address(this).balance >= etherAmount, ""Insufficient Ether in contract"");

        token.transferFrom(msg.sender, address(this), tokenAmount);
        payable(msg.sender).transfer(etherAmount);
    }
}",15.644625902175903,sellTokens,"[{'function': 'setPrices', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 2}, {'function': 'sellTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sellTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient tokens in user balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""etherAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sellPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""etherAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient Ether in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""tokenAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""etherAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",38.0,0.4569488299653397,0.0084696743690812,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenExchange is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public buyPrice;
    uint256 public sellPrice;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
        buyPrice = 1; // Set to 1 (never 0)
        sellPrice = 1; // Set to 1 (never 0)
    }

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) external {
        require(newBuyPrice > 0, ""Buy price must be greater than zero"");
        require(newSellPrice > 0, ""Sell price must be greater than zero"");
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }

    function buyTokens(uint256 amount) external payable nonReentrant {
        require(msg.value == amount.mul(buyPrice), ""Ether value sent is not correct"");

        uint256 tokenAmount = amount.div(buyPrice);
        require(token.balanceOf(address(this)) >= tokenAmount, ""Insufficient tokens in contract"");

        token.transfer(msg.sender, tokenAmount);
    }

    function sellTokens(uint256 tokenAmount) external nonReentrant {
        require(token.balanceOf(msg.sender) >= tokenAmount, ""Insufficient tokens in user balance"");

        uint256 etherAmount = tokenAmount.mul(sellPrice);
        require(address(this).balance >= etherAmount, ""Insufficient Ether in contract"");

        token.transferFrom(msg.sender, address(this), tokenAmount);
        payable(msg.sender).transfer(etherAmount);
    }
}"
4219,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AIX {
    function totalSupply() external view returns (uint256);
    function generateTokens(address to, uint256 value) external;
}

abstract contract Finalizable is Ownable {
    using SafeMath for uint256;

    AIX public aix;
    address public remainderHolder;
    address public devHolder;
    address public communityHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public constant TOKEN_CAP_MULTIPLIER = 100;
    uint256 public constant TOKEN_DISTRIBUTION_RATIO = 51;

    event Finalized(uint256 indexed blockNumber);

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == controller || getBlockTimestamp() > endTime || weiToCollect() == 0);

        aix.generateTokens(remainderHolder, weiToCollect().mul(2000));
        uint256 tokenCap = aix.totalSupply().mul(TOKEN_CAP_MULTIPLIER).div(TOKEN_DISTRIBUTION_RATIO);
        aix.generateTokens(devHolder, tokenCap.mul(20).div(100));
        aix.generateTokens(communityHolder, tokenCap.mul(29).div(100));

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public endTime;
    bool public contributionPeriodEnded;

    event ContributionPeriodEndTriggered(address indexed triggerer, uint256 timestamp);

    function endContributionPeriod() public nonReentrant {
        require(block.timestamp > endTime || _msgSender() == owner(), ""Cannot end contribution period"");
        contributionPeriodEnded = true;
        emit ContributionPeriodEndTriggered(_msgSender(), block.timestamp);
    }
}",11.478524923324583,endContributionPeriod,"[{'function': 'endContributionPeriod', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""endContributionPeriod"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Cannot end contribution period""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contributionPeriodEnded""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ContributionPeriodEndTriggered""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",79.0,0.4873434013069066,0.0121748818442553,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable, ReentrancyGuard {
    using SafeMath for uint256;

    uint256 public endTime = 1; // Set to 1 instead of 0
    bool public contributionPeriodEnded = false; // Set to false instead of true

    event ContributionPeriodEndTriggered(address indexed triggerer, uint256 timestamp);

    constructor() Ownable(msg.sender) {
        // No need to initialize endTime and contributionPeriodEnded again as they are already initialized in the state variables
    }

    function endContributionPeriod() public nonReentrant {
        require(block.timestamp > endTime || _msgSender() == owner(), ""Cannot end contribution period"");
        contributionPeriodEnded = true;
        emit ContributionPeriodEndTriggered(_msgSender(), block.timestamp);
    }
}"
6178,Checks whether the contract operations is paused or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Encoder {
    function getKey(string memory key) external pure returns (bytes32);
}

abstract contract Pausable is Ownable {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private pausedMap;
    Encoder public encoder;

    constructor(address _encoderAddress) {
        encoder = Encoder(_encoderAddress);
    }

    function getBool(bytes32 key) internal view returns (bool) {
        return pausedMap[key];
    }

    function isPaused() public view returns (bool) {
        return getBool(encoder.getKey(""paused""));
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/Pausable.sol"";

contract OperationsPauser is Pausable {
    function checkIfOperationIsPaused() public view returns(bool) {
        return paused();
    }
}",6.114253997802734,checkIfOperationIsPaused,"[{'function': 'checkIfOperationIsPaused', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkIfOperationIsPaused"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""paused""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",4.0,0.5967580343218962,0.3898938932918352,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OperationsPauser is Pausable, Ownable {
    constructor() Pausable(), Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function checkIfOperationIsPaused() public view returns(bool) {
        return paused();
    }
}"
1600,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ConverterRamp {
    // Define the interface of the ConverterRamp contract here if necessary
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    ConverterRamp public converterRamp;

    event SetConverterRamp(ConverterRamp indexed oldConverterRamp, ConverterRamp indexed newConverterRamp);

    function setConverterRamp(ConverterRamp _converterRamp) external onlyOwner returns (bool) {
        require(_isContract(_converterRamp), ""Should be a contract"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","// Import OpenZeppelin's SafeMath library
import ""@openzeppelin/contracts/math/SafeMath.sol"";

// Import access control library
import ""@openzeppelin/contracts/access/Ownable.sol"";

pragma solidity ^0.8.0;

contract LoanContract is Ownable {
  using SafeMath for uint256;

  // State variable
  address public converterRamp;

  // Event that triggers when a new converter ramp is set
  event NewConverterRamp(address newConverterRamp);

  // Only owner can set new converter ramp
  function setConverterRamp(address _newConverterRamp) public onlyOwner {
    // Check if the address is not a zero address
    require(_newConverterRamp != address(0), ""Invalid address"");

    // Change the converter ramp
    converterRamp = _newConverterRamp;

    // Triggering the NewConverterRamp event
    emit NewConverterRamp(_newConverterRamp);
  }
}",8.422056913375854,setConverterRamp,"[{'function': 'setConverterRamp', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newConverterRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newConverterRamp""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""converterRamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newConverterRamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NewConverterRamp""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newConverterRamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.8358814187667366,0.0387832708005715,"// Import OpenZeppelin's SafeMath library
import ""node_modules/@openzeppelin/contracts/math/SafeMath.sol"";

// Import access control library
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

pragma solidity ^0.8.0;

contract LoanContract is Ownable {
  using SafeMath for uint256;

  // State variable
  address public converterRamp;

  // Event that triggers when a new converter ramp is set
  event NewConverterRamp(address newConverterRamp);

  // Only owner can set new converter ramp
  function setConverterRamp(address _newConverterRamp) public onlyOwner {
    // Check if the address is not a zero address
    require(_newConverterRamp != address(0), ""Invalid address"");

    // Change the converter ramp
    converterRamp = _newConverterRamp;

    // Triggering the NewConverterRamp event
    emit NewConverterRamp(_newConverterRamp);
  }
}"
4079,Get the token spender allowance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

abstract contract TokenAllowanceWrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) Storage;
    }

    function getTokenAllowance(Data storage self, string memory currency, address account, address spender) internal view returns (uint256 allowance) {
        bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, _getForwardedAccount(self, account), _getForwardedAccount(self, spender)));
        return self.Storage[id];
    }

    function _getForwardedAccount(Data storage self, address account) private view returns (address) {
        // Implement any forwarding logic here if necessary
        return account;
    }
}","Solidity function that retrieves the token spender's allowance for a given account. It uses the ERC20 standard interface for tokens, which includes an ""allowance"" function.

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract AllowanceChecker {
    IERC20 private _token;

    constructor(address tokenAddress) {
        _token = IERC20(tokenAddress);
    }

    function getTokenAllowance(address owner, address spender) external view returns (uint256) {
        return _token.allowance(owner, spender);
    }
}",7.260274887084961,getTokenAllowance,"[{'function': 'getTokenAllowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",21.0,0.8267767252245682,0.0951517163729446," ```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AllowanceChecker is Ownable {
    IERC20 private _token;

    constructor(address tokenAddress) Ownable(msg.sender) {
        _token = IERC20(tokenAddress);
    }

    function getTokenAllowance(address owner, address spender) external view returns (uint256) {
        return _token.allowance(owner, spender);
    }
}
```"
5836,amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint public tokenMinted;

    function getTokenMinted() public constant returns (uint) {
        return tokenMinted;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract MyToken is ERC20, Pausable, Ownable, ReentrancyGuard {
    uint256 public mintedTokens;

    constructor() ERC20(""MyToken"", ""MTK"") {}

    function mint(address to, uint256 amount) external onlyOwner nonReentrant whenNotPaused {
        mintedTokens += amount;
        _mint(to, amount);
    }
}",12.238099336624146,mint,"[{'function': 'mint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""mintedTokens""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",14.0,0.5681131898742917,0.0123225068485656,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Pausable, Ownable, ReentrancyGuard {
    uint256 public mintedTokens;

    constructor() ERC20(""MyToken"", ""MTK"") Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        mintedTokens = 1;
    }

    function mint(address to, uint256 amount) external onlyOwner nonReentrant whenNotPaused {
        mintedTokens += amount;
        _mint(to, amount);
    }
}"
6399,Sets an external ` manager ` that will be able to call ` setInterfaceImplementer ( ) ` on behalf of the address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ManagerChange {
    using SafeMath for uint256;

    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Only the current manager can change the manager."");
        _;
    }

    function changeManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ERC1820ImplementerInterface {
    function canImplementInterfaceForAddress(address account, bytes32 interfaceHash) external view returns(bytes32);
}

contract TestContract {
    address public manager;
    mapping(address => mapping(bytes32 => address)) internal interfaces;

    modifier onlyManager() {
        require(msg.sender == manager, ""Access is allowed only for manager"");
        _;
    }

    function setManager(address _manager) public onlyManager {
        manager = _manager;
    }

    function setInterfaceImplementer(address _address, bytes32 _interfaceHash, address _implementer) public onlyManager {
        if (_implementer != address(0)) {
            require(ERC1820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_address, _interfaceHash) == bytes32(0), ""Can't implement this interface for this address"");
        }

        interfaces[_address][_interfaceHash] = _implementer;
    }
}",9.990203857421877,setInterfaceImplementer,"[{'function': 'canImplementInterfaceForAddress', 'complexity': 0}, {'function': 'setManager', 'complexity': 0}, {'function': 'setInterfaceImplementer', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInterfaceImplementer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_interfaceHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_implementer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_implementer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC1820ImplementerInterface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_implementer""}], ""names"": []}, ""memberName"": ""canImplementInterfaceForAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""_interfaceHash""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Can""t implement this interface for this address""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""interfaces""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_interfaceHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_implementer""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",13.0,0.5017061461695311,0.0317221763598249,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface ERC1820ImplementerInterface {
    function canImplementInterfaceForAddress(address account, bytes32 interfaceHash) external view returns(bytes32);
}
import ""openzeppelin/SafeMath.sol"";
contract TestContract is Ownable {
    address public manager;
    mapping(address => mapping(bytes32 => address)) internal interfaces;

    modifier onlyManager() {
        require(msg.sender == manager, ""Access is allowed only for manager"");
        _;
    }

    constructor() Ownable(msg.sender) {
        manager = msg.sender; // Initialize to the deployer's address
    }

    function setManager(address _manager) public onlyOwner {
        manager = _manager;
    }

    function setInterfaceImplementer(address _address, bytes32 _interfaceHash, address _implementer) public onlyOwner {
        if (_implementer != address(0)) {
            require(ERC1820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_address, _interfaceHash) == bytes32(0), ""Can't implement this interface for this address"");
        }

        interfaces[_address][_interfaceHash] = _implementer;
    }
}"
5804,Returns current sell offer for the canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasMarketplace is Ownable {
    using SafeMath for uint256;

    struct SellOffer {
        bool isForSale;
        address seller;
        uint minPrice;
        address onlySellTo;
    }

    mapping(uint32 => SellOffer) public canvasForSale;

    function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint minPrice, address onlySellTo) {
        SellOffer storage offer = canvasForSale[_canvasId];
        return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ArtCanvas is Ownable {
    struct SaleOffer {
        address seller;
        uint256 price;
    }

    mapping(uint256 => SaleOffer) private saleOffers;

    function currentSellOfferForCanvas(uint256 canvasId) public view returns(address, uint256) {
        SaleOffer memory offer = saleOffers[canvasId];

        require(saleOffers[canvasId].seller != address(0), ""No sell offer found."");

        return (offer.seller, offer.price);
    }
}",10.974442958831789,currentSellOfferForCanvas,"[{'function': 'currentSellOfferForCanvas', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""currentSellOfferForCanvas"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""SaleOffer""}, ""name"": ""offer"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""saleOffers""}, ""index"": {""type"": ""Identifier"", ""name"": ""canvasId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""saleOffers""}, ""index"": {""type"": ""Identifier"", ""name"": ""canvasId""}}, ""memberName"": ""seller""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""No sell offer found.""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""seller""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""price""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",16.0,0.8778316324456382,0.0580355922620969,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ArtCanvas is Ownable {
    struct SaleOffer {
        address seller;
        uint256 price;
    }

    mapping(uint256 => SaleOffer) private saleOffers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            saleOffers[i] = SaleOffer({seller: address(uint160(uint256(keccak256(abi.encodePacked(""seller"", i)))), price: uint256(keccak256(abi.encodePacked(""price"", i)))});
        }
    }

    function currentSellOfferForCanvas(uint256 canvasId) public view returns (address, uint256) {
        SaleOffer memory offer = saleOffers[canvasId];

        require(saleOffers[canvasId].seller != address(0), ""No sell offer found."");

        return (offer.seller, offer.price);
    }
}"
1832,Generates ` amount ` tokens that are assigned to ` owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function mGenerateTokens(address owner, uint256 amount) internal {
        // logic goes here
    }
}","// Importing the OpenZeppelin 'SafeMath' library for safely performing mathematical operations
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

// Importing OpenZeppelin's ERC20 token contract
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    using SafeMath for uint256;

    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor(string memory name, string memory symbol, address _owner) ERC20(name, symbol) {
        owner = _owner;
    }

    function mintTokens(uint256 amount) public onlyOwner {
        _mint(owner, amount);
    }
}",12.040691137313845,mintTokens,"[{'function': 'mintTokens', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.7300656198938759,0.0829170593286543,"// Importing the OpenZeppelin 'SafeMath' library for safely performing mathematical operations
import ""openzeppelin/SafeMath.sol"";

// Importing OpenZeppelin's ERC20 token contract
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";

// Adding Ownable to the contract
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is ERC20, Ownable {
    using SafeMath for uint256;

    constructor(string memory name, string memory symbol, address _owner) ERC20(name, symbol) Ownable() {
        owner = _owner;
    }

    function mintTokens(uint256 amount) public onlyOwner {
        _mint(owner, amount);
    }
}"
107,Allows the owner to register and the details for a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRegistry is Ownable {
    using SafeMath for uint256;

    struct TokenInfo {
        address tokenAddress;
        uint8 tokenDecimals;
    }

    mapping(uint32 => TokenInfo) public tokenInfos;

    event RegisteredToken(uint32 indexed tokenCode, address indexed tokenAddress, uint8 tokenDecimals);

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(_tokenCode > 0, ""Invalid token code"");
        require(_tokenAddress != address(0), ""Invalid token address"");
        require(_tokenDecimals > 0, ""Invalid token decimals"");

        uint32 tokenCode = _tokenCode;
        address tokenAddress = _tokenAddress;
        uint8 tokenDecimals = _tokenDecimals;

        TokenInfo storage tokenInfo = tokenInfos[tokenCode];
        require(tokenInfo.tokenAddress == address(0), ""Token already registered"");

        tokenInfo.tokenAddress = tokenAddress;
        tokenInfo.tokenDecimals = tokenDecimals;

        emit RegisteredToken(_tokenCode, tokenAddress, tokenDecimals);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenRegistry is Ownable {

    struct TokenDetails {
        string name;
        string symbol;
        uint8 decimals;
    }

    mapping(address => TokenDetails) private tokenDetails;

    function registerToken(address tokenAddress, string memory name, string memory symbol, uint8 decimals) public onlyOwner {
        tokenDetails[tokenAddress] = TokenDetails({ name: name, symbol: symbol, decimals: decimals });
    }
}",8.17284870147705,registerToken,"[{'function': 'registerToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""symbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""decimals"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenDetails""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenDetails""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""symbol""}, {""type"": ""Identifier"", ""name"": ""decimals""}], ""names"": [""name"", ""symbol"", ""decimals""]}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",72.0,0.7973442579421481,0.0201594249349768,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRegistry is Ownable {

    struct TokenDetails {
        string name;
        string symbol;
        uint8 decimals;
    }

    mapping(address => TokenDetails) private tokenDetails;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            tokenDetails[addr] = TokenDetails({ name: 'initialized', symbol: 'init', decimals: 18 });
        }
    }

    function registerToken(address tokenAddress, string memory name, string memory symbol, uint8 decimals) public onlyOwner {
        tokenDetails[tokenAddress] = TokenDetails({ name: name, symbol: symbol, decimals: decimals });
    }
}"
2044,Mint ` _amount ` tokens that are assigned to ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function updateValueAtNow(mapping(address => uint256) storage data, uint value) external;
}

abstract contract Token is Ownable, IToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint256 => uint256) public totalSupplyHistory;
    bool public finalized;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyController() {
        require(isController[msg.sender], ""Only controller can call this function"");
        _;
    }

    modifier notFinalized() {
        require(!finalized, ""Contract is finalized and cannot be modified"");
        _;
    }

    function mintTokens(address _owner, uint256 _amount) public onlyController notFinalized returns (bool) {
        uint256 curTotalSupply = totalSupply();
        require(curTotalSupply.add(_amount) >= curTotalSupply, ""SafeMath: addition overflow"");
        uint256 previousBalanceTo = balanceOf(_owner);
        require(previousBalanceTo.add(_amount) >= previousBalanceTo, ""SafeMath: addition overflow"");
        updateValueAtNow(balances[_owner], previousBalanceTo.add(_amount));
        updateValueAtNow(totalSupplyHistory, curTotalSupply.add(_amount));
        emit Transfer(address(0), _owner, _amount);
        return true;
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupplyHistory[block.number];
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function updateValueAtNow(mapping(address => uint256) storage data, uint value) internal {
        data[block.number] = value;
    }
}","y
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/utils/Context.sol"";


contract Token is ERC20, Ownable, Pausable {
    using SafeERC20 for IERC20;

    constructor(string memory name_, string memory symbol_)
        ERC20(name_, symbol_)
    {}

    function mint(address _owner, uint256 _amount) public onlyOwner whenNotPaused {
        _mint(_owner, _amount);
    }
}",7.013159990310669,mint,"[{'function': 'mint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",56.0,0.7145305183855459,0.0139801145453719,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/Context.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is ERC20, Ownable, Pausable {
    using SafeERC20 for IERC20;

    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        _mint(msg.sender, 1 * 10 ** uint256(decimals())); // Mint initial tokens to owner
        transferOwnership(msg.sender); // Transfer ownership to deployer
    }

    function mint(address _owner, uint256 _amount) public onlyOwner whenNotPaused {
        _mint(_owner, _amount);
    }
}"
2892,Makes an offer which can be filled by other users .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Coordinator {
    function onlyCoordinator() external view;
    function onlyActiveState() external view;
}

abstract contract OfferManager is Ownable, SafeMath {
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        uint256 availableAmount;
        uint64 nonce;
    }

    mapping(bytes32 => Offer) public offers;
    address public coordinator;

    event Make(address indexed maker, bytes32 indexed offerHash);

    function makeOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint64 _nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external onlyOwner {
        require(_offerAmount > 0 && _wantAmount > 0, ""Invalid amounts"");
        require(_offerAsset != _wantAsset, ""Invalid assets"");

        bytes32 offerHash = keccak256(abi.encodePacked(""makeOffer"", _maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _feeAsset, _feeAmount, _nonce));

        require(_recoverAddress(offerHash, v, r, s) == _maker, ""Invalid signature"");

        _validateAndAddHash(offerHash);

        _decreaseBalanceAndPayFees(_maker, _offerAsset, _offerAmount, _feeAsset, _feeAmount, ReasonMakerGive, ReasonMakerFeeGive, ReasonMakerFeeReceive);

        Offer storage offer = offers[offerHash];
        offer.maker = _maker;
        offer.offerAsset = _offerAsset;
        offer.wantAsset = _wantAsset;
        offer.offerAmount = _offerAmount;
        offer.wantAmount = _wantAmount;
        offer.availableAmount = _offerAmount;
        offer.nonce = _nonce;

        emit Make(_maker, offerHash);
    }

    function setCoordinator(address _coordinator) external onlyOwner {
        coordinator = _coordinator;
    }

    modifier onlyCoordinator() {
        require(msg.sender == coordinator, ""Only coordinator can call this function"");
        _;
    }

    modifier onlyActiveState() {
        // Assuming there's a way to check if the state is active
        require(isStateActive(), ""Contract state is not active"");
        _;
    }

    function isStateActive() internal view returns (bool) {
        // Implement logic to check if the state is active
        return true; // Placeholder
    }

    function _validateAndAddHash(bytes32 hash) internal {
        // Implement validation and adding of hash logic
    }

    function _decreaseBalanceAndPayFees(
        address account,
        address token,
        uint256 amount,
        address feeToken,
        uint256 feeAmount,
        Reason reasonMakerGive,
        Reason reasonMakerFeeGive,
        Reason reasonMakerFeeReceive
    ) internal {
        // Implement logic to decrease balance and pay fees
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract OfferContract is Ownable, ReentrancyGuard {
    struct Offer {
        address offeror;
        uint256 amount;
        IERC20 token;
        bool isFilled;
    }

    Offer[] public offers;

    event NewOffer(uint256 indexed offerId, address indexed offeror, uint256 amount, IERC20 token);

    function makeOffer(IERC20 _token, uint256 _amount) external nonReentrant {
        require(_amount > 0, ""Offer amount must be greater than zero"");
        require(_token.balanceOf(msg.sender) >= _amount, ""Insufficient token balance"");

        _token.transferFrom(msg.sender, address(this), _amount);

        offers.push(Offer({
            offeror: msg.sender,
            amount: _amount,
            token: _token,
            isFilled: false
        }));

        emit NewOffer(offers.length - 1, msg.sender, _amount, _token);
    }

    function fillOffer(uint256 _offerId) external nonReentrant {
        Offer storage offer = offers[_offerId];
        require(!offer.isFilled, ""Offer is already filled"");

        offer.token.transfer(msg.sender, offer.amount);
        offer.isFilled = true;
    }
}",17.268693923950195,makeOffer,"[{'function': 'makeOffer', 'complexity': 2}, {'function': 'fillOffer', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""makeOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Offer amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offers""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Offer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": [""offeror"", ""amount"", ""token"", ""isFilled""]}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NewOffer""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offers""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",100.0,0.7412130835899691,0.0424362168536778,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OfferContract is Ownable, ReentrancyGuard {
    struct Offer {
        address offeror;
        uint256 amount;
        IERC20 token;
        bool isFilled;
    }

    Offer[] public offers;

    event NewOffer(uint256 indexed offerId, address indexed offeror, uint256 amount, IERC20 token);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables with fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function makeOffer(IERC20 _token, uint256 _amount) external nonReentrant {
        require(_amount > 0, ""Offer amount must be greater than zero"");
        require(_token.balanceOf(msg.sender) >= _amount, ""Insufficient token balance"");

        _token.transferFrom(msg.sender, address(this), _amount);

        offers.push(Offer({
            offeror: msg.sender,
            amount: _amount,
            token: _token,
            isFilled: false
        }));

        emit NewOffer(offers.length - 1, msg.sender, _amount, _token);
    }

    function fillOffer(uint256 _offerId) external nonReentrant {
        Offer storage offer = offers[_offerId];
        require(!offer.isFilled, ""Offer is already filled"");

        offer.token.transfer(msg.sender, offer.amount);
        offer.isFilled = true;
    }
}"
5927,A getter to find the level of authority a specific Project has using a self-referential loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminWrapper {
    using SafeMath for uint256;

    struct PledgeAdmin {
        uint adminType;
        uint parentProject;
        // Add other necessary state variables here
    }

    enum PledgeAdminType { Project, Other }

    function getProjectLevel(PledgeAdmin storage m) internal returns (uint) {
        require(m.adminType == uint(PledgeAdminType.Project), ""Invalid admin type"");
        if (m.parentProject == 0) return 1;
        PledgeAdmin storage parentNM = findAdmin(m.parentProject);
        return getProjectLevel(parentNM).add(1);
    }

    function findAdmin(uint projectId) internal view returns (PledgeAdmin storage) {
        // Implement the logic to retrieve the PledgeAdmin struct by projectId
        // This is a placeholder for where you would have your actual implementation
        revert(""Not implemented"");
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract ProjectAuthority is AccessControl, ReentrancyGuard {
    bytes32 public constant PROJECT_ROLE = keccak256(""PROJECT_ROLE"");

    mapping(address => uint) private authorityLevels;
    address[] private projectList;

    constructor() {
        _setRoleAdmin(PROJECT_ROLE, PROJECT_ROLE);
        _setupRole(PROJECT_ROLE, msg.sender);
    }

    function setAuthorityLevel(address _projectAddress, uint _level) external onlyRole(PROJECT_ROLE) nonReentrant {
        authorityLevels[_projectAddress] = _level;
        projectList.push(_projectAddress);
    }

    function getAuthorityLevel(address _projectAddress) external view returns (uint authorityLevel) {
        for(uint i = 0; i < projectList.length; i++) {
            if(projectList[i] == _projectAddress) {
                authorityLevel = authorityLevels[projectList[i]];
                break;
            }
        }
    }
}",9.683001279830933,getAuthorityLevel,"[{'function': 'setAuthorityLevel', 'complexity': 0}, {'function': 'getAuthorityLevel', 'complexity': 4}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAuthorityLevel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_projectAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_level"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorityLevels""}, ""index"": {""type"": ""Identifier"", ""name"": ""_projectAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_level""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""projectList""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_projectAddress""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRole"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""PROJECT_ROLE""}]}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.6033992152682507,0.0288396056577261,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ProjectAuthority is Ownable, AccessControl, ReentrancyGuard {
    bytes32 public constant PROJECT_ROLE = keccak256(""PROJECT_ROLE"");

    mapping(address => uint) private authorityLevels;
    address[] private projectList;

    constructor() Ownable(msg.sender) {
        _setRoleAdmin(PROJECT_ROLE, PROJECT_ROLE);
        _setupRole(PROJECT_ROLE, msg.sender);
    }

    function setAuthorityLevel(address _projectAddress, uint _level) external onlyRole(PROJECT_ROLE) nonReentrant {
        authorityLevels[_projectAddress] = _level;
        projectList.push(_projectAddress);
    }

    function getAuthorityLevel(address _projectAddress) external view returns (uint authorityLevel) {
        for(uint i = 0; i < projectList.length; i++) {
            if(projectList[i] == _projectAddress) {
                authorityLevel = authorityLevels[projectList[i]];
                break;
            }
        }
    }
}"
3990,Notifies the controller about a token transfer allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onTransfer(address _from, address _to, uint256 _amount) public returns (bool) {
        return false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenController is ReentrancyGuard, Ownable {
    mapping(address => bool) private controllers;

    modifier onlyController {
        require(controllers[msg.sender] == true, ""Not a controller"");
        _;
    }

    function setController(address _controller, bool _status) public onlyOwner {
        controllers[_controller] = _status;
    }

    function notifyTransfer(address _from, address _to, uint256 _amount) public onlyController nonReentrant returns (bool) {
        // here we have a notification of a token transfer
        // you can react to this notification as desired
        // for example: check if _from and _to are not blacklisted, if _amount is not too high, etc.

        // code to be inserted here instead of comments based on the specifications

        return true;
    }
}",10.017594814300535,notifyTransfer,"[{'function': 'setController', 'complexity': 0}, {'function': 'notifyTransfer', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setController"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_controller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_status"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""controllers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_controller""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_status""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",11.0,0.7450479995129492,0.1794354969410351,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenController is ReentrancyGuard, Ownable {
    mapping(address => bool) private controllers;

    modifier onlyController {
        require(controllers[msg.sender] == true, ""Not a controller"");
        _;
    }

    function setController(address _controller, bool _status) public onlyOwner {
        controllers[_controller] = _status;
    }

    function notifyTransfer(address _from, address _to, uint256 _amount) public onlyController nonReentrant returns (bool) {
        // here we have a notification of a token transfer
        // you can react to this notification as desired
        // for example: check if _from and _to are not blacklisted, if _amount is not too high, etc.

        // code to be inserted here instead of comments based on the specifications

        return true;
    }
}"
5074,` onlyOwner ` Cancel a payment all together,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint indexed idPayment);

    function cancelPayment(uint _idPayment) public onlyOwner {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if (p.canceled) revert();
        if (p.paid) revert();
        p.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract PaymentContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _payments;

    function cancelPayment(address payee) public onlyOwner {
        require(_payments[payee] > 0, ""Payment does not exist"");

        uint256 paymentAmount = _payments[payee];
        _payments[payee] = 0;

        // Return payment to the owner
        payable(owner()).transfer(paymentAmount);
    }
}",11.827126026153564,cancelPayment,"[{'function': 'cancelPayment', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""payee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""payee""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Payment does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""paymentAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""payee""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""payee""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""paymentAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.7784767142592912,0.1067445024278554,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract PaymentContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _payments;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function cancelPayment(address payee) public onlyOwner {
        require(_payments[payee] > 0, ""Payment does not exist"");

        uint256 paymentAmount = _payments[payee];
        _payments[payee] = 0;

        // Return payment to the owner
        payable(owner()).transfer(paymentAmount);
    }
}"
1247,Helper function that checks for IEIP777TokensOperator on the recipient and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function callOperator(address _operator, address _from, address _to, uint256 _value, bytes memory _userData, bytes memory _operatorData, bool _preventLocking) public onlyOwner {
        address recipientImplementation = interfaceAddr(_to, ""ERC777TokensOperator"");
        if (recipientImplementation != 0) {
            ERC777TokensOperator(recipientImplementation).madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking) {
            require(isRegularAddress(_to), ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"");
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""@openzeppelin/contracts/token/ERC777/IERC777.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract MyContract is ReentrancyGuard {
    function callTokensReceived(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external nonReentrant {
        require(IERC777(to).isOperatorFor(operator, to), ""Not an operator"");

        try IERC777Recipient(to).tokensReceived(operator, from, amount, userData, operatorData) {
        } catch (bytes memory /*lowLevelData*/) {
            revert(""TokensReceived hook failed"");
        }
    }
}",18.1576509475708,callTokensReceived,"[{'function': 'callTokensReceived', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""callTokensReceived"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""userData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""operatorData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC777""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""isOperatorFor""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""operator""}, {""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Not an operator""}], ""names"": []}}, {""type"": ""TryStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC777Recipient""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""tokensReceived""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""operator""}, {""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""userData""}, {""type"": ""Identifier"", ""name"": ""operatorData""}], ""names"": []}, ""block"": {""type"": ""Block"", ""statements"": []}, ""returnParameters"": None, ""catchClause"": [{""type"": ""CatchClause"", ""identifier"": None, ""parameterList"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""block"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""TokensReceived hook failed""}], ""names"": []}}]}}]}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",,0.7134797898777525,0.0649261081444413,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC777/IERC777.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is ReentrancyGuard, Ownable {
    // Fixed values
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    uint256 public constant DEFAULT_UINT256 = 1;
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed values
        _setAddress(DEFAULT_ADDRESS);
        _setUint256(DEFAULT_UINT256);
        _setBool(DEFAULT_BOOL);
        _setString(DEFAULT_STRING);
        _setBytes32(DEFAULT_BYTES32);
    }

    function callTokensReceived(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external nonReentrant {
        require(IERC777(to).isOperatorFor(operator, to), ""Not an operator"");

        try IERC777Recipient(to).tokensReceived(operator, from, amount, userData, operatorData) {
        } catch (bytes memory /*lowLevelData*/) {
            revert(""TokensReceived hook failed"");
        }
    }

    // Other functions and variables...
}"
5500,Approves another address to claim for the ownership of any tokens owned by this account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveAllWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function approveAll(address _to) public onlyOwner {
        require(_to != msg.sender, ""cant approve yourself"");
        require(_to != address(0), ""invalid owner"");
        operatorApprovals[msg.sender][_to] = true;
        emit ApprovalForAll(msg.sender, _to, true);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

contract ApproveToClaim {
    IERC721 private _token;
    mapping (address => mapping (address => bool)) private _approvals;

    constructor(IERC721 token) {
        _token = token;
    }

    function approveToClaim(address claimer) public {
        require(_token.balanceOf(msg.sender) > 0, ""Account does not own any token"");
        _approvals[msg.sender][claimer] = true;
    }

    function claim(address owner, uint256 tokenId) public {
        require(_approvals[owner][msg.sender] == true, ""Not approved to claim"");
        require(_token.ownerOf(tokenId) == owner, ""Not the owner of this token"");
        _token.transferFrom(owner, msg.sender, tokenId);
    }
}",10.690061807632446,claim,"[{'function': 'approveToClaim', 'complexity': 1}, {'function': 'claim', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""stringLiteral"", ""value"": ""Not approved to claim""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Not the owner of this token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",24.0,0.5888537477346588,0.1199444648720945,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ApproveToClaim is Ownable {
    IERC721 private _token;
    mapping (address => mapping (address => bool)) private _approvals;

    mapping(address => uint256) public balanceOf;

 constructor(IERC721 token) Ownable(msg.sender) {
        _token = token;
    }

    function approveToClaim(address claimer) public {
        require(_token.balanceOf(msg.sender) > 0, ""Account does not own any token"");
        _approvals[msg.sender][claimer] = true;
    }

    function claim(address owner, uint256 tokenId) public {
        require(_approvals[owner][msg.sender] == true, ""Not approved to claim"");
        require(_token.ownerOf(tokenId) == owner, ""Not the owner of this token"");
        _token.transferFrom(owner, msg.sender, tokenId);
    }
}"
4001,Function calls other functions to calculate tokenamount to send to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    Token public token;
    address payable public wallet;
    uint256 public rate;
    uint256 public weiRaised;
    uint256 public tokensSold;

    constructor(uint256 _rate, address payable _wallet, Token _token) {
        require(_rate > 0, ""Crowdsale: rate is 0"");
        require(_wallet != address(0), ""Crowdsale: wallet is the zero address"");
        require(address(_token) != address(0), ""Crowdsale: token is the zero address"");

        rate = _rate;
        wallet = _wallet;
        token = _token;
    }

    function buyTokens(address _beneficiary) public payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        uint256 tokens = _getTokenAmount(weiAmount);
        require(token.balanceOf(address(this)) >= tokens, ""Crowdsale: token contract has insufficient balance"");

        weiRaised = weiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokens);
        _deliverTokens(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
        _processBonus(msg.sender, tokens);
        _forwardFunds();
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure {
        require(_beneficiary != address(0), ""Crowdsale: beneficiary is the zero address"");
        require(_weiAmount > 0, ""Crowdsale: wei amount is 0"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(rate);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(token.transfer(_beneficiary, _tokenAmount), ""Crowdsale: token transfer failed"");
    }

    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function _processBonus(address _investor, uint256 _tokens) internal virtual {
        // Implement bonus logic here
    }
}","fully implemented and independent version of the function:

```javascript
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    IERC20 public tokenContract;

    constructor(IERC20 _tokenContract) {
        tokenContract = _tokenContract;
    }

    function calculateAndSendTokens(address recipient, uint256 baseAmount, uint256 rate) public onlyOwner {
        require(recipient != address(0), ""Invalid recipient address"");
        require(baseAmount > 0, ""Base amount must be greater than zero"");
        require(rate > 0, ""Rate must be greater than zero"");

        uint256 tokens = calculateTokenAmount(baseAmount, rate);

        require(tokenContract.balanceOf(address(this)) >= tokens, ""Insufficient tokens in contract"");

        tokenContract.transfer(recipient, tokens);
    }

    function calculateTokenAmount(uint256 baseAmount, uint256 rate) internal pure returns (uint256) {
        return baseAmount.mul(rate);
    }
}",14.328144073486328,calculateAndSendTokens,"[{'function': 'calculateAndSendTokens', 'complexity': 4}, {'function': 'calculateTokenAmount', 'complexity': 0}]",5.0,{},69.0,0.6617183999308118,0.2215718785285805," ```javascript
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    IERC20 public tokenContract;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _tokenContract) Ownable() {
        require(_tokenContract != IERC20(address(0)), ""Invalid token contract address"");
        tokenContract = _tokenContract;
    }

    function calculateAndSendTokens(address recipient, uint256 baseAmount, uint256 rate) public onlyOwner {
        require(recipient != address(0), ""Invalid recipient address"");
        require(baseAmount > 0, ""Base amount must be greater than zero"");
        require(rate > 0, ""Rate must be greater than zero"");

        uint256 tokens = calculateTokenAmount(baseAmount, rate);

        require(tokenContract.balanceOf(address(this)) >= tokens, ""Insufficient tokens in contract"");

        tokenContract.transfer(recipient, tokens);
    }

    function calculateTokenAmount(uint256 baseAmount, uint256 rate) internal pure returns (uint256) {
        return baseAmount.mul(rate);
    }
}
```"
267,Redeem required amount of tokens for the real asset,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function redeem(uint256 _tokens) public onlyOwner {
        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address account, uint256 tokens) internal {
        // Implementation of the redeem logic
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract AssetRedemption is ReentrancyGuard, Ownable {
    ERC20 public token;

    constructor(address _token) {
        token = ERC20(_token);
    }

    function redeem(uint256 amount) external nonReentrant {
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient token balance"");

        bool success = token.transferFrom(msg.sender, address(this), amount);
        require(success, ""Transfer failed"");

        // Do something with the tokens, redeem real asset etc.

        // Emit some meaningful event
    }
}",14.877745151519775,redeem,"[{'function': 'redeem', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeem"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",22.0,0.697044284377776,0.062346216986067,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetRedemption is ReentrancyGuard, Ownable {
    ERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = ERC20(_token);
    }

    function redeem(uint256 amount) external nonReentrant {
        require(token.balanceOf(msg.sender) >= amount, ""Insufficient token balance"");

        bool success = token.transferFrom(msg.sender, address(this), amount);
        require(success, ""Transfer failed"");

        // Do something with the tokens, redeem real asset etc.

        // Emit some meaningful event
    }
}"
1315,Burns ` _amount ` tokens from ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function balanceOf(address owner) external view returns (uint256);
    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) external;
    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) external view returns (uint256);
}

abstract contract TokenWrapper is Ownable, TokenInterface {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint => uint256) public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function balanceOf(address _owner) public override view returns (uint256 balance) {
        return balances[_owner];
    }

    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) public override view returns (uint256) {
        require(blockNumber <= getBlockNumber(), ""Block number must be in the past"");
        return data[blockNumber];
    }

    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) public override {
        data[getBlockNumber()] = value;
    }

    function getBlockNumber() internal view virtual returns (uint256) {
        return block.number;
    }

    function destroyTokens(address _owner, uint256 _amount) public onlyController returns (bool) {
        uint256 curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());
        require(curTotalSupply >= _amount, ""Insufficient balance"");
        updateValueAtNow(totalSupplyHistory, curTotalSupply.sub(_amount));
        uint256 previousBalanceFrom = balanceOf(_owner);
        require(previousBalanceFrom >= _amount, ""Insufficient balance"");
        updateValueAtNow(balances[_owner], previousBalanceFrom.sub(_amount));
        emit Transfer(_owner, address(0), _amount);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is IERC20, Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    function burnFrom(address _owner, uint256 _amount) public onlyOwner {
        require(_balances[_owner] >= _amount, ""Burn amount exceeds balance"");
        _balances[_owner] = _balances[_owner].sub(_amount);
        _totalSupply = _totalSupply.sub(_amount);
        emit Transfer(_owner, address(0), _amount);
    }
}",9.84841799736023,burnFrom,"[{'function': 'burnFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Burn amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",35.0,0.6833980778378124,0.2451542101519051,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is IERC20, Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    uint256 private _totalSupply = 1000000000000000000; // Set to 1 instead of 0

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _balances[owner()] = 1; // Balance for the owner
    }

    function burnFrom(address _owner, uint256 _amount) public onlyOwner {
        require(_balances[_owner] >= _amount, ""Burn amount exceeds balance"");
        _balances[_owner] = _balances[_owner].sub(_amount);
        _totalSupply = _totalSupply.sub(_amount);
        emit Transfer(_owner, address(0), _amount);
    }
}"
4051,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract AuthorizedOperator is AccessControl {
    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function isAuthorizedOperator(address operator, address user) public view returns (bool) {
        return hasRole(OPERATOR_ROLE, operator) && hasRole(OPERATOR_ROLE, user);
    }
}",5.094190835952759,isAuthorizedOperator,"[{'function': 'isAuthorizedOperator', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isAuthorizedOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""OPERATOR_ROLE""}, {""type"": ""Identifier"", ""name"": ""operator""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""OPERATOR_ROLE""}, {""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",6.0,0.6873253484800895,0.2257118047882956,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AuthorizedOperator is AccessControl, Ownable {
    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    constructor() AccessControl() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function isAuthorizedOperator(address operator, address user) public view returns (bool) {
        return hasRole(OPERATOR_ROLE, operator) && hasRole(OPERATOR_ROLE, user);
    }
}"
5314,Modifies the list of overrides for non-accredited limits in USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    event SetNonAccreditedLimit(address indexed investor, uint256 limit);

    function changeNonAccreditedLimit(address[] memory _investors, uint256[] memory _nonAccreditedLimit) public onlyOwner {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");

        for (uint256 i = 0; i < _investors.length; i++) {
            require(_nonAccreditedLimit[i] > 0, ""Limit can not be 0"");

            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];
            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract NonAccreditedLimitOverride is Ownable {

    using SafeMath for uint256;

    mapping (address => uint256) public nonAccreditedLimitOverride;

    function modifyNonAccreditedLimitOverride(address _beneficiary, uint256 _limit) public onlyOwner {
        require(_beneficiary != address(0), ""Cannot set limit for zero address"");
        require(_limit > 0, ""Limit cannot be zero"");

        nonAccreditedLimitOverride[_beneficiary] = _limit;
    }
}",6.327998161315918,modifyNonAccreditedLimitOverride,"[{'function': 'modifyNonAccreditedLimitOverride', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""modifyNonAccreditedLimitOverride"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_limit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot set limit for zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_limit""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Limit cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonAccreditedLimitOverride""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_limit""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",34.0,0.7924211647719839,0.141637546761166,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NonAccreditedLimitOverride is Ownable {

    using SafeMath for uint256;

    mapping (address => uint256) public nonAccreditedLimitOverride;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            nonAccreditedLimitOverride[addr] = 1;
        }
    }

    function modifyNonAccreditedLimitOverride(address _beneficiary, uint256 _limit) public onlyOwner {
        require(_beneficiary != address(0), ""Cannot set limit for zero address"");
        require(_limit > 0, ""Limit cannot be zero"");

        nonAccreditedLimitOverride[_beneficiary] = _limit;
    }
}"
2308,Return the boolean ( true/false ) registration status for an issuer firm,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Data {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private storageMap;

    function getBool(bytes32 key) public view returns (bool) {
        return storageMap[key];
    }
}

abstract contract RegisteredFirm is Ownable {
    Data private dataStorage;

    constructor() {
        dataStorage = new Data();
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool registered) {
        bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));
        return dataStorage.getBool(id);
    }
}","X-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract IssuerRegistry is Ownable {
    mapping(address => bool) private isIssuerRegistered;

    function registerIssuer(address issuer) external onlyOwner {
        isIssuerRegistered[issuer] = true;
    }

    function isRegisteredIssuer(address issuer) external view returns (bool) {
        return isIssuerRegistered[issuer];
    }
}",5.194344758987427,registerIssuer,"[{'function': 'registerIssuer', 'complexity': 0}, {'function': 'isRegisteredIssuer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerIssuer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""issuer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isIssuerRegistered""}, ""index"": {""type"": ""Identifier"", ""name"": ""issuer""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.6176532117907728,0.004476603183992,"X-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract IssuerRegistry is Ownable {
    mapping(address => bool) private isIssuerRegistered;

    constructor() Ownable(msg.sender) {
        // No initialization needed for state variables as they are already set to safe non-zero values by default constructors
    }

    function registerIssuer(address issuer) external onlyOwner {
        isIssuerRegistered[issuer] = true;
    }

    function isRegisteredIssuer(address issuer) external view returns (bool) {
        return isIssuerRegistered[issuer];
    }
}"
1642,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool);
}

abstract contract ERC20Token is Ownable {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    bool public transfersEnabled;
    address public controller;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply.mul(10 ** uint256(decimals));
        balances[msg.sender] = totalSupply;
        transfersEnabled = true;
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0), ""Allowance already granted"");
        if (isContract(_spender)) {
            bool onApprove = TokenController(controller).onApprove(msg.sender, _spender, _amount);
            require(onApprove, ""Approval rejected by controller"");
        }
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function approveSpender(address _spender, uint256 _amount) public returns (bool) {
       _approve(msg.sender, _spender, _amount);
       return true;
    }
}",6.104920148849487,approveSpender,"[{'function': 'approveSpender', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",37.0,0.859917357789725,0.0601038346680149,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") Ownable(msg.sender) {
        _mint(owner(), initialSupply);
    }

    function approveSpender(address _spender, uint256 _amount) public returns (bool) {
       _approve(msg.sender, _spender, _amount);
       return true;
    }
}"
3698,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    address public snt = 0x0;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        require(_token != snt, ""Cannot withdraw SNT tokens"");
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    function recoverERC20(address tokenAddress) external onlyOwner {
        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));
        require(balance > 0, ""No tokens to recover"");
        IERC20(tokenAddress).transfer(owner(), balance);
    }
}",6.283524990081787,recoverERC20,"[{'function': 'recoverERC20', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""recoverERC20"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to recover""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",29.0,0.6414582908944015,0.168584005596708,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    uint256 public constant MAX_TOKENS = 1;
    address public constant DEFAULT_TOKEN_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant IS_INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    function recoverERC20(address tokenAddress) external onlyOwner {
        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));
        require(balance > 0, ""No tokens to recover"");
        IERC20(tokenAddress).transfer(owner(), balance);
    }
}"
6060,Set current ICO prices in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public currentTokenPrice;
    bool public preIcoIsRunning;
    uint256 public preICOprice;
    uint256 public ICOprice;

    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function updatePrices() external onlyOwner {
        uint256 oldPrice = currentTokenPrice;
        if (preIcoIsRunning) {
            checkPreIcoStatus();
        }
        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }
        if (oldPrice != currentTokenPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price updated!"");
        }
    }

    function checkPreIcoStatus() internal view {
        // Implement the logic to check pre-ICO status
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract ICOPriceSetter is Ownable, ReentrancyGuard {
    uint256 public currentPrice;

    function setICOPrice(uint256 newPrice) public onlyOwner nonReentrant {
        require(newPrice > 0, ""Price should be greater than 0"");
        currentPrice = newPrice;
    }
}",5.011039018630981,setICOPrice,"[{'function': 'setICOPrice', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setICOPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price should be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",16.0,0.5628410757843831,0.0078909905695632,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ICOPriceSetter is Ownable, ReentrancyGuard {
    uint256 public currentPrice;

    constructor() Ownable(msg.sender) {
        currentPrice = 1; // Set to a non-zero value for uint256
    }

    function setICOPrice(uint256 newPrice) public onlyOwner nonReentrant {
        require(newPrice > 0, ""Price should be greater than 0"");
        currentPrice = newPrice;
    }
}"
6552,upper bound of series of snapshotIds for which there 's a value in series,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract SnapshotHolder is Ownable {
    using SafeMath for uint256;

    uint256 private _currentSnapshotId;

    function currentSnapshotId() public view onlyOwner returns (uint256) {
        return _currentSnapshotId;
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

contract Snapshot {
    using EnumerableSet for EnumerableSet.UintSet;

    EnumerableSet.UintSet private snapshots;

    function upperBound(uint snapshotId) public view returns (uint) {
        require(EnumerableSet.contains(snapshots, snapshotId), ""SnapshotId does not exist"");
        uint upperBoundId;
        for(uint i = 0; i < EnumerableSet.length(snapshots); i++){
            if(EnumerableSet.at(snapshots, i) > snapshotId){
                upperBoundId = EnumerableSet.at(snapshots, i);
                break;
            }
        }
        return upperBoundId;
    }
}",12.12561583518982,upperBound,"[{'function': 'upperBound', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""upperBound"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""snapshotId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""EnumerableSet""}, ""memberName"": ""contains""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""snapshots""}, {""type"": ""Identifier"", ""name"": ""snapshotId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""SnapshotId does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""upperBoundId"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""EnumerableSet""}, ""memberName"": ""length""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""snapshots""}], ""names"": []}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""EnumerableSet""}, ""memberName"": ""at""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""snapshots""}, {""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""snapshotId""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upperBoundId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""EnumerableSet""}, ""memberName"": ""at""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""snapshots""}, {""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""upperBoundId""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",37.0,0.6412657683848149,0.0202586374712465,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Snapshot is Ownable {
    using EnumerableSet for EnumerableSet.UintSet;

    EnumerableSet.UintSet private snapshots;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        snapshots = EnumerableSet.UintSet();
    }

    function upperBound(uint snapshotId) public view returns (uint) {
        require(EnumerableSet.contains(snapshots, snapshotId), ""SnapshotId does not exist"");
        uint upperBoundId;
        for(uint i = 0; i < EnumerableSet.length(snapshots); i++){
            if(EnumerableSet.at(snapshots, i) > snapshotId){
                upperBoundId = EnumerableSet.at(snapshots, i);
                break;
            }
        }
        return upperBoundId;
    }
}"
2199,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function mintToken(address target, uint256 mintedAmount) public onlyOwner {
        token.mint(target, mintedAmount);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    address private _minter;

    constructor(address minter_) ERC20(""MyToken"", ""MTK"") {
        _minter = minter_;
    }

    modifier onlyMinter() {
        require(msg.sender == _minter, ""Only minter can mint"");
        _;
    }

    function mint(address target, uint256 mintedAmount) external onlyMinter {
        _mint(target, mintedAmount);
    }
}",5.547563076019287,mint,"[{'function': 'mint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyMinter"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",1.0,0.8380534348383131,0.602867050301643,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    address private _minter;

    constructor(address minter_) ERC20(""MyToken"", ""MTK"") {
        require(minter_ != address(0), ""Invalid minter address"");
        _minter = minter_;
    }

    modifier onlyMinter() {
        require(msg.sender == _minter, ""Only minter can mint"");
        _;
    }

    function mint(address target, uint256 mintedAmount) external onlyMinter {
        _mint(target, mintedAmount);
    }
}"
1644,Trim the realitio question content to the part before the initial delimiter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;
    string constant REALITIO_DELIMITER = ""|"";

    function _trimQuestion(string memory q) public pure returns (string memory) {
        return abi.decode(bytes(q).length > 0 ? bytes.concat(bytes(q), bytes(REALITIO_DELIMITER)) : bytes(""""), (string));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RealitioTrim {
    function trimRealitioQuestion(bytes memory content, byte delimiter) public pure returns (bytes memory) {
        uint256 i = 0;
        while (content[i] != delimiter) {
            require(i < content.length, ""Delimiter not found in the content."");
            i++;
        }

        bytes memory trimmedContent = new bytes(i);
        for (uint256 j = 0; j < i; j++) {
            trimmedContent[j] = content[j];
        }

        return trimmedContent;
    }
}",6.628698825836182,trimRealitioQuestion,"[{'function': 'trimRealitioQuestion', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""trimRealitioQuestion"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""content"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""byte""}, ""name"": ""delimiter"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""WhileStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""content""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""delimiter""}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""content""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Delimiter not found in the content.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""trimmedContent"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""j""}, ""right"": {""type"": ""Identifier"", ""name"": ""i""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""j""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""trimmedContent""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""content""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}}}]}}, {""type"": ""Identifier"", ""name"": ""trimmedContent""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}",48.0,0.7344378191966335,0.094902061912426,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RealitioTrim is Ownable {
    function trimRealitioQuestion(bytes memory content, byte delimiter) public pure returns (bytes memory) {
        uint256 i = 0;
        while (content[i] != delimiter) {
            require(i < content.length, ""Delimiter not found in the content."");
            i++;
        }

        bytes memory trimmedContent = new bytes(i);
        for (uint256 j = 0; j < i; j++) {
            trimmedContent[j] = content[j];
        }

        return trimmedContent;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables:
        // uint256: Set to 1 (never 0)
        uint256 private _exampleUint = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address private _exampleAddress = address(uint160(uint256(keccak256('address1'))));

        // bool: Set to true
        bool private _exampleBool = true;

        // string: Set to 'initialized'
        string memory _exampleString = ""initialized"";

        // bytes32: Set to bytes32('init')
        bytes32 private _exampleBytes32 = keccak256(""init"");
    }
}"
2321,Function to send tokens or refund after the closing time of the funding proposals,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(uint => uint) public pendingAmounts;

    event SentPendingAmount(address indexed buyer, uint indexed id, uint amount);

    function sendPendingAmounts(uint _from, uint _to, address _buyer) public onlyOwner returns (bool) {
        require(_from <= _to);
        for (uint i = _from; i <= _to; i++) {
            if (pendingAmounts[i] > 0) {
                pendingAmounts[i].transfer(address(this));
                emit SentPendingAmount(_buyer, i, pendingAmounts[i]);
                pendingAmounts[i] = 0;
            }
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract FundingProposal is ReentrancyGuard {
    IERC20 public token;
    uint256 public closingTime;

    mapping(address => uint256) public contributions;

    constructor(IERC20 _token, uint256 _closingTime) {
        token = _token;
        closingTime = _closingTime;
    }

    function disburseFunds(address recipient, uint256 amount)
        external
        nonReentrant
    {
        require(block.timestamp > closingTime, ""Funding proposal has not closed yet"");
        require(contributions[recipient] >= amount, ""Insufficient contribution"");

        contributions[recipient] -= amount;
        ensureTransferFrom(address(this), recipient, amount);
    }

    function refundContributor(address contributor)
        external
        nonReentrant
    {
        require(block.timestamp > closingTime, ""Funding proposal has not closed yet"");
        require(contributions[contributor] > 0, ""No contribution"");

        uint256 amount = contributions[contributor];
        contributions[contributor] = 0;
        ensureTransferFrom(address(this), contributor, amount);
    }

    function ensureTransferFrom(
        address from,
        address to,
        uint256 amount
    ) private {
        bool success = token.transferFrom(from, to, amount);
        require(success, ""Transfer failed"");
    }
}",16.077518939971924,refundContributor,"[{'function': 'disburseFunds', 'complexity': 0}, {'function': 'refundContributor', 'complexity': 0}, {'function': 'ensureTransferFrom', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""refundContributor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contributor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""closingTime""}}, {""type"": ""stringLiteral"", ""value"": ""Funding proposal has not closed yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No contribution""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ensureTransferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""contributor""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.5074756593980361,0.102072217766203,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FundingProposal is ReentrancyGuard, Ownable {
    IERC20 public token;
    uint256 public closingTime;

    mapping(address => uint256) public contributions;

    constructor(IERC20 _token, uint256 _closingTime) Ownable(msg.sender) {
        token = _token;
        closingTime = _closingTime;
    }

    function disburseFunds(address recipient, uint256 amount)
        external
        nonReentrant
    {
        require(block.timestamp > closingTime, ""Funding proposal has not closed yet"");
        require(contributions[recipient] >= amount, ""Insufficient contribution"");

        contributions[recipient] -= amount;
        ensureTransferFrom(address(this), recipient, amount);
    }

    function refundContributor(address contributor)
        external
        nonReentrant
    {
        require(block.timestamp > closingTime, ""Funding proposal has not closed yet"");
        require(contributions[contributor] > 0, ""No contribution"");

        uint256 amount = contributions[contributor];
        contributions[contributor] = 0;
        ensureTransferFrom(address(this), contributor, amount);
    }

    function ensureTransferFrom(
        address from,
        address to,
        uint256 amount
    ) private {
        bool success = token.transferFrom(from, to, amount);
        require(success, ""Transfer failed"");
    }
}"
5497,Returns asset balance for a particular holder id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IAsset {
    function balanceOf(uint _holderId, bytes32 _symbol) external view returns (uint);
}

abstract contract AssetWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => Asset) public assets;

    struct Asset {
        mapping(uint => Wallet) wallets;
    }

    struct Wallet {
        uint balance;
    }

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol].wallets[_holderId].balance;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract AssetBalance {
    using SafeMath for uint256;

    IERC20 public token;

    constructor (IERC20 _token) {
        token = _token;
    }

    function getAssetBalance(address holderId) public view returns (uint256) {
        require(holderId != address(0), ""Invalid holder address"");
        return token.balanceOf(holderId);
    }
}",6.398334264755249,getAssetBalance,"[{'function': 'getAssetBalance', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAssetBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""holderId""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid holder address""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""holderId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",14.0,0.7575638905748111,0.1341063964832027,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetBalance is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function getAssetBalance(address holderId) public view returns (uint256) {
        require(holderId != address(0), ""Invalid holder address"");
        return token.balanceOf(holderId);
    }
}"
124,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender; // Simplified ownership check for demonstration purposes
    }
}","// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is ERC20, Ownable {
    using SafeERC20 for ERC20;

    function grantTransferRight(address to) public onlyOwner {
        _approve(to, _msgSender(), _allowances[_msgSender()][to] + totalSupply());
    }

    function takeOwnership(address from, address to, uint256 tokenId) public {
        require(msg.sender == owner() || isApprovedForAll(from, msg.sender), ""MyToken: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }
}",15.562963962554932,takeOwnership,"[{'function': 'grantTransferRight', 'complexity': 0}, {'function': 'takeOwnership', 'complexity': 2}, {'function': 'transferFrom', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isApprovedForAll""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""MyToken: transfer caller is not owner nor approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.6578047585231996,0.1350759904901803,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    using SafeERC20 for ERC20;

    uint256 public totalSupply;

 constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _totalSupply = 1 * 10 ** decimals(); // Set total supply to 1 token
        _balances[msg.sender] = _totalSupply; // Assign initial tokens to the contract owner
    }

    function grantTransferRight(address to) public onlyOwner {
        _approve(to, _msgSender(), _allowances[_msgSender()][to] + totalSupply());
    }

    function takeOwnership(address from, address to, uint256 tokenId) public {
        require(msg.sender == owner() || isApprovedForAll(from, msg.sender), ""MyToken: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(_msgSender(), tokenId), ""ERC721: transfer caller is not owner nor approved"");
        _transfer(from, to, tokenId);
    }
}"
467,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    mapping(address => Beneficiary) public beneficiaries;
    IERC20 public token;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        require(token.transfer(owner, balance), ""Token transfer failed"");
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        emit BeneficiaryDestroyed(_beneficiary);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Beneficiary is Ownable {
    mapping (address => bool) public beneficiaries;

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        beneficiaries[_beneficiary] = false;
    }
}",4.662906885147095,destroyBeneficiary,"[{'function': 'destroyBeneficiary', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",40.0,0.8780079636715356,0.0877556581361701,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Beneficiary is Ownable {
    mapping (address => bool) public beneficiaries;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            beneficiaries[addr] = true;
        }
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary], ""Beneficiary does not exist"");
        beneficiaries[_beneficiary] = false;
    }
}"
3604,Adds a co-owner for an asset with provided symbol .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetWrapper {
    using SafeMath for uint256;

    struct Asset {
        mapping(uint => bool) partowners;
    }

    bytes32[] public symbols;
    mapping(bytes32 => Asset) public assets;
    address public eventsHistory;
    uint constant OK = 1;

    modifier onlyOneOfOwners(bytes32 _symbol) {
        require(_isPartowner(_symbol, msg.sender), ""Not a part owner"");
        _;
    }

    function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {
        uint holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);
        return OK;
    }

    function _isPartowner(bytes32 _symbol, address _partowner) internal view returns (bool) {
        for (uint i = 0; ; ++i) {
            if (!assets[_symbol].partowners[i]) {
                return false;
            }
            if (_partowner == address(0)) {
                break;
            }
        }
        return true;
    }

    function _createHolderId(address _partowner) internal pure returns (uint holderId) {
        holderId = uint256(_partowner);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract AssetOwnership is AccessControl {
    bytes32 public constant CO_OWNER_ROLE = keccak256(""CO_OWNER_ROLE"");

    mapping(string => address) private assetOwners;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function addCoOwner(string memory symbol, address newCoOwner) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        require(newCoOwner != address(0), ""New co-owner's address can't be zero"");
        require(assetOwners[symbol] != newCoOwner, ""Provided address is already a co-owner"");

        assetOwners[symbol] = newCoOwner;
        _setupRole(CO_OWNER_ROLE, newCoOwner);
    }
}",7.368150949478149,addCoOwner,"[{'function': 'addCoOwner', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addCoOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""symbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newCoOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newCoOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New co-owner""s address can""t be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""symbol""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newCoOwner""}}, {""type"": ""stringLiteral"", ""value"": ""Provided address is already a co-owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""symbol""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newCoOwner""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setupRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""CO_OWNER_ROLE""}, {""type"": ""Identifier"", ""name"": ""newCoOwner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",33.0,0.4997882865254687,0.0525647506848874,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetOwnership is Ownable, AccessControl {
    bytes32 public constant CO_OWNER_ROLE = keccak256(""CO_OWNER_ROLE"");

    mapping(string => address) private assetOwners;

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function addCoOwner(string memory symbol, address newCoOwner) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        require(newCoOwner != address(0), ""New co-owner's address can't be zero"");
        require(assetOwners[symbol] != newCoOwner, ""Provided address is already a co-owner"");

        assetOwners[symbol] = newCoOwner;
        _setupRole(CO_OWNER_ROLE, newCoOwner);
    }
}"
5691,allows participants in the Atonomi network to claim their rewards,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWithdrawal is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public rewards;
    IERC20 public token;
    bool public paused = false;

    event TokensWithdrawn(address indexed user, uint256 amount);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function withdrawTokens() public whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");
        rewards[msg.sender] = rewards[msg.sender].sub(amount);
        emit TokensWithdrawn(msg.sender, amount);
        require(token.transfer(msg.sender, amount), ""token transfer failed"");
        return true;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract AtonomiRewards is Ownable {
    using SafeMath for uint256;

    ERC20 public rewardToken;

    mapping(address => uint256) private _rewards;

    constructor(address token) {
        rewardToken = ERC20(token);
    }

    function claimReward(uint256 amount) public {
        require(amount <= _rewards[msg.sender], ""Insufficient reward balance"");
        _rewards[msg.sender] = _rewards[msg.sender].sub(amount);
        rewardToken.transfer(msg.sender, amount);
    }

    function setReward(address participant, uint256 amount) external onlyOwner {
        _rewards[participant] = amount;
    }
}",11.402850151062012,claimReward,"[{'function': 'claimReward', 'complexity': 1}, {'function': 'setReward', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient reward balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rewardToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.5443218926962445,0.1512236011556769,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract AtonomiRewards is Ownable {
    using SafeMath for uint256;

    ERC20 public rewardToken;

    mapping(address => uint256) private _rewards;

    constructor(address token) Ownable(msg.sender) {
        rewardToken = ERC20(token);
        // Initialize state variables with safe, non-corner-case values
        _rewards[address(0x111)] = 1; // Example fixed address and value
        _rewards[address(0x222)] = 1; // Example fixed address and value
        _rewards[address(0x333)] = 1; // Example fixed address and value
    }

    function claimReward(uint256 amount) public {
        require(amount <= _rewards[msg.sender], ""Insufficient reward balance"");
        _rewards[msg.sender] = _rewards[msg.sender].sub(amount);
        rewardToken.transfer(msg.sender, amount);
    }

    function setReward(address participant, uint256 amount) external onlyOwner {
        _rewards[participant] = amount;
    }
}"
2271,Deposit Ether where the contribution is credited to the address specified in the parameter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public isOpen = true;
    address[] public swimmersList;
    mapping(address => bool) public invested;
    mapping(address => uint256) public swimmers;
    uint256 public weiRaised;

    event Deposit(address indexed user, uint256 amount);

    modifier depositIsConfigCompliant() {
        require(isOpen, ""Deposit is not open"");
        _;
    }

    modifier canDeposit(address _user) {
        // Assuming some logic for checking if the user can deposit
        require(/* some condition */, ""User cannot deposit at this time"");
        _;
    }

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            swimmersList.push(_user);
            invested[_user] = true;
        }
        weiRaised = weiRaised.add(msg.value);
        swimmers[_user] = swimmers[_user].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;
    mapping(address => uint256) private balances;

    function depositEther(address _contributor) public payable {
        require(msg.value > 0, ""Deposit value must be greater than zero"");
        balances[_contributor] = balances[_contributor].add(msg.value);
    }

    function balanceOf(address _contributor) public view returns(uint256) {
      return balances[_contributor];
    }
}",6.173283100128174,depositEther,"[{'function': 'depositEther', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""depositEther"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contributor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Deposit value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_contributor""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_contributor""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",21.0,0.651801011097412,0.1053681774166879,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) private balances;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        balances[msg.sender] = 1000; // Set to 1 (never 0)
        balances[0x1111111111111111111111111111111111111111] = 2; // Use a fixed address value
        balances[0x2222222222222222222222222222222222222222] = 3; // Use another fixed address value
    }

    function depositEther(address _contributor) public payable {
        require(msg.value > 0, ""Deposit value must be greater than zero"");
        balances[_contributor] = balances[_contributor].add(msg.value);
    }

    function balanceOf(address _contributor) public view returns(uint256) {
      return balances[_contributor];
    }
}"
2948,The auction contract variable ( saleAuction ) is defined in MasterpieceBase to allow us to refer to them in MasterpieceOwnership to prevent accidental transfers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    SaleClockAuction public saleAuction;

    function setSaleAuctionAddress(address _address) external onlyCEO {
        SaleClockAuction candidateContract = SaleClockAuction(_address);
        require(candidateContract.isSaleClockAuction());
        saleAuction = candidateContract;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract MasterpieceBase is AccessControl, ReentrancyGuard {
    bytes32 public constant SALE_AUCTION_ROLE = keccak256(""SALE_AUCTION_ROLE"");

    constructor() {
        _setupRole(SALE_AUCTION_ROLE, _msgSender());
    }

}

contract MasterpieceOwnership is MasterpieceBase {
    using Address for address;

    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual {
        require(hasRole(SALE_AUCTION_ROLE, _msgSender()), ""MasterpieceOwnership: caller is not the sale auction"");
        require(from != address(0), ""MasterpieceOwnership: transfer from the zero address"");
        require(to != address(0), ""MasterpieceOwnership: transfer to the zero address"");
        require(_exists(tokenId), ""MasterpieceOwnership: operator query for nonexistent token"");

        _beforeTokenTransfer(from, to, tokenId);

        _afterTokenTransfer(from, to, tokenId);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }

    function _afterTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }

    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return tokenId != 0;
    }
}",13.71612811088562,safeTransferFrom,"[{'function': 'safeTransferFrom', 'complexity': 4}, {'function': '_beforeTokenTransfer', 'complexity': -1}, {'function': '_afterTokenTransfer', 'complexity': 0}, {'function': '_exists', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeTransferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""SALE_AUCTION_ROLE""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""MasterpieceOwnership: caller is not the sale auction""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""MasterpieceOwnership: transfer from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""MasterpieceOwnership: transfer to the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""MasterpieceOwnership: operator query for nonexistent token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_beforeTokenTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_afterTokenTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.4644905657552608,0.0399346210925662,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MasterpieceBase is Ownable, ReentrancyGuard, AccessControl {
    bytes32 public constant SALE_AUCTION_ROLE = keccak256(""SALE_AUCTION_ROLE"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(SALE_AUCTION_ROLE, msg.sender);
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MasterpieceOwnership is MasterpieceBase {
    using Address for address;

    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual {
        require(hasRole(SALE_AUCTION_ROLE, _msgSender()), ""MasterpieceOwnership: caller is not the sale auction"");
        require(from != address(0), ""MasterpieceOwnership: transfer from the zero address"");
        require(to != address(0), ""MasterpieceOwnership: transfer to the zero address"");
        require(_exists(tokenId), ""MasterpieceOwnership: operator query for nonexistent token"");

        _beforeTokenTransfer(from, to, tokenId);

        _afterTokenTransfer(from, to, tokenId);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }

    function _afterTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }

    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return tokenId != 0;
    }
}"
4839,"Returns the loan metadata , hashed with keccak256 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataHashWrapper is Ownable {
    using SafeMath for uint256;

    struct Loan {
        bytes32 metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadataHash(uint2atural index) public view returns (bytes32) {
        require(index < totalLoans(), ""Index out of bounds"");
        return keccak256(abi.encodePacked(loans[index].metadata));
    }

    function setLoanMetadata(uint256 index, bytes32 metadata) public onlyOwner {
        require(index < totalLoans(), ""Index out of bounds"");
        loans[index].metadata = metadata;
    }

    function totalLoans() internal view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(loans)));
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Loan {
    struct LoanDetails {
        uint256 amount;
        string purpose;
        uint256 duration;
    }

    mapping(address => LoanDetails) private loans;

    function getLoanHash(address borrower) public view returns (bytes32) {
        LoanDetails memory loan = loans[borrower];
        return keccak256(abi.encodePacked(loan.amount, loan.purpose, loan.duration));
    }
}",5.75714111328125,getLoanHash,"[{'function': 'getLoanHash', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLoanHash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""borrower"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""LoanDetails""}, ""name"": ""loan"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""borrower""}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""purpose""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""duration""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}",14.0,0.6749218652805412,0.351596005090616,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Loan is Ownable {
    struct LoanDetails {
        uint256 amount;
        string purpose;
        uint256 duration;
    }

    mapping(address => LoanDetails) private loans;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        loans[address(0x111)] = LoanDetails({amount: 1, purpose: 'initialized', duration: 365});
        loans[address(0x222)] = LoanDetails({amount: 1, purpose: 'initialized', duration: 365});
        loans[address(0x333)] = LoanDetails({amount: 1, purpose: 'initialized', duration: 365});
    }

    function getLoanHash(address borrower) public view returns (bytes32) {
        LoanDetails memory loan = loans[borrower];
        return keccak256(abi.encodePacked(loan.amount, loan.purpose, loan.duration));
    }
}"
1398,Performs transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transferWithReference(address _to, uint _value, string memory _reference, address _sender) public onlyProxy returns (bool) {
        require(_checkTransferAllowance(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        require(_isValidCountryLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        if (!super.transferWithReference(_to, _value, _reference, _sender)) {
            return false;
        }
        _updateTransferLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender);
        _contractFallbackERC223(_sender, _to, _value);
        return true;
    }

    function _checkTransferAllowance(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for checking transfer allowance
        require(false, ""Not implemented"");
        return false;
    }

    function _isValidCountryLimits(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for validating country limits
        require(false, ""Not implemented"");
        return false;
    }

    function _updateTransferLimits(address _to, uint8 _role, uint _value, address _sender) internal {
        // Implement the logic to update transfer limits
        require(false, ""Not implemented"");
    }

    function _contractFallbackERC223(address _from, address _to, uint _value) internal {
        // Implement the fallback logic for ERC223 contract
        require(false, ""Not implemented"");
    }

    function _getParticipantRoles(address _sender, address _to) internal pure returns (uint8[2] memory roles) {
        // Implement the logic to get participant roles
        require(false, ""Not implemented"");
        return [uint8(0), uint8(0)];
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TransferContract is Ownable {
    using SafeMath for uint256;

    function transferTokens(IERC20 token, address sender, address recipient, uint256 amount) public onlyOwner {
        require(token.balanceOf(sender) >= amount, ""Transfer amount exceeds sender balance"");
        require(token.allowance(sender, address(this)) >= amount, ""Transfer amount exceeds allowance"");

        bool success = token.transferFrom(sender, recipient, amount);
        require(success, ""Transfer failed"");
    }
}",11.100185871124268,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount exceeds sender balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount exceeds allowance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",42.0,0.5803018801519508,0.0514585013711377,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TransferContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(IERC20 token, address sender, address recipient, uint256 amount) public onlyOwner {
        require(token.balanceOf(sender) >= amount, ""Transfer amount exceeds sender balance"");
        require(token.allowance(sender, address(this)) >= amount, ""Transfer amount exceeds allowance"");

        bool success = token.transferFrom(sender, recipient, amount);
        require(success, ""Transfer failed"");
    }
}"
883,Buy from multiple sellers at once to fill a single large order .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITrade {
    function execute(address seller, uint256 quantity, uint256 price) external returns (uint256);
    function isAllowedTrade(address user) external view returns (bool);
}

abstract contract TradeWrapper is Ownable {
    using SafeMath for uint256;

    bool public enforceKyc = false;
    mapping(address => TradeOrder) public orderBook;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
    }

    function setEnforceKyc(bool _enforceKyc) external onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setTradeOrder(address seller, uint256 quantity, uint256 price) external onlyOwner {
        orderBook[seller] = TradeOrder({quantity: quantity, price: price});
    }

    function multiExecute(address[] memory sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {
        require(!enforceKyc || ITrade(this).isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        totalVouchers = 0;
        for (uint i = 0; i < sellers.length; i++) {
            TradeOrder memory to = orderBook[sellers[i]];
            if (i == sellers.length - 1) {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), lastQuantity, to.price);
                totalVouchers += voucherCount;
            } else {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), to.quantity, to.price);
                totalVouchers += voucherCount;
            }
        }
        return totalVouchers;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MarketPlace {
    using SafeMath for uint256;

    mapping(address => uint256) public sellersBalance;

    event Purchase(address buyer, address[] sellers, uint256 amount);

    function buyFromMultipleSellers(address payable[] memory sellers, uint256 totalAmount) public payable {
        uint256 sellersCount = sellers.length;
        require(sellersCount > 0, ""No sellers provided"");
        require(totalAmount == msg.value, ""Insufficient paid amount"");

        uint256 perSellerAmount = totalAmount.div(sellersCount);
        require(perSellerAmount > 0, ""Amount too low to split between sellers"");

        for(uint256 i = 0; i < sellersCount; i++) {
            sellersBalance[sellers[i]] = sellersBalance[sellers[i]].add(perSellerAmount);
            sellers[i].transfer(perSellerAmount);
        }

        emit Purchase(msg.sender, sellers, totalAmount);
    }
}",10.016853094100952,buyFromMultipleSellers,"[{'function': 'buyFromMultipleSellers', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyFromMultipleSellers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""length"": None}, ""name"": ""sellers"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sellersCount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""memberName"": ""length""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""sellersCount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No sellers provided""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""totalAmount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient paid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""perSellerAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalAmount""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sellersCount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""perSellerAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount too low to split between sellers""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellersCount""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellersBalance""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellersBalance""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""perSellerAmount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""perSellerAmount""}], ""names"": []}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Purchase""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""sellers""}, {""type"": ""Identifier"", ""name"": ""totalAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",62.0,0.677488910327733,0.1006900536215098,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MarketPlace is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public sellersBalance;

    event Purchase(address buyer, address[] sellers, uint256 amount);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function buyFromMultipleSellers(address payable[] memory sellers, uint256 totalAmount) public payable {
        uint256 sellersCount = sellers.length;
        require(sellersCount > 0, ""No sellers provided"");
        require(totalAmount == msg.value, ""Insufficient paid amount"");

        uint256 perSellerAmount = totalAmount.div(sellersCount);
        require(perSellerAmount > 0, ""Amount too low to split between sellers"");

        for(uint256 i = 0; i < sellersCount; i++) {
            sellersBalance[sellers[i]] = sellersBalance[sellers[i]].add(perSellerAmount);
            sellers[i].transfer(perSellerAmount);
        }

        emit Purchase(msg.sender, sellers, totalAmount);
    }
}"
2617,Set current mtdAmount price in wei for one token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MTDContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdAmount;

    function setMtdAmount(uint256 mtdAmountInWei) public onlyOwner {
        require(mtdAmountInWei > 0, ""MTD amount must be greater than zero"");
        require(mtdAmount != mtdAmountInWei, ""MTD amount has not changed"");
        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices function
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyToken is ReentrancyGuard {
    using SafeMath for uint256;

    // State variable for the mtdAmount price
    uint256 private mtdAmount;

    // Only the owner can set the price
    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can execute this function"");
        _;
    }

    // The owner of the contract
    address private owner;

    constructor() {
        owner = msg.sender; // The sender is the owner
    }

    function setMtdAmount(uint256 _mtdAmount) public onlyOwner {
        mtdAmount = _mtdAmount;
    }
}",7.773638010025024,setMtdAmount,"[{'function': 'setMtdAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMtdAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_mtdAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_mtdAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.8743424588940532,0.0371307127869061,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    // State variable for the mtdAmount price
    uint256 private mtdAmount;

    constructor() Ownable(msg.sender) {
        mtdAmount = 1; // Set to a non-zero, safe value
    }

    function setMtdAmount(uint256 _mtdAmount) public onlyOwner {
        require(_mtdAmount != 0, ""Value must be greater than zero""); // Ensure safety and correctness
        mtdAmount = _mtdAmount;
    }
}"
191,"Change period duration to ` @ transformTime ( _periodDuration ) ` , effective for next accounting period","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISettings {
    function periodDuration() external view returns (uint64);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Settings {
        uint64 periodDuration;
    }

    Settings public settings;

    event ChangePeriodDuration(uint64 indexed periodDuration);

    error ERROR_SET_PERIOD_TOO_SHORT();

    function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE, arr(uint256(_periodDuration), uint256(settings.periodDuration))) transitionsPeriod {
        require(_periodDuration >= 1 days, ERROR_SET_PERIOD_TOO_SHORT);
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ChangePeriod is Ownable {

    uint256 public periodDuration;
    bool private changingPeriod = false;

    event periodChanged(uint256 newPeriod);

    function setPeriodDuration(uint256 _periodDuration) public onlyOwner {
        require(!changingPeriod, ""Change in progress"");
        changingPeriod = true;
        uint256 newPeriod = transformTime(_periodDuration);
        periodDuration = newPeriod;
        emit periodChanged(newPeriod);
        changingPeriod = false;
    }

    function transformTime(uint256 time) internal pure returns (uint256) {
        return time * 1 days;
    }
}",6.46448278427124,setPeriodDuration,"[{'function': 'setPeriodDuration', 'complexity': 2}, {'function': 'transformTime', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPeriodDuration"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""changingPeriod""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Change in progress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""changingPeriod""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPeriod"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transformTime""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_periodDuration""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPeriod""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""periodChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newPeriod""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""changingPeriod""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",20.0,0.863161402413277,0.1223122210236073,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ChangePeriod is Ownable {

    uint256 public periodDuration;
    bool private changingPeriod = false;

    event periodChanged(uint256 newPeriod);

    constructor() Ownable(msg.sender) {
        periodDuration = 1 days; // Set to a fixed, safe value
    }

    function setPeriodDuration(uint256 _periodDuration) public onlyOwner {
        require(!changingPeriod, ""Change in progress"");
        changingPeriod = true;
        uint256 newPeriod = transformTime(_periodDuration);
        periodDuration = newPeriod;
        emit periodChanged(newPeriod);
        changingPeriod = false;
    }

    function transformTime(uint256 time) internal pure returns (uint256) {
        return time * 1 days;
    }
}"
243,Allows resetting the entire bid decryption/appending process in case a mistake was made and it is not possible to continue appending further bids .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum state { active, ended }

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
    }

    mapping(uint => Bid) public bids;
    uint[] public bids_decrypted;
    uint public bids_reset_count;
    uint public bids_decrypted_count;
    uint public bids_sorted_count;
    uint public bids_ignored_count;
    uint public bids_burned_count;
    state public status;

    function resetAppendDecryptedBids(uint _count) public onlyOwner {
        require(status == state.ended);
        require(bids_decrypted_count > 0);
        require(_count > 0);

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted_count;
        }

        uint count = _count;
        if (bids_reset_count < count) {
            count = bids_reset_count;
        }

        do {
            bids_reset_count--;
            bids[bids_decrypted[bids_reset_count]].is_decrypted = false;
            bids[bids_decrypted[bids_reset_count]].is_burned = false;
            bids[bids_decrypted[bids_reset_count]].will_compute = false;
            count--;
        } while (count > 0);

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BidContract is Ownable {
    uint256 public bidCount;
    mapping(uint256 => bytes32) public bids;

    function resetBidProcess() public onlyOwner {
        for(uint256 i = 0; i < bidCount; i++) {
            delete bids[i];
        }
        bidCount = 0;
    }
}",4.980244159698486,resetBidProcess,"[{'function': 'resetBidProcess', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""resetBidProcess"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""bidCount""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""isPrefix"": True}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bidCount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",61.0,0.7465167782725125,0.0109700869174461,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BidContract is Ownable {
    uint256 public bidCount = 1; // Set to 1 (never 0)
    mapping(uint256 => bytes32) public bids;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        bidCount = 1; // Ensure it's not zero
    }

    function resetBidProcess() public onlyOwner {
        for (uint256 i = 0; i < bidCount; i++) {
            delete bids[i];
        }
        bidCount = 0; // Reset to zero, as per the logic in the function
    }
}"
6808,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public buyPrice;
    uint256 public sellPrice;

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenExchange is ERC20, Ownable {
    using SafeMath for uint256;

    uint256 public buyPrice;
    uint256 public sellPrice;

    constructor(uint256 initialSupply, uint256 _buyPrice, uint256 _sellPrice) ERC20(""Token"", ""TKN"") {
        _mint(msg.sender, initialSupply);
        setPrices(_buyPrice, _sellPrice);
    }

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }

    function buyTokens() public payable {
        uint256 amount = msg.value.mul(buyPrice);
        require(amount <= balanceOf(address(this)), ""Not enough tokens available"");
        _transfer(address(this), msg.sender, amount);
    }

    function sellTokens(uint256 amount) public {
        require(amount <= balanceOf(msg.sender), ""Not enough tokens"");
        _transfer(msg.sender, address(this), amount);
        payable(msg.sender).transfer(amount.div(sellPrice));
    }
}",13.062616109848022,buyTokens,"[{'function': 'setPrices', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 1}, {'function': 'sellTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""buyPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens available""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",24.0,0.5052760837907219,0.0126408748199873,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenExchange is ERC20, Ownable {
    using SafeMath for uint256;

    uint256 public buyPrice;
    uint256 public sellPrice;

    mapping(address => uint256) public balanceOf;

 constructor(uint256 initialSupply, uint256 _buyPrice, uint256 _sellPrice) ERC20(""Token"", ""TKN"") Ownable(msg.sender) {
        _mint(msg.sender, initialSupply);
        setPrices(_buyPrice, _sellPrice);
    }

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }

    function buyTokens() public payable {
        uint256 amount = msg.value.mul(buyPrice);
        require(amount <= balanceOf(address(this)), ""Not enough tokens available"");
        _transfer(address(this), msg.sender, amount);
    }

    function sellTokens(uint256 amount) public {
        require(amount <= balanceOf(msg.sender), ""Not enough tokens"");
        _transfer(msg.sender, address(this), amount);
        payable(msg.sender).transfer(amount.div(sellPrice));
    }
}"
4005,Buy quantity of tokens depending on the amount of sent ethers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event SoldToken(address indexed buyer, uint256 value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function BuyToken(address _buyer, uint256 _value, string memory note) public onlyOwner {
        require(balances[msg.sender] >= _value && balances[_buyer].add(_value) > balances[_buyer], ""Insufficient balance or overflow"");
        SoldToken(_buyer, _value, note);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_buyer] = balances[_buyer].add(_value);
        Transfer(msg.sender, _buyer, _value);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

contract TokenSale is ReentrancyGuard {
    IERC20 public token;
    uint256 public tokenPriceInWei;

    constructor(IERC20 _token, uint256 _tokenPriceInWei) {
        token = _token;
        tokenPriceInWei = _tokenPriceInWei;
    }

    function buyTokens() public payable nonReentrant {
        uint256 tokensToBuy = msg.value / tokenPriceInWei;
        require(token.balanceOf(address(this)) >= tokensToBuy, ""Not enough tokens in contract"");
        token.transfer(msg.sender, tokensToBuy);
    }
}",12.031489849090576,buyTokens,"[{'function': 'buyTokens', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokensToBuy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenPriceInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensToBuy""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokensToBuy""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",52.0,0.7020633780590306,0.0326332995897589,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is ReentrancyGuard, Ownable {
    IERC20 public token;
    uint256 public tokenPriceInWei;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token, uint256 _tokenPriceInWei) Ownable(msg.sender) {
        token = _token;
        tokenPriceInWei = _tokenPriceInWei;
    }

    function buyTokens() public payable nonReentrant {
        uint256 tokensToBuy = msg.value / tokenPriceInWei;
        require(token.balanceOf(address(this)) >= tokensToBuy, ""Not enough tokens in contract"");
        token.transfer(msg.sender, tokensToBuy);
    }
}"
5639,Transfers asset balance from the caller to specified receiver .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return _transferWithReference(_to, _value, """");
        }
    }
}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract MyContract is ERC20 {

    using SafeMath for uint256;

    function transferAssetTo(uint256 amount, address receiver) public {
        require(amount <= balanceOf(msg.sender), ""Insufficient balance"");
        _transfer(msg.sender, receiver, amount);
    }
}",4.53133487701416,transferAssetTo,"[{'function': 'transferAssetTo', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferAssetTo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""receiver""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",17.0,0.6056112455380185,0.0429686991943911,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is ERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 constructor() ERC20(""MyToken"", ""MYT"") Ownable(msg.sender) {}

    function transferAssetTo(uint256 amount, address receiver) public {
        require(amount <= balanceOf(msg.sender), ""Insufficient balance"");
        _transfer(msg.sender, receiver, amount);
    }
}"
971,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function approveSpender(address _spender, uint256 _value) public returns (bool) {
        _approve(msg.sender, _spender, _value);
        return true;
    }
}",5.89132285118103,approveSpender,"[{'function': 'approveSpender', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",10.0,0.9057801546418628,0.6431924725481222,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") Ownable(msg.sender) {
        _mint(owner(), initialSupply);
    }

    function approveSpender(address _spender, uint256 _value) public returns (bool) {
        _approve(msg.sender, _spender, _value);
        return true;
    }
}"
2396,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract OfferWrapper is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    bool public enforceKyc = false;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed user, uint256 quantity, uint256 price, uint256 expiry);

    function offer(uint256 quantity, uint256 price, uint256 expiry) public {
        require(enforceKyc == false || isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = ERC20Interface(_tokenContract);
    }

    function setEnforceKyc(bool _enforceKyc) public onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setSellFloor(uint256 _sellFloor) public onlyOwner {
        sellFloor = _sellFloor;
    }

    function setSellCeiling(uint256 _sellCeiling) public onlyOwner {
        sellCeiling = _sellCeiling;
    }

    function isAllowedTrade(address user) internal view returns (bool) {
        // Implement your KYC logic here
        return true; // Placeholder for actual implementation
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    uint256 public rate;

    constructor(IERC20 _token, uint256 _rate) {
        require(address(_token) != address(0), ""TokenSale: Zero token address"");
        require(_rate > 0, ""TokenSale: Non-positive rate"");

        token = _token;
        rate = _rate;
    }

    function setRate(uint256 _rate) public onlyOwner {
        require(_rate > 0, ""TokenSale: Non-positive rate"");
        rate = _rate;
    }

    function buyTokens(uint256 _amount) public payable {
        require(msg.value >= _amount.mul(rate), ""TokenSale: Insufficient ETH for tokens"");
        require(token.allowance(msg.sender, address(this)) >= _amount, ""TokenSale: Not enough allowed tokens"");

        uint256 cost = _amount.mul(rate);
        token.transferFrom(msg.sender, address(this), _amount);
        payable(owner()).transfer(cost);
    }
}",11.070684909820557,buyTokens,"[{'function': 'setRate', 'complexity': 1}, {'function': 'buyTokens', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rate""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""TokenSale: Insufficient ETH for tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""TokenSale: Not enough allowed tokens""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""cost"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cost""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}",83.0,0.6267288867908952,0.0480916761173451,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public rate;

    constructor(IERC20 _token, uint256 _rate) Ownable(msg.sender) {
        require(_token != IERC20(address(0)), ""TokenSale: Zero token address"");
        require(_rate > 0, ""TokenSale: Non-positive rate"");

        token = _token;
        rate = _rate;
    }

    function setRate(uint256 _rate) public onlyOwner {
        require(_rate > 0, ""TokenSale: Non-positive rate"");
        rate = _rate;
    }

    function buyTokens(uint256 _amount) public payable {
        require(msg.value >= _amount.mul(rate), ""TokenSale: Insufficient ETH for tokens"");
        require(token.allowance(msg.sender, address(this)) >= _amount, ""TokenSale: Not enough allowed tokens"");

        uint256 cost = _amount.mul(rate);
        token.transferFrom(msg.sender, address(this), _amount);
        payable(owner()).transfer(cost);
    }
}"
2112,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed receiver, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Contract is Ownable {
    using SafeERC20 for IERC20;

    function recoverERC20(IERC20 token) external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        token.safeTransfer(owner(), balance);
    }
}",5.470345973968506,recoverERC20,"[{'function': 'recoverERC20', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""recoverERC20"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",23.0,0.6556560213078878,0.1094535608659488,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Contract is Ownable {
    using SafeERC20 for IERC20;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables
        uint256 _uintValue = 1;
        address _addressValue = 0x1111111111111111111111111111111111111111; // Replace with actual address
        bool _boolValue = true;
        string _stringValue = 'initialized';
        bytes32 _bytes32Value = bytes32('init');
    }

    function recoverERC20(IERC20 token) external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        token.safeTransfer(owner(), balance);
    }
}"
5098,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public withdrawalRequests;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        if (withdrawalRequests[_from] > 0) revert();
        if (withdrawalRequests[_to] > 0) revert();
        if (balanceOf[_from].sub(balanceOf[_from]) != balanceOf[_from]) revert();
        if (balanceOf[_to].add(_value) < balanceOf[_to]) revert();
        if (_value.add(allowance[_from][msg.sender]) != allowance[_from][msg.sender]) revert();
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TokenContract is ERC20 {
    using SafeMath for uint256;

    mapping (address => mapping (address => uint256)) private _allowances;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        uint256 currentAllowance = _allowances[_from][_to];
        require(currentAllowance >= _value, ""ERC20: transfer amount exceeds allowance"");
        _allowances[_from][_to] = currentAllowance.sub(_value);
        _transfer(_from, _to, _value);
        return true;
    }
}",7.302851915359497,transferFrom,"[{'function': 'transferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: transfer amount exceeds allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",73.0,0.892225399101311,0.1689714299235271,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is ERC20, Ownable {
    using SafeMath for uint256;

    mapping (address => mapping (address => uint256)) private _allowances;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 1 * 10 ** decimals(); // Example initial supply
        _mint(msg.sender, initialSupply);
    }

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {
        uint256 currentAllowance = _allowances[_from][_to];
        require(currentAllowance >= _value, ""ERC20: transfer amount exceeds allowance"");
        _allowances[_from][_to] = currentAllowance.sub(_value);
        _transfer(_from, _to, _value);
        return true;
    }
}"
3297,Used by a staker to withdraw their initial stake,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    enum StakeStateEnum { staked, released }

    struct Stake {
        uint256 initialStake;
        StakeStateEnum state;
    }

    mapping(address => mapping(uint256 => Stake)) public stakes;
    uint256 public activeStakes;
    mapping(address => uint256) public internalRTCBalances;
    IERC20 public RTI;

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staked, ""Invalid stake state"");
        _;
    }

    function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {
        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.released;
        activeStakes = activeStakes.sub(1);
        internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
        require(RTI.transfer(msg.sender, initialStake), ""Unable to transfer tokens likely due to incorrect balance"");
        return true;
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract StakeContract is ReentrancyGuard {
    using SafeMath for uint256;

    ERC20 public token;

    mapping(address => uint256) private stakes;

    constructor(ERC20 _token) {
        token = _token;
    }

    function withdrawStake(uint256 _amount) public nonReentrant {
        require(_amount > 0, ""Withdrawal amount must be greater than zero"");

        uint256 balance = stakes[msg.sender];
        require(balance >= _amount, ""Withdrawal amount exceeds staked balance"");

        stakes[msg.sender] = balance.sub(_amount);
        token.transfer(msg.sender, _amount);
    }
}",9.249742269515991,withdrawStake,"[{'function': 'withdrawStake', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Withdrawal amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Withdrawal amount exceeds staked balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""nonReentrant"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",41.0,0.738825195417999,0.03909923856047,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract StakeContract is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    ERC20 public token;

    mapping(address => uint256) private stakes;

    constructor(ERC20 _token) Ownable(msg.sender) {
        token = _token;
    }

    function withdrawStake(uint256 _amount) public nonReentrant {
        require(_amount > 0, ""Withdrawal amount must be greater than zero"");

        uint256 balance = stakes[msg.sender];
        require(balance >= _amount, ""Withdrawal amount exceeds staked balance"");

        stakes[msg.sender] = balance.sub(_amount);
        token.transfer(msg.sender, _amount);
    }
}"
1877,A function which allows the caller to approve the max amount of any given token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeERC20 {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 value) internal returns (bool) {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(ERC20.approve.selector, spender, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""SafeERC20: approve failed"");
        return true;
    }
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function approveAddress(address addressToApprove, address token) public onlyOwner {
        if (ERC20(token).allowance(address(this), addressToApprove) == 0) {
            require(SafeERC20.safeApprove(token, addressToApprove, uint256(-1)));
        }
    }
}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract ApprovalFunction {

    function approveMax(address tokenAddress, address spender) public returns (bool) {
        IERC20 token = IERC20(tokenAddress);
        uint256 maxApproval = type(uint256).max;
        require(token.approve(spender, maxApproval), ""Token approval failed"");
        return true;
    }
}",6.068320035934448,approveMax,"[{'function': 'approveMax', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveMax"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""maxApproval"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""maxApproval""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token approval failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}",27.0,0.7803624632311161,0.1745572477865013,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ApprovalFunction is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveMax(address tokenAddress, address spender) public returns (bool) {
        IERC20 token = IERC20(tokenAddress);
        uint256 maxApproval = type(uint256).max;
        require(token.approve(spender, maxApproval), ""Token approval failed"");
        return true;
    }
}"
