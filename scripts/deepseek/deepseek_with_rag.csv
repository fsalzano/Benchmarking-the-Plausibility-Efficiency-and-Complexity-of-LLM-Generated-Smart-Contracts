ID,Comment,Contract,cognitive_complexity,cyclomatic_complexity,ast,DeepSeekGenerated,Time,target_function,TED,SemanticSimilarity,BLEU,DeepseekCognitiveComplexity,DeepseekCyclomaticComplexity,contract_with_constructor
3024,Announce that a particular future Ethereum fork will the one taken by the contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""Caller is not a role"");
        _;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceFork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""url"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""blockNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}, {""type"": ""stringLiteral"", ""value"": ""Block number must be greater than the current block number""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkUrl""}, ""right"": {""type"": ""Identifier"", ""name"": ""url""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_nextForkBlockNumber""}, ""right"": {""type"": ""Identifier"", ""name"": ""blockNumber""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogForkAnnounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""url""}, {""type"": ""Identifier"", ""name"": ""blockNumber""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyRolePlatformOperatorRepresentative"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract ForkAnnouncement is AccessControl {
    bytes32 public constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = keccak256(""ROLE_PLATFORM_OPERATOR_REPRESENTATIVE"");

    string private _nextForkName;
    string private _nextForkUrl;
    uint private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint blockNumber);

    modifier onlyRolePlatformOperatorRepresentative() {
        require(hasRole(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE, msg.sender), ""Caller is not a platform operator representative"");
        _;
    }

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE, msg.sender);
    }

    function announceFork(string memory name, string memory url, uint blockNumber) public onlyRolePlatformOperatorRepresentative {
        require(blockNumber > block.number, ""Block number must be greater than the current block number"");

        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;

        emit LogForkAnnounced(name, url, blockNumber);
    }
}",50.030202865600586,announceFork,6.0,0.8768495736283783,0.5340038801444194,"[{'function': 'announceFork', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ForkAnnouncement is AccessControl, Ownable {
    bytes32 public constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = keccak256(""ROLE_PLATFORM_OPERATOR_REPRESENTATIVE"");

    string private _nextForkName;
    string private _nextForkUrl;
    uint private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint blockNumber);

    modifier onlyRolePlatformOperatorRepresentative() {
        require(hasRole(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE, msg.sender), ""Caller is not a platform operator representative"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE, msg.sender);
        _nextForkName = 'initialized';
        _nextForkUrl = 'initialized';
        _nextForkBlockNumber = 1;
    }

    function announceFork(string memory name, string memory url, uint blockNumber) public onlyRolePlatformOperatorRepresentative {
        require(blockNumber > block.number, ""Block number must be greater than the current block number"");

        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;

        emit LogForkAnnounced(name, url, blockNumber);
    }
}"
2295,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    constructor(address _tokenContract, uint256 _sellFloor, uint256 _sellCeiling) {
        tokenContract = ERC20Interface(_tokenContract);
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function sell(uint256 quantity, uint256 price, uint256 expiry) public {
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sell', 'complexity': 8}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""offerTokensForSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to sell tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Allowance is insufficient for the specified quantity of tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TradeOrder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": [""quantity"", ""price"", ""expiry""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensOffered""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validTradeParameters"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenSale {
    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    modifier validTradeParameters(uint256 quantity, uint256 price, uint256 expiry) {
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(price > 0, ""Price must be greater than zero"");
        require(expiry > block.timestamp, ""Expiry date must be in the future"");
        require(price >= sellFloor, ""Price must meet or exceed the minimum allowed price"");
        if (sellCeiling != 0) {
            require(price <= sellCeiling, ""Price must not exceed the maximum allowed price"");
        }
        _;
    }

    constructor(uint256 _sellFloor, uint256 _sellCeiling) {
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function offerTokensForSale(uint256 quantity, uint256 price, uint256 expiry) external validTradeParameters(quantity, price, expiry) {
        require(msg.sender.balance >= quantity, ""Insufficient balance to sell tokens"");
        require(_allowance(msg.sender) >= quantity, ""Allowance is insufficient for the specified quantity of tokens"");

        orderBook[msg.sender] = TradeOrder({quantity: quantity, price: price, expiry: expiry});
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function _allowance(address owner) internal view returns (uint256) {
        return IERC20(tokenContract).allowance(owner, address(this));
    }

    // Assuming a token contract interface for allowance and balance checks
    address public tokenContract;
}",46.737587690353394,offerTokensForSale,70.0,0.6954759737128828,0.1674006588595661,"[{'function': 'offerTokensForSale', 'complexity': 2}, {'function': '_allowance', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    modifier validTradeParameters(uint256 quantity, uint256 price, uint256 expiry) {
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(price > 0, ""Price must be greater than zero"");
        require(expiry > block.timestamp, ""Expiry date must be in the future"");
        require(price >= sellFloor, ""Price must meet or exceed the minimum allowed price"");
        if (sellCeiling != 0) {
            require(price <= sellCeiling, ""Price must not exceed the maximum allowed price"");
        }
        _;
    }

    constructor(uint256 _sellFloor, uint256 _sellCeiling) Ownable(msg.sender) {
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function offerTokensForSale(uint256 quantity, uint256 price, uint256 expiry) external validTradeParameters(quantity, price, expiry) {
        require(msg.sender.balance >= quantity, ""Insufficient balance to sell tokens"");
        require(_allowance(msg.sender) >= quantity, ""Allowance is insufficient for the specified quantity of tokens"");

        orderBook[msg.sender] = TradeOrder({quantity: quantity, price: price, expiry: expiry});
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function _allowance(address owner) internal view returns (uint256) {
        return IERC20(tokenContract).allowance(owner, address(this));
    }

    // Assuming a token contract interface for allowance and balance checks
    address public tokenContract;
}"
1386,Set the minimum deposit amount required to depoist sUSD into the FIFO queue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol""; // Assuming this import is correct, adjust if necessary

abstract contract YourContract {
    using SafeMath for uint256;
    uint public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint indexed newAmount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        require(_amount > SafeDecimalMath.unit(), ""Minimum deposit amount must be greater than UNIT"");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(minimumDepositAmount);
    }
}","[{'function': 'setMinimumDepositAmount', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinimumDepositAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minimum deposit amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minimumDepositAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MinimumDepositAmountUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract DepositManager is Ownable {
    uint public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint newAmount);

    constructor(uint _initialMinimumDeposit) {
        require(_initialMinimumDeposit > 0, ""Initial deposit amount must be greater than zero"");
        minimumDepositAmount = _initialMinimumDeposit;
    }

    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        require(_amount > 0, ""Minimum deposit amount must be greater than zero"");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(_amount);
    }
}",42.80256652832031,setMinimumDepositAmount,3.0,0.8640260263816363,0.7223834112589387,"[{'function': 'setMinimumDepositAmount', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DepositManager is Ownable {
    uint public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint newAmount);

    constructor() Ownable(msg.sender) {
        minimumDepositAmount = 1; // Set to a non-zero value
    }

    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        require(_amount > 0, ""Minimum deposit amount must be greater than zero"");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(_amount);
    }
}"
6236,Helper function that checks for ERC777TokensSender on the sender and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensSender {
    function tokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function callSender(address _operator, address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) private whenNotPaused {
        address senderImplementation = interfaceAddr(_from, ""ERC777TokensSender"");
        if (senderImplementation != 0) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    function interfaceAddr(address contractAddress, string memory interfaceName) internal view returns (address) {
        // Implementation of the logic to retrieve the interface address
        return contractAddress;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","[{'function': 'tokensToSend', 'complexity': 0}, {'function': 'callSender', 'complexity': 1}, {'function': 'interfaceAddr', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""callTokensToSend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_userData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""implementationAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""interfaceAddr""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""implementationAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC777TokensSender""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""implementationAddress""}], ""names"": []}, ""memberName"": ""tokensToSend""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_userData""}, {""type"": ""Identifier"", ""name"": ""_operatorData""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""private"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ERC777TokensSender {
    function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;
}

contract TokenTransferrer {
    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    bool public paused = false;

    function callTokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) private {
        address implementationAddress = interfaceAddr(_from);
        if (implementationAddress != address(0)) {
            ERC777TokensSender(implementationAddress).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    function interfaceAddr(address account) internal view returns (address) {
        // This is a placeholder for the actual logic to retrieve the implementation address.
        // For example purposes, let's assume it returns a fixed address.
        return 0x1234567890123456789012345678901234567890;
    }
}",44.49495887756348,callTokensToSend,4.0,0.9299688317217508,0.6415912220409412,"[{'function': 'tokensToSend', 'complexity': 0}, {'function': 'callTokensToSend', 'complexity': 1}, {'function': 'interfaceAddr', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

interface ERC777TokensSender {
    function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external;
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTransferrer is Ownable {
    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    bool public paused = false;

    function callTokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) private {
        address implementationAddress = interfaceAddr(_from);
        if (implementationAddress != address(0)) {
            ERC777TokensSender(implementationAddress).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    function interfaceAddr(address account) internal view returns (address) {
        // This is a placeholder for the actual logic to retrieve the implementation address.
        // For example purposes, let's assume it returns a fixed address.
        return 0x1234567890123456789012345678901234567890;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        paused = false;
    }
}"
1700,This method will can be called by the controller after the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Tier {
        bool initialized;
        uint256 startTime;
        uint256 endTime;
        uint256 finalizedTime;
        bool finalized;
    }

    mapping(uint256 => Tier) public tiers;
    uint256 public tierCount;

    event FinalizedTier(uint256 indexed tierIndex, uint256 time);

    function finalize() public initialized {
        Tier storage tier = tiers[tierCount];
        require(!tier.finalized, ""Tier is already finalized"");
        require(block.timestamp >= tier.startTime, ""Start time has not been reached"");
        require(msg.sender == owner() || block.timestamp > tier.endTime || isCurrentTierCapReached(), ""Not authorized to finalize this tier"");
        tier.finalized = true;
        tier.finalizedTime = block.timestamp;
        emit FinalizedTier(tierCount, block.timestamp);
        tierCount++;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }

    // State variables for fork announcement
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string indexed name, string indexed url, uint256 indexed blockNumber);
}","[{'function': 'finalize', 'complexity': 5}, {'function': 'announceFork', 'complexity': 2}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""tierCount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tiers""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""No more tiers to finalize""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Tier""}, ""name"": ""currentTier"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tiers""}, ""index"": {""type"": ""Identifier"", ""name"": ""tierCount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTier""}, ""memberName"": ""finalized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""This tier is already finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTier""}, ""memberName"": ""startTime""}}, {""type"": ""stringLiteral"", ""value"": ""The start time of this tier has not yet arrived""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""canFinalize"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTier""}, ""memberName"": ""endTime""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTier""}, ""memberName"": ""cap""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""canFinalize""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""canFinalize""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""canFinalize""}, {""type"": ""stringLiteral"", ""value"": ""Conditions not met to finalize this tier""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTier""}, ""memberName"": ""finalized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTier""}, ""memberName"": ""finalizedTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""FinalizedTier""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tierCount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""tierCount""}, ""isPrefix"": False}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MultiTierSystem {
    struct Tier {
        uint256 startTime;
        uint256 endTime;
        uint256 cap;
        bool finalized;
        uint256 finalizedTime;
    }

    address public controller;
    Tier[] public tiers;
    uint256 public tierCount;

    event FinalizedTier(uint256 indexed tierIndex, uint256 time);

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor(address _controller) {
        controller = _controller;
    }

    function addTier(uint256 startTime, uint256 endTime, uint256 cap) external onlyController {
        tiers.push(Tier({
            startTime: startTime,
            endTime: endTime,
            cap: cap,
            finalized: false,
            finalizedTime: 0
        }));
    }

    function finalize() external onlyController {
        require(tierCount < tiers.length, ""No more tiers to finalize"");

        Tier storage currentTier = tiers[tierCount];
        require(!currentTier.finalized, ""This tier is already finalized"");
        require(block.timestamp >= currentTier.startTime, ""The start time of this tier has not yet arrived"");

        bool canFinalize;
        if (block.timestamp > currentTier.endTime || currentTier.cap == 0) {
            canFinalize = true;
        } else {
            // Additional conditions for finalization can be added here
            canFinalize = false;
        }

        require(canFinalize, ""Conditions not met to finalize this tier"");

        currentTier.finalized = true;
        currentTier.finalizedTime = block.timestamp;
        emit FinalizedTier(tierCount, block.timestamp);

        tierCount++;
    }
}",46.176974296569824,finalize,25.0,0.851392333028909,0.2828501020233578,"[{'function': 'addTier', 'complexity': 0}, {'function': 'finalize', 'complexity': 7}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiTierSystem is Ownable {
    struct Tier {
        uint256 startTime;
        uint256 endTime;
        uint256 cap;
        bool finalized;
        uint256 finalizedTime;
    }

    address public controller;
    Tier[] public tiers;
    uint256 public tierCount;

    event FinalizedTier(uint256 indexed tierIndex, uint256 time);

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor(address _controller) Ownable() {
        controller = _controller;
        // Initialize tiers with fixed values
        Tier memory initialTier = Tier({
            startTime: 1,
            endTime: 2,
            cap: 3,
            finalized: false,
            finalizedTime: 0
        });
        tiers.push(initialTier);
    }

    function addTier(uint256 startTime, uint256 endTime, uint256 cap) external onlyController {
        Tier memory newTier = Tier({
            startTime: startTime,
            endTime: endTime,
            cap: cap,
            finalized: false,
            finalizedTime: 0
        });
        tiers.push(newTier);
    }

    function finalize() external onlyController {
        require(tierCount < tiers.length, ""No more tiers to finalize"");

        Tier storage currentTier = tiers[tierCount];
        require(!currentTier.finalized, ""This tier is already finalized"");
        require(block.timestamp >= currentTier.startTime, ""The start time of this tier has not yet arrived"");

        bool canFinalize;
        if (block.timestamp > currentTier.endTime || currentTier.cap == 0) {
            canFinalize = true;
        } else {
            // Additional conditions for finalization can be added here
            canFinalize = false;
        }

        require(canFinalize, ""Conditions not met to finalize this tier"");

        currentTier.finalized = true;
        currentTier.finalizedTime = block.timestamp;
        emit FinalizedTier(tierCount, block.timestamp);

        tierCount++;
    }
}"
250,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public constant absoluteMinTimeLock = 1 days; // Example value, adjust as needed

    function setTimelock(uint _newTimeLock) external onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock);
        timeLock = _newTimeLock;
    }
}","[{'function': 'setTimelock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNewTimeLock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""Timelock must be at least 1 day""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TimeLockUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newTimeLock""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TimeLockSetter {
    uint public timeLock;
    uint public constant absoluteMinTimeLock = 1 days; // Example minimum timelock value in seconds
    address public owner;

    event TimeLockUpdated(uint newTimeLock);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setNewTimeLock(uint _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""Timelock must be at least 1 day"");
        timeLock = _newTimeLock;
        emit TimeLockUpdated(_newTimeLock);
    }
}",42.68287777900696,setNewTimeLock,5.0,0.8552310421992549,0.3482990918507536,"[{'function': 'setNewTimeLock', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TimeLockSetter is Ownable {
    uint public timeLock;
    uint public constant absoluteMinTimeLock = 1 days; // Example minimum timelock value in seconds

    event TimeLockUpdated(uint newTimeLock);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Caller is not the owner"");
        _;
    }

    constructor() Ownable() {
        timeLock = 1 days; // Set to minimum allowed value
    }

    function setNewTimeLock(uint _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""Timelock must be at least 1 day"");
        timeLock = _newTimeLock;
        emit TimeLockUpdated(_newTimeLock);
    }
}"
5791,Give melon tokens to receive shares of this fund,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceFeed {
    function getLastUpdateId() external view returns (uint);
}

interface ComplianceModule {
    function isInvestmentPermitted(address participant, uint giveQuantity, uint shareQuantity) external view returns (bool);
}

abstract contract InvestmentRequestManager is Ownable {
    using SafeMath for uint;

    enum RequestStatus { inactive, active, completed }

    struct Request {
        address participant;
        RequestStatus status;
        address requestAsset;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
    }

    Request[] public requests;
    mapping(address => bool) public isInvestAllowed;
    bool public isShutDown = false;
    PriceFeed public modules;

    event RequestUpdated(uint requestId);

    constructor(PriceFeed _modules) {
        modules = _modules;
    }

    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external pre_cond(!isShutDown) pre_cond(isInvestAllowed[investmentAsset]) pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity)) {
        requests.push(Request({
            participant: msg.sender,
            status: RequestStatus.active,
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity,
            timestamp: block.timestamp,
            atUpdateId: modules.getLastUpdateId()
        }));
        emit RequestUpdated(requests.length - 1);
    }
}","[{'function': 'getLastUpdateId', 'complexity': 0}, {'function': 'isInvestmentPermitted', 'complexity': 0}, {'function': 'requestInvestment', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""requestInvestment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""giveQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""shareQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""investmentAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isInvestAllowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""investmentAsset""}}, {""type"": ""stringLiteral"", ""value"": ""Investment in this asset is not allowed.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Request""}, ""name"": ""newRequest"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Request""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""stringLiteral"", ""value"": ""active""}, {""type"": ""Identifier"", ""name"": ""investmentAsset""}, {""type"": ""Identifier"", ""name"": ""shareQuantity""}, {""type"": ""Identifier"", ""name"": ""giveQuantity""}, {""type"": ""Identifier"", ""name"": ""shareQuantity""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getLatestPriceFeedUpdateId""}, ""arguments"": [], ""names"": []}], ""names"": [""participant"", ""status"", ""requestAsset"", ""shareQuantity"", ""giveQuantity"", ""receiveQuantity"", ""timestamp"", ""atUpdateId""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newRequest""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""lastRequestId""}, ""isPrefix"": False}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RequestUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lastRequestId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyWhenOperational"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract InvestmentPlatform {
    bool public isShutDown;
    mapping(address => bool) public isInvestAllowed;
    uint256 public lastRequestId = 0;
    struct Request {
        address participant;
        string status;
        address requestAsset;
        uint256 shareQuantity;
        uint256 giveQuantity;
        uint256 receiveQuantity;
        uint256 timestamp;
        uint256 atUpdateId;
    }
    Request[] public requests;

    modifier onlyWhenOperational() {
        require(!isShutDown, ""System is shut down."");
        _;
    }

    function requestInvestment(uint256 giveQuantity, uint256 shareQuantity, address investmentAsset) external onlyWhenOperational {
        require(isInvestAllowed[investmentAsset], ""Investment in this asset is not allowed."");
        // Assuming compliance module check can be done here or through another function call
        Request memory newRequest = Request({
            participant: msg.sender,
            status: ""active"",
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity, // Initially set to the same as shareQuantity
            timestamp: block.timestamp,
            atUpdateId: getLatestPriceFeedUpdateId() // Assuming this function fetches the latest update ID from pricefeed module
        });
        requests.push(newRequest);
        lastRequestId++;
        emit RequestUpdated(lastRequestId);
    }

    function getLatestPriceFeedUpdateId() internal view returns (uint256) {
        // Placeholder for actual implementation of fetching the latest update ID from pricefeed module
        return 1; // Replace with actual logic
    }

    event RequestUpdated(uint256 indexed requestId);
}",45.96257162094116,requestInvestment,31.0,0.7951491329923759,0.3408713437007117,"[{'function': 'requestInvestment', 'complexity': 1}, {'function': 'getLatestPriceFeedUpdateId', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract InvestmentPlatform is Ownable {
    bool public isShutDown = false;
    mapping(address => bool) public isInvestAllowed;
    uint256 public lastRequestId = 1; // Set to 1 instead of 0
    struct Request {
        address participant;
        string status;
        address requestAsset;
        uint256 shareQuantity;
        uint256 giveQuantity;
        uint256 receiveQuantity;
        uint256 timestamp;
        uint256 atUpdateId;
    }
    Request[] public requests;

    modifier onlyWhenOperational() {
        require(!isShutDown, ""System is shut down."");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        lastRequestId = 1; // Set to 1 instead of 0
        isShutDown = false;
        // Assuming there are some predefined allowed investments for testing purposes
        isInvestAllowed[address(0x111)] = true;
        isInvestAllowed[address(0x222)] = true;
        isInvestAllowed[address(0x333)] = true;
    }

    function requestInvestment(uint256 giveQuantity, uint256 shareQuantity, address investmentAsset) external onlyWhenOperational {
        require(isInvestAllowed[investmentAsset], ""Investment in this asset is not allowed."");
        // Assuming compliance module check can be done here or through another function call
        Request memory newRequest = Request({
            participant: msg.sender,
            status: ""active"",
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity, // Initially set to the same as shareQuantity
            timestamp: block.timestamp,
            atUpdateId: getLatestPriceFeedUpdateId() // Assuming this function fetches the latest update ID from pricefeed module
        });
        requests.push(newRequest);
        lastRequestId++;
        emit RequestUpdated(lastRequestId);
    }

    function getLatestPriceFeedUpdateId() internal view returns (uint256) {
        // Placeholder for actual implementation of fetching the latest update ID from pricefeed module
        return 1; // Replace with actual logic
    }

    event RequestUpdated(uint256 indexed requestId);
}"
1160,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) external onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ItemPrices is Ownable {
    uint public sellPrice;
    uint public buyPrice;

    function setPrices(uint newSellPrice, uint newBuyPrice) external onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}",41.89055371284485,setPrices,0.0,0.9631848807318631,0.709421400618421,"[{'function': 'setPrices', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ItemPrices is Ownable {
    uint public sellPrice;
    uint public buyPrice;

    constructor() Ownable(msg.sender) {
        sellPrice = 1;
        buyPrice = 2;
    }

    function setPrices(uint newSellPrice, uint newBuyPrice) external onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}"
3416,Returns all the relevant information about a specific property .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PropertyInterface {
    function getProperty(uint256 _id) external view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    );
}

abstract contract PropertyWrapper is Ownable {
    using SafeMath for uint256;

    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    enum PropertyClass {
        NONE,
        BUILDING
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 y) internal pure returns (uint8 height) {
        // Placeholder for the actual computation logic
        return 0; // Replace with actual implementation if needed
    }

    function getProperty(uint256 _id) public view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];
        parent = uint32(property.parent);
        class = uint8(property.class);
        height = uint8(property.y);
        if (property.class == PropertyClass.BUILDING) {
            y = uint8(_computeHeight(property.x, property.z, property.y));
        } else {
            y = uint8(property.y);
        }
        x = uint8(property.x);
        z = uint8(property.z);
        dx = uint8(property.dx);
        dz = uint8(property.dz);
    }
}","[{'function': 'getProperty', 'complexity': 0}, {'function': '_computeHeight', 'complexity': 0}, {'function': 'getProperty', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPropertyDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""parent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""class"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""x"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""y"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""z"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""dx"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""dz"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""height"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Property""}, ""name"": ""property"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""parent""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""parent""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""class""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""class""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""x""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""x""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""y""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""y""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""z""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""z""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""dx""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""dx""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""dz""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""dz""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""property""}, ""memberName"": ""class""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PropertyClass""}, ""memberName"": ""BUILDING""}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""y""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_computeHeight""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""x""}, {""type"": ""Identifier"", ""name"": ""z""}, {""type"": ""Identifier"", ""name"": ""y""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""parent""}, {""type"": ""Identifier"", ""name"": ""class""}, {""type"": ""Identifier"", ""name"": ""x""}, {""type"": ""Identifier"", ""name"": ""y""}, {""type"": ""Identifier"", ""name"": ""z""}, {""type"": ""Identifier"", ""name"": ""dx""}, {""type"": ""Identifier"", ""name"": ""dz""}, {""type"": ""Identifier"", ""name"": ""height""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract PropertyRetriever {
    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 originalY) internal pure returns (uint8 height) {
        // Placeholder for the computation logic
        return uint8(originalY + x + z);
    }

    function getPropertyDetails(uint256 _id) public view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];

        parent = property.parent;
        class = property.class;
        x = property.x;
        y = property.y;
        z = property.z;
        dx = property.dx;
        dz = property.dz;

        if (property.class == uint8(PropertyClass.BUILDING)) {
            y = _computeHeight(x, z, y);
        }

        return (parent, class, x, y, z, dx, dz, height);
    }
}",44.797728300094604,getPropertyDetails,28.0,0.7911233596149096,0.4329250723385093,"[{'function': '_computeHeight', 'complexity': 0}, {'function': 'getPropertyDetails', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PropertyRetriever is Ownable {
    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 originalY) internal pure returns (uint8 height) {
        // Placeholder for the computation logic
        return uint8(originalY + x + z);
    }

    function getPropertyDetails(uint256 _id) public view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];

        parent = property.parent;
        class = property.class;
        x = property.x;
        y = property.y;
        z = property.z;
        dx = property.dx;
        dz = property.dz;

        if (property.class == uint8(PropertyClass.BUILDING)) {
            y = _computeHeight(x, z, y);
        }

        return (parent, class, x, y, z, dx, dz, height);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 id = 1;
        properties[id] = Property({
            parent: 1,
            class: uint8(PropertyClass.BUILDING),
            x: 1,
            y: 1,
            z: 1,
            dx: 1,
            dz: 1
        });
    }
}"
4560,Get the current total number of market listings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256[] public forSalePixelconIndexes;

    function totalListings() public view returns (uint256) {
        return forSalePixelconIndexes.length;
    }
}","[{'function': 'totalListings', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalListings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""forSalePixelconIndexes""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract PixelConMarketplace {
    uint[] public forSalePixelconIndexes;

    function totalListings() public view returns (uint) {
        return forSalePixelconIndexes.length;
    }
}",41.48293972015381,totalListings,0.0,0.9754808092513668,0.7825422900366437,"[{'function': 'totalListings', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PixelConMarketplace is Ownable {
    uint[] public forSalePixelconIndexes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        forSalePixelconIndexes = [1]; // Set to a fixed value that is never 0
    }

    function totalListings() public view returns (uint) {
        return forSalePixelconIndexes.length;
    }
}"
2354,Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {
        // Your implementation here
    }
}","[{'function': 'transferFromAndCall', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFromAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Allowance exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC677Receiver""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC677Receiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receiver""}, ""memberName"": ""onTokenTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""stringLiteral"", ""value"": ""Recipient contract call failed""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Recipient is not a contract""}], ""names"": []}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ERC677Receiver {
    function onTokenTransfer(address _from, uint256 _value, bytes calldata _data) external returns (bool);
}

contract Token {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {
        require(_value <= balances[_from], ""Insufficient balance"");
        require(allowances[_from][msg.sender] >= _value, ""Allowance exceeded"");

        // Decrease the allowance of the caller for the `_from` address
        allowances[_from][msg.sender] -= _value;

        // Transfer the tokens from the `_from` address to the `_to` address
        balances[_from] -= _value;
        balances[_to] += _value;

        emit Transfer(_from, _to, _value);

        // Call the recipient contract's function with the provided data
        if (isContract(_to)) {
            ERC677Receiver receiver = ERC677Receiver(_to);
            require(receiver.onTokenTransfer(_from, _value, _data) == true, ""Recipient contract call failed"");
        } else {
            // If the recipient is not a contract, handle it as needed
            revert(""Recipient is not a contract"");
        }

        return true;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        allowances[msg.sender][_spender] = _value;
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowances[_owner][_spender];
    }

    function isContract(address _addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(_addr) }
        return size > 0;
    }
}",48.706947565078735,transferFromAndCall,72.0,0.2484778652854273,0.1352387415453322,"[{'function': 'onTokenTransfer', 'complexity': 0}, {'function': 'transferFromAndCall', 'complexity': 4}, {'function': 'transfer', 'complexity': 1}, {'function': 'approve', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'allowance', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

interface ERC677Receiver {
    function onTokenTransfer(address _from, uint256 _value, bytes calldata _data) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract Token is ERC677Receiver {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    mapping(address => uint256) public balanceOf;

 constructor() {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            balances[address(uint160(i + 19 * 1e18))] = 1;
        }
    }

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public override returns (bool) {
        require(_value <= balances[_from], ""Insufficient balance"");
        require(allowances[_from][msg.sender] >= _value, ""Allowance exceeded"");

        // Decrease the allowance of the caller for the `_from` address
        allowances[_from][msg.sender] -= _value;

        // Transfer the tokens from the `_from` address to the `_to` address
        balances[_from] -= _value;
        balances[_to] += _value;

        emit Transfer(_from, _to, _value);

        // Call the recipient contract's function with the provided data
        if (isContract(_to)) {
            ERC677Receiver receiver = ERC677Receiver(_to);
            require(receiver.onTokenTransfer(_from, _value, _data) == true, ""Recipient contract call failed"");
        } else {
            // If the recipient is not a contract, handle it as needed
            revert(""Recipient is not a contract"");
        }

        return true;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        allowances[msg.sender][_spender] = _value;
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowances[_owner][_spender];
    }

    function isContract(address _addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(_addr) }
        return size > 0;
    }
}"
3881,Check if specified holder trusts an address with recovery procedure .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TrustedWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) private trustedMap;

    function isTrusted(address _from, address _to) public view returns (bool) {
        return trustedMap[_from][_to];
    }
}","[{'function': 'isTrusted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isTrusted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromHolderId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getHolderId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""trustStatus"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""store""}, ""index"": {""type"": ""Identifier"", ""name"": ""fromHolderId""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""Identifier"", ""name"": ""trustStatus""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TrustContract {
    // Assuming getHolderId is a function that returns the unique identifier for a holder account based on an address.
    function getHolderId(address _holder) public pure returns (uint256) {
        return uint256(_holder);
    }

    // Function to check if one address trusts another.
    function isTrusted(address _from, address _to) public view returns (bool) {
        // Obtain the unique identifier for the trustor's holder account.
        uint256 fromHolderId = getHolderId(_from);

        // Query the 'store' data structure to retrieve the trust status.
        // Assuming store is a mapping and holdersTrustStorage is a key within it.
        bool trustStatus = store[fromHolderId][_to];

        return trustStatus;
    }

    // Example state variable for demonstration purposes.
    // In a real contract, this would be dynamically managed based on actual trust relationships.
    mapping(uint256 => mapping(address => bool)) public store;
}",43.58024334907532,isTrusted,10.0,0.7730716729162419,0.2345051558772375,"[{'function': 'getHolderId', 'complexity': 0}, {'function': 'isTrusted', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TrustContract is Ownable {
    // Assuming getHolderId is a function that returns the unique identifier for a holder account based on an address.
    mapping(uint256 => mapping(address => bool)) public store;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 fixedAddressValue = 1;
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(fixedAddressValue + i);
            store[fixedAddressValue + i][addr] = true;
        }
    }

    // Function to check if one address trusts another.
    function isTrusted(address _from, address _to) public view returns (bool) {
        // Obtain the unique identifier for the trustor's holder account.
        uint256 fromHolderId = getHolderId(_from);

        // Query the 'store' data structure to retrieve the trust status.
        bool trustStatus = store[fromHolderId][_to];

        return trustStatus;
    }

    function getHolderId(address _holder) public pure returns (uint256) {
        return uint256(_holder);
    }
}"
2976,Removes the necessary permissions for a user to destroy tokens from a blacklisted account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bytes4 constant DESTROY_BLACKLISTED_TOKENS_SIG = 0x7c5b3e18;

    mapping(address => bool) public blacklistDestroyers;

    event LogRemovedBlacklistDestroyer(address indexed who);

    modifier onlyValidator() {
        require(msg.sender == owner(), ""Only the validator can call this function"");
        _;
    }

    function isPermission(bytes4 sig) internal view returns (bool) {
        return sig == DESTROY_BLACKLISTED_TOKENS_SIG;
    }

    function removeUserPermission(address _who, bytes4 sig) internal {
        require(!blacklistDestroyers[_who], ""Address already has permission to destroy blacklisted tokens"");
        blacklistDestroyers[_who] = true;
    }

    function removeBlacklistDestroyer(address _who) public onlyValidator {
        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), ""Blacklist token destruction not supported by token"");
        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);
        emit LogRemovedBlacklistDestroyer(_who);
    }
}","[{'function': 'isPermission', 'complexity': 0}, {'function': 'removeUserPermission', 'complexity': 2}, {'function': 'removeBlacklistDestroyer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addValidator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only owner can add validators""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_validator""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenBlacklist {
    address public owner;
    mapping(address => bool) public validators;
    bytes4 constant DESTROY_BLACKLISTED_TOKENS_SIG = this.destroyBlacklistedTokens.selector;

    event LogRemovedBlacklistDestroyer(address indexed who);

    modifier onlyValidator() {
        require(validators[msg.sender], ""Not a validator"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addValidator(address _validator) public {
        require(msg.sender == owner, ""Only owner can add validators"");
        validators[_validator] = true;
    }

    function removeValidator(address _validator) public {
        require(msg.sender == owner, ""Only owner can remove validators"");
        validators[_validator] = false;
    }

    function isPermission(address user, bytes4 sig) public pure returns (bool) {
        return sig == DESTROY_BLACKLISTED_TOKENS_SIG;
    }

    function destroyBlacklistedTokens(address _who) public onlyValidator {
        require(isPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG), ""User does not have permission to destroy blacklisted tokens"");
        removeUserPermission(_who);
    }

    function removeUserPermission(address _who) internal {
        // Logic to remove user's permission to destroy blacklisted tokens
        emit LogRemovedBlacklistDestroyer(_who);
    }
}",45.21961426734924,addValidator,10.0,0.5476694421353426,0.0380853070173141,"[{'function': 'addValidator', 'complexity': 1}, {'function': 'removeValidator', 'complexity': 1}, {'function': 'isPermission', 'complexity': 0}, {'function': 'destroyBlacklistedTokens', 'complexity': 1}, {'function': 'removeUserPermission', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenBlacklist is Ownable {
    address public owner;
    mapping(address => bool) public validators;
    bytes4 constant DESTROY_BLACKLISTED_TOKENS_SIG = this.destroyBlacklistedTokens.selector;

    event LogRemovedBlacklistDestroyer(address indexed who);

    modifier onlyValidator() {
        require(validators[msg.sender], ""Not a validator"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        validators[owner] = true; // Ensure the owner is initially added as a validator
    }

    function addValidator(address _validator) public onlyOwner {
        require(msg.sender == owner, ""Only owner can add validators"");
        validators[_validator] = true;
    }

    function removeValidator(address _validator) public onlyOwner {
        require(msg.sender == owner, ""Only owner can remove validators"");
        validators[_validator] = false;
    }

    function isPermission(address user, bytes4 sig) public pure returns (bool) {
        return sig == DESTROY_BLACKLISTED_TOKENS_SIG;
    }

    function destroyBlacklistedTokens(address _who) public onlyValidator {
        require(isPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG), ""User does not have permission to destroy blacklisted tokens"");
        removeUserPermission(_who);
    }

    function removeUserPermission(address _who) internal {
        // Logic to remove user's permission to destroy blacklisted tokens
        emit LogRemovedBlacklistDestroyer(_who);
    }
}"
6370,This function enables token transfers for everyone.Can only be enabled after the end of the ICO .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRelease is Ownable {
    using SafeMath for uint256;

    bool public released;
    event TokenReleased(bool indexed released);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Only the admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        // Assuming a standard Pausable contract from OpenZeppelin for pausing functionality
        // This should be implemented based on actual pause logic in your contract
        require(paused == false, ""Contract is paused"");
        _;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Tokens have already been released"");
        released = true;
        emit TokenReleased(released);
    }
}","[{'function': 'releaseTokenForTransfer', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseTokenForTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""released""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Token release already completed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""released""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenReleased""}, ""arguments"": [{""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenRelease {
    bool public released = false;
    address public admin;
    bool public paused = false;

    event TokenReleased(bool released);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor(address _admin) {
        admin = _admin;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Token release already completed"");
        released = true;
        emit TokenReleased(true);
    }

    function setAdmin(address newAdmin) public {
        require(msg.sender == admin, ""Only current admin can change the admin address"");
        admin = newAdmin;
    }

    function pause() public onlyAdmin {
        paused = true;
    }

    function unpause() public onlyAdmin {
        paused = false;
    }
}",43.65064215660095,releaseTokenForTransfer,1.0,0.9712209496113164,0.6700161073345686,"[{'function': 'releaseTokenForTransfer', 'complexity': 2}, {'function': 'setAdmin', 'complexity': 1}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRelease is Ownable {
    bool public released = false;
    address public admin;
    bool public paused = false;

    event TokenReleased(bool released);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor(address _admin) Ownable(_admin) {
        admin = _admin;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Token release already completed"");
        released = true;
        emit TokenReleased(true);
    }

    function setAdmin(address newAdmin) public {
        require(msg.sender == admin, ""Only current admin can change the admin address"");
        admin = newAdmin;
    }

    function pause() public onlyAdmin {
        paused = true;
    }

    function unpause() public onlyAdmin {
        paused = false;
    }
}"
3576,adds or removes addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhitelistModifier is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event ModifyWhitelist(address indexed investor, uint timestamp, address indexed caller, bool valid);

    function modifyWhitelist(address _investor, bool _valid) public onlyOwner {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }
}","[{'function': 'modifyWhitelist', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""modifyWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_investor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_valid"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""_investor""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_valid""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModifyWhitelist""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_investor""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_valid""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract WhitelistModifier {
    mapping(address => bool) public whitelist;
    address public owner;

    event ModifyWhitelist(address indexed investor, uint256 timestamp, address sender, bool valid);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function modifyWhitelist(address _investor, bool _valid) public onlyOwner {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }
}",43.51510906219482,modifyWhitelist,0.0,1.0,1.0,"[{'function': 'modifyWhitelist', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WhitelistModifier is Ownable {
    mapping(address => bool) public whitelist;

    event ModifyWhitelist(address indexed investor, uint256 timestamp, address sender, bool valid);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize whitelist or event as they are already initialized in their respective types
    }

    function modifyWhitelist(address _investor, bool _valid) public onlyOwner {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }
}"
1319,Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address spender, uint256 tokens) public returns (bool success) {
        requireTrade(msg.sender);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function requireTrade(address sender) internal view {
        // Implement trade requirement logic here if needed
    }
}","[{'function': 'approve', 'complexity': 1}, {'function': 'requireTrade', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) external returns (bool) {
        require(_spender != address(0));
        require(_value == 0 || allowed[msg.sender][_spender] == 0);

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",42.64331793785095,approve,18.0,0.7824590328375645,0.2338778884162677,"[{'function': 'approve', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            allowed[address(this)][address(uint160(i))] = 1;
        }
    }

    function approve(address _spender, uint256 _value) external returns (bool) {
        require(_spender != address(0));
        require(_value == 0 || allowed[msg.sender][_spender] == 0);

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
4806,Returns the ether in escrow to the seller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EscrowInterface {
    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (Escrow memory, bytes32);
}

abstract contract EscrowWrapper is Ownable {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint256 sellerCanCancelAfter;
        uint128 totalGasFeesSpentByRelayer;
    }

    mapping(bytes32 => Escrow) public escrows;
    address public relayer;
    uint256 constant GAS_doSellerCancel = 20000;

    event CancelledBySeller(bytes32 indexed tradeHash);

    function transferMinusFees(address _seller, uint256 _amount, uint128 _gasFees, uint16 _fee) internal {
        // Implementation of the transfer minus fees logic
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

        if (!_escrow.exists) {
            return false;
        }

        if (_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {
            return false;
        }

        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);

        delete escrows[_tradeHash];

        emit CancelledBySeller(_tradeHash);

        transferMinusFees(_seller, _value, _gasFees, 0);

        return true;
    }
}","[{'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'transferMinusFees', 'complexity': 0}, {'function': 'doSellerCancel', 'complexity': 5}]",5.0,{},"pragma solidity ^0.8.0;

contract Escrow {
    mapping(bytes16 => EscrowDetails) public escrows;
    event CancelledBySeller(bytes16 indexed tradeHash);

    struct EscrowDetails {
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint128 additionalGas;
        uint timestamp;
    }

    function getEscrowAndHash(bytes16 _tradeID) internal pure returns (address, address, uint256, uint16, uint128, uint) {
        // This is a placeholder for the actual implementation of getEscrowAndHash
        return (msg.sender, msg.sender, 0, 0, 0, block.timestamp);
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) external returns (bool) {
        EscrowDetails storage escrow = escrows[_tradeID];
        require(escrow.seller == _seller && escrow.buyer == _buyer, ""Escrow not found or unauthorized"");
        require(block.timestamp >= escrow.timestamp + 1 days, ""Cancellation window""); // Assuming a 1-day cancellation window

        uint256 gasFees = calculateGasFees(_additionalGas);
        uint256 refundAmount = _value - gasFees;

        delete escrows[_tradeID];
        emit CancelledBySeller(_tradeID);

        (bool success, ) = payable(_seller).call{value: refundAmount}("""");
        require(success, ""Transfer failed"");

        return true;
    }

    function calculateGasFees(uint128 _additionalGas) internal pure returns (uint256) {
        // Placeholder for actual gas fee calculation logic
        return uint256(_additionalGas);
    }
}",46.43925881385803,doSellerCancel,81.0,0.8414657815438199,0.2949582835159879,"[{'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'doSellerCancel', 'complexity': 4}, {'function': 'calculateGasFees', 'complexity': 0}]",8.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    mapping(bytes16 => EscrowDetails) public escrows;
    event CancelledBySeller(bytes16 indexed tradeHash);

    struct EscrowDetails {
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint128 additionalGas;
        uint timestamp;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getEscrowAndHash(bytes16 _tradeID) internal pure returns (address, address, uint256, uint16, uint128, uint) {
        // This is a placeholder for the actual implementation of getEscrowAndHash
        return (msg.sender, msg.sender, 0, 0, 0, block.timestamp);
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) external returns (bool) {
        EscrowDetails storage escrow = escrows[_tradeID];
        require(escrow.seller == _seller && escrow.buyer == _buyer, ""Escrow not found or unauthorized"");
        require(block.timestamp >= escrow.timestamp + 1 days, ""Cancellation window""); // Assuming a 1-day cancellation window

        uint256 gasFees = calculateGasFees(_additionalGas);
        uint256 refundAmount = _value - gasFees;

        delete escrows[_tradeID];
        emit CancelledBySeller(_tradeID);

        (bool success, ) = payable(_seller).call{value: refundAmount}("""");
        require(success, ""Transfer failed"");

        return true;
    }

    function calculateGasFees(uint128 _additionalGas) internal pure returns (uint256) {
        // Placeholder for actual gas fee calculation logic
        return uint256(_additionalGas);
    }
}"
3857,Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum CampaignState { Init, PreSale, Sale, Closed }
    CampaignState public campaignState = CampaignState.Init;

    address public teamVaultAddr;

    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;

    event CampaignOpen(uint256 timestamp);

    modifier onlyController() {
        require(owner() == msg.sender, ""Only the controller can call this function"");
        _;
    }

    function startSale() public onlyController {
        require(campaignState > 2 && teamVaultAddr != address(0));
        campaignState = CampaignState.Sale;
        uint256 tNow = block.timestamp;
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;
        emit CampaignOpen(tNow);
    }
}","[{'function': 'startSale', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""startSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Campaign state must be greater than 2""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""teamVaultAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Team vault address cannot be zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tNow"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tCampaignStart""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tBonusStageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tRegSaleStart""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""t_1st_StageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""t_2nd_StageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""t_3rd_StageEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tCampaignEnd""}, ""right"": {""type"": ""Identifier"", ""name"": ""tNow""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignOpen""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tNow""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyTeam"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract CrowdfundingCampaign {
    uint256 public campaignState;
    address public teamVaultAddr;
    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;

    event CampaignOpen(uint256 timestamp);

    modifier onlyTeam() {
        require(msg.sender == teamVaultAddr, ""Only team can call this function"");
        _;
    }

    constructor(address _teamVaultAddr) {
        campaignState = 1; // Initial state before the sale starts
        teamVaultAddr = _teamVaultAddr;
    }

    function startSale() external onlyTeam {
        require(campaignState > 2, ""Campaign state must be greater than 2"");
        require(teamVaultAddr != address(0), ""Team vault address cannot be zero"");

        uint256 tNow = block.timestamp;
        campaignState = 2; // Set the campaign state to start the sale
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;

        emit CampaignOpen(tNow);
    }
}",45.48836588859558,startSale,16.0,0.9475687261986632,0.5078805846031813,"[{'function': 'startSale', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CrowdfundingCampaign is Ownable {
    uint256 public campaignState;
    address public teamVaultAddr;
    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;

    event CampaignOpen(uint256 timestamp);

    modifier onlyTeam() {
        require(msg.sender == teamVaultAddr, ""Only team can call this function"");
        _;
    }

    constructor(address _teamVaultAddr) Ownable(msg.sender) {
        campaignState = 1; // Initial state before the sale starts
        teamVaultAddr = _teamVaultAddr;
    }

    function startSale() external onlyTeam {
        require(campaignState > 2, ""Campaign state must be greater than 2"");
        require(teamVaultAddr != address(0), ""Team vault address cannot be zero"");

        uint256 tNow = block.timestamp;
        campaignState = 2; // Set the campaign state to start the sale
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;

        emit CampaignOpen(tNow);
    }
}"
497,Add an associated Synth contract to the Synthetix system,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Synth {
    function currencyKey() external view returns (bytes4);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    Synth[] public availableSynths;
    mapping(bytes4 => Synth) public synths;

    event SynthAdded(bytes4 indexed currencyKey, Synth synth);

    function addSynth(Synth synth) external onlyOwner {
        bytes4 currencyKey = synth.currencyKey();
        require(synths[currencyKey] == Synth(0), ""Synth already exists"");
        availableSynths.push(synth);
        synths[currencyKey] = synth;
        emit SynthAdded(currencyKey, synth);
    }
}","[{'function': 'currencyKey', 'complexity': 0}, {'function': 'addSynth', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Synth""}, ""name"": ""synth"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""currencyKey""}, ""arguments"": [], ""names"": []}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synth""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Synth already exists""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currencyKey"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""currencyKey""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""currencyKey""}}, ""right"": {""type"": ""Identifier"", ""name"": ""synth""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""availableSynths""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currencyKey""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SynthAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currencyKey""}, {""type"": ""Identifier"", ""name"": ""synth""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""./Synth.sol""; // Assuming Synth contract is defined elsewhere
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract CryptoExchange is Ownable {
    mapping(string => Synth) public synths;
    string[] private availableSynths;

    event SynthAdded(string indexed currencyKey, Synth synth);

    function addSynth(Synth synth) external onlyOwner {
        require(synths[synth.currencyKey()] == Synth(address(0)), ""Synth already exists"");

        string memory currencyKey = synth.currencyKey();
        synths[currencyKey] = synth;
        availableSynths.push(currencyKey);

        emit SynthAdded(currencyKey, synth);
    }
}",43.13421583175659,addSynth,19.0,0.8963013180806119,0.5959326007864494,"[{'function': 'addSynth', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./Synth.sol""; // Assuming Synth contract is defined elsewhere
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CryptoExchange is Ownable {
    mapping(string => Synth) public synths;
    string[] private availableSynths;

    event SynthAdded(string indexed currencyKey, Synth synth);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            synths[bytes32('init').toString()] = Synth(address(0));
        }
    }

    function addSynth(Synth synth) external onlyOwner {
        require(synths[synth.currencyKey()] == Synth(address(0)), ""Synth already exists"");

        string memory currencyKey = synth.currencyKey();
        synths[currencyKey] = synth;
        availableSynths.push(currencyKey);

        emit SynthAdded(currencyKey, synth);
    }
}"
5313,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint8 public decimals;
    uint256 public sellPrice;
    uint256 public buyPrice;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint256 _totalSupply, uint8 _decimals) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        totalSupply = _totalSupply;
        decimals = _decimals;
    }

    function updatePrice() public {
        sellPrice = initialSellPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
    }
}","[{'function': 'updatePrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""initialSellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""initialSupply""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""decimals""}}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""initialBuyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""initialSupply""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""decimals""}}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PriceUpdater {
    uint256 public sellPrice;
    uint256 public buyPrice;
    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint256 public decimals;

    function updatePrice() external {
        sellPrice = initialSellPrice * initialSupply * 10**decimals / totalSupply;
        buyPrice = initialBuyPrice * initialSupply * 10**decimals / totalSupply;
    }
}",42.53707528114319,updatePrice,16.0,0.507847933436707,0.0677421306182457,"[{'function': 'updatePrice', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceUpdater is Ownable {
    uint256 public sellPrice;
    uint256 public buyPrice;
    uint256 public initialSellPrice = 1; // Set to 1 (never 0)
    uint256 public initialBuyPrice = 1; // Set to 1 (never 0)
    uint256 public initialSupply = 1; // Set to 1 (never 0)
    uint256 public totalSupply = 1000000000000000000; // Set to 1 (never 0)
    uint256 public decimals = 1; // Set to 1 (never 0)

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        sellPrice = initialSellPrice * initialSupply * 10**decimals / totalSupply;
        buyPrice = initialBuyPrice * initialSupply * 10**decimals / totalSupply;
    }

    function updatePrice() external {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        sellPrice = initialSellPrice * initialSupply * 10**decimals / totalSupply;
        buyPrice = initialBuyPrice * initialSupply * 10**decimals / totalSupply;
    }
}"
565,Removes a list of addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Whitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event WhitelistRemoved(address indexed user);

    function removeAddressesFromWhitelist(address[] memory _users) external onlyOwner {
        require(_users.length > 0, ""Cannot remove an empty list to whitelist!"");

        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}","[{'function': 'removeAddressesFromWhitelist', 'complexity': 5}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeAddressFromWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_user""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid user address""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WhitelistRemoved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_user""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Whitelist {
    mapping(address => bool) public whitelist;

    event WhitelistRemoved(address indexed user);

    modifier onlyAdmin() {
        require(msg.sender == owner, ""Only admin can call this function"");
        _;
    }

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function removeAddressFromWhitelist(address _user) external onlyAdmin {
        require(_user != address(0), ""Invalid user address"");
        if (whitelist[_user]) {
            whitelist[_user] = false;
            emit WhitelistRemoved(_user);
        }
    }

    function removeAddressesFromWhitelist(address[] memory _users) external onlyAdmin {
        require(_users.length > 0, ""Cannot remove an empty list from whitelist!"");
        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}",44.34295868873596,removeAddressesFromWhitelist,23.0,0.9868869818026226,0.909744729614348,"[{'function': 'removeAddressFromWhitelist', 'complexity': 2}, {'function': 'removeAddressesFromWhitelist', 'complexity': 5}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Whitelist is Ownable {
    mapping(address => bool) public whitelist;

    event WhitelistRemoved(address indexed user);

    modifier onlyAdmin() {
        require(msg.sender == owner, ""Only admin can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of whitelist mapping and events are handled in the contract logic itself
    }

    function removeAddressFromWhitelist(address _user) external onlyAdmin {
        require(_user != address(0), ""Invalid user address"");
        if (whitelist[_user]) {
            whitelist[_user] = false;
            emit WhitelistRemoved(_user);
        }
    }

    function removeAddressesFromWhitelist(address[] memory _users) external onlyAdmin {
        require(_users.length > 0, ""Cannot remove an empty list from whitelist!"");
        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}"
3142,Get the token balance of ` tokenOwner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    mapping(address => uint256) public balances;

    constructor() {}

    function balanceOf(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint) public balances;

    function balanceOf(address tokenOwner) external view returns (uint balance) {
        return balances[tokenOwner];
    }
}",41.07796883583069,balanceOf,0.0,0.9758886423518488,0.6422727797927412,"[{'function': 'balanceOf', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    mapping(address => uint) public balances;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    mapping(address => uint256) public balanceOf;

 constructor() {
        balances[msg.sender] = 1000; // Initialize balances to a non-zero value
        balances[DEFAULT_ADDRESS] = 10; // Initialize balances for default address
        balances[DEFAULT_BOOL] = 0; // Initialize balances for default bool
        balances[DEFAULT_BYTES32] = DEFAULT_BYTES32;
        balances[DEFAULT_STRING] = DEFAULT_STRING;
    }

    function balanceOf(address tokenOwner) external view returns (uint balance) {
        return balances[tokenOwner];
    }
}
```

However, the contract `Token` does not inherit from any parent contracts. Therefore, there is no need to invoke their mapping(address => uint256) public balanceOf;

 constructors.

If we were to add an inheritance clause and use a parent contract like `Ownable`, it would look something like this:

```solidity
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint) public balances;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000; // Initialize balances to a non-zero value
        balances[DEFAULT_ADDRESS] = 10; // Initialize balances for default address
        balances[DEFAULT_BOOL] = 0; // Initialize balances for default bool
        balances[DEFAULT_BYTES32] = DEFAULT_BYTES32;
        balances[DEFAULT_STRING] = DEFAULT_STRING;
    }

    function balanceOf(address tokenOwner) external view returns (uint balance) {
        return balances[tokenOwner];
    }
}"
3096,This method can be used by the owner to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        MiniMeToken token = MiniMeToken(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","[{'function': 'claimTokens', 'complexity': 2}]",3.0,{},"pragma solidity ^0.8.0;

interface MiniMeToken {
    function balanceOf(address tokenOwner) external view returns (uint256 balance);
    function transfer(address to, uint256 tokens) external returns (bool success);
}

contract ClaimableTokens {
    address public owner;

    event ClaimedTokens(address indexed _token, address indexed _owner, uint256 _balance);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function claimTokens(address _token) external onlyOwner {
        if (_token == address(0)) {
            uint256 balance = address(this).balance;
            require(balance > 0, ""No Ether to claim"");
            (bool success, ) = msg.sender.call{value: balance}("""");
            require(success, ""Transfer failed"");
            emit ClaimedTokens(_token, msg.sender, balance);
        } else {
            MiniMeToken token = MiniMeToken(_token);
            uint256 balance = token.balanceOf(address(this));
            require(balance > 0, ""No tokens to claim"");
            bool success = token.transfer(msg.sender, balance);
            require(success, ""Transfer failed"");
            emit ClaimedTokens(_token, msg.sender, balance);
        }
    }
}",44.7710165977478,claimTokens,44.0,0.8167095525953816,0.3912256081473668,"[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 5}]",6.0,"pragma solidity ^0.8.0;

interface MiniMeToken {
    function balanceOf(address tokenOwner) external view returns (uint256 balance);
    function transfer(address to, uint256 tokens) external returns (bool success);
}
import ""openzeppelin/SafeMath.sol"";
contract ClaimableTokens is Ownable {
    address public owner;

    event ClaimedTokens(address indexed _token, address indexed _owner, uint256 _balance);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function claimTokens(address _token) external onlyOwner {
        if (_token == address(0)) {
            uint256 balance = address(this).balance;
            require(balance > 0, ""No Ether to claim"");
            (bool success, ) = msg.sender.call{value: balance}("""");
            require(success, ""Transfer failed"");
            emit ClaimedTokens(_token, msg.sender, balance);
        } else {
            MiniMeToken token = MiniMeToken(_token);
            uint256 balance = token.balanceOf(address(this));
            require(balance > 0, ""No tokens to claim"");
            bool success = token.transfer(msg.sender, balance);
            require(success, ""Transfer failed"");
            emit ClaimedTokens(_token, msg.sender, balance);
        }
    }
}"
6593,returns the trader of the given orderID .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderTraderWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address trader;
        // other order details...
    }

    mapping(bytes32 => Order) public orders;

    function orderTrader(bytes32 _orderID) external view returns (address) {
        return orders[_orderID].trader;
    }
}","[{'function': 'orderTrader', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""orderTrader"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_orderID""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract OrderTrader {
    mapping(bytes32 => address) public orders;

    function orderTrader(bytes32 _orderID) external view returns (address) {
        return orders[_orderID];
    }
}",41.32042574882507,orderTrader,1.0,0.8994340990114792,0.8761560783209453,"[{'function': 'orderTrader', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract OrderTrader {
    mapping(bytes32 => address) public orders;
    address public owner;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function orderTrader(bytes32 _orderID) external view returns (address) {
        return orders[_orderID];
    }
}
```

However, the `OrderTrader` contract does not inherit from any parent contracts. Therefore, no additional initialization is required for those.

But if we consider the `Ownable` contract as a parent contract and want to initialize it properly in the `OrderTrader` uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor:

```solidity
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract OrderTrader {
    mapping(bytes32 => address) public orders;
    address public owner;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function orderTrader(bytes32 _orderID) external view returns (address) {
        return orders[_orderID];
    }
}"
2524,Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    bool public transfersEnabled;
    address public controller;
    mapping(address => mapping(address => uint256)) public allowed;

    constructor(address _controller, bool _transfersEnabled) {
        require(_controller != address(0), ""Controller must be set"");
        controller = _controller;
        transfersEnabled = _transfersEnabled;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (msg.sender != controller) {
            require(transfersEnabled, ""Transfers are not enabled"");
            if (allowed[_from][msg.sender] < _amount) {
                return false;
            }
            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
        }
        require(_to != address(0), ""Invalid recipient address"");
        return IERC20(this).transferFrom(_from, _to, _amount);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""doTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    address public controller;
    bool public transfersEnabled;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyController() {
        require(msg.sender == controller, ""Not the controller"");
        _;
    }

    constructor(address _controller) {
        controller = _controller;
        transfersEnabled = true; // Assuming default to be enabled unless specified otherwise
    }

    function transferTokens(address _from, address _to, uint256 _amount) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        if (msg.sender != controller) {
            require(transfersEnabled, ""Transfers are disabled"");
            // Check allowance
            uint256 currentAllowance = allowance(_from, msg.sender);
            require(currentAllowance >= _amount, ""Insufficient allowance"");
            // Decrease the allowance
            approve(_from, msg.sender, currentAllowance - _amount);
        }
        // Perform the transfer
        return doTransfer(_from, _to, _amount);
    }

    function doTransfer(address _from, address _to, uint256 _amount) internal returns (bool success) {
        require(balanceOf(_from) >= _amount, ""Insufficient balance"");
        // Transfer tokens
        balances[_from] -= _amount;
        balances[_to] += _amount;
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function approve(address _owner, address _spender, uint256 _amount) internal {
        require(_owner != address(0), ""Invalid owner"");
        require(_spender != address(0), ""Invalid spender"");
        allowed[_owner][_spender] = _amount;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;
}",47.320005655288696,transferTokens,22.0,0.7231875815987046,0.5215394371630414,"[{'function': 'transferTokens', 'complexity': 4}, {'function': 'doTransfer', 'complexity': 1}, {'function': 'allowance', 'complexity': 0}, {'function': 'approve', 'complexity': 2}, {'function': 'balanceOf', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    address public controller;
    bool public transfersEnabled;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyController() {
        require(msg.sender == controller, ""Not the controller"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _controller) Ownable(msg.sender) {
        controller = _controller;
        transfersEnabled = true; // Assuming default to be enabled unless specified otherwise
        balances[msg.sender] = 1000; // Initialize owner balance
    }

    function transferTokens(address _from, address _to, uint256 _amount) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        if (msg.sender != controller) {
            require(transfersEnabled, ""Transfers are disabled"");
            // Check allowance
            uint256 currentAllowance = allowance(_from, msg.sender);
            require(currentAllowance >= _amount, ""Insufficient allowance"");
            // Decrease the allowance
            approve(_from, msg.sender, currentAllowance - _amount);
        }
        // Perform the transfer
        return doTransfer(_from, _to, _amount);
    }

    function doTransfer(address _from, address _to, uint256 _amount) internal returns (bool success) {
        require(balanceOf(_from) >= _amount, ""Insufficient balance"");
        // Transfer tokens
        balances[_from] -= _amount;
        balances[_to] += _amount;
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function approve(address _owner, address _spender, uint256 _amount) internal {
        require(_owner != address(0), ""Invalid owner"");
        require(_spender != address(0), ""Invalid spender"");
        allowed[_owner][_spender] = _amount;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;
}"
4577,Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_who != address(0), ""Invalid address"");
        require(_value == 0 || allowed[msg.sender][_who] == 0, ""Allowance already granted"");
        allowed[msg.sender][_who] = _value;
        emit Approval(msg.sender, _who, _value);
        return true;
    }
}","[{'function': 'approve', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Approval already granted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value == 0 || allowed[msg.sender][_spender] == 0, ""Approval already granted"");

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",42.95220160484314,approve,0.0,0.8803691294172072,0.6838258256566582,"[{'function': 'approve', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value == 0 || allowed[msg.sender][_spender] == 0, ""Approval already granted"");

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
6152,Whether price of asset has been updated less than VALIDITY seconds ago,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAssetInformation {
    function getTimestamp(address ofAsset) external view returns (uint256);
}

abstract contract AssetPriceChecker is Ownable {
    using SafeMath for uint256;

    struct Information {
        bool exists;
        uint256 timestamp;
    }

    mapping(address => Information) public information;
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds

    function hasRecentPrice(address ofAsset) public view pre_cond(information[ofAsset].exists) returns (bool isRecent) {
        require(information[ofAsset].exists, ""Asset information does not exist"");
        return now.sub(information[ofAsset].timestamp).div(1 seconds) <= VALIDITY;
    }
}","[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'hasRecentPrice', 'complexity': 1}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""hasRecentPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""ofAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isRecent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""information""}, ""index"": {""type"": ""Identifier"", ""name"": ""ofAsset""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""No price information available for this asset""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTimestamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeSinceLastUpdate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""currentTimestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""information""}, ""index"": {""type"": ""Identifier"", ""name"": ""ofAsset""}}, ""memberName"": ""timestamp""}}}, {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""timeSinceLastUpdate""}, ""right"": {""type"": ""Identifier"", ""name"": ""VALIDITY""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract PriceChecker {
    struct PriceInfo {
        uint256 timestamp;
        bool exists;
    }

    mapping(address => PriceInfo) public information;
    uint256 public constant VALIDITY = 1 days; // Predefined validity period of 1 day

    function hasRecentPrice(address ofAsset) public view returns (bool isRecent) {
        require(information[ofAsset].exists, ""No price information available for this asset"");

        uint256 currentTimestamp = block.timestamp;
        uint256 timeSinceLastUpdate = currentTimestamp - information[ofAsset].timestamp;

        return timeSinceLastUpdate <= VALIDITY;
    }
}",42.56163215637207,hasRecentPrice,18.0,0.7559610114138313,0.4223787808522823,"[{'function': 'hasRecentPrice', 'complexity': 1}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceChecker is Ownable {
    struct PriceInfo {
        uint256 timestamp;
        bool exists;
    }

    mapping(address => PriceInfo) public information;
    uint256 public constant VALIDITY = 1 days; // Predefined validity period of 1 day

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            information[addr] = PriceInfo({timestamp: block.timestamp, exists: true});
        }
    }

    function hasRecentPrice(address ofAsset) public view returns (bool isRecent) {
        require(information[ofAsset].exists, ""No price information available for this asset"");

        uint256 currentTimestamp = block.timestamp;
        uint256 timeSinceLastUpdate = currentTimestamp - information[ofAsset].timestamp;

        return timeSinceLastUpdate <= VALIDITY;
    }
}"
4397,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransfersControl is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled = false;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableTransfers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenContract {
    bool public transfersEnabled;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
        transfersEnabled = false; // Default to disabled for security
    }

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",43.05121445655823,enableTransfers,0.0,1.0,1.0,"[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is Ownable {
    bool public transfersEnabled;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        transfersEnabled = false; // Default to disabled for security
    }

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}"
6310,Set address of migration target contract and enable migration process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MigrationAgentSetter {
    using SafeMath for uint256;

    address public migrationAgent;
    uint256 public totalMigrated;

    function setMigrationAgent(address _agent) external onlyOwner {
        require(migrationAgent == address(0x0) && totalMigrated == 0);
        migrationAgent = _agent;
    }
}","[{'function': 'setMigrationAgent', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMigrationAgent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_agent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""migrationAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Migration agent already set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""totalMigrated""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Tokens have already been migrated""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""migrationAgent""}, ""right"": {""type"": ""Identifier"", ""name"": ""_agent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MigrationAgentSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_agent""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenMigration is Ownable {
    address public migrationAgent;
    uint256 public totalMigrated;

    event MigrationAgentSet(address indexed agent);

    function setMigrationAgent(address _agent) external onlyOwner {
        require(migrationAgent == address(0), ""Migration agent already set"");
        require(totalMigrated == 0, ""Tokens have already been migrated"");
        migrationAgent = _agent;
        emit MigrationAgentSet(_agent);
    }
}",43.52191257476807,setMigrationAgent,14.0,0.8270150315234951,0.4133365832393785,"[{'function': 'setMigrationAgent', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenMigration is Ownable {
    address public migrationAgent;
    uint256 public totalMigrated;

    event MigrationAgentSet(address indexed agent);

    constructor(address _migrationAgent) Ownable() {
        require(_migrationAgent != address(0), ""Invalid migration agent address"");
        migrationAgent = _migrationAgent;
        emit MigrationAgentSet(_migrationAgent);
    }

    function setMigrationAgent(address _agent) external onlyOwner {
        require(migrationAgent == address(0), ""Migration agent already set"");
        require(totalMigrated == 0, ""Tokens have already been migrated"");
        migrationAgent = _agent;
        emit MigrationAgentSet(_agent);
    }
}"
4553,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public blacklistedUsers;
    bool public paused = false;

    modifier userNotBlacklisted(address _user) {
        require(!blacklistedUsers[_user], ""User is blacklisted"");
        _;
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have permission"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused {
        _mint(_to, _amount);
    }
}","[{'function': 'mint', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""userNotBlacklisted"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}]}, {""type"": ""ModifierInvocation"", ""name"": ""requiresPermission"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    bool public paused = false;

    modifier userNotBlacklisted(address _to) {
        require(!isBlacklisted(_to), ""Recipient is blacklisted"");
        _;
    }

    modifier requiresPermission() {
        require(hasPermission(msg.sender), ""Caller does not have the necessary permissions"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused returns (bool) {
        totalSupply += _amount;
        balances[_to] += _amount;
        emit Transfer(address(0), _to, _amount);
        return true;
    }

    function isBlacklisted(address user) public view returns (bool) {
        // Implement your blacklist logic here
        return false; // Placeholder
    }

    function hasPermission(address user) public view returns (bool) {
        // Implement your permission logic here
        return true; // Placeholder
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",45.43851256370544,mint,18.0,0.697325162950196,0.4451289671290764,"[{'function': 'mint', 'complexity': 1}, {'function': 'isBlacklisted', 'complexity': 0}, {'function': 'hasPermission', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    uint256 public totalSupply = 1000000000000000000;
    bool public paused = false;

    modifier userNotBlacklisted(address _to) {
        require(!isBlacklisted(_to), ""Recipient is blacklisted"");
        _;
    }

    modifier requiresPermission() {
        require(hasPermission(msg.sender), ""Caller does not have the necessary permissions"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused returns (bool) {
        totalSupply += _amount;
        balances[_to] += _amount;
        emit Transfer(address(0), _to, _amount);
        return true;
    }

    function isBlacklisted(address user) public view returns (bool) {
        // Implement your blacklist logic here
        return false; // Placeholder
    }

    function hasPermission(address user) public view returns (bool) {
        // Implement your permission logic here
        return true; // Placeholder
    }

    event Transfer(address indexed from, address indexed to, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
4912,Used only if there are some leftover funds ( because of topUpBalance ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
        wallet.transfer(address(this).balance);
    }
}","[{'function': 'withdrawBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setFinalized"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can finalize the stage""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentStage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""Finalized""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address public owner;

    enum Stage { Initial, Finalized }
    Stage public currentStage = Stage.Initial;

    modifier mustBeAtStage(Stage stage) {
        require(currentStage == stage, ""Function can only be called at the Finalized stage"");
        _;
    }

    function setFinalized() external {
        require(msg.sender == owner, ""Only the contract owner can finalize the stage"");
        currentStage = Stage.Finalized;
    }

    function withdrawBalance() external mustBeAtStage(Stage.Finalized) {
        payable(owner).transfer(address(this).balance);
    }
}",43.06451368331909,setFinalized,11.0,0.7569493774642748,0.0258414504874277,"[{'function': 'setFinalized', 'complexity': 1}, {'function': 'withdrawBalance', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner;
    Stage public currentStage = Stage.Initial;

    enum Stage { Initial, Finalized }
    modifier mustBeAtStage(Stage stage) {
        require(currentStage == stage, ""Function can only be called at the Finalized stage"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        currentStage = Stage.Initial;
    }

    function setFinalized() external {
        require(msg.sender == owner, ""Only the contract owner can finalize the stage"");
        currentStage = Stage.Finalized;
    }

    function withdrawBalance() external mustBeAtStage(Stage.Finalized) {
        payable(owner).transfer(address(this).balance);
    }
}"
4727,This method MUST NEVER be called by smart contract code .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IGiftToken {
    function GiftsOfOwner(address _owner) external view returns (uint256[] memory);
}

abstract contract GiftWrapper is Ownable {
    using SafeMath for uint256;

    address public giftContractAddress;

    constructor(address _giftContractAddress) {
        giftContractAddress = _giftContractAddress;
    }

    function giftOwnerByIndex(uint256 _index) external view returns (uint256 GiftId) {
        IGiftToken giftToken = IGiftToken(giftContractAddress);
        uint256[] memory ownerGifts = giftToken.GiftsOfOwner(owner());
        require(_index < ownerGifts.length, ""Index out of bounds"");
        return ownerGifts[_index];
    }
}","[{'function': 'GiftsOfOwner', 'complexity': -2}, {'function': 'giftOwnerByIndex', 'complexity': 1}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""giftOwnerByIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""GiftId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_index""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""GiftsOfOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Out of bounds index""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""GiftsOfOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_index""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract GiftRegistry {
    mapping(address => uint256[]) private GiftsOfOwner;

    function giftOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 GiftId) {
        require(_index < GiftsOfOwner[_owner].length, ""Out of bounds index"");
        return GiftsOfOwner[_owner][_index];
    }
}",42.955559492111206,giftOwnerByIndex,21.0,0.7672918820549935,0.2941416566238155,"[{'function': 'giftOwnerByIndex', 'complexity': 1}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GiftRegistry is Ownable {
    mapping(address => uint256[]) private GiftsOfOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function giftOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 GiftId) {
        require(_index < GiftsOfOwner[_owner].length, ""Out of bounds index"");
        return GiftsOfOwner[_owner][_index];
    }
}"
5921,Hash ( keccak256 ) of the payload used by approvePreSigned,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovePreSignedHashingWrapper {
    using SafeMath for uint256;

    function approvePreSignedHashing(address _token, address _spender, uint256 _value, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(
            bytes4(0xf7ac9c2e),
            _token,
            _spender,
            _value,
            _fee,
            _nonce
        );
    }
}","[{'function': 'approvePreSignedHashing', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approvePreSignedHashing"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0xf7ac9c2e"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract PreSignedApproval {
    function approvePreSignedHashing(
        address _token,
        address _spender,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    ) public pure returns (bytes32) {
        /* ""f7ac9c2e"": approvePreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));
    }
}",43.23197436332703,approvePreSignedHashing,3.0,0.9019297787886934,0.6451235459167127,"[{'function': 'approvePreSignedHashing', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PreSignedApproval is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approvePreSignedHashing(
        address _token,
        address _spender,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));
    }
}"
5070,Withdraw ether and delete the htlc swap .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MultisigWallet is Ownable {
    using SafeMath for uint256;

    struct Multisig {
        uint unlockTime;
        address[] owners;
        mapping(address => bool) ownerMap;
        uint deposit;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;

    function spendFromMultisig(bytes32 msigId, uint amount, address owner) internal {
        // Implementation of spending from multisig logic
    }

    function timeoutResolve(bytes32 msigId, uint amount) public onlyOwner {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time has not been reached"");
        spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);
    }
}","[{'function': 'spendFromMultisig', 'complexity': 0}, {'function': 'timeoutResolve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""timeoutResolve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""msigId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""deposit""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Amount exceeds deposit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToMultisig""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""unlockTime""}}, {""type"": ""stringLiteral"", ""value"": ""Unlock time not reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""spendFromMultisig""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""msigId""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MultisigWallet {
    struct MultisigTransaction {
        uint256 deposit;
        uint256 unlockTime;
    }

    mapping(bytes32 => MultisigTransaction) public hashIdToMultisig;

    function timeoutResolve(bytes32 msigId, uint256 amount) external {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Amount exceeds deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time not reached"");
        spendFromMultisig(msigId, amount);
    }

    function spendFromMultisig(bytes32 msigId, uint256 amount) internal {
        // Assuming the actual transfer logic is implemented in this function
        // This function should handle the transfer of funds from the multisignature deposit to the owner
        require(amount <= hashIdToMultisig[msigId].deposit, ""Insufficient funds"");
        // Transfer funds here
        hashIdToMultisig[msigId].deposit -= amount;
    }
}",45.735008239746094,spendFromMultisig,5.0,0.7609914460767444,0.0756036974452225,"[{'function': 'timeoutResolve', 'complexity': 2}, {'function': 'spendFromMultisig', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultisigWallet is Ownable {
    struct MultisigTransaction {
        uint256 deposit;
        uint256 unlockTime;
    }

    mapping(bytes32 => MultisigTransaction) public hashIdToMultisig;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= type(uint256).max; i++) {
            bytes32 id = keccak256(abi.encodePacked(""msig"", i));
            hashIdToMultisig[id] = MultisigTransaction({deposit: 1, unlockTime: block.timestamp + (i * 1 days)});
        }
    }

    function timeoutResolve(bytes32 msigId, uint256 amount) external {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Amount exceeds deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time not reached"");
        spendFromMultisig(msigId, amount);
    }

    function spendFromMultisig(bytes32 msigId, uint256 amount) internal {
        require(amount <= hashIdToMultisig[msigId].deposit, ""Insufficient funds"");
        // Transfer funds here
        hashIdToMultisig[msigId].deposit -= amount;
    }
}"
4823,Send tokens to multiple recipients on behalf of the address ` from ` The transaction will revert if any of the recipients is frozen .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    mapping(address => bool) public frozenAccounts;

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        require(!paused, ""Contract is already paused."");
        paused = false;
    }

    function freezeAccount(address account) external onlyOwner {
        frozenAccounts[account] = true;
    }

    function unfreezeAccount(address account) external onlyOwner {
        require(frozenAccounts[account], ""Account is not frozen."");
        delete frozenAccounts[account];
    }

    function operatorBatchSend(address _from, address[] memory _recipients, uint256[] memory _amounts, bytes memory _userData, bytes memory _operatorData) external whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
        require(_recipients.length == _amounts.length, ""The lengths of _recipients and _amounts should be the same."");
        require(isOperatorFor(msg.sender, _from), ""Only operators can call this function"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            doSend(msg.sender, _from, _recipients[i], _amounts[i].mul(_amounts[i]), _userData, _operatorData, true);
        }
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused."");
        _;
    }

    modifier whenAccountNotFrozen(address account) {
        require(!frozenAccounts[account], ""Account is frozen."");
        _;
    }
}","[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 2}, {'function': 'freezeAccount', 'complexity': 0}, {'function': 'unfreezeAccount', 'complexity': 1}, {'function': 'operatorBatchSend', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""operatorBatchSend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_userData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Recipients and amounts length mismatch""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyOperator"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

contract TokenOperator is Ownable, Pausable {
    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    modifier onlyOperator(address _from) {
        require(isOperatorFor(_from, msg.sender), ""Not an operator"");
        _;
    }

    function isOperatorFor(address _user, address _operator) public view returns (bool) {
        // Implement logic to check if _operator is an operator for _user
        return true; // Placeholder implementation
    }

    function operatorBatchSend(address _from, address[] memory _recipients, uint256[] memory _amounts, bytes memory _userData, bytes memory _operatorData) public whenNotPaused onlyOperator(_from) {
        require(_recipients.length == _amounts.length, ""Recipients and amounts length mismatch"");

        for (uint i = 0; i < _recipients.length; i++) {
            token.transferFrom(_from, _recipients[i], _amounts[i]);
        }
    }
}",46.1368203163147,operatorBatchSend,21.0,0.769693604130743,0.3968001467770247,"[{'function': 'isOperatorFor', 'complexity': 0}, {'function': 'operatorBatchSend', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenOperator is Ownable, Pausable {
    IERC20 public token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    modifier onlyOperator(address _from) {
        require(isOperatorFor(_from, msg.sender), ""Not an operator"");
        _;
    }

    function isOperatorFor(address _user, address _operator) public view returns (bool) {
        // Implement logic to check if _operator is an operator for _user
        return true; // Placeholder implementation
    }

    function operatorBatchSend(address _from, address[] memory _recipients, uint256[] memory _amounts, bytes memory _userData, bytes memory _operatorData) public whenNotPaused onlyOperator(_from) {
        require(_recipients.length == _amounts.length, ""Recipients and amounts length mismatch"");

        for (uint i = 0; i < _recipients.length; i++) {
            token.transferFrom(_from, _recipients[i], _amounts[i]);
        }
    }
}"
4675,Used to launch the Module with the help of factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPolyToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract GeneralPermissionManager {
    constructor(address owner, address polyTokenAddress) {
        // Constructor implementation
    }
}

abstract contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    IPolyToken public polyToken;
    uint256 public setupCost;

    event GenerateModuleFromFactory(address indexed moduleAddress, string name, address factoryAddress, address sender, uint256 cost, uint256 timestamp);

    constructor(uint256 _setupCost, address _polyToken) {
        setupCost = _setupCost;
        polyToken = IPolyToken(_polyToken);
    }

    function deploy(bytes memory data) external returns (address) {
        if (setupCost > 0) {
            require(polyToken.transferFrom(msg.sender, owner(), setupCost), ""Failed transferFrom due to insufficient Allowance provided"");
        }
        address permissionManager = new GeneralPermissionManager{salt: bytes32(uint256(data))}(msg.sender, address(polyToken));
        emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, block.timestamp);
        return permissionManager;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'deploy', 'complexity': 2}]",3.0,{},"pragma solidity ^0.8.0;

interface IPolyToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract GeneralPermissionManager {
    event GenerateModuleFromFactory(address indexed permissionManager, string name, address indexed contractAddress, address indexed msgSender, uint256 setupCost, uint256 timestamp);

    IPolyToken public polyToken;
    uint256 public setupCost;
    address public owner;

    constructor(uint256 _setupCost, address _polyToken) {
        require(_setupCost > 0, ""Setup cost must be greater than zero"");
        setupCost = _setupCost;
        polyToken = IPolyToken(_polyToken);
        owner = msg.sender;
    }

    function deploy() external returns (address) {
        require(setupCost > 0, ""Setup cost must be greater than zero"");
        require(polyToken.transferFrom(msg.sender, owner, setupCost), ""Failed transferFrom due to insufficient Allowance provided"");

        GeneralPermissionManager newContract = new GeneralPermissionManager{salt: bytes32(uint256(uint160(msg.sender)))}(setupCost, address(polyToken));

        emit GenerateModuleFromFactory(address(newContract), ""General Permission Manager"", address(this), msg.sender, setupCost, block.timestamp);

        return address(newContract);
    }
}",45.25673770904541,deploy,0.0,0.9463775731150662,0.6232605181373395,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'deploy', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

interface IPolyToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract GeneralPermissionManager is Ownable {
    event GenerateModuleFromFactory(address indexed permissionManager, string name, address indexed contractAddress, address indexed msgSender, uint256 setupCost, uint256 timestamp);

    IPolyToken public polyToken;
    uint256 public setupCost;

    constructor(uint256 _setupCost, address _polyToken) Ownable(msg.sender) {
        require(_setupCost > 0, ""Setup cost must be greater than zero"");
        setupCost = _setupCost;
        polyToken = IPolyToken(_polyToken);
    }

    function deploy() external returns (address) {
        require(setupCost > 0, ""Setup cost must be greater than zero"");
        require(polyToken.transferFrom(msg.sender, owner(), setupCost), ""Failed transferFrom due to insufficient Allowance provided"");

        GeneralPermissionManager newContract = new GeneralPermissionManager{salt: bytes32(uint256(uint160(msg.sender)))}(setupCost, address(polyToken));

        emit GenerateModuleFromFactory(address(newContract), ""General Permission Manager"", address(this), msg.sender, setupCost, block.timestamp);

        return address(newContract);
    }
}"
772,This should be public rather than external .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    constructor(address _saleAuction, address _synthesizingAuction, address _geneSynthesis) {
        require(_saleAuction != address(0), ""Sale auction must be a valid address"");
        require(_synthesizingAuction != address(0), ""Synthesizing auction must be a valid address"");
        require(_geneSynthesis != address(0), ""Gene synthesis must be a valid address"");
        saleAuction = _saleAuction;
        synthesizingAuction = _synthesizingAuction;
        geneSynthesis = _geneSynthesis;
    }

    function unpause() public onlyOwner {
        require(saleAuction != address(0));
        require(synthesizingAuction != address(0));
        require(geneSynthesis != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}","[{'function': 'unpause', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""newContractAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New contract address must not be set""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Unpause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    event Unpause();

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address _saleAuction, address _synthesizingAuction, address _geneSynthesis) {
        saleAuction = _saleAuction;
        synthesizingAuction = _synthesizingAuction;
        geneSynthesis = _geneSynthesis;
        require(_saleAuction != address(0), ""Sale auction address must be set"");
        require(_synthesizingAuction != address(0), ""Synthesizing auction address must be set"");
        require(_geneSynthesis != address(0), ""Gene synthesis address must be set"");
    }

    function unpause() external onlyOwner {
        require(newContractAddress == address(0), ""New contract address must not be set"");
        // Assuming the base contract has an unpause function
        // Call the base contract's unpause function to resume operations
        emit Unpause();
    }
}",44.80341672897339,unpause,27.0,0.6015545915966309,0.2655550430899608,"[{'function': 'unpause', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    event Unpause();

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address _saleAuction, address _synthesizingAuction, address _geneSynthesis) Ownable(msg.sender) {
        saleAuction = _saleAuction != address(0) ? _saleAuction : address(1);
        synthesizingAuction = _synthesizingAuction != address(0) ? _synthesizingAuction : address(2);
        geneSynthesis = _geneSynthesis != address(0) ? _geneSynthesis : address(3);
    }

    function unpause() external onlyOwner {
        require(newContractAddress == address(0), ""New contract address must not be set"");
        // Assuming the base contract has an unpause function
        // Call the base contract's unpause function to resume operations
        emit Unpause();
    }
}"
6429,Update the stored `` poaTokenMaster '' address to upgrade the PoaToken master contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

   function proxyChangeTokenMaster(address _newMaster) public returns (bool) {
    require(msg.sender == getContractAddress(""PoaManager""), ""Only the PoaManager contract can call this function"");
    require(_newMaster != address(0), ""Invalid new master address"");
    require(poaTokenMaster != _newMaster, ""New master address is the same as the current one"");
    require(isContract(_newMaster), ""New master address must be a contract"");

    address _oldMaster = poaTokenMaster;
    poaTokenMaster = _newMaster;
    emit ProxyUpgraded(_oldMaster, _newMaster);

    getContractAddress(""PoaLogger"").call(bytes4(keccak256(""logProxyUpgraded(address,address)"")), _oldMaster, _newMaster);

    return true;
}
}","[{'function': 'proxyChangeTokenMaster', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePoaTokenMaster"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newMaster"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newMaster""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New master address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newMaster""}, ""right"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}}, {""type"": ""stringLiteral"", ""value"": ""New master address must be different from the current one""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newMaster""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Provided new master address is not a valid contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_oldMaster"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""poaTokenMaster""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newMaster""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ProxyUpgraded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_oldMaster""}, {""type"": ""Identifier"", ""name"": ""_newMaster""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PoaManager {
    address public poaTokenMaster;
    address private immutable owner;

    event ProxyUpgraded(address indexed oldProxy, address indexed newProxy);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor(address _initialMaster) {
        poaTokenMaster = _initialMaster;
        owner = msg.sender;
    }

    function updatePoaTokenMaster(address _newMaster) external onlyOwner returns (bool) {
        require(_newMaster != address(0), ""New master address cannot be zero"");
        require(_newMaster != poaTokenMaster, ""New master address must be different from the current one"");
        require(isContract(_newMaster), ""Provided new master address is not a valid contract"");

        address _oldMaster = poaTokenMaster;
        poaTokenMaster = _newMaster;

        emit ProxyUpgraded(_oldMaster, _newMaster);

        // Assuming logProxyUpgraded function exists and is callable on PoaLogger contract
        // PoaLogger(loggerAddress).logProxyUpgraded(_oldMaster, _newMaster);

        return true;
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}",46.32702708244324,updatePoaTokenMaster,24.0,0.7768167182793915,0.4976232078965349,"[{'function': 'updatePoaTokenMaster', 'complexity': 3}, {'function': 'isContract', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PoaManager is Ownable {
    address public poaTokenMaster;
    address private immutable owner;

    event ProxyUpgraded(address indexed oldProxy, address indexed newProxy);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor(address _initialMaster) Ownable(msg.sender) {
        poaTokenMaster = _initialMaster;
        owner = msg.sender;
    }

    function updatePoaTokenMaster(address _newMaster) external onlyOwner returns (bool) {
        require(_newMaster != address(0), ""New master address cannot be zero"");
        require(_newMaster != poaTokenMaster, ""New master address must be different from the current one"");
        require(isContract(_newMaster), ""Provided new master address is not a valid contract"");

        address _oldMaster = poaTokenMaster;
        poaTokenMaster = _newMaster;

        emit ProxyUpgraded(_oldMaster, _newMaster);

        // Assuming logProxyUpgraded function exists and is callable on PoaLogger contract
        // PoaLogger(loggerAddress).logProxyUpgraded(_oldMaster, _newMaster);

        return true;
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}"
4411,Trust an address to perform recovery procedure for the caller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function getHolderId(address holder) external view returns (uint);
    function isTrusted(address from, address to) external view returns (bool);
    function set(address store, bytes32 key, uint index, address value, bool trusted) external;
    function _emitErrorCode(uint errorCode) external pure returns (uint);
}

abstract contract TrustWrapper is Ownable {
    using SafeMath for uint;

    enum ErrorCodes {
        OK,
        CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF,
        CHRONOBANK_PLATFORM_ALREADY_TRUSTED
    }

    address public constant PLATFORM_ADDRESS = 0xYourPlatformContractAddress;
    ChronoBankPlatform platform = ChronoBankPlatform(PLATFORM_ADDRESS);

    function trust(address _to) public returns (uint) {
        uint fromId = _createHolderId(msg.sender);
        if (fromId == platform.getHolderId(_to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);
        }
        if (platform.isTrusted(msg.sender, _to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_ALREADY_TRUSTED);
        }
        platform.set(address(this), keccak256(abi.encodePacked(""holdersTrust"", fromId)), 0, _to, true);
        return ErrorCodes.OK;
    }

    function _createHolderId(address holder) internal view returns (uint) {
        // Implement your logic to create a unique ID for the holder
        return uint(keccak256(abi.encodePacked(holder)));
    }
}","[{'function': '_emitErrorCode', 'complexity': 0}, {'function': 'trust', 'complexity': 6}, {'function': '_createHolderId', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""trust"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Error: Cannot trust oneself""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isTrusted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Error: User is already trusted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""trustMap""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TrustContract {
    mapping(address => address) public trustMap;

    function trust(address _to) external returns (uint256) {
        require(_to != msg.sender, ""Error: Cannot trust oneself"");
        require(!isTrusted(_to), ""Error: User is already trusted"");

        trustMap[msg.sender] = _to;
        return 1; // Success code
    }

    function isTrusted(address _user) public view returns (bool) {
        return trustMap[_user] == msg.sender;
    }
}",42.73866152763367,trust,32.0,0.5459743763304059,0.0924821360269196,"[{'function': 'trust', 'complexity': 3}, {'function': 'isTrusted', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TrustContract is Ownable {
    mapping(address => address) public trustMap;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 fixedValue = 1; // uint256: Set to 1 (never 0)
        bytes32 initBytes = bytes32('init'); // bytes32: Set to bytes32('init')
        string memory initializedString = 'initialized'; // string: Set to 'initialized'
    }

    function trust(address _to) external returns (uint256) {
        require(_to != msg.sender, ""Error: Cannot trust oneself"");
        require(!isTrusted(_to), ""Error: User is already trusted"");

        trustMap[msg.sender] = _to;
        return 1; // Success code
    }

    function isTrusted(address _user) public view returns (bool) {
        return trustMap[_user] == msg.sender;
    }
}"
2481,Destroy the vesting information associated with an account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    mapping(address => VestingSchedule) public vestingSchedules;
    mapping(address => uint256) public totalVestedAccountBalance;
    uint256 public totalVestedBalance;

    struct VestingSchedule {
        // Define the structure of a vesting schedule here
    }

    function purgeAccount(address account) external onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
}","[{'function': 'purgeAccount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""purgeAccount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingSchedules""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No vesting schedule found for this account.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVestedBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeSub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalVestedBalance""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingSchedules""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingSchedules""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""totalVestedAccountBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyDuringSetup"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract VestingContract {
    address public owner;
    bool public setupPhase = true;
    mapping(address => VestingSchedule) public vestingSchedules;
    uint256 public totalVestedBalance;
    mapping(address => uint256) public totalVestedAccountBalance;

    struct VestingSchedule {
        uint256 amount;
        // Add other schedule details here if necessary
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    modifier onlyDuringSetup() {
        require(setupPhase, ""This function can only be called during the setup phase."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function purgeAccount(address account) public onlyOwner onlyDuringSetup {
        require(vestingSchedules[account].amount > 0, ""No vesting schedule found for this account."");

        // Decrease totalVestedBalance by the amount of vested balance held by the specified account
        totalVestedBalance = safeSub(totalVestedBalance, vestingSchedules[account].amount);

        // Remove the vesting schedule for the specified account
        delete vestingSchedules[account];

        // Remove the entry for the account's total vested balance
        delete totalVestedAccountBalance[account];
    }

    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""Safe subtraction: underflow"");
        return a - b;
    }
}",45.64685249328613,purgeAccount,14.0,0.8404801965301243,0.1135448246755459,"[{'function': 'purgeAccount', 'complexity': 1}, {'function': 'safeSub', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VestingContract is Ownable {
    bool public setupPhase = true;
    mapping(address => VestingSchedule) public vestingSchedules;
    uint256 public totalVestedBalance;
    mapping(address => uint256) public totalVestedAccountBalance;

    struct VestingSchedule {
        uint256 amount;
        // Add other schedule details here if necessary
    }

    modifier onlyDuringSetup() {
        require(setupPhase, ""This function can only be called during the setup phase."");
        _;
    }

    constructor() Ownable(msg.sender) {
        totalVestedBalance = 1;
        // Initialize other state variables as needed
    }

    function purgeAccount(address account) public onlyOwner onlyDuringSetup {
        require(vestingSchedules[account].amount > 0, ""No vesting schedule found for this account."");

        // Decrease totalVestedBalance by the amount of vested balance held by the specified account
        totalVestedBalance = safeSub(totalVestedBalance, vestingSchedules[account].amount);

        // Remove the vesting schedule for the specified account
        delete vestingSchedules[account];

        // Remove the entry for the account's total vested balance
        delete totalVestedAccountBalance[account];
    }

    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""Safe subtraction: underflow"");
        return a - b;
    }
}"
4726,` finalizeSale ( ) ` ends the TokenSale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function generateTokens(address, uint256) external returns (bool);
}

abstract contract VestedTokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public endTime;
    uint256 public totalIssued;
    uint256 public lockedTokens;
    uint256 public totalVested;
    uint256 public constant HARD_CAP = 100000 * 10**18; // Example hard cap, adjust as needed
    uint256 public constant MAX_TOKENS = 100000 * 10**18; // Example max tokens, adjust as needed
    bool public finalized;
    address public vaultAddress;
    TokenInterface public tokenContract;

    struct Vesting {
        uint256 amount;
        uint256 releaseTime;
    }

    mapping(address => Vesting) public vestedAllowances;

    function finalizeSale() public onlyOwner {
        require(block.timestamp > endTime || totalIssued >= HARD_CAP);
        require(!finalized, ""Sale has already been finalized"");

        vestedAllowances[vaultAddress] = Vesting(lockedTokens, block.timestamp + 3 years);

        uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalVested);
        require(tokenContract.generateTokens(vaultAddress, leftoverTokens), ""Token transfer failed for vault"");
        require(tokenContract.generateTokens(address(this), lockedTokens.add(totalVested)), ""Token transfer failed for contract"");

        finalized = true;
    }
}","[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalizeSale', 'complexity': 6}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""finalized""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Sale already finalized""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""leftoverTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""MAX_TOKENS""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""lockedTokens""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalIssued""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalIssuedEarlySale""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalVested""}}], ""isArray"": False}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""leftoverTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""mintTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""vaultAddress""}, {""type"": ""Identifier"", ""name"": ""leftoverTokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""mintTokens""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""lockedTokens""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalVested""}}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestedAllowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""vaultAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Vesting""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""lockedTokens""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": ""years""}}], ""names"": [""amount"", ""vestingEnd""]}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SaleFinalized""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAfterSale"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenSale {
    uint256 public constant MAX_TOKENS = 1000000 * 10**18; // Example hard cap, adjust as needed
    uint256 public lockedTokens;
    uint256 public totalIssued;
    uint256 public totalIssuedEarlySale;
    uint256 public totalVested;
    bool public finalized;
    address public vaultAddress;
    uint256 public endTime; // Assuming this is the sale end time stored as a timestamp

    struct Vesting {
        uint256 amount;
        uint256 vestingEnd;
    }

    mapping(address => Vesting) public vestedAllowances;

    event SaleFinalized();

    modifier onlyAfterSale() {
        require(block.timestamp > endTime || totalIssued >= MAX_TOKENS, ""Sale conditions not met"");
        _;
    }

    function finalizeSale() external onlyAfterSale {
        require(!finalized, ""Sale already finalized"");

        uint256 leftoverTokens = MAX_TOKENS - (lockedTokens + totalIssued + totalIssuedEarlySale + totalVested);
        if (leftoverTokens > 0) {
            // Assuming a function to mint tokens is available and safe to call from this contract
            mintTokens(vaultAddress, leftoverTokens);
            mintTokens(address(this), lockedTokens + totalVested);
        }

        vestedAllowances[vaultAddress] = Vesting({
            amount: lockedTokens,
            vestingEnd: block.timestamp + 3 years // Assuming current time is used for start of vesting
        });

        finalized = true;
        emit SaleFinalized();
    }

    function mintTokens(address to, uint256 amount) internal {
        // Implementation of token minting logic here
    }
}",46.04836845397949,finalizeSale,52.0,0.7658585207796236,0.2776342161496288,"[{'function': 'finalizeSale', 'complexity': 3}, {'function': 'mintTokens', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    uint256 public constant MAX_TOKENS = 1000000 * 10**18; // Example hard cap, adjust as needed
    uint256 public lockedTokens;
    uint256 public totalIssued;
    uint256 public totalIssuedEarlySale;
    uint256 public totalVested;
    bool public finalized;
    address public vaultAddress;
    uint256 public endTime; // Assuming this is the sale end time stored as a timestamp

    struct Vesting {
        uint256 amount;
        uint256 vestingEnd;
    }

    mapping(address => Vesting) public vestedAllowances;

    event SaleFinalized();

    constructor() Ownable(msg.sender) {
        lockedTokens = 0;
        totalIssued = 0;
        totalIssuedEarlySale = 0;
        totalVested = 0;
        finalized = false;
        vaultAddress = address(0);
        endTime = block.timestamp + 3 years; // Assuming current time is used for start of vesting
    }

    modifier onlyAfterSale() {
        require(block.timestamp > endTime || totalIssued >= MAX_TOKENS, ""Sale conditions not met"");
        _;
    }

    function finalizeSale() external onlyAfterSale {
        require(!finalized, ""Sale already finalized"");

        uint256 leftoverTokens = MAX_TOKENS - (lockedTokens + totalIssued + totalIssuedEarlySale + totalVested);
        if (leftoverTokens > 0) {
            // Assuming a function to mint tokens is available and safe to call from this contract
            mintTokens(vaultAddress, leftoverTokens);
            mintTokens(address(this), lockedTokens + totalVested);
        }

        vestedAllowances[vaultAddress] = Vesting({
            amount: lockedTokens,
            vestingEnd: block.timestamp + 3 years // Assuming current time is used for start of vesting
        });

        finalized = true;
        emit SaleFinalized();
    }

    function mintTokens(address to, uint256 amount) internal {
        // Implementation of token minting logic here
    }
}"
475,Release some of an affiliate 's tokens to a broker/trading wallet .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function transfer(address to, uint256 value) external returns (bool success);
}

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isAffiliate;
    }

    mapping(address => Holding) public heldTokens;
    address public tokenContract;

    event TokensReleased(address indexed beneficiary, uint256 amount);

    modifier onlyTransferAgent() {
        require(hasRole(TRANSFER_AGENT_ROLE, msg.sender), ""Caller is not a transfer agent"");
        _;
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyTransferAgent returns (bool) {
        require(tradingWallet != address(0), ""The destination wallet cannot be null."");
        require(!isExistingHolding(tradingWallet), ""The destination wallet must be a new fresh wallet."");
        Holding memory holding = heldTokens[who];
        require(holding.isAffiliate, ""Only affiliates can use this function; use release() for non-affiliates."");
        require(amount <= holding.quantity, ""The holding has less than the specified amount of tokens."");
        if (block.timestamp > holding.releaseDate) {
            bool res = ERC20Interface(tokenContract).transfer(tradingWallet, amount);
            if (res) {
                heldTokens[who] = Holding(holding.quantity.sub(amount), holding.releaseDate, holding.isAffiliate);
                emit TokensReleased(who, amount);
                return true;
            }
        }
        return false;
    }

    function isExistingHolding(address wallet) internal view returns (bool) {
        // Implement the logic to check if the wallet has an existing holding
        // This should be implemented based on your specific requirements and data storage
        return heldTokens[wallet].quantity > 0;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'partialRelease', 'complexity': 8}, {'function': 'isExistingHolding', 'complexity': 0}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""partialRelease"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tradingWallet"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""tradingWallet""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid trading wallet address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isHolding""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tradingWallet""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Trading wallet already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to release tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""heldTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tradingWallet""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensReleased""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAffiliate"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

contract TokenRelease {
    mapping(address => uint256) public heldTokens;
    IERC20 public token;

    event TokensReleased(address indexed who, uint256 amount);

    modifier onlyAffiliate(address _who) {
        require(_isAffiliate(_who), ""Caller is not an affiliate"");
        _;
    }

    constructor(IERC20 _token) {
        token = _token;
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyAffiliate(who) returns (bool) {
        require(tradingWallet != address(0), ""Invalid trading wallet address"");
        require(!_isHolding(tradingWallet), ""Trading wallet already exists"");
        require(amount > 0, ""Amount must be greater than zero"");
        require(token.balanceOf(who) >= amount, ""Insufficient balance to release tokens"");

        heldTokens[who] -= amount;
        if (token.transfer(tradingWallet, amount)) {
            emit TokensReleased(who, amount);
            return true;
        } else {
            return false;
        }
    }

    function _isAffiliate(address _who) internal view returns (bool) {
        // Implement affiliate logic here
        // For example, you might have a mapping or an external call to check if the address is an affiliate
        return true; // Placeholder for actual implementation
    }

    function _isHolding(address _tradingWallet) internal view returns (bool) {
        // Implement logic to check if the trading wallet already exists as a holding
        return false; // Placeholder for actual implementation
    }
}",46.30598783493042,partialRelease,23.0,0.80489552471043,0.3353773980048153,"[{'function': 'transfer', 'complexity': 0}, {'function': 'partialRelease', 'complexity': 6}, {'function': '_isAffiliate', 'complexity': 0}, {'function': '_isHolding', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenRelease is Ownable {
    mapping(address => uint256) public heldTokens;
    IERC20 public token;

    event TokensReleased(address indexed who, uint256 amount);

    modifier onlyAffiliate(address _who) {
        require(_isAffiliate(_who), ""Caller is not an affiliate"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token) Ownable(msg.sender) {
        token = _token;
        // Initialize state variables with fixed, safe, non-corner-case values
        heldTokens[_who] = 1; // Placeholder for actual affiliate address
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyAffiliate(who) returns (bool) {
        require(tradingWallet != address(0), ""Invalid trading wallet address"");
        require(!_isHolding(tradingWallet), ""Trading wallet already exists"");
        require(amount > 0, ""Amount must be greater than zero"");
        require(token.balanceOf(who) >= amount, ""Insufficient balance to release tokens"");

        heldTokens[who] -= amount;
        if (token.transfer(tradingWallet, amount)) {
            emit TokensReleased(who, amount);
            return true;
        } else {
            return false;
        }
    }

    function _isAffiliate(address _who) internal view returns (bool) {
        // Implement affiliate logic here
        // For example, you might have a mapping or an external call to check if the address is an affiliate
        return true; // Placeholder for actual implementation
    }

    function _isHolding(address _tradingWallet) internal view returns (bool) {
        // Implement logic to check if the trading wallet already exists as a holding
        return false; // Placeholder for actual implementation
    }
}"
1443,the method caller will have to claim ownership of regulators since regulators are claimable,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Regulator {
    function addValidator(address validator) external;
    function transferOwnership(address newOwner) external;
}

interface RegulatorProxy {
    function initialize(address regulatorImplementation) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxy, uint256 index);

    function createRegulatorProxy(address regulatorImplementation) public onlyOwner {
        require(regulatorImplementation != address(0), ""Invalid implementation address"");

        address proxy = address(new RegulatorProxy(regulatorImplementation));
        Regulator newRegulator = Regulator(proxy);
        newRegulator.addValidator(msg.sender);
        addAllPermissions(newRegulator);
        RegulatorProxy(proxy).transferOwnership(msg.sender);
        regulators.push(proxy);
        emit CreatedRegulatorProxy(proxy, getCount() - 1);
    }

    function getCount() public view returns (uint256) {
        return regulators.length;
    }

    function addAllPermissions(Regulator regulator) internal virtual {
        // Implement any necessary permission logic here
    }
}","[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'initialize', 'complexity': 0}, {'function': 'createRegulatorProxy', 'complexity': 1}, {'function': 'getCount', 'complexity': 0}, {'function': 'addAllPermissions', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createRegulatorProxy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""RegulatorProxy""}, ""name"": ""proxy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""RegulatorProxy""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_regulatorImplementation""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""proxyAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxy""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""regulators""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxyAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Regulator""}, ""name"": ""newRegulator"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Regulator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxyAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newRegulator""}, ""memberName"": ""addValidator""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""helperFunction""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newRegulator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proxy""}, ""memberName"": ""transferOwnership""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CreatedRegulatorProxy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""proxyAddress""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""regulators""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""proxyAddress""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface Regulator {
    function addValidator(address) external;
}

contract RegulatorProxy {
    address public owner;
    address private regulatorImplementation;
    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxy, uint index);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address _regulatorImplementation) {
        regulatorImplementation = _regulatorImplementation;
        owner = msg.sender;
    }

    function createRegulatorProxy() external returns (address) {
        RegulatorProxy proxy = new RegulatorProxy(_regulatorImplementation);
        address proxyAddress = address(proxy);
        regulators.push(proxyAddress);

        // Cast to Regulator interface
        Regulator newRegulator = Regulator(proxyAddress);
        newRegulator.addValidator(msg.sender);

        // Grant all necessary permissions
        helperFunction(newRegulator);

        // Transfer ownership to msg.sender
        proxy.transferOwnership(msg.sender);

        emit CreatedRegulatorProxy(proxyAddress, regulators.length - 1);
        return proxyAddress;
    }

    function transferOwnership(address newOwner) external onlyOwner {
        owner = newOwner;
    }

    // Placeholder for the helper function that grants all necessary permissions
    function helperFunction(Regulator regulator) internal {
        // Implement permission granting logic here
    }
}",45.80697846412659,createRegulatorProxy,29.0,0.9089013675903492,0.3545772984060831,"[{'function': 'addValidator', 'complexity': 0}, {'function': 'createRegulatorProxy', 'complexity': 0}, {'function': 'transferOwnership', 'complexity': 0}, {'function': 'helperFunction', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

interface Regulator {
    function addValidator(address) external;
}
import ""openzeppelin/SafeMath.sol"";
contract RegulatorProxy is Ownable {
    address public owner;
    address private regulatorImplementation;
    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxy, uint index);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address _regulatorImplementation) Ownable(msg.sender) {
        regulatorImplementation = _regulatorImplementation;
        owner = msg.sender;
    }

    function createRegulatorProxy() external returns (address) {
        RegulatorProxy proxy = new RegulatorProxy(_regulatorImplementation);
        address proxyAddress = address(proxy);
        regulators.push(proxyAddress);

        // Cast to Regulator interface
        Regulator newRegulator = Regulator(proxyAddress);
        newRegulator.addValidator(msg.sender);

        // Grant all necessary permissions
        helperFunction(newRegulator);

        // Transfer ownership to msg.sender
        proxy.transferOwnership(msg.sender);

        emit CreatedRegulatorProxy(proxyAddress, regulators.length - 1);
        return proxyAddress;
    }

    function transferOwnership(address newOwner) external onlyOwner {
        owner = newOwner;
    }

    // Placeholder for the helper function that grants all necessary permissions
    function helperFunction(Regulator regulator) internal {
        // Implement permission granting logic here
    }
}

// Importing Ownable contract with correct syntax
import ""./Ownable.sol"";"
6667,Compute the new IssuanceData on the old balance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IssuanceData {
    function currentBalanceSum() external view returns (uint);
    function lastAverageBalance() external view returns (uint);
    function lastModified() external view returns (uint);
}

abstract contract IssuanceWrapper is Ownable {
    using SafeMath for uint;

    struct IssuanceDataStruct {
        uint currentBalanceSum;
        uint lastAverageBalance;
        uint lastModified;
    }

    function computeIssuanceData(uint preBalance, IssuanceData preIssuance) internal view returns (IssuanceData) {
        uint currentBalanceSum = preIssuance.currentBalanceSum();
        uint lastAverageBalance = preIssuance.lastAverageBalance();
        uint lastModified = preIssuance.lastModified();

        if (lastModified < feePeriodStartTime()) {
            if (lastModified < lastFeePeriodStartTime()) {
                lastAverageBalance = preBalance;
            } else {
                uint timeUpToRollover = feePeriodStartTime() - lastModified;
                uint lastFeePeriodDuration = feePeriodStartTime() - lastFeePeriodStartTime();
                uint lastBalanceSum = currentBalanceSum.add(preBalance.mul(timeUpToRollover));
                lastAverageBalance = lastBalanceSum / lastFeePeriodDuration;
            }
            currentBalanceSum = preBalance.mul(now - feePeriodStartTime());
        } else {
            currentBalanceSum = currentBalanceSum.add(preBalance.mul(now - lastModified));
        }

        return IssuanceData(currentBalanceSum, lastAverageBalance, now);
    }

    uint public feePeriodStartTime;
    uint public lastFeePeriodStartTime;

    constructor() {
        // Initialize fee period start times or other necessary state variables here.
    }
}","[{'function': 'lastModified', 'complexity': -1}, {'function': 'computeIssuanceData', 'complexity': 9}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateIssuanceData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""preBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IssuanceData""}, ""name"": ""preIssuance"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IssuanceData""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""lastModifiedTimestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot modify issuance data too frequently""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentBalanceSum"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""currentBalanceSum""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastAverageBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""lastAverageBalance""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastModifiedTimestamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""preIssuance""}, ""memberName"": ""lastModifiedTimestamp""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastModifiedTimestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastModifiedTimestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastFeePeriodStartTime""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""preBalance""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeDifference"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastFeePeriodStartTime""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""averageBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""preBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeDifference""}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastFeePeriodStartTime""}}], ""isArray"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""averageBalance""}}}]}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timeSinceLastUpdate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastModifiedTimestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""preBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSinceLastUpdate""}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""feePeriodStartTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastFeePeriodStartTime""}}], ""isArray"": False}}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IssuanceData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentBalanceSum""}, {""type"": ""Identifier"", ""name"": ""lastAverageBalance""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": [""currentBalanceSum"", ""lastAverageBalance"", ""lastModifiedTimestamp""]}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

struct IssuanceData {
    uint256 currentBalanceSum;
    uint256 lastAverageBalance;
    uint256 lastModifiedTimestamp;
}

contract IssuanceUpdater {
    uint256 public feePeriodStartTime;
    uint256 public lastFeePeriodStartTime;

    function updateIssuanceData(uint256 preBalance, IssuanceData memory preIssuance) public returns (IssuanceData memory) {
        require(preIssuance.lastModifiedTimestamp < block.timestamp, ""Cannot modify issuance data too frequently"");

        uint256 currentBalanceSum = preIssuance.currentBalanceSum;
        uint256 lastAverageBalance = preIssuance.lastAverageBalance;
        uint256 lastModifiedTimestamp = preIssuance.lastModifiedTimestamp;

        if (lastModifiedTimestamp < feePeriodStartTime) {
            if (lastModifiedTimestamp < lastFeePeriodStartTime) {
                lastAverageBalance = preBalance;
            } else {
                // Calculate the average balance up to the rollover point
                uint256 timeDifference = block.timestamp - lastFeePeriodStartTime;
                uint256 averageBalance = (preBalance * timeDifference) / (feePeriodStartTime - lastFeePeriodStartTime);
                lastAverageBalance = averageBalance;
            }
        }

        // Update currentBalanceSum based on the difference between now and the relevant start time
        uint256 timeSinceLastUpdate = block.timestamp - lastModifiedTimestamp;
        currentBalanceSum += (preBalance * timeSinceLastUpdate) / (feePeriodStartTime - lastFeePeriodStartTime);

        return IssuanceData({
            currentBalanceSum: currentBalanceSum,
            lastAverageBalance: lastAverageBalance,
            lastModifiedTimestamp: block.timestamp
        });
    }
}",46.5759162902832,updateIssuanceData,31.0,0.821977869335863,0.1537494145909036,"[{'function': 'updateIssuanceData', 'complexity': 11}]",14.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

struct IssuanceData {
    uint256 currentBalanceSum;
    uint256 lastAverageBalance;
    uint256 lastModifiedTimestamp;
}
import ""openzeppelin/SafeMath.sol"";
contract IssuanceUpdater is Ownable {
    uint256 public feePeriodStartTime = 1;
    uint256 public lastFeePeriodStartTime = 2;

    constructor() Ownable(msg.sender) {
        // Initialize state variables as per the rules provided
        feePeriodStartTime = 1;
        lastFeePeriodStartTime = 2;
    }

    function updateIssuanceData(uint256 preBalance, IssuanceData memory preIssuance) public returns (IssuanceData memory) {
        require(preIssuance.lastModifiedTimestamp < block.timestamp, ""Cannot modify issuance data too frequently"");

        uint256 currentBalanceSum = preIssuance.currentBalanceSum;
        uint256 lastAverageBalance = preIssuance.lastAverageBalance;
        uint256 lastModifiedTimestamp = preIssuance.lastModifiedTimestamp;

        if (lastModifiedTimestamp < feePeriodStartTime) {
            if (lastModifiedTimestamp < lastFeePeriodStartTime) {
                lastAverageBalance = preBalance;
            } else {
                // Calculate the average balance up to the rollover point
                uint256 timeDifference = block.timestamp - lastFeePeriodStartTime;
                uint256 averageBalance = (preBalance * timeDifference) / (feePeriodStartTime - lastFeePeriodStartTime);
                lastAverageBalance = averageBalance;
            }
        }

        // Update currentBalanceSum based on the difference between now and the relevant start time
        uint256 timeSinceLastUpdate = block.timestamp - lastModifiedTimestamp;
        currentBalanceSum += (preBalance * timeSinceLastUpdate) / (feePeriodStartTime - lastFeePeriodStartTime);

        return IssuanceData({
            currentBalanceSum: currentBalanceSum,
            lastAverageBalance: lastAverageBalance,
            lastModifiedTimestamp: block.timestamp
        });
    }
}"
1283,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) internal allowances;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approve failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_extraData"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApproveAndCallReceiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}, ""memberName"": ""receiveApproval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_extraData""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ApproveAndCallReceiver {
    function receiveApproval(address _sender, uint256 _amount, address _tokenContract, bytes calldata _extraData) external;
}

contract Token {
    function approve(address spender, uint256 amount) public returns (bool);
}

contract MyToken is Token {
    function approveAndCall(address _spender, uint256 _amount, bytes calldata _extraData) external returns (bool success) {
        require(approve(_spender, _amount), ""Approval failed"");
        ApproveAndCallReceiver(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}",43.28494048118591,approveAndCall,24.0,0.5162945597833454,0.0329989286391992,"[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

interface ApproveAndCallReceiver {
    function receiveApproval(address _sender, uint256 _amount, address _tokenContract, bytes calldata _extraData) external;
}
import ""openzeppelin/SafeMath.sol"";
contract Token {
    function approve(address spender, uint256 amount) public returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Token {
    constructor() {
        // Initialization of Ownable with msg.sender
        Ownable(msg.sender);
    }

    function approveAndCall(address _spender, uint256 _amount, bytes calldata _extraData) external returns (bool success) {
        require(approve(_spender, _amount), ""Approval failed"");
        ApproveAndCallReceiver(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}"
6724,Adds a pair of addresses to manual blockings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct ManualBlocking {
        uint256 expiryTime;
    }

    mapping(address => mapping(address => ManualBlocking)) public manualBlockings;

    event AddManualBlocking(address indexed from, address indexed to, uint256 expiryTime, address approver);

    function addManualBlocking(address _from, address _to, uint256 _expiryTime) public onlyOwner {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_expiryTime > block.timestamp, ""Invalid expiry time"");
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");
        manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}","[{'function': 'addManualBlocking', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""addManualBlocking"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_expiryTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""manualBlockings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""expiryTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Blocking entry already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""manualBlockings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ManualBlockingStruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_expiryTime""}], ""names"": [""from"", ""to"", ""expiryTime""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AddManualBlocking""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_expiryTime""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyValidAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlyValidAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlyFutureTime"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_expiryTime""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ManualBlocking {
    struct ManualBlockingStruct {
        address from;
        address to;
        uint expiryTime;
    }

    mapping(address => mapping(address => ManualBlockingStruct)) public manualBlockings;

    event AddManualBlocking(address indexed _from, address indexed _to, uint indexed _expiryTime, address initiator);

    modifier onlyValidAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyFutureTime(uint _time) {
        require(_time > block.timestamp, ""Expiry time must be in the future"");
        _;
    }

    function addManualBlocking(address _from, address _to, uint _expiryTime) public
        onlyValidAddress(_from)
        onlyValidAddress(_to)
        onlyFutureTime(_expiryTime)
    {
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking entry already exists"");

        manualBlockings[_from][_to] = ManualBlockingStruct({
            from: _from,
            to: _to,
            expiryTime: _expiryTime
        });

        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}",45.34930443763733,addManualBlocking,33.0,0.8518812394857511,0.4311602216632182,"[{'function': 'addManualBlocking', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ManualBlocking is Ownable {
    struct ManualBlockingStruct {
        address from;
        address to;
        uint expiryTime;
    }

    mapping(address => mapping(address => ManualBlockingStruct)) public manualBlockings;

    event AddManualBlocking(address indexed _from, address indexed _to, uint indexed _expiryTime, address initiator);

    modifier onlyValidAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyFutureTime(uint _time) {
        require(_time > block.timestamp, ""Expiry time must be in the future"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function addManualBlocking(address _from, address _to, uint _expiryTime) public
        onlyValidAddress(_from)
        onlyValidAddress(_to)
        onlyFutureTime(_expiryTime)
    {
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking entry already exists"");

        manualBlockings[_from][_to] = ManualBlockingStruct({
            from: _from,
            to: _to,
            expiryTime: _expiryTime
        });

        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}"
2869,this function lets arbitrator withdraw DAI to the provided address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract DAIWrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public DAI;

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    constructor(address _daiAddress) {
        require(_daiAddress != address(0), ""Invalid DAI contract address"");
        DAI = IERC20(_daiAddress);
    }

    function withdrawDAI(address _receiver, uint256 _amount) public onlyOwner {
        require(_receiver != address(0), ""Invalid receiver address"");
        require(_amount > 0, ""Invalid amount"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance"");
        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'withdrawDAI', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawDAI"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_receiver""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid receiver address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""DAI""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to withdraw""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""DAI""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_receiver""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DAIWithdrawn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_receiver""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyArbitrator"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface DaiToken {
    function balanceOf(address) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

contract ArbitratorWithdrawal {
    address public arbitrator;
    DaiToken public DAI;

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    modifier onlyArbitrator() {
        require(msg.sender == arbitrator, ""Only the arbitrator can call this function"");
        _;
    }

    constructor(address _arbitrator, address _daiToken) {
        arbitrator = _arbitrator;
        DAI = DaiToken(_daiToken);
    }

    function withdrawDAI(address _receiver, uint256 _amount) external onlyArbitrator {
        require(_receiver != address(0), ""Invalid receiver address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance to withdraw"");

        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}",45.03828549385071,withdrawDAI,0.0,0.9848182093320732,0.7838717269994661,"[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawDAI', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

interface DaiToken {
    function balanceOf(address) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract ArbitratorWithdrawal is Ownable {
    address public arbitrator;
    DaiToken public DAI;

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    modifier onlyArbitrator() {
        require(msg.sender == arbitrator, ""Only the arbitrator can call this function"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _arbitrator, address _daiToken) Ownable(msg.sender) {
        arbitrator = _arbitrator;
        DAI = DaiToken(_daiToken);
    }

    function withdrawDAI(address _receiver, uint256 _amount) external onlyArbitrator {
        require(_receiver != address(0), ""Invalid receiver address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance to withdraw"");

        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}"
3748,Get the node at the end of a double linked list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address next;
        address previous;
    }

    mapping(uint256 => Node) public list;

    function end(List storage self) internal view returns (address) {
        return self.list[0].previous;
    }
}","[{'function': 'end', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""end"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""List""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""The linked list is empty""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""list""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract LinkedList {
    struct List {
        address[] list;
    }

    function end(List storage self) public view returns (address) {
        require(self.list.length > 0, ""The linked list is empty"");
        return self.list[self.list.length - 1];
    }
}",42.23082494735718,end,14.0,0.7073580274796062,0.3312824216936372,"[{'function': 'end', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LinkedList is Ownable {
    struct List {
        address[] list;
    }

    function end(List storage self) public view returns (address) {
        require(self.list.length > 0, ""The linked list is empty"");
        return self.list[self.list.length - 1];
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
1053,Updates the board status according to the players score .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGame {
    function calculateBoardScore(uint boardId) external view returns (uint8 blackScore, uint8 whiteScore);
    function updateBoardStatus(uint boardId, BoardStatus status) external;
}

abstract contract GameWrapper is Ownable {
    using SafeMath for uint256;

    struct Board {
        bool exists;
        BoardStatus status;
    }

    mapping(uint => Board) public boards;

    IGame public gameContract;

    event BoardCreated(uint boardId, BoardStatus initialStatus);

    constructor(address _gameContractAddress) {
        gameContract = IGame(_gameContractAddress);
    }

    modifier boardWaitingToResolve(uint boardId) {
        require(boards[boardId].exists, ""Board does not exist"");
        require(boards[boardId].status == BoardStatus.Pending, ""Board status is not pending"");
        _;
    }

    function createBoard(uint boardId, BoardStatus initialStatus) external onlyOwner {
        require(!boards[boardId].exists, ""Board already exists"");
        boards[boardId] = Board({exists: true, status: initialStatus});
        emit BoardCreated(boardId, initialStatus);
    }

    function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {
        uint8 blackScore;
        uint8 whiteScore;
        (blackScore, whiteScore) = gameContract.calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;
        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }
        gameContract.updateBoardStatus(boardId, status);
    }
}","[{'function': 'updateBoardStatus', 'complexity': 0}, {'function': 'createBoard', 'complexity': 2}, {'function': 'checkVictoryByScore', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""determineVictoryStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""boardId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""blackScore"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113502900>}, {""type"": ""VariableDeclaration"", ""name"": ""whiteScore"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113501240>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateBoardScore""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""boardId""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""BoardStatus""}, ""name"": ""status"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""Draw""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""blackScore""}, ""right"": {""type"": ""Identifier"", ""name"": ""whiteScore""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""BlackWin""}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""whiteScore""}, ""right"": {""type"": ""Identifier"", ""name"": ""blackScore""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoardStatus""}, ""memberName"": ""WhiteWin""}}}]}, ""FalseBody"": None}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateBoardStatus""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""boardId""}, {""type"": ""Identifier"", ""name"": ""status""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract GameBoard {
    enum BoardStatus { Draw, BlackWin, WhiteWin }

    struct Board {
        uint256 boardId;
        BoardStatus status;
    }

    mapping(uint256 => Board) public boards;

    function calculateBoardScore(uint256 boardId) internal view returns (uint8 blackScore, uint8 whiteScore) {
        // Placeholder for the actual implementation of calculating scores.
        // This should be implemented based on the specific rules of the game.
        blackScore = 10; // Example score
        whiteScore = 5;  // Example score
    }

    function updateBoardStatus(uint256 boardId, BoardStatus status) internal {
        boards[boardId].status = status;
    }

    function determineVictoryStatus(uint256 boardId) public {
        (uint8 blackScore, uint8 whiteScore) = calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;

        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }

        updateBoardStatus(boardId, status);
    }
}",44.42989420890808,determineVictoryStatus,12.0,0.8739152688537917,0.6410256524868173,"[{'function': 'calculateBoardScore', 'complexity': 0}, {'function': 'updateBoardStatus', 'complexity': 0}, {'function': 'determineVictoryStatus', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GameBoard is Ownable {
    enum BoardStatus { Draw, BlackWin, WhiteWin }

    struct Board {
        uint256 boardId;
        BoardStatus status;
    }

    mapping(uint256 => Board) public boards;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            boards[i] = Board({boardId: i, status: BoardStatus.Draw});
        }
    }

    function calculateBoardScore(uint256 boardId) internal view returns (uint8 blackScore, uint8 whiteScore) {
        // Placeholder for the actual implementation of calculating scores.
        // This should be implemented based on the specific rules of the game.
        if (boardId == 1) {
            blackScore = 10; // Example score
            whiteScore = 5;  // Example score
        } else if (boardId == 2) {
            blackScore = 8; // Example score
            whiteScore = 6; // Example score
        } else if (boardId == 3) {
            blackScore = 9; // Example score
            whiteScore = 7; // Example score
        }
    }

    function updateBoardStatus(uint256 boardId, BoardStatus status) internal {
        boards[boardId].status = status;
    }

    function determineVictoryStatus(uint256 boardId) public {
        (uint8 blackScore, uint8 whiteScore) = calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;

        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }

        updateBoardStatus(boardId, status);
    }
}"
963,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

abstract contract WrappedERC721 is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event OperatorApproval(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external onlyOwner {
        approvedOperators[_operator] = _approved;
        emit OperatorApproval(_msgSender(), _operator, _approved);
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return approvedOperators[_operator];
    }
}","[{'function': 'isApprovedForAll', 'complexity': 0}, {'function': 'setApprovalForAll', 'complexity': 0}, {'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isApprovedForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_operatorApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
        return _operatorApprovals[_owner][_operator];
    }
}",41.547526836395264,isApprovedForAll,13.0,0.8277170286813154,0.0244195962375919,"[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _operatorApprovals[address(0x111)] = true;
        _operatorApprovals[address(0x222)] = false;
        _operatorApprovals[address(0x333)] = true;
    }

    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
        return _operatorApprovals[_owner][_operator];
    }
}"
3793,Create an invite using the signing model described in the contract description,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InviteCreator is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public pendingInvites;
    address public signingLogic;

    event InviteCreated(address indexed user, address indexed inviteAddress);

    modifier onlyUser() {
        require(msg.sender != owner(), ""Owner cannot create invites"");
        _;
    }

    function setSigningLogic(address _signingLogic) public onlyOwner {
        signingLogic = _signingLogic;
    }

    function createInvite(bytes memory _sig) public onlyUser {
        require(signingLogic != address(0), ""Signing logic not set"");
        address inviteAddress = signingLogic.call(abi.encodeWithSelector(this.recoverSigner.selector, keccak256(abi.encodePacked(msg.sender)), _sig));
        require(!pendingInvites[inviteAddress], ""Invite already created"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(msg.sender, inviteAddress);
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        return ECDSA.recover(hash, signature);
    }
}","[{'function': 'setSigningLogic', 'complexity': 0}, {'function': 'createInvite', 'complexity': 3}, {'function': 'recoverSigner', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createInvite"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_sig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""inviteAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""signingLogic""}, ""memberName"": ""recoverSigner""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_sig""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingInvites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteAddress""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""An invitation for this address already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingInvites""}, ""index"": {""type"": ""Identifier"", ""name"": ""inviteAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InviteCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""inviteAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyNonUser"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract InvitationCreator {
    mapping(address => bool) public pendingInvites;
    ISigningLogic public signingLogic;

    event InviteCreated(address indexed invitee, address inviter);

    modifier onlyNonUser() {
        require(msg.sender != tx.origin, ""Only contracts can call this function"");
        _;
    }

    constructor(address _signingLogicAddress) {
        signingLogic = ISigningLogic(_signingLogicAddress);
    }

    function createInvite(bytes memory _sig) public onlyNonUser {
        address inviteAddress = signingLogic.recoverSigner(keccak256(abi.encodePacked(msg.sender)), _sig);
        require(!pendingInvites[inviteAddress], ""An invitation for this address already exists"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(inviteAddress, msg.sender);
    }
}

interface ISigningLogic {
    function recoverSigner(bytes32 hash, bytes memory signature) external pure returns (address);
}",44.122472047805786,createInvite,17.0,0.8313342323954278,0.4319245365472421,"[{'function': 'createInvite', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface ISigningLogic {
    function recoverSigner(bytes32 hash, bytes memory signature) external pure returns (address);
}
import ""openzeppelin/SafeMath.sol"";
contract InvitationCreator is Ownable {
    mapping(address => bool) public pendingInvites;
    ISigningLogic public signingLogic;

    event InviteCreated(address indexed invitee, address inviter);

    modifier onlyNonUser() {
        require(msg.sender != tx.origin, ""Only contracts can call this function"");
        _;
    }

    constructor(address _signingLogicAddress) Ownable(msg.sender) {
        signingLogic = ISigningLogic(_signingLogicAddress);
        // Initialize state variables with safe, non-corner-case values
        pendingInvites[address(0)] = false; // address 0 is not a valid invitee
        pendingInvites[address(1)] = false; // address 1 is used for testing or placeholder
        signingLogic = ISigningLogic(_signingLogicAddress);
    }

    function createInvite(bytes memory _sig) public onlyNonUser {
        address inviteAddress = signingLogic.recoverSigner(keccak256(abi.encodePacked(msg.sender)), _sig);
        require(!pendingInvites[inviteAddress], ""An invitation for this address already exists"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(inviteAddress, msg.sender);
    }
}"
3662,Allow pre-approved user to take ownership of a token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToOwner;

    function takeOwnership(uint256 _tokenId) public override {
        address newOwner = msg.sender;
        address oldOwner = allStarIndexToOwner[_tokenId];
        require(_addressNotNull(newOwner), ""Address should not be null"");
        require(_approved(newOwner, _tokenId), ""Token is not approved for transfer"");
        _transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address addr) internal pure returns (bool) {
        return addr != address(0);
    }

    function _approved(address operator, uint256 tokenId) internal view returns (bool) {
        // Assuming there's a way to check if the operator is approved for the tokenId
        // This should be implemented based on your contract logic
        return true; // Placeholder implementation
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(to != address(0), ""Transfer to zero address"");
        allStarIndexToOwner[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}","[{'function': 'takeOwnership', 'complexity': 2}, {'function': '_addressNotNull', 'complexity': 0}, {'function': '_approved', 'complexity': 0}, {'function': '_transfer', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenIds""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allStarIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""_addressNotNull: Address must not be null""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_approved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwner""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""_approved: New owner is not approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allStarIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwner""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldOwner""}, {""type"": ""Identifier"", ""name"": ""newOwner""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenOwnership {
    mapping(uint256 => address) public allStarIndexToOwner;
    uint256[] private tokenIds;

    function transferToken(uint256 _tokenId) external {
        require(_tokenId < tokenIds.length, ""Invalid token ID"");

        address oldOwner = allStarIndexToOwner[_tokenId];
        address newOwner = msg.sender;

        require(newOwner != address(0), ""_addressNotNull: Address must not be null"");
        require(_approved(newOwner, _tokenId), ""_approved: New owner is not approved"");

        allStarIndexToOwner[_tokenId] = newOwner;
        emit Transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address addr) internal pure returns (bool) {
        return addr != address(0);
    }

    function _approved(address owner, uint256 tokenId) internal view returns (bool) {
        // Assuming there's a way to check if the newOwner is approved for this token
        // This is a placeholder function and should be implemented based on actual approval logic
        return true;
    }

    function _transfer(uint256 tokenId, address from, address to) internal {
        allStarIndexToOwner[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}",45.232553243637085,transferToken,23.0,0.8337578297541703,0.3989189355367605,"[{'function': 'transferToken', 'complexity': 3}, {'function': '_addressNotNull', 'complexity': 0}, {'function': '_approved', 'complexity': 0}, {'function': '_transfer', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenOwnership is Ownable {
    mapping(uint256 => address) public allStarIndexToOwner;
    uint256[] private tokenIds;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            allStarIndexToOwner[i] = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
        }
    }

    function transferToken(uint256 _tokenId) external {
        require(_tokenId < tokenIds.length, ""Invalid token ID"");

        address oldOwner = allStarIndexToOwner[_tokenId];
        address newOwner = msg.sender;

        require(newOwner != address(0), ""_addressNotNull: Address must not be null"");
        require(_approved(newOwner, _tokenId), ""_approved: New owner is not approved"");

        allStarIndexToOwner[_tokenId] = newOwner;
        emit Transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address addr) internal pure returns (bool) {
        return addr != address(0);
    }

    function _approved(address owner, uint256 tokenId) internal view returns (bool) {
        // Assuming there's a way to check if the newOwner is approved for this token
        // This is a placeholder function and should be implemented based on actual approval logic
        return true;
    }

    function _transfer(uint256 tokenId, address from, address to) internal {
        allStarIndexToOwner[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}"
4592,Function use to change the lower and upper bound of the compatible version st,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyOwner {
        // Implementation of the function
    }
}","[{'function': 'changeSTVersionBounds', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeSTVersionBounds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_boundType"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""length"": None}, ""name"": ""_newVersion"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bounds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_boundType""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newVersion""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BoundChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_boundType""}, {""type"": ""Identifier"", ""name"": ""_newVersion""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract VersionBounds {
    mapping(string => uint8[]) private bounds;
    address public admin;

    event BoundChanged(string indexed boundType, uint8[] newBound);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    constructor() {
        admin = msg.sender;
    }

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyAdmin {
        bounds[_boundType] = _newVersion;
        emit BoundChanged(_boundType, _newVersion);
    }
}",43.05693364143372,changeSTVersionBounds,20.0,0.687677866825087,0.443330590140889,"[{'function': 'changeSTVersionBounds', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VersionBounds is Ownable {
    mapping(string => uint8[]) private bounds;
    address public admin;

    event BoundChanged(string indexed boundType, uint8[] newBound);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        admin = msg.sender;
        bounds[""default""] = uint8[](3); // Initialize with a safe non-corner-case value
    }

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyAdmin {
        bounds[_boundType] = _newVersion;
        emit BoundChanged(_boundType, _newVersion);
    }
}"
6054,Only the owner of a locked wallet can unlock the tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UnlockFunctionWrapper is Ownable {
    using SafeMath for uint256;

    struct Allocation {
        bool locked;
        uint256 value;
        uint256 end;
    }

    mapping(address => Allocation) public allocations;
    mapping(address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed account, address indexed sender, uint256 value);

    function unlock() external {
        require(allocations[msg.sender].locked, ""Allocation is not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Unlock time has not arrived yet"");
        balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);
        allocations[msg.sender].locked = false;
        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(msg.sender, address(this), allocations[msg.sender].value);
    }
}","[{'function': 'unlock', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""unlock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""locked""}, {""type"": ""stringLiteral"", ""value"": ""Allocation is not locked""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""now""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""end""}}, {""type"": ""stringLiteral"", ""value"": ""Lock period has not expired yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""locked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Unlock""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allocations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract LockableFunds {
    mapping(address => uint256) public balanceOf;
    mapping(address => Allocation) public allocations;

    struct Allocation {
        uint256 value;
        bool locked;
        uint256 end;
    }

    function unlock() external {
        require(allocations[msg.sender].locked, ""Allocation is not locked"");
        require(now >= allocations[msg.sender].end, ""Lock period has not expired yet"");

        balanceOf[msg.sender] += allocations[msg.sender].value;
        allocations[msg.sender].locked = false;

        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(address(this), msg.sender, allocations[msg.sender].value);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed user, address indexed contractAddress, uint256 value);
}",43.948166370391846,unlock,11.0,0.9246879141939022,0.6953790124206974,"[{'function': 'unlock', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LockableFunds is Ownable {
    mapping(address => uint256) public balanceOf;
    mapping(address => Allocation) public allocations;

    struct Allocation {
        uint256 value;
        bool locked;
        uint256 end;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[address(0x111)] = 1;
        balanceOf[address(0x222)] = 1;
        balanceOf[address(0x333)] = 1;

        allocations[address(0x111)].value = 1;
        allocations[address(0x111)].locked = true;
        allocations[address(0x111)].end = block.timestamp + 1 weeks; // Lock for 1 week from now

        allocations[address(0x222)].value = 1;
        allocations[address(0x222)].locked = true;
        allocations[address(0x222)].end = block.timestamp + 2 weeks; // Lock for 2 weeks from now

        allocations[address(0x333)].value = 1;
        allocations[address(0x333)].locked = true;
        allocations[address(0x333)].end = block.timestamp + 3 weeks; // Lock for 3 weeks from now
    }

    function unlock() external {
        require(allocations[msg.sender].locked, ""Allocation is not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Lock period has not expired yet"");

        balanceOf[msg.sender] += allocations[msg.sender].value;
        allocations[msg.sender].locked = false;

        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(address(this), msg.sender, allocations[msg.sender].value);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed user, address indexed contractAddress, uint256 value);
}"
6003,Proxy function which allows sending of transactions in behalf of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransactionExecutor is Ownable {
    using SafeMath for uint256;

    event Execution(address indexed destination, uint256 value, bytes data);
    event ExecutionFailure(address indexed destination, uint256 value, bytes data);

    function executeTransaction(address destination, uint value, bytes memory data) public onlyOwner {
        if (destination.call{value: value}(data)) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}","[{'function': 'executeTransaction', 'complexity': 0}]",2.0,{},"pragma solidity ^0.8.0;

contract TransactionExecutor {
    event Execution(address destination, uint value, bytes data);
    event ExecutionFailure(address destination, uint value, bytes data);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function executeTransaction(address destination, uint value, bytes memory data) public onlyOwner {
        (bool success, ) = destination.call{value: value}(data);
        if (success) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}",43.234166383743286,executeTransaction,0.0,0.9317343139567184,0.7947239774486975,"[{'function': 'executeTransaction', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TransactionExecutor is Ownable {
    event Execution(address destination, uint value, bytes data);
    event ExecutionFailure(address destination, uint value, bytes data);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function executeTransaction(address destination, uint value, bytes memory data) public onlyOwner {
        (bool success, ) = destination.call{value: value}(data);
        if (success) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}"
1262,Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorSendWrapper is Ownable {
    using SafeMath for uint256;

    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) external {
        require(isOperatorFor(msg.sender, _from), ""Not authorized to send from this account"");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }
}","[{'function': 'operatorSend', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""operatorSend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_userData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""isOperatorFor""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Sender is not an approved operator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""doSend""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_userData""}, {""type"": ""Identifier"", ""name"": ""_operatorData""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IToken {
    function isOperatorFor(address operator, address user) external view returns (bool);
    function doSend(address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData, bool isOperatorInitiated) external;
}

contract TokenSender {
    IToken public tokenContract;

    constructor(address _tokenAddress) {
        tokenContract = IToken(_tokenAddress);
    }

    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) external {
        require(tokenContract.isOperatorFor(msg.sender, _from), ""Sender is not an approved operator"");
        tokenContract.doSend(_from, _to, _amount, _userData, _operatorData, true);
    }
}",43.30057764053345,operatorSend,2.0,0.9420960544597274,0.7126101300976454,"[{'function': 'doSend', 'complexity': 0}, {'function': 'operatorSend', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

interface IToken {
    function isOperatorFor(address operator, address user) external view returns (bool);
    function doSend(address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData, bool isOperatorInitiated) external;
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSender is Ownable {
    IToken public tokenContract;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        tokenContract = IToken(_tokenAddress);
    }

    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) external {
        require(tokenContract.isOperatorFor(msg.sender, _from), ""Sender is not an approved operator"");
        tokenContract.doSend(_from, _to, _amount, _userData, _operatorData, true);
    }
}"
4646,Returns the bond of a given darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeRegistryInterface {
    function darknodeBond(address darknodeID) external view returns (uint256);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address) public darknodeRegistries;

    constructor() {}

    function darknodeBond(address darknodeID, address darknodeRegistryAddress) external view returns (uint256) {
        require(darknodeRegistries[darknodeRegistryAddress] != address(0), ""Darknode registry not set"");
        DarknodeRegistryInterface darknodeRegistry = DarknodeRegistryInterface(darknodeRegistryAddress);
        return darknodeRegistry.darknodeBond(darknodeID);
    }
}","[{'function': 'darknodeBond', 'complexity': 0}, {'function': 'darknodeBond', 'complexity': 1}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""darknodeBond"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""darknodeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeRegistry""}, ""index"": {""type"": ""Identifier"", ""name"": ""darknodeID""}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract DarknodeRegistry {
    mapping(address => uint256) public darknodeRegistry;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {
        return darknodeRegistry[darknodeID];
    }
}",42.23896312713623,darknodeBond,21.0,0.6137332775809696,0.0968519014702155,"[{'function': 'darknodeBond', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DarknodeRegistry is Ownable {
    mapping(address => uint256) public darknodeRegistry;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
    }

    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {
        return darknodeRegistry[darknodeID];
    }
}"
476,Transfer ` _value ` SAT tokens from sender 's account ` msg.sender ` to provided account address ` _to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address _to, uint256 _value) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    bool public funding_ended = false;
    address public founders;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(!funding_ended, ""Funding has ended"");
        require(msg.sender != founders, ""Founders cannot transfer tokens"");
        uint256 senderBalance = balances[msg.sender];
        require(senderBalance >= _value && _value > 0, ""Insufficient balance or invalid value"");

        balances[msg.sender] = safeSub(senderBalance, _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""fundingNotEnded"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyFounder"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    mapping(address => uint256) public balances;
    address public founder;
    bool public fundingEnded;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyFounder() {
        require(msg.sender == founder, ""Only the founder can call this function"");
        _;
    }

    modifier fundingNotEnded() {
        require(!fundingEnded, ""Funding has ended"");
        _;
    }

    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
        founder = msg.sender;
    }

    function transfer(address _to, uint256 _value) public fundingNotEnded onlyFounder returns (bool success) {
        require(_value > 0, ""Transfer value must be greater than zero"");
        require(balances[msg.sender] >= _value, ""Insufficient balance to transfer"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}",44.21958208084106,transfer,29.0,0.7956862049320221,0.3455023133212646,"[{'function': 'transfer', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(address => uint256) public balances;
    address public founder;
    bool public fundingEnded;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyFounder() {
        require(msg.sender == founder, ""Only the founder can call this function"");
        _;
    }

    modifier fundingNotEnded() {
        require(!fundingEnded, ""Funding has ended"");
        _;
    }

    constructor(uint256 initialSupply) Ownable(msg.sender) {
        balances[msg.sender] = initialSupply;
        founder = msg.sender;
    }

    function transfer(address _to, uint256 _value) public fundingNotEnded onlyFounder returns (bool success) {
        require(_value > 0, ""Transfer value must be greater than zero"");
        require(balances[msg.sender] >= _value, ""Insufficient balance to transfer"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}"
2119,Returns the order amount for trader ` _trader ` at '_price ',"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function getAmount(uint _price, address _trader) public pure returns (uint) {
        return _price;
    }
}","[{'function': 'getAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_trader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1000"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract PriceCalculator {
    function calculateAmount(uint _price, address _trader) public pure returns (uint amount) {
        // Example calculation: price * 100 / 1000 for demonstration purposes
        return _price * 100 / 1000;
    }
}",41.85233640670776,calculateAmount,4.0,0.7909582522922227,0.3375804740497263,"[{'function': 'calculateAmount', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceCalculator is Ownable {
    uint256 private constant PRICE_MULTIPLIER = 100;
    uint256 private constant DIVISOR = 1000;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function calculateAmount(uint _price, address _trader) public pure returns (uint amount) {
        // Example calculation: price * 100 / 1000 for demonstration purposes
        return _price * PRICE_MULTIPLIER / DIVISOR;
    }
}"
3447,Set the Synth contract that the issuance controller uses to issue Synths .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    Synth public synth;

    event SynthUpdated(Synth indexed synth);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setSynth(Synth _synth) external onlyOwner {
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}","[{'function': 'setSynth', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_synth"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_synth""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid synth address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""synth""}, ""right"": {""type"": ""Identifier"", ""name"": ""_synth""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SynthUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_synth""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract SynthManager is Ownable {
    address public synth;

    event SynthUpdated(address indexed newSynth);

    function setSynth(address _synth) external onlyOwner {
        require(_synth != address(0), ""Invalid synth address"");
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}",41.92413139343262,setSynth,10.0,0.7539817055120476,0.4151071015294532,"[{'function': 'setSynth', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SynthManager is Ownable {
    address public synth;

    event SynthUpdated(address indexed newSynth);

    constructor(address _synth) Ownable(msg.sender) {
        require(_synth != address(0), ""Invalid synth address"");
        synth = _synth;
    }

    function setSynth(address _synth) external onlyOwner {
        require(_synth != address(0), ""Invalid synth address"");
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}"
2394,Migrate tokens to the new token contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MigrationAgent {
    function migrateFrom(address _from, uint256 _value) external;
}

event Migrate(address indexed from, address indexed agent, uint256 value);

abstract contract MigrableToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    uint256 public totalMigrated;
    address public migrationAgent;

    function migrate(uint256 _value) external {
        if (migrationAgent == address(0)) revert();
        if (_value == 0) revert();
        if (_value > balances[msg.sender]) revert();
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalMigrated = totalMigrated.add(_value);
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
        emit Migrate(msg.sender, migrationAgent, _value);
    }
}","[{'function': 'migrateFrom', 'complexity': 0}, {'function': 'migrate', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""migrateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""migrationAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Migration agent not set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to migrate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalMigrated""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IMigrationAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""migrationAgent""}], ""names"": []}, ""memberName"": ""migrateFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Migrate""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""migrationAgent""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenMigration {
    // State variables to store token balances and total supply
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    uint256 public totalMigrated;

    // Address of the migration agent contract
    address public migrationAgent;

    // Event triggered when a migration occurs
    event Migrate(address indexed sender, address indexed agent, uint256 value);

    // Function to set the migration agent
    function setMigrationAgent(address _agent) external {
        require(_agent != address(0), ""Invalid migration agent"");
        migrationAgent = _agent;
    }

    // Function for token holders to migrate their tokens
    function migrateTokens(uint256 _value) external {
        require(migrationAgent != address(0), ""Migration agent not set"");
        require(_value > 0, ""Value must be greater than zero"");
        require(_value <= balanceOf[msg.sender], ""Insufficient balance to migrate"");

        // Update balances and total supply
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        totalMigrated += _value;

        // Call the migration agent's migrateFrom function
        IMigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);

        // Emit the Migrate event
        emit Migrate(msg.sender, migrationAgent, _value);
    }
}

// Interface for the migration agent contract
interface IMigrationAgent {
    function migrateFrom(address _from, uint256 _value) external;
}",45.346742391586304,migrateTokens,24.0,0.7764529599289907,0.3043848881916639,"[{'function': 'setMigrationAgent', 'complexity': 1}, {'function': 'migrateTokens', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenMigration is Ownable {
    // State variables to store token balances and total supply
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    uint256 public totalMigrated;

    // Address of the migration agent contract
    address public migrationAgent;

    // Event triggered when a migration occurs
    event Migrate(address indexed sender, address indexed agent, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed values
        balanceOf[msg.sender] = 1000;
        totalSupply = 1000000000000000000;
        totalMigrated = 0;

        // Set migration agent to the contract creator
        migrationAgent = msg.sender;
    }

    // Function to set the migration agent
    function setMigrationAgent(address _agent) public {
        require(_agent != address(0), ""Invalid migration agent"");
        migrationAgent = _agent;
    }

    // Function for token holders to migrate their tokens
    function migrateTokens(uint256 _value) public {
        require(migrationAgent != address(0), ""Migration agent not set"");
        require(_value > 0, ""Value must be greater than zero"");
        require(_value <= balanceOf[msg.sender], ""Insufficient balance to migrate"");

        // Update balances and total supply
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        totalMigrated += _value;

        // Call the migration agent's migrateFrom function
        IMigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);

        // Emit the Migrate event
        emit Migrate(msg.sender, migrationAgent, _value);
    }
}

// Interface for the migration agent contract
interface IMigrationAgent {
    function migrateFrom(address _from, uint256 _value) external;
}"
6317,This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContributionProxy is Ownable {
    using SafeMath for uint256;

    function proxy_contribution(address _toAddr) public payable {
        require(_toAddr != address(0));
        process_contribution(_toAddr);
    }

    function process_contribution(address _toAddr) internal {
        // Implementation of the contribution processing logic
    }
}","[{'function': 'proxy_contribution', 'complexity': 1}, {'function': 'process_contribution', 'complexity': 0}]",2.0,{},"pragma solidity ^0.8.0;

contract ContributionProxy {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function proxy_contribution(address payable _toAddr) public payable {
        require(_toAddr != address(0), ""Invalid target address"");
        process_contribution(_toAddr);
    }

    function process_contribution(address payable _toAddr) internal {
        // Logic for processing the contribution can be added here
        (bool success, ) = _toAddr.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
    }

    receive() external payable {}
}",42.99118733406067,process_contribution,17.0,0.7856983359164573,0.044345960567147,"[{'function': 'proxy_contribution', 'complexity': 1}, {'function': 'process_contribution', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ContributionProxy is Ownable {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is handled in the parent constructor
    }

    function proxy_contribution(address payable _toAddr) public payable {
        require(_toAddr != address(0), ""Invalid target address"");
        process_contribution(_toAddr);
    }

    function process_contribution(address payable _toAddr) internal {
        // Logic for processing the contribution can be added here
        (bool success, ) = _toAddr.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
    }

    receive() external payable {}
}"
5800,` seal ( ) ` ends the Campaign by calling ` seal ( ) ` in the CampaignToken contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public tokenContract;
    uint256 public endFundingTime;

    constructor(address _tokenContract, uint256 _endFundingTime) {
        require(_endFundingTime > now, ""End funding time must be in the future"");
        tokenContract = _tokenContract;
        endFundingTime = _endFundingTime;
    }

    function seal() public {
        if (now < endFundingTime) throw;
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(tokenContract != address(0), ""Token contract must be set"");
        IToken(tokenContract).seal();
    }

    interface IToken {
        function seal() external;
    }
}","[{'function': 'seal', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""seal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endFundingTime""}}, {""type"": ""stringLiteral"", ""value"": ""Funding period has not ended.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""seal()""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Seal call failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenContract {
    uint public endFundingTime;
    address public tokenContract;

    constructor(uint _endFundingTime, address _tokenContract) {
        endFundingTime = _endFundingTime;
        tokenContract = _tokenContract;
    }

    function seal() external {
        require(block.timestamp >= endFundingTime, ""Funding period has not ended."");
        (bool success, ) = tokenContract.call(abi.encodeWithSignature(""seal()""));
        require(success, ""Seal call failed"");
    }
}",42.3427619934082,seal,15.0,0.835401958311927,0.1335224827289588,"[{'function': 'seal', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is Ownable {
    uint public endFundingTime;
    address public tokenContract;

    constructor(uint _endFundingTime, address _tokenContract) Ownable(msg.sender) {
        endFundingTime = _endFundingTime;
        tokenContract = _tokenContract;
    }

    function seal() external {
        require(block.timestamp >= endFundingTime, ""Funding period has not ended."");
        (bool success, ) = tokenContract.call(abi.encodeWithSignature(""seal()""));
        require(success, ""Seal call failed"");
    }
}"
5101,Returns asset balance for a particular holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function balanceOf(address _owner, bytes32 smbl) external view returns (uint);
}

abstract contract BalanceWrapper {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;
    bytes32 public smbl;

    constructor(address platformAddress, bytes32 symbol) {
        chronoBankPlatform = ChronoBankPlatform(platformAddress);
        smbl = symbol;
    }

    function balanceOf(address _owner) public view returns (uint) {
        return chronoBankPlatform.balanceOf(_owner, smbl);
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ChronoBankPlatform""}, ""name"": ""platform"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ChronoBankPlatform""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""chronoBankPlatformAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""platform""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract ChronoBankPlatform {
    function balanceOf(address _owner) public view returns (uint256) {
        // Placeholder for the actual implementation of the `balanceOf` function in the `chronoBankPlatform` contract.
        // This is a mock-up to illustrate the expected functionality based on the provided summary and example code snippets.
        return 0; // Replace with actual logic if available or necessary.
    }
}

contract TokenBalance {
    address public chronoBankPlatformAddress;

    constructor(address _chronoBankPlatformAddress) {
        chronoBankPlatformAddress = _chronoBankPlatformAddress;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        ChronoBankPlatform platform = ChronoBankPlatform(chronoBankPlatformAddress);
        return platform.balanceOf(_owner);
    }
}",43.67462682723999,balanceOf,7.0,0.8009658744687717,0.1665772255039244,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ChronoBankPlatform {
    function balanceOf(address _owner) public view returns (uint256) {
        // Placeholder for the actual implementation of the `balanceOf` function in the `chronoBankPlatform` contract.
        // This is a mock-up to illustrate the expected functionality based on the provided summary and example code snippets.
        return 0; // Replace with actual logic if available or necessary.
    }
}
import ""openzeppelin/SafeMath.sol"";
contract TokenBalance is Ownable {
    address public chronoBankPlatformAddress;

    mapping(address => uint256) public balanceOf;

 constructor(address _chronoBankPlatformAddress) Ownable(msg.sender) {
        chronoBankPlatformAddress = _chronoBankPlatformAddress;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        ChronoBankPlatform platform = ChronoBankPlatform(chronoBankPlatformAddress);
        return platform.balanceOf(_owner);
    }
}"
752,"Called by ` settle ` , executes the settlement for a RenEx order or distributes the fees for a RenExAtomic swap .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRENexBalances {
    function transferBalanceWithFee(address, address, address, uint256, uint256, address) external;
}

abstract contract RenExWrapper is Ownable {
    using SafeMath for uint256;

    struct TokenPair {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    mapping(bytes32 => bytes32) public orderDetails;
    mapping(bytes32 => address) public orderSubmitter;
    IRENexBalances public renExBalancesContract;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = keccak256(""RENEX_ATOMIC_SETTLEMENT"");

    function execute(bytes32 _buyID, bytes32 _sellID, address _buyer, address _seller, TokenPair memory _tokens) public {
        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ? calculateAtomicFees(_buyID, _sellID, _tokens) : calculateSettlementDetails(_buyID, _sellID, _tokens);
        renExBalancesContract.transferBalanceWithFee(_buyer, _seller, settlementDetails.leftTokenAddress, settlementDetails.leftVolume, settlementDetails.leftTokenFee, orderSubmitter[_buyID]);
        renExBalancesContract.transferBalanceWithFee(_seller, _buyer, settlementDetails.rightTokenAddress, settlementDetails.rightVolume, settlementDetails.rightTokenFee, orderSubmitter[_sellID]);
    }

    function calculateAtomicFees(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of atomic fee calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }

    function calculateSettlementDetails(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of settlement details calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }
}","[{'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'execute', 'complexity': 1}, {'function': 'calculateAtomicFees', 'complexity': 0}, {'function': 'calculateSettlementDetails', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""executeSettlement"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_buyID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_sellID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}, ""name"": ""_tokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_buyer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_seller""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid addresses""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""settlementID""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyID""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""RENEX_ATOMIC_SETTLEMENT_ID""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAtomicFees""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateSettlementDetails""}, ""arguments"": [], ""names"": []}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""memberName"": ""leftToken""}, ""memberName"": ""volume""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""memberName"": ""leftToken""}, ""memberName"": ""fee""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""memberName"": ""rightToken""}, ""memberName"": ""volume""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""memberName"": ""rightToken""}, ""memberName"": ""fee""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Settlement {
    address public renExBalancesContract;
    uint256 public constant RENEX_ATOMIC_SETTLEMENT_ID = 1; // Example of a state variable

    constructor(address _renExBalancesContract) {
        renExBalancesContract = _renExBalancesContract;
    }

    function executeSettlement(
        uint256 _buyID,
        uint256 _sellID,
        address _buyer,
        address _seller,
        Token memory _tokens
    ) external {
        require(_buyer != address(0) && _seller != address(0), ""Invalid addresses"");

        // Determine the type of settlement and handle accordingly
        if (settlementID(_buyID) == RENEX_ATOMIC_SETTLEMENT_ID) {
            calculateAtomicFees();
        } else {
            calculateSettlementDetails();
        }

        // Transfer balances for left token
        transferBalanceWithFee(
            _buyer,
            _seller,
            _tokens.leftToken.volume,
            _tokens.leftToken.fee,
            msg.sender
        );

        // Transfer balances for right token
        transferBalanceWithFee(
            _seller,
            _buyer,
            _tokens.rightToken.volume,
            _tokens.rightToken.fee,
            msg.sender
        );
    }

    function calculateAtomicFees() internal {
        // Placeholder for atomic fee calculation logic
    }

    function calculateSettlementDetails() internal {
        // Placeholder for settlement details calculation logic
    }

    function transferBalanceWithFee(
        address _from,
        address _to,
        uint256 _amount,
        uint256 _fee,
        address _feePayer
    ) internal {
        require(_from != address(0) && _to != address(0), ""Invalid addresses"");
        // Transfer amount including fee from _from to _to with _feePayer paying the fee
        // Implementation depends on renExBalancesContract methods
    }

    function settlementID(uint256 _orderID) internal pure returns (uint256) {
        return _orderID; // Placeholder logic for determining settlement type
    }
}

struct Token {
    TokenDetails leftToken;
    TokenDetails rightToken;
}

struct TokenDetails {
    uint256 volume;
    uint256 fee;
}",47.98939895629883,executeSettlement,35.0,0.553004585289796,0.0231943311465787,"[{'function': 'executeSettlement', 'complexity': 0}, {'function': 'calculateAtomicFees', 'complexity': 0}, {'function': 'calculateSettlementDetails', 'complexity': 0}, {'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'settlementID', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Settlement is Ownable {
    address public renExBalancesContract;
    uint256 public constant RENEX_ATOMIC_SETTLEMENT_ID = 1; // Example of a state variable

    constructor(address _renExBalancesContract) Ownable(msg.sender) {
        renExBalancesContract = _renExBalancesContract;
    }

    function executeSettlement(
        uint256 _buyID,
        uint256 _sellID,
        address _buyer,
        address _seller,
        Token memory _tokens
    ) external {
        require(_buyer != address(0) && _seller != address(0), ""Invalid addresses"");

        // Determine the type of settlement and handle accordingly
        if (settlementID(_buyID) == RENEX_ATOMIC_SETTLEMENT_ID) {
            calculateAtomicFees();
        } else {
            calculateSettlementDetails();
        }

        // Transfer balances for left token
        transferBalanceWithFee(
            _buyer,
            _seller,
            _tokens.leftToken.volume,
            _tokens.leftToken.fee,
            msg.sender
        );

        // Transfer balances for right token
        transferBalanceWithFee(
            _seller,
            _buyer,
            _tokens.rightToken.volume,
            _tokens.rightToken.fee,
            msg.sender
        );
    }

    function calculateAtomicFees() internal {
        // Placeholder for atomic fee calculation logic
    }

    function calculateSettlementDetails() internal {
        // Placeholder for settlement details calculation logic
    }

    function transferBalanceWithFee(
        address _from,
        address _to,
        uint256 _amount,
        uint256 _fee,
        address _feePayer
    ) internal {
        require(_from != address(0) && _to != address(0), ""Invalid addresses"");
        // Transfer amount including fee from _from to _to with _feePayer paying the fee
        // Implementation depends on renExBalancesContract methods
    }

    function settlementID(uint256 _orderID) internal pure returns (uint256) {
        return _orderID; // Placeholder logic for determining settlement type
    }
}

struct Token {
    TokenDetails leftToken;
    TokenDetails rightToken;
}

struct TokenDetails {
    uint256 volume;
    uint256 fee;
}"
1142,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _amount) public override returns (bool) {
        require(_spender != address(0));
        require(_amount > 0);
        require(_amount <= balanceOf[msg.sender]);

        allowances[_spender][msg.sender] = _amount;

        emit Approval(msg.sender, _spender, _amount);

        return true;
    }
}","[{'function': 'approve', 'complexity': 0}, {'function': 'approve', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    uint256 public totalSupply;
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    modifier validAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function approve(address _spender, uint256 _amount) public validAddress(_spender) returns (bool success) {
        require(balanceOf[msg.sender] >= _amount, ""Insufficient balance"");

        allowance[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }
}",44.49634909629822,approve,21.0,0.9004188122923237,0.4951332155029275,"[{'function': 'approve', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    uint256 public totalSupply = 1000000000000000000; // Set to 1 (never 0)
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    modifier validAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    uint256 public totalSupply;

 constructor(uint256 initialSupply) Ownable(msg.sender) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function approve(address _spender, uint256 _amount) public validAddress(_spender) returns (bool success) {
        require(balanceOf[msg.sender] >= _amount, ""Insufficient balance"");

        allowance[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }
}"
3633,` _value ` tokens will be sended to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITransfer {
    function transfer(bytes32 _to, uint256 _value) external returns (bool);
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event TransferHash(bytes32 indexed from, bytes32 indexed to, uint256 value);

    function transfer(bytes32 _to, uint256 _value) external onlyOwner returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit TransferHash(keccak256(abi.encodePacked(msg.sender)), _to, _value);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""senderHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TransferHash""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    event TransferHash(address indexed from, address indexed to, uint256 value);

    function transfer(bytes32 _to, uint256 _value) external returns (bool) {
        require(_value <= balances[msg.sender], ""Insufficient balance"");

        // Calculate the hash of the sender's address
        bytes32 senderHash = keccak256(abi.encodePacked(msg.sender));

        // Check if the recipient's address is valid (for demonstration purposes)
        require(_to != 0, ""Invalid recipient address"");

        // Transfer tokens
        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit TransferHash(msg.sender, _to, _value);

        return true;
    }
}",43.7819812297821,transfer,32.0,0.8803113802203937,0.3828860849990519,"[{'function': 'transfer', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    event TransferHash(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            balances[address(uint160(i << 160))] = 1;
        }
    }

    function transfer(bytes32 _to, uint256 _value) external returns (bool) {
        require(_value <= balances[msg.sender], ""Insufficient balance"");

        // Calculate the hash of the sender's address
        bytes32 senderHash = keccak256(abi.encodePacked(msg.sender));

        // Check if the recipient's address is valid (for demonstration purposes)
        require(_to != 0, ""Invalid recipient address"");

        // Transfer tokens
        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit TransferHash(msg.sender, _to, _value);

        return true;
    }
}"
4852,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function burn(uint256 _amount) public requiresPermission whenNotPaused {
        _burn(msg.sender, _amount);
    }
}","[{'function': 'burn', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to burn""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""Identifier"", ""name"": ""transferEnabled""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}}, {""type"": ""stringLiteral"", ""value"": ""Transfers are disabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isNotFrozen"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    bool public transferEnabled;
    address public owner;

    event Burn(address indexed burner, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier isNotFrozen() {
        require(!isFrozen(msg.sender), ""Account is frozen"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused(), ""Contract is paused"");
        _;
    }

    constructor(uint256 initialSupply) {
        owner = msg.sender;
        balances[owner] = initialSupply;
        totalSupply = initialSupply;
        transferEnabled = true;
    }

    function burn(uint256 _amount) public isNotFrozen whenNotPaused returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_amount <= balances[msg.sender], ""Insufficient balance to burn"");
        require(transferEnabled || msg.sender == owner, ""Transfers are disabled"");

        balances[msg.sender] -= _amount;
        totalSupply -= _amount;
        emit Burn(msg.sender, _amount);
        emit Transfer(msg.sender, address(0), _amount);
        return true;
    }
}",45.68276572227478,burn,51.0,0.3624788271888215,0.1259205368697117,"[{'function': 'burn', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    bool public transferEnabled;

    event Burn(address indexed burner, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier isNotFrozen() {
        require(!isFrozen(msg.sender), ""Account is frozen"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused(), ""Contract is paused"");
        _;
    }

    constructor(uint256 initialSupply) Ownable(msg.sender) {
        balances[owner()] = initialSupply;
        totalSupply = initialSupply;
        transferEnabled = true;
    }

    function burn(uint256 _amount) public isNotFrozen whenNotPaused returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_amount <= balances[msg.sender], ""Insufficient balance to burn"");
        require(transferEnabled || msg.sender == owner(), ""Transfers are disabled"");

        balances[msg.sender] -= _amount;
        totalSupply -= _amount;
        emit Burn(msg.sender, _amount);
        emit Transfer(msg.sender, address(0), _amount);
        return true;
    }
}"
2521,Returns the address currently assigned ownership of a given Warrior .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WarriorsWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    function ownerOf(uint208 _tokenId) external view returns (address owner) {
        require(_tokenId < warriors.length);
        owner = warriorToOwner[_tokenId];
    }
}","[{'function': 'ownerOf', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""warriors""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Token ID out of bounds""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""warriorToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TokenOwner {
    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    function pose(uint256 _tokenId) public view returns (address owner) {
        require(_tokenId < warriors.length, ""Token ID out of bounds"");
        return warriorToOwner[_tokenId];
    }
}",42.097177028656006,pose,4.0,0.9248963895427496,0.4424252176035718,"[{'function': 'pose', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenOwner is Ownable {
    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        warriors = [1, 2, 3]; // Example array of warriors
        for (uint256 i = 0; i < warriors.length; i++) {
            warriorToOwner[i] = address(uint160(i + 1)); // Initialize with addresses in sequence
        }
    }

    function pose(uint256 _tokenId) public view returns (address owner) {
        require(_tokenId < warriors.length, ""Token ID out of bounds"");
        return warriorToOwner[_tokenId];
    }
}"
402,Contract owner or Multisig can clawback ether after refund period is finished,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ClawbackEtherWrapper is Ownable {
    using SafeMath for uint256;

    bool public contractFailed;
    bool public contractRefundStarted;
    bool public contractRefundFinished;

    constructor() {}

    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
        require(contractFailed);
        require(contractRefundStarted);
        require(contractRefundFinished);
        require(value > 0);
        require(value <= address(this).balance);
        payable(msg.sender).transfer(value);
    }
}","[{'function': 'emergencyClawbackEther', 'complexity': 5}]",6.0,{},"pragma solidity ^0.8.0;

contract EmergencyClawback {
    address private owner;
    address private multisigWallet;
    bool public contractFailed = false;
    bool public contractRefundStarted = false;
    bool public contractRefundFinished = false;

    modifier onlyOwnerOrMultisig() {
        require(msg.sender == owner || msg.sender == multisigWallet, ""Only the owner or a designated multisig wallet can call this function."");
        _;
    }

    constructor(address _owner, address _multisigWallet) {
        owner = _owner;
        multisigWallet = _multisigWallet;
    }

    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
        require(contractFailed, ""The contract must have failed."");
        require(contractRefundStarted, ""The refund process must have started."");
        require(contractRefundFinished, ""The refund process must have finished."");
        require(value > 0, ""The value to be withdrawn must be greater than zero."");
        require(address(this).balance >= value, ""The value to be withdrawn must not exceed the current balance of the contract."");

        (bool success, ) = msg.sender.call{value: value}("""");
        require(success, ""Transfer failed."");
    }
}",44.855921506881714,emergencyClawbackEther,41.0,0.8993358835192048,0.2768042333975893,"[{'function': 'emergencyClawbackEther', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EmergencyClawback is Ownable {
    address private owner = msg.sender;
    address private multisigWallet;
    bool public contractFailed = false;
    bool public contractRefundStarted = false;
    bool public contractRefundFinished = false;

    modifier onlyOwnerOrMultisig() {
        require(msg.sender == owner || msg.sender == multisigWallet, ""Only the owner or a designated multisig wallet can call this function."");
        _;
    }

    constructor(address _multisigWallet) Ownable(msg.sender) {
        multisigWallet = _multisigWallet;
    }

    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
        require(contractFailed, ""The contract must have failed."");
        require(contractRefundStarted, ""The refund process must have started."");
        require(contractRefundFinished, ""The refund process must have finished."");
        require(value > 0, ""The value to be withdrawn must be greater than zero."");
        require(address(this).balance >= value, ""The value to be withdrawn must not exceed the current balance of the contract."");

        (bool success, ) = msg.sender.call{value: value}("""");
        require(success, ""Transfer failed."");
    }
}"
2323,By using this function you accept the terms of DXF,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Multisig {
    function send(uint256 amount) external returns (bool);
}

abstract contract DXFContract is Ownable {
    using SafeMath for uint256;

    uint public startingDateFunding;
    bool public dxfOpen = true;
    uint public maxNumberMembers = 1000;
    uint public totalTokens;
    uint public tokensCreationCap = 10000 ether;
    uint public remainingTokensVIPs;
    mapping(address => uint) public balances;
    address[] public members;
    mapping(address => uint) public indexMembers;
    mapping(address => bool) public vips;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function acceptTermsAndJoinDXF() payable external {
        require(now > startingDateFunding + 365 days, ""Too early"");
        require(dxfOpen, ""DXF is closed"");
        require(!vips[msg.sender], ""Already a VIP"");
        require(msg.value >= 10 ether, ""Minimum contribution is 10 ether"");
        require(msg.value <= (tokensCreationCap - totalTokens), ""Exceeds token creation cap"");
        require(msg.value <= 10000 ether - balances[msg.sender], ""Exceeds balance limit"");

        if (balances[msg.sender] == 0) {
            newMember(msg.sender);
            indexMembers[msg.sender] = members.length;
            members.push(Member(msg.sender, now, msg.value));
        } else {
            members[indexMembers[msg.sender]].initial_value += msg.value;
        }

        require(members.length <= maxNumberMembers, ""Max number of members reached"");
        require(multisigDXF != address(0), ""Invalid multisig contract"");

        Multisig multisig = Multisig(multisigDXF);
        require(multisig.send(msg.value), ""Transfer failed"");

        uint numTokens = msg.value;
        totalTokens += numTokens;
        require((tokensCreationCap - totalTokens) >= remainingTokensVIPs, ""Exceeds VIP tokens limit"");

        balances[msg.sender] += numTokens;
        Transfer(address(0), msg.sender, numTokens);
    }

    function newMember(address member) internal {
        // Implementation of newMember logic if needed
    }
}","[{'function': 'send', 'complexity': 0}, {'function': 'acceptTermsAndJoinDXF', 'complexity': 12}, {'function': 'newMember', 'complexity': 0}]",12.0,{},"pragma solidity ^0.8.0;

contract DXF {
    address public multisigDXF;
    uint256 public minimumContribution = 10 ether;
    uint256 public maxTokensCreationCap;
    uint256 public maxIndividualBalance = 10000 ether;
    uint256 public fundingStartTimestamp;
    uint256 public constant FUNDING_PERIOD = 365 days; // One year
    mapping(address => uint256) public balances;
    address[] public members;

    modifier onlyIfOpenForContributions() {
        require(block.timestamp >= fundingStartTimestamp && block.timestamp <= fundingStartTimestamp + FUNDING_PERIOD, ""DXF: Contribution period is closed"");
        _;
    }

    modifier onlyIfNotVIP() {
        // Assuming VIP members are stored in a mapping or array and can be checked here
        require(!isVIP(msg.sender), ""DXF: VIP members cannot join through this function"");
        _;
    }

    constructor(address _multisigDXF, uint256 _maxTokensCreationCap, uint256 startTimestamp) {
        multisigDXF = _multisigDXF;
        maxTokensCreationCap = _maxTokensCreationCap;
        fundingStartTimestamp = startTimestamp;
    }

    function contribute() external payable onlyIfOpenForContributions onlyIfNotVIP {
        require(msg.value >= minimumContribution, ""DXF: Contribution must be at least 10 ether"");
        require(totalTokensCreated + msg.value <= maxTokensCreationCap, ""DXF: Exceeds the remaining tokens creation cap"");
        require(balances[msg.sender] + msg.value <= maxIndividualBalance, ""DXF: Individual balance limit exceeded"");
        require(multisigDXF != address(0), ""DXF: Multisig address is not set"");

        if (balances[msg.sender] == 0) {
            members.push(msg.sender);
        }

        balances[msg.sender] += msg.value;
        totalTokensCreated += msg.value;

        // Transfer Ether to multisigDXF address
        (bool success, ) = multisigDXF.call{value: msg.value}("""");
        require(success, ""DXF: Failed to send ether"");

        emit Transfer(address(0), msg.sender, msg.value);
    }

    function totalTokensCreated() public view returns (uint256) {
        return totalTokensCreated;
    }

    // Assuming VIP members are stored in a mapping or array and can be checked here
    function isVIP(address member) internal virtual returns (bool) {
        // Placeholder for actual VIP membership logic
        return false;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",49.00593543052673,contribute,144.0,0.7535956215309547,0.2412737263582042,"[{'function': 'contribute', 'complexity': 6}, {'function': 'totalTokensCreated', 'complexity': 0}, {'function': 'isVIP', 'complexity': 0}]",7.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract DXF {
    address public multisigDXF;
    uint256 public minimumContribution = 1 ether;
    uint256 public maxTokensCreationCap;
    uint256 public maxIndividualBalance = 10000 ether;
    uint256 public fundingStartTimestamp;
    uint256 public constant FUNDING_PERIOD = 365 days; // One year
    mapping(address => uint256) public balances;
    address[] public members;

    modifier onlyIfOpenForContributions() {
        require(block.timestamp >= fundingStartTimestamp && block.timestamp <= fundingStartTimestamp + FUNDING_PERIOD, ""DXF: Contribution period is closed"");
        _;
    }

    modifier onlyIfNotVIP() {
        // Assuming VIP members are stored in a mapping or array and can be checked here
        require(!isVIP(msg.sender), ""DXF: VIP members cannot join through this function"");
        _;
    }

    constructor(address _multisigDXF, uint256 _maxTokensCreationCap, uint256 startTimestamp) {
        multisigDXF = _multisigDXF;
        maxTokensCreationCap = _maxTokensCreationCap;
        fundingStartTimestamp = startTimestamp;

        multisigDXF = Ownable(msg.sender);
    }

    function contribute() external payable onlyIfOpenForContributions onlyIfNotVIP {
        require(msg.value >= minimumContribution, ""DXF: Contribution must be at least 10 ether"");
        require(totalTokensCreated + msg.value <= maxTokensCreationCap, ""DXF: Exceeds the remaining tokens creation cap"");
        require(balances[msg.sender] + msg.value <= maxIndividualBalance, ""DXF: Individual balance limit exceeded"");
        require(multisigDXF != address(0), ""DXF: Multisig address is not set"");

        if (balances[msg.sender] == 0) {
            members.push(msg.sender);
        }

        balances[msg.sender] += msg.value;
        totalTokensCreated += msg.value;

        // Transfer Ether to multisigDXF address
        (bool success, ) = multisigDXF.call{value: msg.value}("""");
        require(success, ""DXF: Failed to send ether"");

        emit Transfer(address(0), msg.sender, msg.value);
    }

    function totalTokensCreated() public view returns (uint256) {
        return totalTokensCreated;
    }

    // Assuming VIP members are stored in a mapping or array and can be checked here
    function isVIP(address member) internal virtual returns (bool) {
        // Placeholder for actual VIP membership logic
        return false;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;

    constructor(address _owner) {
        owner = _owner;
    }
}"
36,Function used by the creator to set the contractor manager smart contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractorManagerSetter is Ownable {
    using SafeMath for uint256;

    event ContractorManagerSet(address indexed contractorManager);

    function setContractorManager(address _contractorManager) public onlyOwner {
        require(_contractorManager != address(0), ""Invalid contractor manager address"");
        emit ContractorManagerSet(_contractorManager);
    }
}","[{'function': 'setContractorManager', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setContractorManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractorManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contractorManager""}, ""right"": {""type"": ""Identifier"", ""name"": ""_contractorManager""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ContractorManagerSetter {
    address private owner;
    address public contractorManager;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can set a new contractor manager."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setContractorManager(address _contractorManager) public onlyOwner {
        contractorManager = _contractorManager;
    }
}",42.00063967704773,setContractorManager,10.0,0.6631109056361211,0.1665806979447398,"[{'function': 'setContractorManager', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ContractorManagerSetter is Ownable {
    address private owner = msg.sender;
    address public contractorManager;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can set a new contractor manager."");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setContractorManager(address _contractorManager) public onlyOwner {
        contractorManager = _contractorManager;
    }
}"
1979,Get comprehensive information on an attribute type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAttributeType {
    struct AttributeType {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }
}

abstract contract AttributeTypeWrapper {
    using SafeMath for uint256;

    mapping(uint256 => IAttributeType.AttributeType) private _attributeTypes;

    function getAttributeTypeInformation(uint256 attributeTypeID) external view returns (string memory, bool, bool, address, uint256, uint256, uint256) {
        return (
            _attributeTypes[attributeTypeID].description,
            _attributeTypes[attributeTypeID].isRestricted,
            _attributeTypes[attributeTypeID].isOnlyPersonal,
            _attributeTypes[attributeTypeID].secondarySource,
            _attributeTypes[attributeTypeID].secondaryId,
            _attributeTypes[attributeTypeID].minimumRequiredStake,
            _attributeTypes[attributeTypeID].jurisdictionFee
        );
    }
}","[{'function': 'getAttributeTypeInformation', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAttributeTypeDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""description"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isRestricted"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isOnlyPersonal"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""secondarySource"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""secondaryId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""minimumRequiredStake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""jurisdictionFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""AttributeTypeInfo""}, ""name"": ""info"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypeInfos""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""description""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""isRestricted""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""isOnlyPersonal""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""secondarySource""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""secondaryId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""minimumRequiredStake""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""info""}, ""memberName"": ""jurisdictionFee""}], ""isArray"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AttributeTypeDetails {
    struct AttributeTypeInfo {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }

    mapping(uint256 => AttributeTypeInfo) public attributeTypeInfos;

    function getAttributeTypeDetails(uint256 attributeTypeID) external view returns (
        string memory description,
        bool isRestricted,
        bool isOnlyPersonal,
        address secondarySource,
        uint256 secondaryId,
        uint256 minimumRequiredStake,
        uint256 jurisdictionFee
    ) {
        AttributeTypeInfo storage info = attributeTypeInfos[attributeTypeID];
        return (
            info.description,
            info.isRestricted,
            info.isOnlyPersonal,
            info.secondarySource,
            info.secondaryId,
            info.minimumRequiredStake,
            info.jurisdictionFee
        );
    }
}",44.04522657394409,getAttributeTypeDetails,19.0,0.6560076719499531,0.2644198632638797,"[{'function': 'getAttributeTypeDetails', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttributeTypeDetails is Ownable {
    struct AttributeTypeInfo {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }

    mapping(uint256 => AttributeTypeInfo) public attributeTypeInfos;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address secondarySource = address(uint160(i + 111e18));
            attributeTypeInfos[i] = AttributeTypeInfo({
                description: 'initialized',
                isRestricted: true,
                isOnlyPersonal: false,
                secondarySource: secondarySource,
                secondaryId: i * 100,
                minimumRequiredStake: 1,
                jurisdictionFee: 1
            });
        }
    }

    function getAttributeTypeDetails(uint256 attributeTypeID) external view returns (
        string memory description,
        bool isRestricted,
        bool isOnlyPersonal,
        address secondarySource,
        uint256 secondaryId,
        uint256 minimumRequiredStake,
        uint256 jurisdictionFee
    ) {
        AttributeTypeInfo storage info = attributeTypeInfos[attributeTypeID];
        return (
            info.description,
            info.isRestricted,
            info.isOnlyPersonal,
            info.secondarySource,
            info.secondaryId,
            info.minimumRequiredStake,
            info.jurisdictionFee
        );
    }
}"
2733,Set the stale period on the updated havven price,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public priceStalePeriod;

    function setPriceStalePeriod(uint time) external optionalProxy_onlyOwner {
        priceStalePeriod = time;
    }
}","[{'function': 'setPriceStalePeriod', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPriceStalePeriod"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""time"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""priceStalePeriod""}, ""right"": {""type"": ""Identifier"", ""name"": ""time""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PriceStalePeriodSetter {
    uint public priceStalePeriod;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor(uint initialPriceStalePeriod) {
        owner = msg.sender;
        priceStalePeriod = initialPriceStalePeriod;
    }

    function setPriceStalePeriod(uint time) public onlyOwner {
        priceStalePeriod = time;
    }
}",42.41413640975952,setPriceStalePeriod,0.0,0.9335675283720976,0.6703420896351792,"[{'function': 'setPriceStalePeriod', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceStalePeriodSetter is Ownable {
    uint public priceStalePeriod;

    constructor(uint initialPriceStalePeriod) Ownable(msg.sender) {
        priceStalePeriod = initialPriceStalePeriod;
    }

    function setPriceStalePeriod(uint time) public onlyOwner {
        priceStalePeriod = time;
    }
}"
1587,allows EtherToken to reclaim tokens wrongly sent to its address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/SafeMath.sol"";

interface IBasicToken {
    // Define the interface of the token contract here if needed
}

abstract contract Reclaimable is Ownable {
    using SafeMath for uint256;

    address public constant RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function reclaim(IBasicToken token) public onlyOwner {
        require(token != IBasicToken(RECLAIM_ETHER));
        Reclaimable.reclaim(token);
    }
}","[{'function': 'reclaim', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IBasicToken""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""reclaim""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IBasicToken {
    function reclaim() external;
}

contract Reclaimable {
    function reclaim(IBasicToken token) public {
        require(address(token) != address(0), ""Invalid token address"");
        token.reclaim();
    }
}",41.49452447891235,reclaim,7.0,0.890612478967157,0.3394828928639166,"[{'function': 'reclaim', 'complexity': 0}, {'function': 'reclaim', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IBasicToken {
    function reclaim() external;
}
import ""openzeppelin/SafeMath.sol"";
contract Reclaimable is Ownable, Reclaimable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
1004,"Used to reference a loan that is not yet created , and by that does not have an index","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentifierBuilder {
    using SafeMath for uint256;

    function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public view returns (bytes32) {
        return keccak256(abi.encodePacked(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}","[{'function': 'buildIdentifier', 'complexity': 0}]",1.0,{},,41.84495282173157,,45.0,0.1945209900887441,0.0,"{'function': '', 'complexity': 0}",,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract IdentifierBuilder is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public view returns (bytes32) {
        return keccak256(abi.encodePacked(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}"
6826,Returns the block number for when the channel was closed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        uint closed;
    }

    Data private data;

    function closed() public view returns (uint) {
        return data.closed;
    }
}","[{'function': 'closed', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""closed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""closed""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract DataContract {
    struct Data {
        bool closed;
        // other fields...
    }

    Data private data;

    constructor(bool _closed) {
        data.closed = _closed;
    }

    function closed() public view returns (bool) {
        return data.closed;
    }
}",45.21314191818237,closed,0.0,0.9613764575822822,0.7825422900366437,"[{'function': 'closed', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DataContract is Ownable {
    struct Data {
        bool closed;
        // other fields...
    }

    Data private data;

    constructor() Ownable(msg.sender) {
        data.closed = true;
    }

    function closed() public view returns (bool) {
        return data.closed;
    }
}"
4437,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value > 0, ""Invalid value"");
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","[{'function': 'approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",42.68885064125061,approve,15.0,0.7451851740915157,0.3930238879221665,"[{'function': 'approve', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            if (i == 1) allowed[address(0x111)][address(0x222)] = 1;
            else if (i == 2) allowed[address(0x222)][address(0x333)] = 1;
            else if (i == 3) allowed[address(0x333)][address(0x111)] = 1;
        }
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
2473,Finalize an upgrade process setting new asset implementation contract address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UpgradeHandler is Ownable {
    using SafeMath for uint256;

    uint256 public pendingVersion;
    uint256 public pendingVersionTimestamp;
    uint256 public constant UPGRADE_FREEZE_TIME = 7 days; // Example freeze time, adjust as needed
    uint256 public latestVersion;

    function commitUpgrade() public onlyOwner returns (bool) {
        if (pendingVersion == 0x0) {
            return false;
        }

        if (pendingVersionTimestamp.add(UPGRADE_FREEZE_TIME) > block.timestamp) {
            return false;
        }

        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;

        return true;
    }
}","[{'function': 'commitUpgrade', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeUpgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""pendingVersion""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""No pending version set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""pendingVersionTimestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""UPGRADE_FREEZE_TIME""}}}, {""type"": ""stringLiteral"", ""value"": ""Freeze period not passed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""latestVersion""}, ""right"": {""type"": ""Identifier"", ""name"": ""pendingVersion""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""pendingVersion""}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""pendingVersionTimestamp""}, ""isPrefix"": True}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ContractUpgrade {
    address public pendingVersion;
    uint256 public pendingVersionTimestamp;
    address public latestVersion;
    uint256 public constant UPGRADE_FREEZE_TIME = 7 days; // Example freeze time, adjust as needed

    function finalizeUpgrade() external returns (bool) {
        require(pendingVersion != address(0), ""No pending version set"");
        require(block.timestamp >= pendingVersionTimestamp + UPGRADE_FREEZE_TIME, ""Freeze period not passed"");

        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;

        return true;
    }
}",43.1836256980896,finalizeUpgrade,14.0,0.8055179465113763,0.2979883618320799,"[{'function': 'finalizeUpgrade', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ContractUpgrade is Ownable {
    address public pendingVersion;
    uint256 public pendingVersionTimestamp;
    address public latestVersion;
    uint256 public constant UPGRADE_FREEZE_TIME = 7 days; // Example freeze time, adjust as needed

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function finalizeUpgrade() external returns (bool) {
        require(pendingVersion != address(0), ""No pending version set"");
        require(block.timestamp >= pendingVersionTimestamp + UPGRADE_FREEZE_TIME, ""Freeze period not passed"");

        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;

        return true;
    }
}"
4258,Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","[{'function': 'approve', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",42.84917140007019,approve,8.0,0.876494388142539,0.6894081762825689,"[{'function': 'approve', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
3893,should be called off chain with as much gas as needed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface KyberReserveInterface {
    // Define the interface of the KyberReserve here if needed
}

abstract contract KyberReserveWrapper is Ownable {
    using SafeMath for uint256;

    KyberReserveInterface[] public reserves;

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}","[{'function': 'getReserves', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getReserves"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""KyberReserveInterface""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""reserves""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

interface KyberReserveInterface {
    // Define the interface of a Kyber reserve here if necessary
}

contract KyberExchange {
    KyberReserveInterface[] public reserves;

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}",41.802680253982544,getReserves,0.0,1.0,1.0,"[{'function': 'getReserves', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

interface KyberReserveInterface {
    // Define the interface of a Kyber reserve here if necessary
}
import ""openzeppelin/SafeMath.sol"";
contract KyberExchange is Ownable {
    KyberReserveInterface[] public reserves;
    uint256 public constant RESERVE_INDEX = 1;
    address public constant RESERVE_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        reserves[RESERVE_INDEX] = KyberReserveInterface(RESERVE_ADDRESS);
    }

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}"
3338,Exposes that this contract thinks it is an AffiliateProgram,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AffiliateProgramWrapper is Ownable {
    using SafeMath for uint256;

    function isAffiliateProgram() public pure returns (bool) {
    return true;
}
}","[{'function': 'isAffiliateProgram', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkAffiliateStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""isActive""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract AffiliateProgram {
    bool public isActive = true;

    function checkAffiliateStatus() external pure returns (bool) {
        return isActive;
    }
}",41.42274451255798,checkAffiliateStatus,1.0,0.912958108091848,0.5031747626530138,"[{'function': 'checkAffiliateStatus', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AffiliateProgram is Ownable {
    bool public isActive = true;

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already initialized with safe, non-corner-case values
    }

    function checkAffiliateStatus() external pure returns (bool) {
        return isActive;
    }
}"
812,Allow users to buy tokens for ` newRate ` x eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public tokensPerEther;

    function setPrices(uint256 newRate) public onlyOwner {
        tokensPerEther = newRate;
    }
}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensPerEther""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRate""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenContract is Ownable {
    uint256 public tokensPerEther;

    function setPrices(uint256 newRate) external onlyOwner {
        tokensPerEther = newRate;
    }
}",41.533934116363525,setPrices,0.0,0.97410354936029,0.7611606003349892,"[{'function': 'setPrices', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is Ownable {
    uint256 public tokensPerEther;

    constructor() Ownable(msg.sender) {
        tokensPerEther = 1; // Set to a non-zero, safe value
    }

    function setPrices(uint256 newRate) external onlyOwner {
        tokensPerEther = newRate;
    }
}"
714,Transfers ` amount ` from msg.sender to ` destination `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function balances(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address destination, uint256 amount) public tradable(msg.sender) returns (bool success) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);
        emit Transfer(msg.sender, destination, amount);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""destination"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""destination""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""destination""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""destination""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""destination""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""tradable"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenTransfer is AccessControl {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) private balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier tradable() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have trading privileges"");
        _;
    }

    constructor(address tokenAddress) {
        token = IERC20(tokenAddress);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function transferTokens(address destination, uint256 amount) public tradable returns (bool) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);

        emit Transfer(msg.sender, destination, amount);

        return token.transfer(destination, amount);
    }
}",45.12766075134277,transferTokens,7.0,0.9741684588414424,0.7871451340333823,"[{'function': 'transfer', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenTransfer is Ownable, AccessControl {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) private balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier tradable() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have trading privileges"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address tokenAddress) Ownable(msg.sender) {
        token = IERC20(tokenAddress);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        // Initialization of state variables
        balances[msg.sender] = 1000; // Safe initialization for uint256
    }

    function transferTokens(address destination, uint256 amount) public tradable returns (bool) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);

        emit Transfer(msg.sender, destination, amount);

        return token.transfer(destination, amount);
    }
}"
6517,Set ` _token_address ` as the token address to be used in the auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RaidenToken {
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

abstract contract Auction is Ownable {
    using SafeMath for uint256;

    enum Stages { NotDeployed, AuctionDeployed, AuctionSetUp, AuctionEnded }
    Stages public stage;

    RaidenToken public token;
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;

    event Setup();

    modifier atStage(Stages expectedStage) {
        require(stage == expectedStage, ""Auction: Invalid stage"");
        _;
    }

    function setup(address _token_address) public onlyOwner atStage(Stages.AuctionDeployed) {
        require(_token_address != address(0), ""Token address must be valid"");
        token = RaidenToken(_token_address);
        num_tokens_auctioned = token.balanceOf(address(this));
        token_multiplier = 10 ** uint256(token.decimals());
        stage = Stages.AuctionSetUp;
        emit Setup();
    }
}","[{'function': 'decimals', 'complexity': 0}, {'function': 'setup', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""RaidenToken""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RaidenToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""decimals"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}], ""names"": []}, ""memberName"": ""decimals""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenMultiplier""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""decimals""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""AuctionSetUp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Setup""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyValidToken"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface RaidenToken {
    function balanceOf(address owner) external view returns (uint256);
}

contract AuctionSetup {
    address public tokenAddress;
    uint256 public numTokensAuctioned;
    uint256 public tokenMultiplier;
    enum Stage { NotStarted, AuctionSetUp }
    Stage public stage = Stage.NotStarted;

    event Setup(address indexed tokenAddress, uint256 numTokensAuctioned);

    modifier onlyValidToken(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        _;
    }

    function setup(address _token_address) external onlyValidToken(_token_address) {
        RaidenToken token = RaidenToken(_token_address);
        uint256 balance = token.balanceOf(address(this));
        numTokensAuctioned = balance;

        // Calculate token multiplier based on the number of decimals
        uint8 decimals = ERC20(_token_address).decimals();
        tokenMultiplier = 10 ** decimals;

        // Update stage to indicate setup is complete
        stage = Stage.AuctionSetUp;

        // Emit Setup event
        emit Setup(_token_address, balance);
    }
}",44.43369483947754,setup,32.0,0.8720678714550462,0.2934085447475146,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'setup', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

interface RaidenToken {
    function balanceOf(address owner) external view returns (uint256);
}

interface ERC20 {
    function decimals() external view returns (uint8);
}
import ""openzeppelin/SafeMath.sol"";
contract AuctionSetup is Ownable {
    address public tokenAddress;
    uint256 public numTokensAuctioned;
    uint256 public tokenMultiplier;
    enum Stage { NotStarted, AuctionSetUp }
    Stage public stage = Stage.NotStarted;

    event Setup(address indexed tokenAddress, uint256 numTokensAuctioned);

    modifier onlyValidToken(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setup(address _token_address) external onlyValidToken(_token_address) {
        RaidenToken token = RaidenToken(_token_address);
        uint256 balance = token.balanceOf(address(this));
        numTokensAuctioned = balance;

        // Calculate token multiplier based on the number of decimals
        ERC20 erc20Token = ERC20(_token_address);
        uint8 decimals = erc20Token.decimals();
        tokenMultiplier = 10 ** decimals;

        // Update stage to indicate setup is complete
        stage = Stage.AuctionSetUp;

        // Emit Setup event
        emit Setup(_token_address, balance);
    }
}"
2209,"match orders with admins involved , only admin","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Matcher {
    using SafeMath for uint256;

    address public admin;
    mapping(uint256 => address) public userId2Address;
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;

    constructor() {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    function matchByAdmin_TwH36(uint256[] memory inputs) external onlyAdmin {
        uint256 data = inputs[3];
        address user = userId2Address[data & USER_MASK];
        require(data >> 224 > userNonce[user]);
        (address token, bool isBuy) = decodeOrderTokenAndIsBuy(data);
        bytes32 orderHash = keccak256(this, inputs[0], inputs[1], inputs[2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
        require(verify(orderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[4]), bytes32(inputs[5])));
        uint256 tokenExecute = isBuy ? inputs[1] : inputs[0];
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        require(tokenExecute != 0);
        uint256 etherExecute = 0;
        isBuy = !isBuy;
        for (uint256 i = 6; i < inputs.length; i += 6) {
            require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));
            data = inputs[i + 3];
            user = userId2Address[data & USER_MASK];
            require(data >> 224 > userNonce[user]);
            bytes32 makerOrderHash = keccak256(this, inputs[i], inputs[i + 1], inputs[i + 2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
            require(verify(makerOrderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 4]), bytes32(inputs[i + 5])));
            (tokenExecute, etherExecute) = internalTrade(inputs[i], inputs[i + 1], inputs[i + 2], data, tokenExecute, etherExecute, isBuy, token, 0, makerOrderHash);
        }
        isBuy = !isBuy;
        tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        processTakerOrder(inputs[2], inputs[3], tokenExecute, etherExecute, isBuy, token, 0, orderHash);
    }
}","[{'function': 'matchByAdmin_TwH36', 'complexity': 17}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""matchByAdmin_TwH36"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""inputs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid input length""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint160""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""providedNonce"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""providedNonce""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userNonce""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid nonce""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userNonce""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""Identifier"", ""name"": ""providedNonce""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""v"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113502660>}, {""type"": ""VariableDeclaration"", ""name"": ""r"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113502200>}, {""type"": ""VariableDeclaration"", ""name"": ""s"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1135038c0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""extractOrderDetails""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""inputs""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""makerAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ecrecover""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""orderHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""makerAddress""}, {""type"": ""Identifier"", ""name"": ""providedNonce""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""verify""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""orderHash""}, {""type"": ""Identifier"", ""name"": ""makerAddress""}, {""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Signature verification failed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountToFill"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amountToFill""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount to fill must be greater than zero""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract OrderMatcher {
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;
    address public tokenExecute;
    address public etherExecute;

    function matchByAdmin_TwH36(uint256[] memory inputs) external {
        require(inputs.length >= 10, ""Invalid input length"");

        // Extract user address and nonce from the first few elements in the inputs array
        address user = address(uint160(inputs[0]));
        uint256 providedNonce = inputs[1];
        require(providedNonce > userNonce[user], ""Invalid nonce"");

        // Update user nonce
        userNonce[user] = providedNonce;

        // Extract order details from the input data
        (uint8 v, bytes32 r, bytes32 s) = extractOrderDetails(inputs);
        address makerAddress = ecrecover(keccak256(abi.encodePacked(inputs[0], inputs[1])), v, r, s);

        // Generate order hash and check if the signature is valid
        bytes32 orderHash = keccak256(abi.encodePacked(makerAddress, providedNonce, inputs[2]));
        require(verify(orderHash, makerAddress, v, r, s), ""Signature verification failed"");

        // Calculate amount to be executed based on the order type (buy or sell)
        uint256 amountToFill = inputs[3];
        require(amountToFill > 0, ""Amount to fill must be greater than zero"");

        // Iterate over additional inputs to match orders
        for (uint256 i = 1; i < inputs.length; i++) {
            // Check if the current trade can proceed based on price comparison
            // Assuming some logic here to compare prices and ensure they are matchable
            // Update maker's nonce and verify their signature
            // Generate a maker order hash and execute internalTrade to perform token/ether exchange
        }

        // After all matches, process the taker order by calling processTakerOrder
    }

    function extractOrderDetails(uint256[] memory inputs) private pure returns (uint8 v, bytes32 r, bytes32 s) {
        return (uint8(inputs[4]), bytes32(inputs[5]), bytes32(inputs[6]));
    }

    function verify(bytes32 orderHash, address makerAddress, uint8 v, bytes32 r, bytes32 s) internal pure returns (bool) {
        return ecrecover(orderHash, v, r, s) == makerAddress;
    }

    function processTakerOrder() internal {
        // Implement the logic to process the taker order after all matches are completed
    }
}",49.04529333114624,matchByAdmin_TwH36,243.0,0.5303705123176898,0.116641420654114,"[{'function': 'matchByAdmin_TwH36', 'complexity': 5}, {'function': 'extractOrderDetails', 'complexity': 0}, {'function': 'verify', 'complexity': 0}, {'function': 'processTakerOrder', 'complexity': 0}]",8.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract OrderMatcher is Ownable {
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;
    address public tokenExecute = 0x1111111111111111111111111111111111111111; // fixed value for token execute
    address public etherExecute = 0x2222222222222222222222222222222222222222; // fixed value for ether execute

    constructor() Ownable(msg.sender) {
        require(tokenExecute != address(0), ""Token execute cannot be zero"");
        require(etherExecute != address(0), ""Ether execute cannot be zero"");

        userNonce[msg.sender] = 1;
        orderFills[bytes32('init')] = 1;

        // Initialize other state variables to fixed, safe values
        // For example:
        uint256[] memory inputs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    }

    function matchByAdmin_TwH36(uint256[] memory inputs) external {
        require(inputs.length >= 10, ""Invalid input length"");

        // Extract user address and nonce from the first few elements in the inputs array
        address user = address(uint160(inputs[0]));
        uint256 providedNonce = inputs[1];
        require(providedNonce > userNonce[user], ""Invalid nonce"");

        // Update user nonce
        userNonce[user] = providedNonce;

        // Extract order details from the input data
        (uint8 v, bytes32 r, bytes32 s) = extractOrderDetails(inputs);
        address makerAddress = ecrecover(keccak256(abi.encodePacked(inputs[0], inputs[1])), v, r, s);

        // Generate order hash and check if the signature is valid
        bytes32 orderHash = keccak256(abi.encodePacked(makerAddress, providedNonce, inputs[2]));
        require(verify(orderHash, makerAddress, v, r, s), ""Signature verification failed"");

        // Calculate amount to be executed based on the order type (buy or sell)
        uint256 amountToFill = inputs[3];
        require(amountToFill > 0, ""Amount to fill must be greater than zero"");

        // Iterate over additional inputs to match orders
        for (uint256 i = 1; i < inputs.length; i++) {
            // Check if the current trade can proceed based on price comparison
            // Assuming some logic here to compare prices and ensure they are matchable
            // Update maker's nonce and verify their signature
            // Generate a maker order hash and execute internalTrade to perform token/ether exchange
        }

        // After all matches, process the taker order by calling processTakerOrder
    }

    function extractOrderDetails(uint256[] memory inputs) private pure returns (uint8 v, bytes32 r, bytes32 s) {
        return (uint8(inputs[4]), bytes32(inputs[5]), bytes32(inputs[6]));
    }

    function verify(bytes32 orderHash, address makerAddress, uint8 v, bytes32 r, bytes32 s) internal pure returns (bool) {
        return ecrecover(orderHash, v, r, s) == makerAddress;
    }

    function processTakerOrder() internal {
        // Implement the logic to process the taker order after all matches are completed
    }
}"
5033,Returns the total number of Properties currently in existence .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PropertyRegistry is Ownable {
    using SafeMath for uint256;

    struct Property {
        // Define property structure here
    }

    Property[] public properties;

    function totalSupply() public view returns (uint) {
        return properties.length;
    }
}","[{'function': 'totalSupply', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""properties""}, ""memberName"": ""length""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract PropertyRegistry {
    struct Property {
        uint256 id;
        string name;
        address owner;
    }

    Property[] public properties;

    function totalSupply() external view returns (uint256) {
        return properties.length;
    }
}",41.38672828674317,totalSupply,0.0,0.9612928828803818,0.5333505353503044,"[{'function': 'totalSupply', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PropertyRegistry is Ownable {
    struct Property {
        uint256 id;
        string name;
        address owner;
    }

    Property[] public properties;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        properties = [
            Property({id: 1, name: ""Property 1"", owner: address(0x111)}),
            Property({id: 2, name: ""Property 2"", owner: address(0x222)})
        ];
    }

    function totalSupply() external view returns (uint256) {
        return properties.length;
    }
}"
2439,Grant ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionManager {
    using SafeMath for uint256;

    struct Permission {
        address entity;
        bytes32 role;
        bytes32 paramsHash;
    }

    mapping(address => mapping(address => mapping(bytes32 => Permission))) private permissions;
    bytes32 public constant EMPTY_PARAM_HASH = keccak256("""");

    address public owner;

    modifier onlyPermissionManager(address _app, bytes32 _role) {
        require(permissions[msg.sender][_app][_role].entity != address(0), ""Only permission manager can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] memory _params) public onlyPermissionManager(_app, _role) {
        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal pure returns (bytes32) {
        require(_params.length > 0, ""Params array must not be empty"");
        return keccak256(abi.encodePacked(_params));
    }

    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {
        permissions[_entity][_app][_role] = Permission({
            entity: _entity,
            role: _role,
            paramsHash: _paramsHash
        });
    }
}","[{'function': 'grantPermissionP', 'complexity': 1}, {'function': '_saveParams', 'complexity': 1}, {'function': '_setPermission', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_saveParams"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_params"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_params""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""hash""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_params""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}]}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_params""}], ""names"": []}], ""names"": []}], ""names"": []}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract PermissionManager {
    address public permissionManager;
    mapping(address => bool) public isPermissionManager;
    uint256 constant EMPTY_PARAM_HASH = 0x0;

    event PermissionSet(address indexed entity, address indexed app, bytes32 role, uint256 paramsHash);

    modifier onlyPermissionManager() {
        require(isPermissionManager[msg.sender], ""Only permission manager can call this function"");
        _;
    }

    function setPermissionManager(address _manager) external {
        isPermissionManager[_manager] = true;
    }

    function grantPermission(address _entity, address _app, bytes32 _role, uint256[] memory _params) external onlyPermissionManager {
        uint256 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal pure returns (uint256) {
        uint256 hash = 1; // Placeholder for actual hashing logic
        for (uint256 i = 0; i < _params.length; i++) {
            hash += _params[i];
        }
        return uint256(keccak256(abi.encodePacked(_params)));
    }

    function _setPermission(address _entity, address _app, bytes32 _role, uint256 _paramsHash) internal {
        emit PermissionSet(_entity, _app, _role, _paramsHash);
    }
}",45.782058238983154,_saveParams,30.0,0.6413470259059704,0.0267528944914513,"[{'function': 'setPermissionManager', 'complexity': 0}, {'function': 'grantPermission', 'complexity': 1}, {'function': '_saveParams', 'complexity': 1}, {'function': '_setPermission', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PermissionManager is Ownable {
    address public permissionManager;
    mapping(address => bool) public isPermissionManager;
    uint256 constant EMPTY_PARAM_HASH = 0x0;

    event PermissionSet(address indexed entity, address indexed app, bytes32 role, uint256 paramsHash);

    modifier onlyPermissionManager() {
        require(isPermissionManager[msg.sender], ""Only permission manager can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        permissionManager = msg.sender;
        isPermissionManager[msg.sender] = true;
    }

    function setPermissionManager(address _manager) external onlyOwner {
        isPermissionManager[_manager] = true;
    }

    function grantPermission(address _entity, address _app, bytes32 _role, uint256[] memory _params) external onlyPermissionManager {
        uint256 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal pure returns (uint256) {
        uint256 hash = 1; // Placeholder for actual hashing logic
        for (uint256 i = 0; i < _params.length; i++) {
            hash += _params[i];
        }
        return uint256(keccak256(abi.encodePacked(_params)));
    }

    function _setPermission(address _entity, address _app, bytes32 _role, uint256 _paramsHash) internal {
        emit PermissionSet(_entity, _app, _role, _paramsHash);
    }
}"
6671,Offer ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy for day ` aday ` at a price ` ( aprice / 1.0e3 ) .toFixed ( 3 ) + ' ct/kWh ' ` above market price for a date given as day ` aday ` whilst asserting that the current date and time in nanoseconds since 1970 is ` atimestamp ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface BidInterface {
    struct Bid {
        address producer;
        uint32 day;
        uint32 price;
        uint64 energy;
        uint64 timestamp;
    }
}

abstract contract EnergyMarket is Ownable, BidInterface {
    using SafeMath for uint256;

    uint public kWh = 1000; // Example value for kWh
    Bid[] public bids;
    mapping(address => mapping(uint32 => uint)) public bidsIndex;

    event BidMade(address indexed producer, uint32 day, uint price, uint energy);
    event BidRevoked(address indexed producer, uint32 day, uint price, uint energy);

    modifier onlyRegisteredProducers() {
        require(isProducerRegistered(msg.sender), ""Only registered producers can call this function"");
        _;
    }

    function offer_energy(uint32 aday, uint32 aprice, uint64 aenergy, uint64 atimestamp) onlyRegisteredProducers external {
        require(aenergy >= kWh);
        uint idx = bidsIndex[msg.sender][aday];
        if ((bids.length > idx) && (bids[idx].producer == msg.sender) && (bids[idx].day == aday)) {
            require(atimestamp > bids[idx].timestamp);
            emit BidRevoked(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
        }
        idx = bids.length;
        bidsIndex[msg.sender][aday] = idx;
        bids.push(Bid({producer: msg.sender, day: aday, price: aprice, energy: aenergy, timestamp: atimestamp}));
        emit BidMade(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
    }

    function isProducerRegistered(address producer) internal view returns (bool) {
        // Implement your logic to check if the producer is registered
        return true; // Placeholder for actual implementation
    }
}","[{'function': 'offer_energy', 'complexity': 3}, {'function': 'isProducerRegistered', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""offerEnergy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""aday"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""aprice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""aenergy"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""atimestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""aenergy""}, ""right"": {""type"": ""Identifier"", ""name"": ""MIN_ENERGY""}}, {""type"": ""stringLiteral"", ""value"": ""Energy amount must be greater than or equal to the minimum allowed (kWh)""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bidsIndex""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""aday""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bidsIndex""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""aday""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Bid""}, ""name"": ""existingBid"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""atimestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""existingBid""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""New timestamp must be later than the existing one""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BidRevoked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""existingBid""}, ""memberName"": ""producer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""existingBid""}, ""memberName"": ""day""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""existingBid""}, ""memberName"": ""price""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""existingBid""}, ""memberName"": ""energy""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""existingBid""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bidsIndex""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""aday""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Bid""}, ""name"": ""newBid"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Bid""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""aday""}, {""type"": ""Identifier"", ""name"": ""aprice""}, {""type"": ""Identifier"", ""name"": ""aenergy""}, {""type"": ""Identifier"", ""name"": ""atimestamp""}], ""names"": [""producer"", ""day"", ""price"", ""energy"", ""timestamp""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newBid""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BidMade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""aday""}, {""type"": ""Identifier"", ""name"": ""aprice""}, {""type"": ""Identifier"", ""name"": ""aenergy""}, {""type"": ""Identifier"", ""name"": ""atimestamp""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyProducer"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract EnergyBid {
    struct Bid {
        address producer;
        uint day;
        uint price;
        uint energy;
        uint timestamp;
    }

    mapping(address => mapping(uint => uint)) public bidsIndex;
    Bid[] public bids;
    uint public constant MIN_ENERGY = 100; // Example minimum allowed energy in kWh

    event BidMade(address indexed producer, uint day, uint price, uint energy, uint timestamp);
    event BidRevoked(address indexed producer, uint day, uint price, uint energy, uint timestamp);

    modifier onlyProducer() {
        require(msg.sender == tx.origin, ""Only producers can call this function"");
        _;
    }

    function offerEnergy(uint aday, uint aprice, uint aenergy, uint atimestamp) external onlyProducer {
        require(aenergy >= MIN_ENERGY, ""Energy amount must be greater than or equal to the minimum allowed (kWh)"");

        if (bidsIndex[msg.sender][aday] != 0) {
            // Check if there is an existing bid from the same producer for the same day
            uint index = bidsIndex[msg.sender][aday];
            Bid storage existingBid = bids[index];
            require(atimestamp > existingBid.timestamp, ""New timestamp must be later than the existing one"");

            // Revoke the existing bid by emitting a BidRevoked event
            emit BidRevoked(existingBid.producer, existingBid.day, existingBid.price, existingBid.energy, existingBid.timestamp);
        } else {
            // Update or create a new entry in the 'bids' array
            bidsIndex[msg.sender][aday] = bids.length + 1;
        }

        // Create a new bid and add it to the bids array
        Bid memory newBid = Bid({
            producer: msg.sender,
            day: aday,
            price: aprice,
            energy: aenergy,
            timestamp: atimestamp
        });
        bids.push(newBid);

        // Emit a BidMade event to log the creation of the new bid
        emit BidMade(msg.sender, aday, aprice, aenergy, atimestamp);
    }
}",47.38363599777222,offerEnergy,51.0,0.7423305189913532,0.2048323718820522,"[{'function': 'offerEnergy', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EnergyBid is Ownable {
    struct Bid {
        address producer;
        uint day;
        uint price;
        uint energy;
        uint timestamp;
    }

    mapping(address => mapping(uint => uint)) public bidsIndex;
    Bid[] public bids;
    uint public constant MIN_ENERGY = 100; // Example minimum allowed energy in kWh

    event BidMade(address indexed producer, uint day, uint price, uint energy, uint timestamp);
    event BidRevoked(address indexed producer, uint day, uint price, uint energy, uint timestamp);

    modifier onlyProducer() {
        require(msg.sender == tx.origin, ""Only producers can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        bids = [];
        MIN_ENERGY = 100;
    }

    function offerEnergy(uint aday, uint aprice, uint aenergy, uint atimestamp) external onlyProducer {
        require(aenergy >= MIN_ENERGY, ""Energy amount must be greater than or equal to the minimum allowed (kWh)"");

        if (bidsIndex[msg.sender][aday] != 0) {
            // Check if there is an existing bid from the same producer for the same day
            uint index = bidsIndex[msg.sender][aday];
            Bid storage existingBid = bids[index];
            require(atimestamp > existingBid.timestamp, ""New timestamp must be later than the existing one"");

            // Revoke the existing bid by emitting a BidRevoked event
            emit BidRevoked(existingBid.producer, existingBid.day, existingBid.price, existingBid.energy, existingBid.timestamp);
        } else {
            // Update or create a new entry in the 'bids' array
            bidsIndex[msg.sender][aday] = bids.length + 1;
        }

        // Create a new bid and add it to the bids array
        Bid memory newBid = Bid({
            producer: msg.sender,
            day: aday,
            price: aprice,
            energy: aenergy,
            timestamp: atimestamp
        });
        bids.push(newBid);

        // Emit a BidMade event to log the creation of the new bid
        emit BidMade(msg.sender, aday, aprice, aenergy, atimestamp);
    }
}"
4083,Calculates unpaid rewards of a given address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RewardCalculator {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] rewardsCumulative;
        mapping(address => uint) addressToPaidRewardIndex;
    }

    uint constant PIXEL_COUNT = 100; // Assuming PIXEL_COUNT is defined somewhere in your contract

    mapping(uint32 => FeeHistory) private feeHistories;

    function _getFeeHistory(uint32 _canvasId) internal view returns (FeeHistory storage) {
        return feeHistories[_canvasId];
    }

    function getPaintedPixelsCountByAddress(address _address, uint32 _canvasId) public view returns (uint);

    function calculateRewardToWithdraw(uint32 _canvasId, address _address) public view stateOwned(_canvasId) returns (uint reward, uint pixelsOwned) {
        FeeHistory storage _history = _getFeeHistory(_canvasId);
        uint _lastIndex = _history.rewardsCumulative.length - 1;
        uint _lastPaidIndex = _history.addressToPaidRewardIndex[_address];
        uint _pixelsOwned = getPaintedPixelsCountByAddress(_address, _canvasId);
        if (_lastIndex < 0) {
            return (0, _pixelsOwned);
        }
        uint _rewardsSum = _history.rewardsCumulative[_lastIndex];
        uint _lastWithdrawn = _history.rewardsCumulative[_lastPaidIndex];
        uint _toWithdraw = ((_rewardsSum - _lastWithdrawn) / PIXEL_COUNT) * _pixelsOwned;
        return (_toWithdraw, _pixelsOwned);
    }
}","[{'function': '_getFeeHistory', 'complexity': 0}, {'function': 'getPaintedPixelsCountByAddress', 'complexity': 0}, {'function': 'calculateRewardToWithdraw', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""pixelsOwned"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_lastIndex""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_canvasId""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_canvasId""}, {""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""FeeHistory""}, ""name"": ""history"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""feeHistories""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastCumulativeReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""history""}, ""memberName"": ""rewardsCumulative""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""history""}, ""memberName"": ""rewardsCumulative""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastPaidIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_lastPaidIndex""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_canvasId""}, {""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPaidIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_canvasId""}, {""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""rewardPerPixel"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""history""}, ""memberName"": ""rewardsCumulative""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""history""}, ""memberName"": ""rewardsCumulative""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""history""}, ""memberName"": ""rewardsCumulative""}, ""index"": {""type"": ""Identifier"", ""name"": ""lastPaidIndex""}}}], ""isArray"": False}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_canvasId""}, {""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_canvasId""}, {""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""rewardPerPixel""}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_pixelsOwned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_canvasId""}, {""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CanvasRewardCalculator {
    struct FeeHistory {
        uint[] rewardsCumulative;
    }

    mapping(uint => FeeHistory) private feeHistories;

    function calculateReward(uint _canvasId, address _address) public view returns (uint reward, uint pixelsOwned) {
        if (_lastIndex(_canvasId) < 0) {
            return (0, _pixelsOwned(_canvasId, _address));
        }

        FeeHistory storage history = feeHistories[_canvasId];
        uint lastCumulativeReward = history.rewardsCumulative[uint(history.rewardsCumulative.length - 1)];
        uint lastPaidIndex = _lastPaidIndex(_canvasId, _address);
        if (lastPaidIndex == 0) {
            return (0, _pixelsOwned(_canvasId, _address));
        }

        uint rewardPerPixel = (history.rewardsCumulative[uint(history.rewardsCumulative.length - 1)] - history.rewardsCumulative[lastPaidIndex]) / _pixelsOwned(_canvasId, _address);
        return (_pixelsOwned(_canvasId, _address) * rewardPerPixel, _pixelsOwned(_canvasId, _address));
    }

    function _lastIndex(uint _canvasId) internal view returns (int) {
        FeeHistory storage history = feeHistories[_canvasId];
        return history.rewardsCumulative.length > 0 ? int(history.rewardsCumulative.length - 1) : -1;
    }

    function _lastPaidIndex(uint _canvasId, address _address) internal view returns (uint) {
        // Assuming some logic to get the last paid index based on _address and _canvasId
        return 0; // Placeholder implementation
    }

    function _pixelsOwned(uint _canvasId, address _address) internal view returns (uint) {
        // Assuming some logic to get the number of pixels owned by _address on _canvasId
        return 0; // Placeholder implementation
    }
}",47.10785937309265,calculateReward,44.0,0.8118953726541478,0.2677327224620112,"[{'function': 'calculateReward', 'complexity': 2}, {'function': '_lastIndex', 'complexity': 1}, {'function': '_lastPaidIndex', 'complexity': 0}, {'function': '_pixelsOwned', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CanvasRewardCalculator is Ownable {
    struct FeeHistory {
        uint[] rewardsCumulative;
    }

    mapping(uint => FeeHistory) private feeHistories;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            feeHistories[i] = FeeHistory({rewardsCumulative: [1]}); // Set to fixed safe value
        }
    }

    function calculateReward(uint _canvasId, address _address) public view returns (uint reward, uint pixelsOwned) {
        if (_lastIndex(_canvasId) < 0) {
            return (0, _pixelsOwned(_canvasId, _address));
        }

        FeeHistory storage history = feeHistories[_canvasId];
        uint lastCumulativeReward = history.rewardsCumulative[uint(history.rewardsCumulative.length - 1)];
        uint lastPaidIndex = _lastPaidIndex(_canvasId, _address);
        if (lastPaidIndex == 0) {
            return (0, _pixelsOwned(_canvasId, _address));
        }

        uint rewardPerPixel = (history.rewardsCumulative[uint(history.rewardsCumulative.length - 1)] - history.rewardsCumulative[lastPaidIndex]) / _pixelsOwned(_canvasId, _address);
        return (_pixelsOwned(_canvasId, _address) * rewardPerPixel, _pixelsOwned(_canvasId, _address));
    }

    function _lastIndex(uint _canvasId) internal view returns (int) {
        FeeHistory storage history = feeHistories[_canvasId];
        return history.rewardsCumulative.length > 0 ? int(history.rewardsCumulative.length - 1) : -1;
    }

    function _lastPaidIndex(uint _canvasId, address _address) internal view returns (uint) {
        // Assuming some logic to get the last paid index based on _address and _canvasId
        return 0; // Placeholder implementation
    }

    function _pixelsOwned(uint _canvasId, address _address) internal view returns (uint) {
        // Assuming some logic to get the number of pixels owned by _address on _canvasId
        return 0; // Placeholder implementation
    }
}"
6519,ERC20 transfer function overridden to disable transfers when paused,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    modifier notPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _value) public notPaused {
        super.transfer(_to, _value);
    }
}","[{'function': 'transfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""notPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is ERC20, Ownable {
    modifier notPaused() {
        require(!paused(), ""Contract is paused"");
        _;
    }

    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function transferToken(address _to, uint256 _value) public notPaused returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Amount must be greater than zero"");

        _transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value);

        return true;
    }
}",43.76642537117005,transferToken,28.0,0.5409387053370646,0.1786069868578312,"[{'function': 'transferToken', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is ERC20, Ownable {
    modifier notPaused() {
        require(!paused(), ""Contract is paused"");
        _;
    }

    constructor(string memory name, string memory symbol) ERC20(name, symbol) Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialSupply = 1 ether; // Using a placeholder value for ERC20 initialization
        _mint(msg.sender, initialSupply); // Mint tokens to the contract owner
    }

    function transferToken(address _to, uint256 _value) public notPaused returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Amount must be greater than zero"");

        _transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value);

        return true;
    }
}"
5444,"Set a new campaign owner Based on the Campaign id , update the owner of the refered campaign .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CampaignManager is Ownable {
    using SafeMath for uint256;

    struct Campaign {
        address owner;
        // other campaign details...
    }

    mapping(bytes32 => Campaign) public campaigns;

    event CampaignUpdated(bytes32 indexed bidId, address newOwner);

    modifier onlyIfCampaignExists(bytes32 bidId) {
        require(campaigns[bidId].owner != address(0), ""Campaign does not exist"");
        _;
    }

    modifier onlyIfWhitelisted(address user) {
        // Assuming whitelist is managed elsewhere, implement as needed.
        require(isWhitelisted(user), ""User is not whitelisted"");
        _;
    }

    function setCampaignOwnerById(bytes32 bidId, address newOwner) public onlyIfCampaignExists(bidId) onlyIfWhitelisted(newOwner) {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }

    function isWhitelisted(address user) internal view returns (bool) {
        // Implement whitelist logic here.
        return true; // Placeholder for actual implementation.
    }
}","[{'function': 'setCampaignOwnerById', 'complexity': 0}, {'function': 'isWhitelisted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateCampaignOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwner""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""bidId""}, {""type"": ""Identifier"", ""name"": ""newOwner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyIfWhitelisted"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyIfCampaignExists"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""bidId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract CampaignManager {
    struct Campaign {
        bool exists;
        address owner;
    }

    mapping(bytes32 => Campaign) public campaigns;
    mapping(address => bool) public whitelist;

    event CampaignUpdated(bytes32 indexed bidId, address indexed newOwner);

    modifier onlyIfWhitelisted() {
        require(whitelist[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    modifier onlyIfCampaignExists(bytes32 bidId) {
        require(campaigns[bidId].exists, ""Campaign does not exist"");
        _;
    }

    function addToWhitelist(address user) public {
        whitelist[user] = true;
    }

    function updateCampaignOwner(bytes32 bidId, address newOwner) public onlyIfWhitelisted onlyIfCampaignExists(bidId) {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }
}",44.059781312942505,updateCampaignOwner,1.0,0.9043322953017272,0.7273648160801438,"[{'function': 'addToWhitelist', 'complexity': 0}, {'function': 'updateCampaignOwner', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CampaignManager is Ownable {
    struct Campaign {
        bool exists;
        address owner;
    }

    mapping(bytes32 => Campaign) public campaigns;
    mapping(address => bool) public whitelist;

    event CampaignUpdated(bytes32 indexed bidId, address indexed newOwner);

    modifier onlyIfWhitelisted() {
        require(whitelist[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    modifier onlyIfCampaignExists(bytes32 bidId) {
        require(campaigns[bidId].exists, ""Campaign does not exist"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        whitelist[address(0x111)] = true;
        whitelist[address(0x222)] = true;
        whitelist[address(0x333)] = true;
    }

    function addToWhitelist(address user) public {
        whitelist[user] = true;
    }

    function updateCampaignOwner(bytes32 bidId, address newOwner) public onlyIfWhitelisted onlyIfCampaignExists(bidId) {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }
}"
2581,Checks if the makeOrder price is reasonable and not manipulative,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TakePermitWrapper {
    using SafeMath for uint256;

    function isTakePermitted(uint orderPrice, uint referencePrice, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (bool) {
        return true;
    }
}","[{'function': 'isTakePermitted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isTakeOrderPermitted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""orderPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""referencePrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sellAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""buyAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""sellQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""buyQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract TakeOrderPermission {
    function isTakeOrderPermitted(
        uint orderPrice,
        uint referencePrice,
        address sellAsset,
        address buyAsset,
        uint sellQuantity,
        uint buyQuantity
    ) public pure returns (bool) {
        return true;
    }
}",41.78367352485657,isTakeOrderPermitted,0.0,0.9566924926125518,0.852101976447847,"[{'function': 'isTakeOrderPermitted', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TakeOrderPermission is Ownable {
    uint public constant MIN_ORDER_PRICE = 1;
    uint public constant MIN_REFERENCE_PRICE = 1;
    address public constant SELL_ASSET = address(0x111);
    address public constant BUY_ASSET = address(0x222);
    uint public constant SELL_QUANTITY = 1;
    uint public constant BUY_QUANTITY = 1;
    bytes32 public constant INITIALIZED = keccak256('init');

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already set in the constructor
    }

    function isTakeOrderPermitted(
        uint orderPrice,
        uint referencePrice,
        address sellAsset,
        address buyAsset,
        uint sellQuantity,
        uint buyQuantity
    ) public pure returns (bool) {
        require(orderPrice >= MIN_ORDER_PRICE, ""Order price must be at least 1"");
        require(referencePrice >= MIN_REFERENCE_PRICE, ""Reference price must be at least 1"");
        require(sellAsset == SELL_ASSET, ""Invalid sell asset"");
        require(buyAsset == BUY_ASSET, ""Invalid buy asset"");
        require(sellQuantity == SELL_QUANTITY, ""Invalid sell quantity"");
        require(buyQuantity == BUY_QUANTITY, ""Invalid buy quantity"");
        return true;
    }
}"
4669,Transfer a LAND owned by an Estate to a new owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LandRegistry is Ownable {
    using SafeMath for uint256;

    struct Estate {
        address owner;
        mapping(uint256 => address) lands;
    }

    mapping(uint256 => Estate) public estates;

    modifier canTransfer(uint256 estateId) {
        require(msg.sender == estates[estateId].owner, ""Not the owner"");
        _;
    }

    function _transferLand(uint256 estateId, uint256 landId, address destinatary) internal returns (bool) {
        require(destinatary != address(0), ""Invalid recipient"");
        estates[estateId].lands[landId] = destinatary;
        return true;
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) external canTransfer(estateId) {
        _transferLand(estateId, landId, destinatary);
    }
}","[{'function': '_transferLand', 'complexity': 1}, {'function': 'transferLand', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transferLand"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""estateId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""landId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""destinatary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Land""}, ""name"": ""land"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""estates""}, ""index"": {""type"": ""Identifier"", ""name"": ""estateId""}}, ""index"": {""type"": ""Identifier"", ""name"": ""landId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedTransferrers""}, ""index"": {""type"": ""Identifier"", ""name"": ""estateId""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Only the current owner or authorized transferrer can transfer this land""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""previousOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""owner""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""destinatary""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LandTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""estateId""}, {""type"": ""Identifier"", ""name"": ""landId""}, {""type"": ""Identifier"", ""name"": ""previousOwner""}, {""type"": ""Identifier"", ""name"": ""destinatary""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract EstateManagement {
    struct Land {
        address owner;
    }

    mapping(uint256 => mapping(uint256 => Land)) public estates;
    mapping(uint256 => address) public authorizedTransferrers;

    event LandTransferred(uint256 estateId, uint256 landId, address indexed previousOwner, address indexed newOwner, bytes32 transactionHash);

    modifier canTransfer(uint256 estateId) {
        require(authorizedTransferrers[estateId] == msg.sender || estates[estateId][0].owner == msg.sender, ""Not authorized to transfer land in this estate"");
        _;
    }

    function setAuthorizedTransferrer(uint256 estateId, address transferrer) public {
        require(estates[estateId][0].owner == msg.sender || estates[estateId][0].owner == address(this), ""Only the owner or contract can authorize a transferrer"");
        authorizedTransferrers[estateId] = transferrer;
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) external {
        require(_transferLand(estateId, landId, destinatary), ""Transfer failed"");
    }

    function _transferLand(uint256 estateId, uint256 landId, address destinatary) internal returns (bool) {
        Land storage land = estates[estateId][landId];
        require(land.owner == msg.sender || authorizedTransferrers[estateId] == msg.sender, ""Only the current owner or authorized transferrer can transfer this land"");

        address previousOwner = land.owner;
        land.owner = destinatary;

        emit LandTransferred(estateId, landId, previousOwner, destinatary, keccak256(abi.encodePacked(msg.sender, block.timestamp)));
        return true;
    }
}",46.55716466903687,_transferLand,43.0,0.5946110276371341,0.269099669272782,"[{'function': 'setAuthorizedTransferrer', 'complexity': 2}, {'function': 'transferLand', 'complexity': 1}, {'function': '_transferLand', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EstateManagement is Ownable {
    struct Land {
        address owner;
    }

    mapping(uint256 => mapping(uint256 => Land)) public estates;
    mapping(uint256 => address) public authorizedTransferrers;

    event LandTransferred(uint256 estateId, uint256 landId, address indexed previousOwner, address indexed newOwner, bytes32 transactionHash);

    modifier canTransfer(uint256 estateId) {
        require(authorizedTransferrers[estateId] == msg.sender || estates[estateId][0].owner == msg.sender, ""Not authorized to transfer land in this estate"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            authorizedTransferrers[i] = address(uint160(uint256(keccak256(abi.encodePacked(""transferrer"", i)))));
        }
    }

    function setAuthorizedTransferrer(uint256 estateId, address transferrer) public {
        require(estates[estateId][0].owner == msg.sender || estates[estateId][0].owner == address(this), ""Only the owner or contract can authorize a transferrer"");
        authorizedTransferrers[estateId] = transferrer;
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) external {
        require(_transferLand(estateId, landId, destinatary), ""Transfer failed"");
    }

    function _transferLand(uint256 estateId, uint256 landId, address destinatary) internal returns (bool) {
        Land storage land = estates[estateId][landId];
        require(land.owner == msg.sender || authorizedTransferrers[estateId] == msg.sender, ""Only the current owner or authorized transferrer can transfer this land"");

        address previousOwner = land.owner;
        land.owner = destinatary;

        emit LandTransferred(estateId, landId, previousOwner, destinatary, keccak256(abi.encodePacked(msg.sender, block.timestamp)));
        return true;
    }
}"
689,Set both ethPreAmount and mtdPreAmount at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) external onlyOwner {
        require(mtdPreAmountInWei > 0);
        require(ethPreAmountInWei > 0);
        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices logic
    }
}","[{'function': 'setPreAmounts', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreAmounts"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mtdPreAmountInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ethPreAmountInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mtdPreAmountInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""MTD pre-amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""ethPreAmountInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ETH pre-amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""mtdPreAmountInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""ethPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""ethPreAmountInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address private owner;
    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) public onlyOwner {
        require(mtdPreAmountInWei > 0, ""MTD pre-amount must be greater than zero"");
        require(ethPreAmountInWei > 0, ""ETH pre-amount must be greater than zero"");

        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;

        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices logic, if needed.
    }
}",43.60969161987305,setPreAmounts,2.0,0.9748363238260792,0.5761036007036797,"[{'function': 'setPreAmounts', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Caller is not the owner"");
        _;
    }

    constructor() Ownable(msg.sender) {
        mtdPreAmount = 1;
        ethPreAmount = 2;
    }

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) public onlyOwner {
        require(mtdPreAmountInWei > 0, ""MTD pre-amount must be greater than zero"");
        require(ethPreAmountInWei > 0, ""ETH pre-amount must be greater than zero"");

        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;

        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices logic, if needed.
    }
}"
4185,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract Collectible is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public collectibleIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender;
    }
}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owns""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller does not own this collectible""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectibleIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Collectible {
    // Mapping to keep track of approved addresses for each collectible token
    mapping(uint256 => address) public collectibleIndexToApproved;

    // Function to check if the caller owns a specific collectible
    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender; // Simplified ownership check for demonstration purposes
    }

    // Function to approve another address to transfer a specific collectible on behalf of the caller
    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId), ""Caller does not own this collectible"");
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    // Event triggered when an approval status changes for a specific collectible
    event Approval(address indexed owner, address approved, uint256 tokenId);
}",43.780739068984985,approve,1.0,0.9907758717182872,0.7884896239035346,"[{'function': '_owns', 'complexity': 0}, {'function': 'approve', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Collectible is Ownable {
    // Mapping to keep track of approved addresses for each collectible token
    mapping(uint256 => address) public collectibleIndexToApproved;

    // Function to check if the caller owns a specific collectible
    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender; // Simplified ownership check for demonstration purposes
    }

    // Function to approve another address to transfer a specific collectible on behalf of the caller
    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId), ""Caller does not own this collectible"");
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    // Event triggered when an approval status changes for a specific collectible
    event Approval(address indexed owner, address approved, uint256 tokenId);
}"
6513,"Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface tokenltkrecipiente {
    function approve(address _spender, uint256 _value) external returns (bool success);
    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        tokenltkrecipiente spender = tokenltkrecipiente(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    function approve(address _spender, uint256 _value) internal returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Value must be greater than zero"");
        return tokenltkrecipiente(_spender).approve(_spender, _value);
    }
}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_extraData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApproveAndCallFallBack""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}, ""memberName"": ""receiveApproval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_extraData""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address tokenContract, bytes memory extraData) external;
}

contract Token {
    mapping(address => mapping(address => uint256)) public allowance;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approval failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function approve(address spender, uint256 amount) internal returns (bool success) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
}",44.63782048225403,approveAndCall,19.0,0.919253147006838,0.6074924928536048,"[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'approve', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address tokenContract, bytes memory extraData) external;
}
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowance;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approval failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function approve(address spender, uint256 amount) internal returns (bool success) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
}"
5584,Function that allows synth contract to delegate sending fee to the fee Pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISynth {
    function burn(address from, uint amount) external;
    function issue(address to, uint amount) external;
    function triggerTokenFallbackIfNeeded(address from, address to, uint amount) external;
}

interface IFeePool {
    function FEE_ADDRESS() external view returns (address);
    function amountReceivedFromExchange(uint amount) external pure returns (uint);
}

abstract contract ExchangeWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes4 => ISynth) public synths;
    IFeePool public feePool;
    address public proxy;

    constructor(address _feePool, address _proxy) {
        feePool = IFeePool(_feePool);
        proxy = _proxy;
    }

    function _internalExchange(
        address from,
        bytes4 sourceCurrencyKey,
        uint sourceAmount,
        bytes4 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal returns (bool) {
        require(destinationAddress != address(0), ""Zero destination"");
        require(destinationAddress != address(this), ""Synthetix is invalid destination"");
        require(destinationAddress != proxy, ""Proxy is invalid destination"");
        synths[sourceCurrencyKey].burn(from, sourceAmount);
        uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);
        uint amountReceived = destinationAmount;
        uint fee = 0;
        if (chargeFee) {
            amountReceived = feePool.amountReceivedFromExchange(destinationAmount);
            fee = destinationAmount.sub(amountReceived);
        }
        synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);
        if (fee > 0) {
            uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, ""XDR"");
            synths[""XDR""].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);
        }
        synths[destinationCurrencyKey].triggerTokenFallbackIfNeeded(from, destinationAddress, amountReceived);
        return true;
    }

    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey) internal view returns (uint) {
        // Implement the logic to calculate effective value based on currency keys and amounts
        // This is a placeholder for actual implementation details
        return sourceAmount;
    }
}","[{'function': 'triggerTokenFallbackIfNeeded', 'complexity': 0}, {'function': 'amountReceivedFromExchange', 'complexity': 0}, {'function': '_internalExchange', 'complexity': 0}, {'function': 'effectiveValue', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""exchangeSynths"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""sourceCurrencyKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sourceAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""destinationCurrencyKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""destinationAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""chargeFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""destinationAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid destination address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""sourceCurrencyKey""}}, ""right"": {""type"": ""Identifier"", ""name"": ""sourceAmount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SynthBurned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""sourceCurrencyKey""}, {""type"": ""Identifier"", ""name"": ""sourceAmount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""exchangeRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getExchangeRate""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""destinationCurrencyKey""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountReceived"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""sourceAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""exchangeRate""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""chargeFee""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""amountReceived""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""amountReceived""}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""feePoolAddress""}}, ""index"": {""type"": ""Identifier"", ""name"": ""XDRKey""}}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SynthIssued""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""feePoolAddress""}, {""type"": ""Identifier"", ""name"": ""XDRKey""}, {""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""destinationAddress""}}, ""index"": {""type"": ""Identifier"", ""name"": ""destinationCurrencyKey""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amountReceived""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SynthIssued""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""destinationAddress""}, {""type"": ""Identifier"", ""name"": ""destinationCurrencyKey""}, {""type"": ""Identifier"", ""name"": ""amountReceived""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ExchangeSynths {
    // Mapping to store balances of each synth for each user
    mapping(address => mapping(bytes32 => uint256)) public balanceOf;

    // Event triggered when a synth is burned
    event SynthBurned(address indexed from, bytes32 currencyKey, uint256 amount);

    // Event triggered when a synth is issued to an address
    event SynthIssued(address indexed to, bytes32 currencyKey, uint256 amount);

    // Function to exchange one synth for another
    function exchangeSynths(
        address from,
        bytes32 sourceCurrencyKey,
        uint256 sourceAmount,
        bytes32 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal {
        require(destinationAddress != address(0), ""Invalid destination address"");

        // Burn the source synth from the sender's balance
        balanceOf[from][sourceCurrencyKey] -= sourceAmount;
        emit SynthBurned(from, sourceCurrencyKey, sourceAmount);

        // Calculate the effective value of the source amount in terms of the destination currency
        uint256 exchangeRate = getExchangeRate(destinationCurrencyKey);
        uint256 amountReceived = (sourceAmount * exchangeRate) / 1e18;

        if (chargeFee) {
            // Calculate and subtract the fee from the received amount
            uint256 fee = (amountReceived * 10) / 100; // Assuming a 10% fee for example
            amountReceived -= fee;

            // Optionally issue the fee in XDRs to the fee pool's designated address
            balanceOf[feePoolAddress][XDRKey] += fee;
            emit SynthIssued(feePoolAddress, XDRKey, fee);
        }

        // Issue the calculated amountReceived to the destination address
        balanceOf[destinationAddress][destinationCurrencyKey] += amountReceived;
        emit SynthIssued(destinationAddress, destinationCurrencyKey, amountReceived);
    }

    // Function to get the exchange rate for a given currency key (example implementation)
    function getExchangeRate(bytes32 currencyKey) internal view returns (uint256) {
        // Placeholder logic: replace with actual exchange rate calculation
        return 1e18; // Assuming 1:1 exchange rate for simplicity
    }

    // Address of the fee pool and XDR currency key (example values)
    address public feePoolAddress = 0xFeePoolAddress;
    bytes32 public constant XDRKey = ""XDR"";
}",48.65485787391663,exchangeSynths,42.0,0.775658518855022,0.2214192645759402,"[{'function': 'exchangeSynths', 'complexity': 0}, {'function': 'getExchangeRate', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ExchangeSynths is Ownable {
    // Mapping to store balances of each synth for each user
    mapping(address => mapping(bytes32 => uint256)) public balanceOf;

    // Event triggered when a synth is burned
    event SynthBurned(address indexed from, bytes32 currencyKey, uint256 amount);

    // Event triggered when a synth is issued to an address
    event SynthIssued(address indexed to, bytes32 currencyKey, uint256 amount);

    // Constructor initializes the contract with fixed values
    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        balanceOf[msg.sender][bytes32('ETH')] = 1;
        balanceOf[msg.sender][bytes32('BTC')] = 1;
        balanceOf[msg.sender][bytes32('XDR')] = 1;
    }

    // Function to exchange one synth for another
    function exchangeSynths(
        address from,
        bytes32 sourceCurrencyKey,
        uint256 sourceAmount,
        bytes32 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal {
        require(destinationAddress != address(0), ""Invalid destination address"");

        // Burn the source synth from the sender's balance
        balanceOf[from][sourceCurrencyKey] -= sourceAmount;
        emit SynthBurned(from, sourceCurrencyKey, sourceAmount);

        // Calculate the effective value of the source amount in terms of the destination currency
        uint256 exchangeRate = getExchangeRate(destinationCurrencyKey);
        uint256 amountReceived = (sourceAmount * exchangeRate) / 1e18;

        if (chargeFee) {
            // Calculate and subtract the fee from the received amount
            uint256 fee = (amountReceived * 10) / 100; // Assuming a 10% fee for example
            amountReceived -= fee;

            // Optionally issue the fee in XDRs to the fee pool's designated address
            balanceOf[feePoolAddress][XDRKey] += fee;
            emit SynthIssued(feePoolAddress, XDRKey, fee);
        }

        // Issue the calculated amountReceived to the destination address
        balanceOf[destinationAddress][destinationCurrencyKey] += amountReceived;
        emit SynthIssued(destinationAddress, destinationCurrencyKey, amountReceived);
    }

    // Function to get the exchange rate for a given currency key (example implementation)
    function getExchangeRate(bytes32 currencyKey) internal view returns (uint256) {
        // Placeholder logic: replace with actual exchange rate calculation
        return 1e18; // Assuming 1:1 exchange rate for simplicity
    }

    // Address of the fee pool and XDR currency key (example values)
    address public feePoolAddress = 0xFeePoolAddress;
    bytes32 public constant XDRKey = ""XDR"";
}"
4746,"Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onApprove(address _owner, address _spender, uint256 _amount) public returns (bool) {
        if (isRegistered(_owner)) {
            return true;
        } else {
            return false;
        }
    }

    function isRegistered(address _owner) internal view returns (bool) {
        // Implement the logic to check if the owner is registered
        revert(""Not implemented"");
    }
}","[{'function': 'onApprove', 'complexity': 1}, {'function': 'isRegistered', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""onApprove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isOwnerRegistered"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""isOwnerRegistered""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TokenApproval {
    function onApprove(address _owner, address _spender, uint256 _amount) external view returns (bool) {
        require(_owner != address(0), ""Invalid owner address"");
        require(_spender != address(0), ""Invalid spender address"");

        // Assuming isRegistered function exists and checks if the owner is registered
        bool isOwnerRegistered = isRegistered(_owner);

        return isOwnerRegistered;
    }

    function isRegistered(address _owner) internal view returns (bool) {
        // Placeholder for actual registration logic
        // This should be implemented based on the specific requirements of your application
        // For example, you might have a mapping or storage to track registered addresses
        return true; // Simplified assumption for demonstration
    }
}",43.36335158348084,onApprove,23.0,0.7715297552194721,0.2487407147939925,"[{'function': 'onApprove', 'complexity': 2}, {'function': 'isRegistered', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    function onApprove(address _owner, address _spender, uint256 _amount) external view returns (bool) {
        require(_owner != address(0), ""Invalid owner address"");
        require(_spender != address(0), ""Invalid spender address"");

        bool isOwnerRegistered = isRegistered(_owner);

        return isOwnerRegistered;
    }

    function isRegistered(address _owner) internal view returns (bool) {
        // Placeholder for actual registration logic
        // This should be implemented based on the specific requirements of your application
        // For example, you might have a mapping or storage to track registered addresses
        return true; // Simplified assumption for demonstration
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
5679,Sets the new dividend percentage for buyouts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContract {
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public buyoutDividendPercentage;

    constructor(uint256 initialBuyoutDividendPercentage) {
        require(2000 <= initialBuyoutDividendPercentage && initialBuyoutDividendPercentage <= 12500);
        buyoutDividendPercentage = initialBuyoutDividendPercentage;
    }
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
    require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500);
    buyoutDividendPercentage = _buyoutDividendPercentage;
}
}","[{'function': 'setBuyoutDividendPercentage', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBuyoutDividendPercentage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_buyoutDividendPercentage"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_buyoutDividendPercentage""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2000"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_buyoutDividendPercentage""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""12500"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid percentage""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyoutDividendPercentage""}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyoutDividendPercentage""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCFO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract BuyoutDividend {
    uint256 public buyoutDividendPercentage;
    address public cfo;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only CFO can call this function"");
        _;
    }

    constructor(address _cfo) {
        cfo = _cfo;
    }

    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
        require(_buyoutDividendPercentage >= 2000 && _buyoutDividendPercentage <= 12500, ""Invalid percentage"");
        buyoutDividendPercentage = _buyoutDividendPercentage;
    }
}",42.76817178726196,setBuyoutDividendPercentage,3.0,0.9605640699275134,0.6485539682067227,"[{'function': 'setBuyoutDividendPercentage', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract BuyoutDividend {
    uint256 public buyoutDividendPercentage;
    address public cfo;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only CFO can call this function"");
        _;
    }

    constructor(address _cfo) {
        cfo = _cfo;
        buyoutDividendPercentage = 1; // Set to a safe non-zero value
    }

    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
        require(_buyoutDividendPercentage >= 2000 && _buyoutDividendPercentage <= 12500, ""Invalid percentage"");
        buyoutDividendPercentage = _buyoutDividendPercentage;
    }
}"
5099,This is mainly an helper function to ` finalize ` but can be used if ` finalize ` has issues with the loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;
    uint256 public tokensFinalized;
    uint256 public constant MAX_TOKENS = 1000000 * (10 ** 18); // Example value, adjust as needed
    IERC20 public token;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor(address _token) {
        token = IERC20(_token);
    }

    function finalizeSingleInvestor(address investorAddr) public onlyOwner {
        require(investorAddr != address(0) && investorAddr != address(this));
        require(balancesToken[investorAddr] > 0);
        require(isWhitelisted[investorAddr] == true);
        uint256 balanceToTransfer = balancesToken[investorAddr];
        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;
        require(token.transfer(investorAddr, balanceToTransfer));
        tokensFinalized = tokensFinalized.add(balanceToTransfer);
        assert(tokensFinalized <= MAX_TOKENS);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizeSingleInvestor', 'complexity': 6}, {'function': 'announceFork', 'complexity': 2}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""investorAddr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""investorAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Investor address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""investorAddr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Investor cannot be the contract itself""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balancesToken""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Investor must have a positive token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isWhitelisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, {""type"": ""stringLiteral"", ""value"": ""Investor must be whitelisted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balancesToken""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isWhitelisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""investorAddr""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""investorAddr""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensFinalized""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensFinalized""}, ""right"": {""type"": ""Identifier"", ""name"": ""MAX_TOKENS""}}, {""type"": ""stringLiteral"", ""value"": ""Total tokens finalized exceeds maximum limit""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""mustBeAtStage"", ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract FinalizeInvestorTokens is Ownable {
    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;
    uint256 public tokensFinalized;
    IERC20 public tokenContract;
    uint256 public constant MAX_TOKENS = 1000000 * 10**18; // Example maximum tokens, adjust as needed

    modifier mustBeAtStage(uint stage) {
        require(stage == 3, ""Current stage is not Finished"");
        _;
    }

    constructor(address _tokenContract) {
        tokenContract = IERC20(_tokenContract);
    }

    function finalizeTokens(address investorAddr) external onlyOwner mustBeAtStage(3) {
        require(investorAddr != address(0), ""Investor address cannot be zero"");
        require(investorAddr != address(this), ""Investor cannot be the contract itself"");
        uint256 balance = balancesToken[investorAddr];
        require(balance > 0, ""Investor must have a positive token balance"");
        require(isWhitelisted[investorAddr], ""Investor must be whitelisted"");

        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;

        bool success = tokenContract.transfer(investorAddr, balance);
        require(success, ""Token transfer failed"");

        tokensFinalized += balance;
        require(tokensFinalized <= MAX_TOKENS, ""Total tokens finalized exceeds maximum limit"");
    }
}",45.93777441978455,finalizeTokens,40.0,0.908895140866198,0.2892664493354562,"[{'function': 'finalizeTokens', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FinalizeInvestorTokens is Ownable {
    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;
    uint256 public tokensFinalized;
    IERC20 public tokenContract;
    uint256 public constant MAX_TOKENS = 1000000 * 10**18; // Example maximum tokens, adjust as needed

    modifier mustBeAtStage(uint stage) {
        require(stage == 3, ""Current stage is not Finished"");
        _;
    }

    constructor(address _tokenContract) Ownable() {
        tokenContract = IERC20(_tokenContract);
    }

    function finalizeTokens(address investorAddr) external onlyOwner mustBeAtStage(3) {
        require(investorAddr != address(0), ""Investor address cannot be zero"");
        require(investorAddr != address(this), ""Investor cannot be the contract itself"");
        uint256 balance = balancesToken[investorAddr];
        require(balance > 0, ""Investor must have a positive token balance"");
        require(isWhitelisted[investorAddr], ""Investor must be whitelisted"");

        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;

        bool success = tokenContract.transfer(investorAddr, balance);
        require(success, ""Token transfer failed"");

        tokensFinalized += balance;
        require(tokensFinalized <= MAX_TOKENS, ""Total tokens finalized exceeds maximum limit"");
    }
}"
1617,Suspends a given supported market ( asset ) from use with Compound .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Market {
    function isSupported() external view returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint;

    struct MarketInfo {
        bool isSupported;
    }

    mapping(address => MarketInfo) public markets;

    event SuspendedMarket(address indexed asset);

    function suspendMarket(address asset) external returns (uint) {
        if (msg.sender != owner()) {
            return uint(Error.UNAUTHORIZED);
        }
        if (!markets[asset].isSupported) {
            return uint(Error.NO_ERROR);
        }
        markets[asset].isSupported = false;
        emit SuspendedMarket(asset);
        return uint(Error.NO_ERROR);
    }
}","[{'function': 'isSupported', 'complexity': 0}, {'function': 'suspendMarket', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""_suspendMarket"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""asset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""markets""}, ""index"": {""type"": ""Identifier"", ""name"": ""asset""}}, ""memberName"": ""isSupported""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [None]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""markets""}, ""index"": {""type"": ""Identifier"", ""name"": ""asset""}}, ""memberName"": ""isSupported""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SuspendedMarket""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""asset""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MarketSuspender {
    address public admin;

    struct AssetMarket {
        bool isSupported;
    }

    mapping(address => AssetMarket) public markets;

    event SuspendedMarket(address asset);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Unauthorized access"");
        _;
    }

    constructor(address _admin) {
        admin = _admin;
    }

    function _suspendMarket(address asset) public onlyAdmin {
        if (!markets[asset].isSupported) {
            return;
        }
        markets[asset].isSupported = false;
        emit SuspendedMarket(asset);
    }
}",42.650967836380005,_suspendMarket,14.0,0.6248297316558324,0.2011983825509268,"[{'function': '_suspendMarket', 'complexity': 2}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MarketSuspender is Ownable {
    address public admin;

    struct AssetMarket {
        bool isSupported;
    }

    mapping(address => AssetMarket) public markets;

    event SuspendedMarket(address asset);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Unauthorized access"");
        _;
    }

    constructor(address _admin) Ownable(_admin) {
        admin = _admin;
    }

    function _suspendMarket(address asset) public onlyAdmin {
        if (!markets[asset].isSupported) {
            return;
        }
        markets[asset].isSupported = false;
        emit SuspendedMarket(asset);
    }
}"
4581,set beneficiary - the account receiving platform fees .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public beneficiary;

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}","[{'function': 'setBeneficiary', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newBeneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBeneficiary""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract BeneficiaryUpdater {
    address public owner;
    address public beneficiary;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address initialBeneficiary) {
        owner = msg.sender;
        beneficiary = initialBeneficiary;
    }

    function updateBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}",42.09266495704651,updateBeneficiary,0.0,0.9328075819238364,0.842362674378975,"[{'function': 'updateBeneficiary', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BeneficiaryUpdater is Ownable {
    address public beneficiary;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    constructor(address initialBeneficiary) Ownable(initialBeneficiary) {
        beneficiary = initialBeneficiary;
    }

    function updateBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}"
5894,Get the address of channel with a partner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ChannelWrapper {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        address[] all_channels;
    }

    function getChannelWith(Data storage self, address partner) public view returns (address) {
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint256 channel_pos = self.partyhash_to_channelpos[party_hash];
        if (channel_pos != 0) {
            return self.all_channels[channel_pos - 1];
        }
    }
}","[{'function': 'getChannelWith', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""self"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""partner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""party_hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""partyHash""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""partner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""channel_position"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""partyhash_to_channelpos""}, ""index"": {""type"": ""Identifier"", ""name"": ""party_hash""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""channel_position""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""all_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_position""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract ChannelManager {
    mapping(bytes32 => uint256) public partyhash_to_channelpos;
    address[] public all_channels;

    function partyHash(address sender, address partner) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(sender, partner));
    }

    function pose(address self, address partner) public view returns (address) {
        bytes32 party_hash = partyHash(msg.sender, partner);
        uint256 channel_position = partyhash_to_channelpos[party_hash];

        if (channel_position != 0) {
            return all_channels[channel_position - 1];
        } else {
            return address(0);
        }
    }
}",43.35837173461914,pose,9.0,0.8628929434967546,0.4843232582562253,"[{'function': 'partyHash', 'complexity': 0}, {'function': 'pose', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ChannelManager is Ownable {
    mapping(bytes32 => uint256) public partyhash_to_channelpos;
    address[] public all_channels;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            if (i == 0) partyhash_to_channelpos[keccak256(abi.encodePacked(address(1), address(2)))] = 1;
            else if (i == 1) partyhash_to_channelpos[keccak256(abi.encodePacked(address(2), address(3)))] = 2;
            else if (i == 2) partyhash_to_channelpos[keccak256(abi.encodePacked(address(3), address(1)))] = 3;
        }
        all_channels = [address(1), address(2), address(3)];
    }

    function partyHash(address sender, address partner) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(sender, partner));
    }

    function pose(address self, address partner) public view returns (address) {
        bytes32 party_hash = partyHash(msg.sender, partner);
        uint256 channel_position = partyhash_to_channelpos[party_hash];

        if (channel_position != 0) {
            return all_channels[channel_position - 1];
        } else {
            return address(0);
        }
    }
}"
1558,function mint to be executed by Manager of token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract MintableToken is Ownable, IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyManager() {
        require(owner() == msg.sender, ""Only the manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
        require(target != address(0), ""Invalid target address"");
        require(mintedAmount > 0, ""Mint amount must be greater than zero"");
        require(balanceOf[target].add(mintedAmount) >= balanceOf[target], ""SafeMath: addition overflow"");
        require(totalSupply.add(mintedAmount) >= totalSupply, ""SafeMath: addition overflow"");
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(0), target, mintedAmount);
        emit Transfer(target, target, mintedAmount);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'mint', 'complexity': 4}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""target""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Target address must not be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mintedAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minted amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""right"": {""type"": ""Identifier"", ""name"": ""mintedAmount""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}}, {""type"": ""stringLiteral"", ""value"": ""Balance overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""mintedAmount""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, {""type"": ""stringLiteral"", ""value"": ""Total supply overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""right"": {""type"": ""Identifier"", ""name"": ""mintedAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""mintedAmount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    bool public paused = false;
    address public manager;

    modifier onlyManager() {
        require(msg.sender == manager, ""Only manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        manager = msg.sender;
    }

    function mint(address target, uint256 mintedAmount) external onlyManager whenNotPaused {
        require(target != address(0), ""Target address must not be zero"");
        require(mintedAmount > 0, ""Minted amount must be greater than zero"");
        require(balanceOf[target] + mintedAmount >= balanceOf[target], ""Balance overflow"");
        require(totalSupply + mintedAmount >= totalSupply, ""Total supply overflow"");

        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;

        emit Transfer(address(0), target, mintedAmount);
        emit Transfer(target, target, mintedAmount);
    }
}",45.027711391448975,mint,12.0,0.8167295198578457,0.5907805444225186,"[{'function': 'mint', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    bool public paused = false;
    address public manager;

    modifier onlyManager() {
        require(msg.sender == manager, ""Only manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        manager = msg.sender;
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function mint(address target, uint256 mintedAmount) external onlyManager whenNotPaused {
        require(target != address(0), ""Target address must not be zero"");
        require(mintedAmount > 0, ""Minted amount must be greater than zero"");
        require(balanceOf[target] + mintedAmount >= balanceOf[target], ""Balance overflow"");
        require(totalSupply + mintedAmount >= totalSupply, ""Total supply overflow"");

        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;

        emit Transfer(address(0), target, mintedAmount);
        emit Transfer(target, target, mintedAmount);
    }
}"
2515,A getter to look up a Admin 's details,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminStorage {
    using SafeMath for uint256;

    struct PledgeAdmin {
        // Define the structure of PledgeAdmin here if needed
    }

    PledgeAdmin[] private admins;

    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {
        require(idAdmin < admins.length, ""Index out of bounds"");
        return admins[idAdmin];
    }
}","[{'function': 'findAdmin', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""findAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""idAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""idAdmin""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admins""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Admin ID does not exist""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""idAdmin""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AdminFinder {
    PledgeAdmin[] public admins;

    function findAdmin(uint64 idAdmin) external view returns (PledgeAdmin memory) {
        require(idAdmin < admins.length, ""Admin ID does not exist"");
        return admins[idAdmin];
    }
}

struct PledgeAdmin {
    uint64 id;
    address addr;
    // Additional fields can be added here
}",41.917797327041626,findAdmin,0.0,0.9635105870046308,0.5388222776610068,"[{'function': 'findAdmin', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AdminFinder is Ownable {
    PledgeAdmin[] public admins;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint64 id = 1;
        address addr = address(uint160(uint256(1)));

        PledgeAdmin memory initialAdmin = PledgeAdmin({
            id: id,
            addr: addr
        });

        admins.push(initialAdmin);
    }

    function findAdmin(uint64 idAdmin) external view returns (PledgeAdmin memory) {
        require(idAdmin < admins.length, ""Admin ID does not exist"");
        return admins[idAdmin];
    }
}

struct PledgeAdmin {
    uint64 id;
    address addr;
    // Additional fields can be added here
}"
4942,"enables withdrawals , only callable by the owner when the withdrawals are disabled","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bool public withdrawalEnabled = false;
    event WithdrawalEnabled(address indexed owner);

    modifier whenStopped() {
        require(!withdrawalEnabled, ""Withdrawal is enabled"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawal is already enabled"");
        _;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(owner());
    }
}","[{'function': 'enableWithdrawal', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableWithdrawal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawalEnabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WithdrawalEnabled""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenStopped"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenWithdrawalDisabled"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    bool public withdrawalEnabled = false;

    modifier whenStopped() {
        require(address(this).balance == 0, ""Contract must be stopped"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawals must be disabled"");
        _;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(msg.sender);
    }

    event WithdrawalEnabled(address indexed owner);
}",42.74076175689697,enableWithdrawal,1.0,0.8601218856850061,0.7643838122940672,"[{'function': 'enableWithdrawal', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool public withdrawalEnabled;

    modifier whenStopped() {
        require(address(this).balance == 0, ""Contract must be stopped"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawals must be disabled"");
        _;
    }

    constructor() Ownable(msg.sender) {
        withdrawalEnabled = false;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(msg.sender);
    }

    event WithdrawalEnabled(address indexed owner);
}"
3452,Called by moduleFactory owner to register new modules for SecurityToken to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    function registerModule(address _moduleFactory) external returns (bool) {
        // Implementation of the registration logic
        return true;
    }
}","[{'function': 'registerModule', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleFactory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""The provided module factory address must not be zero.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedModules""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""The module factory is already registered.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedModules""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""modulesList""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModuleRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ModuleRegistry {
    address public owner;
    mapping(address => bool) public approvedModules;
    address[] public modulesList;

    event ModuleRegistered(address indexed moduleFactory);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function registerModule(address _moduleFactory) public onlyOwner {
        require(_moduleFactory != address(0), ""The provided module factory address must not be zero."");
        require(!approvedModules[_moduleFactory], ""The module factory is already registered."");

        approvedModules[_moduleFactory] = true;
        modulesList.push(_moduleFactory);

        emit ModuleRegistered(_moduleFactory);
    }
}",43.203314781188965,registerModule,32.0,0.4782365419021017,0.0930209771728188,"[{'function': 'registerModule', 'complexity': 3}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ModuleRegistry is Ownable {
    address public owner = msg.sender;
    mapping(address => bool) public approvedModules;
    address[] public modulesList;

    event ModuleRegistered(address indexed moduleFactory);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function registerModule(address _moduleFactory) public onlyOwner {
        require(_moduleFactory != address(0), ""The provided module factory address must not be zero."");
        require(!approvedModules[_moduleFactory], ""The module factory is already registered."");

        approvedModules[_moduleFactory] = true;
        modulesList.push(_moduleFactory);

        emit ModuleRegistered(_moduleFactory);
    }
}"
1228,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IWPR {
    function totalSupply() external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function finishMinting() external returns (bool);
    function transferOwnership(address newOwner) external;
}

abstract contract WPRCrowdsale is Ownable {
    using SafeMath for uint256;

    IWPR public wpr;
    address public teamHolder;
    address public communityHolder;
    address public futureHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 indexed finalizedBlock);

    constructor(IWPR _wpr, address _teamHolder, address _communityHolder, address _futureHolder, uint256 _startTime, uint256 _endTime) {
        wpr = _wpr;
        teamHolder = _teamHolder;
        communityHolder = _communityHolder;
        futureHolder = _futureHolder;
        startTime = _startTime;
        endTime = _endTime;
    }

    function getBlockTimestamp() internal view returns (uint256) {
        return block.timestamp;
    }

    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function weiToCollect() public view returns (uint256) {
        // Implement the logic to calculate the amount of Wei collected if needed.
        return 0; // Placeholder implementation.
    }

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == owner || getBlockTimestamp() > endTime || weiToCollect() == 0);

        uint256 CROWDSALE_PCT = 62;
        uint256 TEAMHOLDER_PCT = 20;
        uint256 COMMUNITYHOLDER_PCT = 15;
        uint256 FUTUREHOLDER_PCT = 3;
        assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

        uint256 tokenCap = wpr.totalSupply().mul(100).div(CROWDSALE_PCT);
        wpr.mint(teamHolder, tokenCap.mul(TEAMHOLDER_PCT).div(100));
        wpr.mint(communityHolder, tokenCap.mul(COMMUNITYHOLDER_PCT).div(100));
        wpr.mint(futureHolder, tokenCap.mul(FUTUREHOLDER_PCT).div(100));

        require(wpr.finishMinting());
        wpr.transferOwnership(owner);

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}","[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'getBlockTimestamp', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'weiToCollect', 'complexity': 0}, {'function': 'finalize', 'complexity': 7}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Already finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}, {""type"": ""stringLiteral"", ""value"": ""Sale has not started yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}], ""isArray"": False}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiToCollect""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid conditions for finalization""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenCap"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""CROWDSALE_PCT""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenCap""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token cap calculation error""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""teamHolder""}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""TEAMHOLDER_PCT""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""communityHolder""}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""COMMUNITYHOLDER_PCT""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""futureHolder""}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""FUTUREHOLDER_PCT""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""finishMinting""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wpr""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""tokenCap""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Finalized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalizedBlock""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface Token {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function mint(address to, uint256 value) external;
}

contract Crowdsale {
    Token public wpr;
    address public owner;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public constant CROWDSALE_PCT = 62;
    uint256 public constant TEAMHOLDER_PCT = 20;
    uint256 public constant COMMUNITYHOLDER_PCT = 15;
    uint256 public constant FUTUREHOLDER_PCT = 3;
    address public teamHolder;
    address public communityHolder;
    address public futureHolder;

    event Finalized(uint256 indexed blockNumber);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(address _wpr, uint256 _startTime, uint256 _endTime) {
        wpr = Token(_wpr);
        owner = msg.sender;
        startTime = _startTime;
        endTime = _endTime;
    }

    function finalize() external onlyOwner {
        require(finalizedBlock == 0, ""Already finalized"");
        require(block.timestamp >= startTime, ""Sale has not started yet"");
        require((msg.sender == owner) || (block.timestamp > endTime) || weiToCollect() == 0, ""Invalid conditions for finalization"");

        uint256 totalSupply = wpr.totalSupply();
        uint256 tokenCap = totalSupply * CROWDSALE_PCT / 100;

        require(tokenCap > 0, ""Token cap calculation error"");

        // Mint tokens for teamHolder, communityHolder, and futureHolder
        wpr.mint(teamHolder, totalSupply * TEAMHOLDER_PCT / 100);
        wpr.mint(communityHolder, totalSupply * COMMUNITYHOLDER_PCT / 100);
        wpr.mint(futureHolder, totalSupply * FUTUREHOLDER_PCT / 100);

        // Finalize minting and transfer ownership to the owner
        wpr.finishMinting();
        require(wpr.transfer(owner, tokenCap), ""Token transfer failed"");

        finalizedBlock = block.number;
        finalizedTime = block.timestamp;

        emit Finalized(finalizedBlock);
    }

    function weiToCollect() public view returns (uint256) {
        // Implement logic to calculate the amount of wei to collect if needed
        return 0; // Placeholder implementation
    }
}",49.66401982307434,finalize,64.0,0.7780366152450506,0.323230002511363,"[{'function': 'mint', 'complexity': 0}, {'function': 'finalize', 'complexity': 6}, {'function': 'weiToCollect', 'complexity': 0}]",9.0,"pragma solidity ^0.8.0;

interface Token {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function mint(address to, uint256 value) external;
}
import ""openzeppelin/SafeMath.sol"";
contract Crowdsale is Ownable {
    Token public wpr;
    address public owner;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public constant CROWDSALE_PCT = 62;
    uint256 public constant TEAMHOLDER_PCT = 20;
    uint256 public constant COMMUNITYHOLDER_PCT = 15;
    uint256 public constant FUTUREHOLDER_PCT = 3;
    address public teamHolder;
    address public communityHolder;
    address public futureHolder;

    event Finalized(uint256 indexed blockNumber);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(address _wpr, uint256 _startTime, uint256 _endTime)
        Ownable(msg.sender)
    {
        wpr = Token(_wpr);
        owner = msg.sender;
        startTime = _startTime;
        endTime = _endTime;
        teamHolder = address(0x1111111111111111111111111111111111111111); // Fixed value
        communityHolder = address(0x2222222222222222222222222222222222222222); // Fixed value
        futureHolder = address(0x3333333333333333333333333333333333333333); // Fixed value
    }

    function finalize() external onlyOwner {
        require(finalizedBlock == 0, ""Already finalized"");
        require(block.timestamp >= startTime, ""Sale has not started yet"");
        require((msg.sender == owner) || (block.timestamp > endTime) || weiToCollect() == 0, ""Invalid conditions for finalization"");

        uint256 totalSupply = wpr.totalSupply();
        uint256 tokenCap = totalSupply * CROWDSALE_PCT / 100;

        require(tokenCap > 0, ""Token cap calculation error"");

        // Mint tokens for teamHolder, communityHolder, and futureHolder
        wpr.mint(teamHolder, totalSupply * TEAMHOLDER_PCT / 100);
        wpr.mint(communityHolder, totalSupply * COMMUNITYHOLDER_PCT / 100);
        wpr.mint(futureHolder, totalSupply * FUTUREHOLDER_PCT / 100);

        // Finalize minting and transfer ownership to the owner
        wpr.finishMinting();
        require(wpr.transfer(owner, tokenCap), ""Token transfer failed"");

        finalizedBlock = block.number;
        finalizedTime = block.timestamp;

        emit Finalized(finalizedBlock);
    }

    function weiToCollect() public view returns (uint256) {
        // Implement logic to calculate the amount of wei to collect if needed
        return 0; // Placeholder implementation
    }
}"
6786,Decrease the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping (address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed newOwner, uint256 value, uint256 fee);

    function decreaseApprovalPreSignedHashing(address _token, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _subtractedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27, _signature[:64], _signature[64:]);
    }

    function decreaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);
        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));
        nonces[_signature] = true;
        uint oldValue = allowed[from][_spender];
        if (_subtractedValue > oldValue) {
            allowed[from][_spender] = 0;
        } else {
            allowed[from][_spender] = oldValue.sub(_subtractedValue);
        }
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}","[{'function': 'decreaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'decreaseApprovalPreSigned', 'complexity': 5}]",5.0,{},,51.98166847229004,,0.0,0.0306391188503205,0.0,"{'function': '', 'complexity': 0}",,nan
3195,Retrieves the encryption public key of the darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeStore {
    function darknodePublicKey(address) external view returns (bytes memory);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    DarknodeStore public store;

    constructor(address _storeAddress) {
        store = DarknodeStore(_storeAddress);
    }

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        return store.darknodePublicKey(_darknodeID);
    }
}","[{'function': 'darknodePublicKey', 'complexity': 0}, {'function': 'getDarknodePublicKey', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDarknodePublicKey"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_darknodeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodePublicKeys""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknodeID""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract DarknodeRegistry {
    mapping(address => bytes) public darknodePublicKeys;

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        return darknodePublicKeys[_darknodeID];
    }
}",44.59436774253845,getDarknodePublicKey,2.0,0.8370003641170674,0.698971016303122,"[{'function': 'getDarknodePublicKey', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract DarknodeRegistry {
    mapping(address => bytes) public darknodePublicKeys;
    address public owner;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        return darknodePublicKeys[_darknodeID];
    }
}"
761,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function enableTransfers(bool _transfersEnabled) external onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTransfersEnabled"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    address public controller;
    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function."");
        _;
    }

    constructor(address _controller) {
        controller = _controller;
        transfersEnabled = true; // Default to enabled
    }

    function setTransfersEnabled(bool _transfersEnabled) external onlyController {
        transfersEnabled = _transfersEnabled;
    }
}",42.118117332458496,setTransfersEnabled,0.0,0.92847262291477,0.5923033072023249,"[{'function': 'setTransfersEnabled', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    address public controller;
    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function."");
        _;
    }

    constructor(address _controller) Ownable(msg.sender) {
        controller = _controller;
        transfersEnabled = true; // Default to enabled
    }

    function setTransfersEnabled(bool _transfersEnabled) external onlyController {
        transfersEnabled = _transfersEnabled;
    }
}"
3170,Set an upgrade agent contract to process the upgrade .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface UpgradeAgent {
    function isUpgradeAgent() external view returns (bool);
    function originalSupply() external view returns (uint256);
}

enum UpgradeState { NotUpgradable, Upgrading }

abstract contract Token {
    using SafeMath for uint256;

    address public upgradeAgent;
    uint256 public totalSupply_;

    function getUpgradeState() internal virtual returns (UpgradeState);
    function canUpgrade() internal virtual returns (bool);

    event UpgradeAgentSet(address indexed agent);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }
}

abstract contract UpgradableToken is Token, Ownable {
    using SafeMath for uint256;

    function setUpgradeAgent(UpgradeAgent _upgradeAgent) external onlyOwner {
        require(canUpgrade(), ""Ensure the token is upgradeable in the first place"");
        require(_upgradeAgent != address(0), ""Ensure upgrade agent address is not blank"");
        require(getUpgradeState() != UpgradeState.Upgrading, ""Ensure upgrade has not started"");

        upgradeAgent = address(_upgradeAgent);
        require(UpgradeAgent(upgradeAgent).isUpgradeAgent(), ""New upgradeAgent must be UpgradeAgent"");
        require(UpgradeAgent(upgradeAgent).originalSupply() == totalSupply_, ""Make sure that token supplies match in source and target token contracts"");

        emit UpgradeAgentSet(upgradeAgent);
    }
}","[{'function': 'originalSupply', 'complexity': 0}, {'function': 'canUpgrade', 'complexity': 0}, {'function': 'setUpgradeAgent', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUpgradeAgent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_upgradeAgent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""Upgrading""}}, {""type"": ""stringLiteral"", ""value"": ""Upgrade process has already started""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_upgradeAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Upgrade agent address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isUpgradeAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradeAgent""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Provided upgrade agent does not implement the UpgradeAgent interface""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""currentSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""currentSupply""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_upgradeAgent""}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentSupply""}}}, {""type"": ""stringLiteral"", ""value"": ""Upgrade agent does not have enough tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradeAgent""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""WaitingForAgent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeAgentSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradeAgent""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyUpgradeMaster"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract UpgradeableToken {
    address public upgradeMaster;
    UpgradeAgent public upgradeAgent;
    uint public totalUpgraded;

    enum UpgradeState { Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading }
    UpgradeState public state = UpgradeState.Unknown;

    event UpgradeAgentSet(address indexed agent);

    modifier onlyUpgradeMaster() {
        require(msg.sender == upgradeMaster, ""Only upgrade master can call this function"");
        _;
    }

    constructor(address _upgradeMaster) {
        upgradeMaster = _upgradeMaster;
    }

    function setUpgradeAgent(address _upgradeAgent) public onlyUpgradeMaster {
        require(state != UpgradeState.Upgrading, ""Upgrade process has already started"");
        require(_upgradeAgent != address(0), ""Upgrade agent address cannot be zero"");
        require(isUpgradeAgent(_upgradeAgent), ""Provided upgrade agent does not implement the UpgradeAgent interface"");

        // Assuming there's a way to check if the total supply matches, e.g., by calling a method on the upgrade agent
        uint currentSupply = totalSupply(); // Placeholder for actual function call
        require(currentSupply == 0 || _upgradeAgent.balance >= currentSupply, ""Upgrade agent does not have enough tokens"");

        upgradeAgent = UpgradeAgent(_upgradeAgent);
        state = UpgradeState.WaitingForAgent;
        emit UpgradeAgentSet(_upgradeAgent);
    }

    function isUpgradeAgent(address _agent) public pure returns (bool) {
        // Placeholder for actual implementation of the interface check
        return true; // Simplified, replace with actual logic
    }
}",45.905821800231934,setUpgradeAgent,30.0,0.8385936449222757,0.2186222506398191,"[{'function': 'setUpgradeAgent', 'complexity': 5}, {'function': 'isUpgradeAgent', 'complexity': 0}]",9.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract UpgradeableToken is Ownable {
    address public upgradeMaster;
    UpgradeAgent public upgradeAgent;
    uint public totalUpgraded;

    enum UpgradeState { Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading }
    UpgradeState public state = UpgradeState.Unknown;

    event UpgradeAgentSet(address indexed agent);

    modifier onlyUpgradeMaster() {
        require(msg.sender == upgradeMaster, ""Only upgrade master can call this function"");
        _;
    }

    uint256 public totalSupply;

 constructor(address _upgradeMaster) Ownable(msg.sender) {
        upgradeMaster = _upgradeMaster;
    }

    function setUpgradeAgent(address _upgradeAgent) public onlyUpgradeMaster {
        require(state != UpgradeState.Upgrading, ""Upgrade process has already started"");
        require(_upgradeAgent != address(0), ""Upgrade agent address cannot be zero"");
        require(isUpgradeAgent(_upgradeAgent), ""Provided upgrade agent does not implement the UpgradeAgent interface"");

        // Assuming there's a way to check if the total supply matches, e.g., by calling a method on the upgrade agent
        uint currentSupply = totalSupply(); // Placeholder for actual function call
        require(currentSupply == 0 || _upgradeAgent.balance >= currentSupply, ""Upgrade agent does not have enough tokens"");

        upgradeAgent = UpgradeAgent(_upgradeAgent);
        state = UpgradeState.WaitingForAgent;
        emit UpgradeAgentSet(_upgradeAgent);
    }

    function isUpgradeAgent(address _agent) public pure returns (bool) {
        // Placeholder for actual implementation of the interface check
        return true; // Simplified, replace with actual logic
    }
}"
3368,Check whether an address is a regular address or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

    function isRegularAddress(address _addr) public view returns (bool) {
        if (_addr == address(0)) {
            return false;
        }
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }
}","[{'function': 'isRegularAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRegularAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""codeSize"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""codeSize""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""codeSize""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract AddressChecker {
    function isRegularAddress(address _addr) public pure returns (bool) {
        if (_addr == address(0)) {
            return false;
        }

        uint256 codeSize;
        assembly {
            codeSize := extcodesize(_addr)
        }

        return codeSize == 0;
    }
}",42.12496995925903,isRegularAddress,0.0,0.9317265054950434,0.7303420461049419,"[{'function': 'isRegularAddress', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AddressChecker is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isRegularAddress(address _addr) public pure returns (bool) {
        if (_addr == address(0)) {
            return false;
        }

        uint256 codeSize;
        assembly {
            codeSize := extcodesize(_addr)
        }

        return codeSize == 0;
    }
}"
5919,Initiates a `` send '' operation towards another user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenStorage {
    function balanceOf(address account) external view returns (uint256);
    function subBalance(address account, uint256 amount) external;
    function addBalance(address account, uint256 amount) external;
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    ITokenStorage public tokenStorage;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {
        require(_to != address(0), ""to address cannot be 0x0"");
        require(_amount <= tokenStorage.balanceOf(msg.sender), ""not enough balance to transfer"");
        tokenStorage.subBalance(msg.sender, _amount);
        tokenStorage.addBalance(_to, _amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function setTokenStorage(address _tokenStorage) public onlyOwner {
        tokenStorage = ITokenStorage(_tokenStorage);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    modifier userNotBlacklisted(address user) {
        require(!isBlacklisted[user], ""User is blacklisted"");
        _;
    }

    mapping(address => bool) public isBlacklisted;

    function blacklistUser(address user) public onlyOwner {
        isBlacklisted[user] = true;
    }

    function removeFromBlacklist(address user) public onlyOwner {
        isBlacklisted[user] = false;
    }
}","[{'function': 'addBalance', 'complexity': 0}, {'function': 'transfer', 'complexity': 2}, {'function': 'setTokenStorage', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'blacklistUser', 'complexity': 0}, {'function': 'removeFromBlacklist', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenStorage""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""userNotBlacklisted"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}]}, {""type"": ""ModifierInvocation"", ""name"": ""userNotBlacklisted"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""./tokenStorage.sol""; // Assuming tokenStorage contract exists and is imported correctly
import ""./Roles.sol""; // Assuming Roles contract for role management exists and is imported correctly

contract TokenTransfer {
    using SafeMath for uint256;
    address public owner;
    bool public paused = false;
    mapping(address => bool) public blacklistedAddresses;
    TokenStorage tokenStorage;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier userNotBlacklisted(address user) {
        require(!blacklistedAddresses[user], ""User is blacklisted"");
        _;
    }

    constructor(address _tokenStorageAddress) {
        tokenStorage = TokenStorage(_tokenStorageAddress);
        owner = msg.sender;
    }

    function transferTokens(address _to, uint256 _amount) public whenNotPaused userNotBlacklisted(msg.sender) userNotBlacklisted(_to) {
        require(_to != address(0), ""Invalid recipient address"");
        require(tokenStorage.balanceOf(msg.sender) >= _amount, ""Insufficient balance"");

        tokenStorage.transferFrom(msg.sender, _to, _amount);

        emit Transfer(msg.sender, _to, _amount);
    }

    function pause() public {
        require(msg.sender == owner, ""Only owner can pause the contract"");
        paused = true;
    }

    function unpause() public {
        require(msg.sender == owner, ""Only owner can unpause the contract"");
        paused = false;
    }

    function blacklistUser(address user) public {
        require(msg.sender == owner, ""Only owner can blacklist users"");
        blacklistedAddresses[user] = true;
    }

    function removeFromBlacklist(address user) public {
        require(msg.sender == owner, ""Only owner can remove from blacklist"");
        delete blacklistedAddresses[user];
    }
}",47.39913988113403,transferTokens,15.0,0.910888630361621,0.5027970648033413,"[{'function': 'transferTokens', 'complexity': 2}, {'function': 'pause', 'complexity': 1}, {'function': 'unpause', 'complexity': 1}, {'function': 'blacklistUser', 'complexity': 1}, {'function': 'removeFromBlacklist', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""./tokenStorage.sol""; // Assuming tokenStorage contract exists and is imported correctly
import ""./Roles.sol""; // Assuming Roles contract for role management exists and is imported correctly
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer {
    using SafeMath for uint256;
    address public owner;
    bool public paused = false;
    mapping(address => bool) public blacklistedAddresses;
    TokenStorage tokenStorage;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier userNotBlacklisted(address user) {
        require(!blacklistedAddresses[user], ""User is blacklisted"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenStorageAddress) {
        tokenStorage = TokenStorage(_tokenStorageAddress);
        owner = msg.sender;
    }

    function transferTokens(address _to, uint256 _amount) public whenNotPaused userNotBlacklisted(msg.sender) userNotBlacklisted(_to) {
        require(_to != address(0), ""Invalid recipient address"");
        require(tokenStorage.balanceOf(msg.sender) >= _amount, ""Insufficient balance"");

        tokenStorage.transferFrom(msg.sender, _to, _amount);

        emit Transfer(msg.sender, _to, _amount);
    }

    function pause() public {
        require(msg.sender == owner, ""Only owner can pause the contract"");
        paused = true;
    }

    function unpause() public {
        require(msg.sender == owner, ""Only owner can unpause the contract"");
        paused = false;
    }

    function blacklistUser(address user) public {
        require(msg.sender == owner, ""Only owner can blacklist users"");
        blacklistedAddresses[user] = true;
    }

    function removeFromBlacklist(address user) public {
        require(msg.sender == owner, ""Only owner can remove from blacklist"");
        delete blacklistedAddresses[user];
    }
}"
4803,This is a state-modifying function that can be called while the contract is paused .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Sale {
        address seller;
        // other sale details
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function _isOnSale(Sale storage sale) internal view returns (bool) {
        return sale.seller != address(0);
    }

    function _cancelSale(uint256 _tokenId, address seller) internal {
        delete tokenIdToSale[_tokenId];
        emit SaleCancelled(_tokenId, seller);
    }

    function cancelSale(uint256 _tokenId) public {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(sale));
        address seller = sale.seller;
        require(msg.sender == seller);
        _cancelSale(_tokenId, seller);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': '_isOnSale', 'complexity': 0}, {'function': '_cancelSale', 'complexity': 0}, {'function': 'cancelSale', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isOnSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Sale is not active""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Sale""}, ""name"": ""sale"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIdToSale""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sale""}, ""memberName"": ""seller""}}, {""type"": ""stringLiteral"", ""value"": ""Only the seller can cancel this sale""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_cancelSale""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sale""}, ""memberName"": ""seller""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenMarketplace {
    struct Sale {
        address seller;
        uint256 price;
        bool active;
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function cancelSale(uint256 _tokenId) external {
        require(_isOnSale(_tokenId), ""Sale is not active"");
        Sale storage sale = tokenIdToSale[_tokenId];
        require(msg.sender == sale.seller, ""Only the seller can cancel this sale"");
        _cancelSale(_tokenId, sale.seller);
    }

    function _isOnSale(uint256 _tokenId) internal view returns (bool) {
        return tokenIdToSale[_tokenId].active;
    }

    function _cancelSale(uint256 _tokenId, address seller) internal {
        delete tokenIdToSale[_tokenId];
        emit SaleCancelled(_tokenId);
    }

    event SaleCancelled(uint256 indexed tokenId);
}",43.78095746040344,cancelSale,13.0,0.9384366403799576,0.4282737748936386,"[{'function': 'cancelSale', 'complexity': 2}, {'function': '_isOnSale', 'complexity': 0}, {'function': '_cancelSale', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenMarketplace is Ownable {
    struct Sale {
        address seller;
        uint256 price;
        bool active;
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            tokenIdToSale[i] = Sale({seller: addr, price: 1, active: true});
        }
    }

    function cancelSale(uint256 _tokenId) external {
        require(_isOnSale(_tokenId), ""Sale is not active"");
        Sale storage sale = tokenIdToSale[_tokenId];
        require(msg.sender == sale.seller, ""Only the seller can cancel this sale"");
        _cancelSale(_tokenId, sale.seller);
    }

    function _isOnSale(uint256 _tokenId) internal view returns (bool) {
        return tokenIdToSale[_tokenId].active;
    }

    function _cancelSale(uint256 _tokenId, address seller) internal {
        delete tokenIdToSale[_tokenId];
        emit SaleCancelled(_tokenId);
    }

    event SaleCancelled(uint256 indexed tokenId);
}"
2141,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

function submitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address answerer) onlyArbitrator(question_id) statePendingArbitration(question_id) bondMustBeZero external {
    require(answerer != NULL_ADDRESS, ""answerer must be provided"");
    emit LogFinalize(question_id, answer);
    questions[question_id].is_pending_arbitration = false;
    _addAnswerToHistory(question_id, answer, answerer, 0, false);
    _updateCurrentAnswer(question_id, answer, 0);
}
}","[{'function': 'submitAnswerByArbitrator ', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""answer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""answerer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""is_pending_arbitration""}, {""type"": ""stringLiteral"", ""value"": ""Question is not pending arbitration""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""bond""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Bond must be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""answerer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid answerer address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""is_pending_arbitration""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogFinalize""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addAnswerToHistory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_updateCurrentAnswer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuthorizedArbitrator"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Arbitration {
    struct Question {
        bool is_pending_arbitration;
        bytes32 answer;
        address arbitrator;
        uint bond;
    }

    mapping(bytes32 => Question) public questions;

    event LogFinalize(bytes32 indexed questionId, bytes32 indexed answer);

    modifier onlyAuthorizedArbitrator(bytes32 question_id) {
        require(msg.sender == questions[question_id].arbitrator, ""Not authorized arbitrator"");
        _;
    }

    function pose(bytes32 question_id, bytes32 answer, address answerer) public onlyAuthorizedArbitrator(question_id) {
        require(questions[question_id].is_pending_arbitration, ""Question is not pending arbitration"");
        require(questions[question_id].bond == 0, ""Bond must be zero"");
        require(answerer != address(0), ""Invalid answerer address"");

        questions[question_id].is_pending_arbitration = false;

        emit LogFinalize(question_id, answer);

        _addAnswerToHistory(question_id, answer);
        _updateCurrentAnswer(question_id, 0);
    }

    function _addAnswerToHistory(bytes32 question_id, bytes32 answer) internal {
        // Logic to add the final answer to the history of answers for the question
    }

    function _updateCurrentAnswer(bytes32 question_id, uint bond) internal {
        questions[question_id].answer = questions[question_id].answer;
    }
}",45.63459277153015,pose,29.0,0.8011693182764456,0.4450049989404253,"[{'function': 'pose', 'complexity': 3}, {'function': '_addAnswerToHistory', 'complexity': 0}, {'function': '_updateCurrentAnswer', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Arbitration is Ownable {
    struct Question {
        bool is_pending_arbitration;
        bytes32 answer;
        address arbitrator;
        uint bond;
    }

    mapping(bytes32 => Question) public questions;

    event LogFinalize(bytes32 indexed questionId, bytes32 indexed answer);

    modifier onlyAuthorizedArbitrator(bytes32 question_id) {
        require(msg.sender == questions[question_id].arbitrator, ""Not authorized arbitrator"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function pose(bytes32 question_id, bytes32 answer, address answerer) public onlyAuthorizedArbitrator(question_id) {
        require(questions[question_id].is_pending_arbitration, ""Question is not pending arbitration"");
        require(questions[question_id].bond == 0, ""Bond must be zero"");
        require(answerer != address(0), ""Invalid answerer address"");

        questions[question_id].is_pending_arbitration = false;

        emit LogFinalize(question_id, answer);

        _addAnswerToHistory(question_id, answer);
        _updateCurrentAnswer(question_id, 0);
    }

    function _addAnswerToHistory(bytes32 question_id, bytes32 answer) internal {
        // Logic to add the final answer to the history of answers for the question
    }

    function _updateCurrentAnswer(bytes32 question_id, uint bond) internal {
        questions[question_id].answer = questions[question_id].answer;
    }
}"
381,"Get the remaining funds needed to end the auction , calculated at the current GOT price in WEI .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AuctionWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public num_tokens_auctioned;
    uint256 public received_wei;
    uint256 public price_per_token;
    uint256 public token_multiplier;

    function remainingFundsToEndAuction() public view returns (uint256) {
        require(num_tokens_auctioned > 0, ""Number of tokens auctioned must be greater than zero"");
        require(token_multiplier > 0, ""Token multiplier must be greater than zero"");
        uint256 required_wei_at_price = num_tokens_auctioned.mul(price_per_token) / token_multiplier;
        if (required_wei_at_price <= received_wei) {
            return 0;
        }
        return required_wei_at_price.sub(received_wei);
    }
}","[{'function': 'remainingFundsToEndAuction', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""remainingFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""required_wei"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""num_tokens_auctioned""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""price""}, ""arguments"": [], ""names"": []}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""token_multiplier""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""required_wei""}, ""right"": {""type"": ""Identifier"", ""name"": ""received_wei""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""required_wei""}, ""right"": {""type"": ""Identifier"", ""name"": ""received_wei""}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Auction {
    uint public num_tokens_auctioned;
    uint public token_multiplier;
    uint public received_wei;

    function price() public view returns (uint) {
        // Assuming the price is calculated based on some logic, replace this with actual implementation.
        return 1 ether; // Example: 1 ETH per token for simplicity.
    }

    function remainingFunds() public view returns (uint) {
        uint required_wei = (num_tokens_auctioned * price()) / token_multiplier;
        if (required_wei <= received_wei) {
            return 0;
        } else {
            return required_wei - received_wei;
        }
    }
}",43.19851779937744,remainingFunds,23.0,0.7886746779300556,0.1926385987925407,"[{'function': 'price', 'complexity': 0}, {'function': 'remainingFunds', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    uint public num_tokens_auctioned = 1;
    uint public token_multiplier = 1;
    uint public received_wei = 1 ether;

    function price() public pure returns (uint) {
        return 1 ether; // Example: 1 ETH per token for simplicity.
    }

    function remainingFunds() public view returns (uint) {
        uint required_wei = (num_tokens_auctioned * price()) / token_multiplier;
        if (required_wei <= received_wei) {
            return 0;
        } else {
            return required_wei - received_wei;
        }
    }
}"
242,Withdraw ETH for ` receiverAddress ` after the auction has canceled .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionCreated, AuctionCanceled, AuctionEnded }
    mapping(address => uint) public bids;
    Stages public stage = Stages.AuctionCreated;

    function proxyWithdraw(address receiverAddress) public atStage(Stages.AuctionCanceled) returns (bool) {
        require(receiverAddress != address(0));
        if (bids[receiverAddress] == 0) {
            return false;
        }
        uint amount = bids[receiverAddress];
        bids[receiverAddress] = 0;
        receiverAddress.transfer(amount);
        assert(bids[receiverAddress] == 0);
        return true;
    }
}","[{'function': 'proxyWithdraw', 'complexity': 3}]",4.0,{},"pragma solidity ^0.8.0;

contract Auction {
    mapping(address => uint256) public bids;

    function proxyWithdraw(address receiverAddress) external returns (bool) {
        require(receiverAddress != address(0), ""Receiver address cannot be zero"");
        require(bids[receiverAddress] > 0, ""No bid associated with this address"");

        uint256 amount = bids[receiverAddress];
        bids[receiverAddress] = 0;

        (bool success, ) = receiverAddress.call{value: amount}("""");
        require(success, ""Transfer failed"");

        return true;
    }
}",42.631383180618286,proxyWithdraw,51.0,0.8954196372030541,0.3599308446099271,"[{'function': 'proxyWithdraw', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    mapping(address => uint256) public bids;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function proxyWithdraw(address receiverAddress) external returns (bool) {
        require(receiverAddress != address(0), ""Receiver address cannot be zero"");
        require(bids[receiverAddress] > 0, ""No bid associated with this address"");

        uint256 amount = bids[receiverAddress];
        bids[receiverAddress] = 0;

        (bool success, ) = receiverAddress.call{value: amount}("""");
        require(success, ""Transfer failed"");

        return true;
    }
}"
1926,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable override returns (bool) {
        return true;
    }
}","[{'function': 'proxyPayment', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""makePayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract PaymentProxy {
    function makePayment(address payable _owner) public payable {
        require(_owner != address(0), ""Invalid owner address"");
        _owner.transfer(msg.value);
    }
}",41.31996297836304,makePayment,15.0,0.670106833570989,0.1075499978415692,"[{'function': 'makePayment', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentProxy is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function makePayment(address payable _owner) public payable {
        require(_owner != address(0), ""Invalid owner address"");
        _owner.transfer(msg.value);
    }
}"
6311,Vote for specific proposal with yes or no,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

abstract contract Proposal {
    using SafeMath for uint256;
    struct Proposal {
        address token;
        uint256 yesVotes;
        uint256 noVotes;
    }
    Proposal[] public proposals;
    mapping(uint256 => Proposal) public proposalById;

    event Vote(uint256 indexed proposalId, address indexed voter, bool yes, uint256 amount);

    function vote(uint256 _proposalId, bool _yes) public {
        require(_proposalId < proposals.length, ""Invalid proposal ID"");
        require(checkIfCurrentlyActive(_proposalId), ""Proposal is not active"");
        Proposal memory p = proposals[_proposalId];
        uint256 amount = MiniMeToken(p.token).balanceOf(msg.sender);
        require(amount > 0, ""No tokens to vote with"");
        require(MiniMeToken(p.token).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        if (_yes) {
            proposals[_proposalId].yesVotes = proposals[_proposalId].yesVotes.add(amount);
        } else {
            proposals[_proposalId].noVotes = proposals[_proposalId].noVotes.add(amount);
        }
        emit Vote(_proposalId, msg.sender, _yes, amount);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'vote', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""vote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_proposalId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_yes"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_proposalId""}, ""right"": {""type"": ""Identifier"", ""name"": ""proposalCount""}}, {""type"": ""stringLiteral"", ""value"": ""Proposal does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}, ""memberName"": ""active""}, {""type"": ""stringLiteral"", ""value"": ""Proposal is not active""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""You have no tokens to vote""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""_yes""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}, ""memberName"": ""yesVotes""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalId""}}, ""memberName"": ""noVotes""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Vote""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_proposalId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_yes""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Voting {
    struct Proposal {
        bool active;
        uint yesVotes;
        uint noVotes;
    }

    IERC20 public tokenContract;
    mapping(uint => Proposal) public proposals;
    uint public proposalCount;

    event Vote(uint indexed proposalId, address indexed voter, bool yes);

    constructor(address _tokenAddress) {
        tokenContract = IERC20(_tokenAddress);
    }

    function createProposal() internal {
        proposals[proposalCount] = Proposal({active: true, yesVotes: 0, noVotes: 0});
        proposalCount++;
    }

    function vote(uint _proposalId, bool _yes) public {
        require(_proposalId < proposalCount, ""Proposal does not exist"");
        require(proposals[_proposalId].active, ""Proposal is not active"");

        uint balance = tokenContract.balanceOf(msg.sender);
        require(balance > 0, ""You have no tokens to vote"");

        bool success = tokenContract.transferFrom(msg.sender, address(this), balance);
        require(success, ""Token transfer failed"");

        if (_yes) {
            proposals[_proposalId].yesVotes += balance;
        } else {
            proposals[_proposalId].noVotes += balance;
        }

        emit Vote(_proposalId, msg.sender, _yes);
    }
}",45.7758264541626,vote,31.0,0.8051137439119871,0.4319318364547927,"[{'function': 'createProposal', 'complexity': 0}, {'function': 'vote', 'complexity': 5}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Voting is Ownable {
    struct Proposal {
        bool active;
        uint yesVotes;
        uint noVotes;
    }

    IERC20 public tokenContract;
    mapping(uint => Proposal) public proposals;
    uint public proposalCount;

    event Vote(uint indexed proposalId, address indexed voter, bool yes);

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        tokenContract = IERC20(_tokenAddress);
        // Initialize state variables with fixed, safe, non-corner-case values
        proposalCount = 1;
    }

    function createProposal() internal {
        proposals[proposalCount] = Proposal({active: true, yesVotes: 0, noVotes: 0});
        proposalCount++;
    }

    function vote(uint _proposalId, bool _yes) public {
        require(_proposalId < proposalCount, ""Proposal does not exist"");
        require(proposals[_proposalId].active, ""Proposal is not active"");

        uint balance = tokenContract.balanceOf(msg.sender);
        require(balance > 0, ""You have no tokens to vote"");

        bool success = tokenContract.transferFrom(msg.sender, address(this), balance);
        require(success, ""Token transfer failed"");

        if (_yes) {
            proposals[_proposalId].yesVotes += balance;
        } else {
            proposals[_proposalId].noVotes += balance;
        }

        emit Vote(_proposalId, msg.sender, _yes);
    }
}"
2268,"Executes active investment and redemption requests , in a way that minimises information advantages of investor","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AssetInterface {
    function transferFrom(address, address, uint) external returns (bool);
    function transfer(address, uint) external returns (bool);
}

interface PriceFeedInterface {
    function getInterval() external view returns (uint);
    function getLastUpdateId() external view returns (uint);
    function hasRecentPrice(address) external view returns (bool);
    function getInvertedPrice(address) external view returns (bool, uint, uint);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint;

    struct Request {
        address requestAsset;
        address participant;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
        RequestStatus status;
        RequestType requestType;
    }

    enum RequestStatus { active, executed }
    enum RequestType { invest, redeem, tokenFallbackRedeem }

    address public constant NATIVE_ASSET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint public totalSupply;
    bool public isInvestAllowed;
    bool public isRedeemAllowed;
    mapping(uint => Request) public requests;
    mapping(address => uint) public balances;

    PriceFeedInterface public module;

    constructor(PriceFeedInterface _module) {
        module = _module;
    }

    function executeRequest(uint id) external pre_cond(!isShutDown()) pre_cond(requests[id].status == RequestStatus.active) pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) pre_cond(totalSupply == 0 || (block.timestamp >= add(requests[id].timestamp, module.getInterval()) && module.getLastUpdateId() >= add(requests[id].atUpdateId, 2))) {
        Request memory request = requests[id];
        require(module.hasRecentPrice(address(request.requestAsset)));
        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));
        if (request.requestAsset == address(NATIVE_ASSET)) {
            var (isPriceRecent, invertedNativeAssetPrice, nativeAssetDecimal) = module.getInvertedPrice(address(NATIVE_ASSET));
            require(isPriceRecent);
            costQuantity = mul(costQuantity, invertedNativeAssetPrice) / 10**nativeAssetDecimal;
        }
        if (isInvestAllowed && request.requestType == RequestType.invest && costQuantity <= request.giveQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity));
            createShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.redeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.tokenFallbackRedeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(address(this), request.shareQuantity);
        } else {
            revert();
        }
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'getInvertedPrice', 'complexity': 0}, {'function': 'executeRequest', 'complexity': 10}]",18.0,{},"pragma solidity ^0.8.0;

contract RequestExecutor {
    struct Request {
        uint id;
        uint type; // 1 for invest, 2 for redeem
        address participant;
        uint shareQuantity;
        bool executed;
    }

    mapping(uint => Request) public requests;
    uint public nextRequestId = 1;

    function executeRequest(uint id) external {
        require(!isShutdown(), ""System is shut down"");
        Request storage request = requests[id];
        require(!request.executed, ""Request already executed"");
        require(request.status == 1, ""Request not in active status"");

        if (request.type == 2) { // redeem
            require(request.shareQuantity <= getBalance(request.participant), ""Share quantity exceeds balance"");
        }

        uint currentTime = block.timestamp;
        if (totalSupply() > 0) {
            require(currentTime >= request.timestamp + priceFeedInterval(), ""Price feed conditions not met"");
            require(lastUpdateId() >= request.updateId + 2, ""Price feed update ID condition not met"");
        }

        // Update request status to executed
        request.executed = true;

        if (request.type == 1) { // invest
            // Ensure investment is allowed and transfer funds from participant to contract
            // Create shares based on the amount transferred
        } else if (request.type == 2) { // redeem
            // Ensure redemption is allowed and transfer funds from contract to participant
            // Annihilate shares
        } else if (request.type == 3) { // tokenFallbackRedeem
            // Ensure redemption is allowed and transfer funds from contract to participant
            // Annihilate shares from the contract itself
        }
    }

    function isShutdown() internal view returns (bool) {
        // Placeholder for system shutdown check logic
        return false;
    }

    function getBalance(address account) public view returns (uint) {
        // Placeholder for balance retrieval logic
        return 0;
    }

    function totalSupply() internal pure returns (uint) {
        // Placeholder for total supply retrieval logic
        return 0;
    }

    function priceFeedInterval() internal pure returns (uint) {
        // Placeholder for price feed interval retrieval logic
        return 0;
    }

    function lastUpdateId() internal pure returns (uint) {
        // Placeholder for last update ID retrieval logic
        return 0;
    }
}",48.27966809272766,executeRequest,144.0,0.5007613702331604,0.1106780817751838,"[{'function': 'executeRequest', 'complexity': 10}, {'function': 'isShutdown', 'complexity': 0}, {'function': 'getBalance', 'complexity': 0}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'priceFeedInterval', 'complexity': 0}, {'function': 'lastUpdateId', 'complexity': 0}]",16.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RequestExecutor is Ownable {
    struct Request {
        uint id;
        uint type; // 1 for invest, 2 for redeem
        address participant;
        uint shareQuantity;
        bool executed;
    }

    mapping(uint => Request) public requests;
    uint public nextRequestId = 1;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function executeRequest(uint id) external {
        require(!isShutdown(), ""System is shut down"");
        Request storage request = requests[id];
        require(!request.executed, ""Request already executed"");
        require(request.status == 1, ""Request not in active status"");

        if (request.type == 2) { // redeem
            require(request.shareQuantity <= getBalance(request.participant), ""Share quantity exceeds balance"");
        }

        uint currentTime = block.timestamp;
        if (totalSupply() > 0) {
            require(currentTime >= request.timestamp + priceFeedInterval(), ""Price feed conditions not met"");
            require(lastUpdateId() >= request.updateId + 2, ""Price feed update ID condition not met"");
        }

        // Update request status to executed
        request.executed = true;

        if (request.type == 1) { // invest
            // Ensure investment is allowed and transfer funds from participant to contract
            // Create shares based on the amount transferred
        } else if (request.type == 2) { // redeem
            // Ensure redemption is allowed and transfer funds from contract to participant
            // Annihilate shares
        } else if (request.type == 3) { // tokenFallbackRedeem
            // Ensure redemption is allowed and transfer funds from contract to participant
            // Annihilate shares from the contract itself
        }
    }

    function isShutdown() internal view returns (bool) {
        // Placeholder for system shutdown check logic
        return false;
    }

    function getBalance(address account) public view returns (uint) {
        // Placeholder for balance retrieval logic
        return 0;
    }

    function totalSupply() internal pure returns (uint) {
        // Placeholder for total supply retrieval logic
        return 1; // Set to 1 instead of 0
    }

    function priceFeedInterval() internal pure returns (uint) {
        // Placeholder for price feed interval retrieval logic
        return 1; // Set to 1 instead of 0
    }

    function lastUpdateId() internal pure returns (uint) {
        // Placeholder for last update ID retrieval logic
        return 1; // Set to 1 instead of 0
    }
}"
2205,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorContract is Ownable {
    using SafeMath for uint256;

    struct Question {
        bytes32 questionId;
        bytes32 answer;
        address answerer;
        bool answered;
    }

    mapping(bytes32 => Question) public questions;

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external onlyOwner {
        require(!questions[question_id].answered, ""Question already answered"");
        questions[question_id] = Question({
            questionId: question_id,
            answer: answer,
            answerer: answerer,
            answered: true
        });
    }
}","[{'function': 'submitAnswerByArbitrator', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""answer"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""answerer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""answers""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""right"": {""type"": ""Identifier"", ""name"": ""answer""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyArbitrator"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Arbitrator {
    address public owner;
    mapping(uint256 => string) private answers;

    modifier onlyArbitrator() {
        require(msg.sender == owner, ""Only arbitrator can perform this action"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function submitAnswer(uint256 question_id, string memory answer, address answerer) external onlyArbitrator {
        answers[question_id] = answer;
    }
}",42.24335813522339,submitAnswer,14.0,0.5230109987394435,0.0738635933770666,"[{'function': 'submitAnswer', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Arbitrator is Ownable {
    mapping(uint256 => string) private answers;

    modifier onlyArbitrator() {
        require(msg.sender == owner(), ""Only arbitrator can perform this action"");
        _;
    }

    constructor() Ownable() {
        owner = msg.sender;
    }

    function submitAnswer(uint256 question_id, string memory answer, address answerer) external onlyArbitrator {
        answers[question_id] = answer;
    }
}"
6381,Calls transferFrom on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface CompatibleERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
        CompatibleERC20(token).transferFrom(from, to, amount);
        require(previousReturnValue(), ""transferFrom failed"");
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""callData"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""transferFrom(address,address,uint256)""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""callData""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""transferFrom failed""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""success""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract SafeTokenTransfer {
    function transferTokens(address token, address from, address to, uint256 amount) external returns (bool success) {
        // ABI encode the call to transferFrom method
        bytes memory callData = abi.encodeWithSelector(bytes4(keccak256(""transferFrom(address,address,uint256)"")), from, to, amount);

        // Perform the low-level call to the token contract
        (bool success, ) = token.call(callData);

        // Check if the transfer was successful
        require(success, ""transferFrom failed"");

        return success;
    }
}",42.926809310913086,transferTokens,18.0,0.7763352592893099,0.2370681578308078,"[{'function': 'transferTokens', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SafeTokenTransfer is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(address token, address from, address to, uint256 amount) external returns (bool success) {
        // ABI encode the call to transferFrom method
        bytes memory callData = abi.encodeWithSelector(bytes4(keccak256(""transferFrom(address,address,uint256)"")), from, to, amount);

        // Perform the low-level call to the token contract
        (bool success, ) = token.call(callData);

        // Check if the transfer was successful
        require(success, ""transferFrom failed"");

        return success;
    }
}"
5030,Slashes the bond of a guilty trader .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOrderbookContract {
    function orderMatch(bytes32 _orderID) external returns (bytes32);
    function orderTrader(bytes32 _orderID) external view returns (address);
}

interface IRenExBalancesContract {
    function transferBalanceWithFee(address _to, address _from, address _tokenAddress, uint256 _amount, uint256 _fee, bytes32 _data) external;
}

abstract contract Slasher is Ownable {
    using SafeMath for uint256;

    IOrderbookContract public orderbookContract;
    IRenExBalancesContract public renExBalancesContract;
    address public slasherAddress;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = 0x0;

    enum OrderStatus { Pending, Settled, Slashed }

    struct TokenPair {
        address tokenA;
        address tokenB;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftTokenFee;
    }

    mapping(bytes32 => OrderStatus) public orderStatus;
    mapping(bytes32 => bytes32) public orderDetails;

    function slash(bytes32 _guiltyOrderID) external onlyOwner {
        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, ""slashing non-atomic trade"");
        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, ""invalid order status"");
        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);
        require(orderStatus[innocentOrderID] == OrderStatus.Settled, ""invalid order status"");
        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;
        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ? (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);
        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);
        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), orderbookContract.orderTrader(innocentOrderID), settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), slasherAddress, settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
    }
}","[{'function': 'orderTrader', 'complexity': 0}, {'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'slash', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""slash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_guiltyOrderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Order""}, ""name"": ""guiltyOrder"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""orderID""}, ""right"": {""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}}, {""type"": ""stringLiteral"", ""value"": ""Guilty order not found.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""settlementID""}, ""right"": {""type"": ""Identifier"", ""name"": ""RENEX_ATOMIC_SETTLEMENT_ID""}}, {""type"": ""stringLiteral"", ""value"": ""Order is not an atomic trade.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""settled""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Guilty order has already been settled.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""innocentOrderID"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getInnocentOrderID""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Order""}, ""name"": ""innocentOrder"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""innocentOrderID""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""innocentOrder""}, ""memberName"": ""orderID""}, ""right"": {""type"": ""Identifier"", ""name"": ""innocentOrderID""}}, {""type"": ""stringLiteral"", ""value"": ""Innocent order not found.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""innocentOrder""}, ""memberName"": ""settled""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Innocent order has already been settled.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""guiltyIsBuy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""_guiltyOrderID""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x1"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""BooleanLiteral"", ""value"": True}, ""FalseExpression"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""innocentIsBuy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""innocentOrderID""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x1"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""BooleanLiteral"", ""value"": True}, ""FalseExpression"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""guiltyIsBuy""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""trader""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""innocentOrder""}, ""memberName"": ""trader""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""amount""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAtomicFees""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""price""}], ""names"": []}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferBalanceWithFee""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""trader""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""innocentOrder""}, ""memberName"": ""trader""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""amount""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateAtomicFees""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""price""}], ""names"": []}], ""names"": []}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""guiltyOrder""}, ""memberName"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""OrderStatus""}, ""memberName"": ""Slashed""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlySlasher"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""./OrderBook.sol"";
import ""./Token.sol"";

contract Exchange {
    struct Order {
        address trader;
        bool isBuy;
        uint256 amount;
        uint256 price;
        bytes32 orderID;
        bool settled;
    }

    enum OrderStatus { Active, Filled, Canceled, Slashed }

    mapping(bytes32 => Order) public orders;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = keccak256(""RENEX_ATOMIC_SETTLEMENT"");
    address public slasher;
    OrderBook public orderBook;

    modifier onlySlasher() {
        require(msg.sender == slasher, ""Only the designated slasher can call this function."");
        _;
    }

    constructor(address _orderBookAddress) {
        orderBook = OrderBook(_orderBookAddress);
    }

    function setSlasher(address _slasher) external {
        require(msg.sender == slasher, ""Only the current slasher can change the slasher."");
        slasher = _slasher;
    }

    function slash(bytes32 _guiltyOrderID) external onlySlasher {
        Order storage guiltyOrder = orders[_guiltyOrderID];
        require(guiltyOrder.orderID == _guiltyOrderID, ""Guilty order not found."");
        require(guiltyOrder.settlementID == RENEX_ATOMIC_SETTLEMENT_ID, ""Order is not an atomic trade."");
        require(!guiltyOrder.settled, ""Guilty order has already been settled."");

        bytes32 innocentOrderID = getInnocentOrderID(_guiltyOrderID);
        Order storage innocentOrder = orders[innocentOrderID];
        require(innocentOrder.orderID == innocentOrderID, ""Innocent order not found."");
        require(!innocentOrder.settled, ""Innocent order has already been settled."");

        // Determine which is the buy order and which is the sell order
        bool guiltyIsBuy = _guiltyOrderID & 0x1 == 0 ? true : false;
        bool innocentIsBuy = innocentOrderID & 0x1 == 0 ? true : false;

        if (guiltyIsBuy) {
            // Transfer balances with fees from the guilty trader to the innocent trader and the slasher address
            transferBalanceWithFee(guiltyOrder.trader, innocentOrder.trader, guiltyOrder.amount, calculateAtomicFees(guiltyOrder.amount, guiltyOrder.price));
        } else {
            // Transfer balances with fees from the guilty trader to the innocent trader and the slasher address
            transferBalanceWithFee(guiltyOrder.trader, innocentOrder.trader, guiltyOrder.amount, calculateAtomicFees(guiltyOrder.amount, guiltyOrder.price));
        }

        // Set the status of the guilty order to Slashed
        guiltyOrder.status = OrderStatus.Slashed;
    }

    function getInnocentOrderID(bytes32 _guiltyOrderID) internal returns (bytes32) {
        return orderBook.getMatchingOrder(_guiltyOrderID);
    }

    function calculateAtomicFees(uint256 amount, uint256 price) internal pure returns (uint256) {
        // Implement the logic to calculate atomic fees
        return 0; // Placeholder
    }

    function transferBalanceWithFee(address from, address to, uint256 amount, uint256 fee) internal {
        // Implement the logic to transfer balances with fees
    }
}",51.41227436065674,slash,75.0,0.8612724573245472,0.1141421095689999,"[{'function': 'setSlasher', 'complexity': 1}, {'function': 'slash', 'complexity': 10}, {'function': 'getInnocentOrderID', 'complexity': 0}, {'function': 'calculateAtomicFees', 'complexity': 0}, {'function': 'transferBalanceWithFee', 'complexity': 0}]",7.0,"pragma solidity ^0.8.0;

import ""./OrderBook.sol"";
import ""./Token.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Exchange is Ownable {
    struct Order {
        address trader;
        bool isBuy;
        uint256 amount;
        uint256 price;
        bytes32 orderID;
        bool settled;
        OrderStatus status;
    }

    enum OrderStatus { Active, Filled, Canceled, Slashed }

    mapping(bytes32 => Order) public orders;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = keccak256(""RENEX_ATOMIC_SETTLEMENT"");
    address public slasher;
    OrderBook public orderBook;

    modifier onlySlasher() {
        require(msg.sender == slasher, ""Only the designated slasher can call this function."");
        _;
    }

    constructor(address _orderBookAddress) Ownable(msg.sender) {
        orderBook = OrderBook(_orderBookAddress);
    }

    function setSlasher(address _slasher) external onlyOwner {
        require(msg.sender == slasher, ""Only the current slasher can change the slasher."");
        slasher = _slasher;
    }

    function slash(bytes32 _guiltyOrderID) external onlySlasher {
        Order storage guiltyOrder = orders[_guiltyOrderID];
        require(guiltyOrder.orderID == _guiltyOrderID, ""Guilty order not found."");
        require(guiltyOrder.status != OrderStatus.Slashed, ""Order is already slashed."");

        bytes32 innocentOrderID = getInnocentOrderID(_guiltyOrderID);
        Order storage innocentOrder = orders[innocentOrderID];
        require(innocentOrder.orderID == innocentOrderID, ""Innocent order not found."");
        require(innocentOrder.status != OrderStatus.Slashed, ""Innocent order is already slashed."");

        bool guiltyIsBuy = _guiltyOrderID & 0x1 == 0 ? true : false;
        bool innocentIsBuy = innocentOrderID & 0x1 == 0 ? true : false;

        if (guiltyIsBuy) {
            transferBalanceWithFee(guiltyOrder.trader, innocentOrder.trader, guiltyOrder.amount, calculateAtomicFees(guiltyOrder.amount, guiltyOrder.price));
        } else {
            transferBalanceWithFee(guiltyOrder.trader, innocentOrder.trader, guiltyOrder.amount, calculateAtomicFees(guiltyOrder.amount, guiltyOrder.price));
        }

        guiltyOrder.status = OrderStatus.Slashed;
    }

    function getInnocentOrderID(bytes32 _guiltyOrderID) internal returns (bytes32) {
        return orderBook.getMatchingOrder(_guiltyOrderID);
    }

    function calculateAtomicFees(uint256 amount, uint256 price) internal pure returns (uint256) {
        // Implement the logic to calculate atomic fees
        return 0; // Placeholder
    }

    function transferBalanceWithFee(address from, address to, uint256 amount, uint256 fee) internal {
        // Implement the logic to transfer balances with fees
    }
}"
3520,Submit the arbitrator 's answer to a question .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RealityCheck {
    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external;
}

abstract contract ArbitrationWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => bool) public arbitration_bounties;
    RealityCheck public realitycheck;

    constructor(address _realityCheckAddress) {
        realitycheck = RealityCheck(_realityCheckAddress);
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) public onlyOwner {
        delete arbitration_bounties[question_id];
        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
    }
}","[{'function': 'submitAnswerByArbitrator', 'complexity': 0}, {'function': 'submitAnswerByArbitrator', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswerByArbitrator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""answer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""answerer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""arbitrationBounties""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""realitycheck""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""RealityCheck contract address must be set""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""realitycheck""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""submitAnswerByArbitrator(bytes32,bytes32,address)""}, {""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}, {""type"": ""Identifier"", ""name"": ""answerer""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Delegate call to Reality Check failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AnswerSubmitted""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""question_id""}, {""type"": ""Identifier"", ""name"": ""answer""}, {""type"": ""Identifier"", ""name"": ""answerer""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract RealityCheckProtocol is Ownable {
    mapping(bytes32 => bool) public arbitrationBounties;
    address public realitycheck;

    event AnswerSubmitted(bytes32 indexed questionId, bytes32 answer, address indexed answerer);

    modifier onlyRealityCheck() {
        require(msg.sender == realitycheck, ""Only Reality Check contract can call this function"");
        _;
    }

    constructor(address _realitycheck) {
        realitycheck = _realitycheck;
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external onlyOwner {
        // Remove any existing bounty information for the specified question
        delete arbitrationBounties[question_id];

        // Delegate the actual submission of the answer to the Reality Check protocol
        require(realitycheck != address(0), ""RealityCheck contract address must be set"");
        (bool success, ) = realitycheck.call(abi.encodeWithSignature(""submitAnswerByArbitrator(bytes32,bytes32,address)"", question_id, answer, answerer));
        require(success, ""Delegate call to Reality Check failed"");

        emit AnswerSubmitted(question_id, answer, answerer);
    }
}",44.68866515159607,submitAnswerByArbitrator,25.0,0.5926884001684394,0.1756384840734712,"[{'function': 'submitAnswerByArbitrator', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RealityCheckProtocol is Ownable {
    mapping(bytes32 => bool) public arbitrationBounties;
    address public realitycheck;

    event AnswerSubmitted(bytes32 indexed questionId, bytes32 answer, address indexed answerer);

    modifier onlyRealityCheck() {
        require(msg.sender == realitycheck, ""Only Reality Check contract can call this function"");
        _;
    }

    constructor(address _realitycheck) Ownable(_realitycheck) {
        realitycheck = _realitycheck;
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external onlyOwner {
        // Remove any existing bounty information for the specified question
        delete arbitrationBounties[question_id];

        // Delegate the actual submission of the answer to the Reality Check protocol
        require(realitycheck != address(0), ""RealityCheck contract address must be set"");
        (bool success, ) = realitycheck.call(abi.encodeWithSignature(""submitAnswerByArbitrator(bytes32,bytes32,address)"", question_id, answer, answerer));
        require(success, ""Delegate call to Reality Check failed"");

        emit AnswerSubmitted(question_id, answer, answerer);
    }
}"
4614,Withdraw nomins : Allows the owner to withdraw nomins from this contract if needed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawNomins(uint amount) external onlyOwner {
        require(address(nomin).balance >= amount, ""Insufficient balance"");
        nomin.transfer(owner(), amount);
    }
}","[{'function': 'withdrawNomins', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nominToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract WithdrawNomin {
    IERC20 public nominToken;

    constructor(address _nominToken) {
        nominToken = IERC20(_nominToken);
    }

    function withdraw(uint amount) external onlyOwner {
        require(nominToken.transfer(msg.sender, amount), ""Transfer failed"");
    }
}",42.47878503799439,withdraw,12.0,0.8214827092367163,0.3196897888043962,"[{'function': 'withdraw', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WithdrawNomin {
    IERC20 public nominToken;

    constructor(address _nominToken) Ownable(msg.sender) {
        nominToken = IERC20(_nominToken);
    }

    function withdraw(uint amount) external onlyOwner {
        require(nominToken.transfer(msg.sender, amount), ""Transfer failed"");
    }
}"
1147,"Return the final answer to the specified question , provided it matches the specified criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorWrapper {
    using SafeMath for uint256;

    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        bytes32 best_answer;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) external constant returns (bytes32) {
        require(content_hash == questions[question_id].content_hash);
        require(arbitrator == questions[question_id].arbitrator);
        require(min_timeout <= questions[question_id].timeout);
        require(min_bond <= questions[question_id].bond);
        return questions[question_id].best_answer;
    }
}","[{'function': 'getFinalAnswerIfMatches', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getFinalAnswerIfMatches"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""content_hash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""arbitrator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""min_timeout"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""min_bond"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""content_hash""}, ""right"": {""type"": ""Identifier"", ""name"": ""content_hash""}}, {""type"": ""stringLiteral"", ""value"": ""Content hash does not match""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""arbitrator""}, ""right"": {""type"": ""Identifier"", ""name"": ""arbitrator""}}, {""type"": ""stringLiteral"", ""value"": ""Arbitrator address does not match""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""min_timeout""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""timeout""}}, {""type"": ""stringLiteral"", ""value"": ""Timeout too low""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""min_bond""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""bond""}}, {""type"": ""stringLiteral"", ""value"": ""Bond amount too low""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}, ""memberName"": ""best_answer""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract QuestionContract {
    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        string best_answer;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalAnswerIfMatches(
        bytes32 question_id,
        bytes32 content_hash,
        address arbitrator,
        uint32 min_timeout,
        uint256 min_bond
    ) external view returns (string memory) {
        require(questions[question_id].content_hash == content_hash, ""Content hash does not match"");
        require(questions[question_id].arbitrator == arbitrator, ""Arbitrator address does not match"");
        require(min_timeout <= questions[question_id].timeout, ""Timeout too low"");
        require(min_bond <= questions[question_id].bond, ""Bond amount too low"");

        return questions[question_id].best_answer;
    }
}",44.027066230773926,getFinalAnswerIfMatches,8.0,0.9731049360913936,0.4981252943228048,"[{'function': 'getFinalAnswerIfMatches', 'complexity': 0}]",7.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract QuestionContract is Ownable {
    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        string best_answer;
    }

    mapping(bytes32 => Question) public questions;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getFinalAnswerIfMatches(
        bytes32 question_id,
        bytes32 content_hash,
        address arbitrator,
        uint32 min_timeout,
        uint256 min_bond
    ) external view returns (string memory) {
        require(questions[question_id].content_hash == content_hash, ""Content hash does not match"");
        require(questions[question_id].arbitrator == arbitrator, ""Arbitrator address does not match"");
        require(min_timeout <= questions[question_id].timeout, ""Timeout too low"");
        require(min_bond <= questions[question_id].bond, ""Bond amount too low"");

        return questions[question_id].best_answer;
    }
}"
6458,This works even if sender does n't own any tokens at the time .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerToOperators;

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        require(_operator != address(0), ""Operator address must be non-zero"");
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    modifier onlyNonZeroAddress(address addr) {
        require(addr != address(0), ""Address must be non-zero"");
        _;
    }
}","[{'function': 'setApprovalForAll', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operators""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyNonZeroAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AssetApproval {
    mapping(address => mapping(address => bool)) public operators;

    event ApprovalForAll(address owner, address operator, bool approved);

    modifier onlyNonZeroAddress(address _operator) {
        require(_operator != address(0), ""Operator address must be non-zero"");
        _;
    }

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        operators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}",42.79512310028076,setApprovalForAll,9.0,0.8537385724418564,0.5219240284797633,"[{'function': 'setApprovalForAll', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetApproval is Ownable {
    mapping(address => mapping(address => bool)) public operators;

    event ApprovalForAll(address owner, address operator, bool approved);

    modifier onlyNonZeroAddress(address _operator) {
        require(_operator != address(0), ""Operator address must be non-zero"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        operators[address(0)][address(0)] = false; // Default approval for all is false
    }

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        operators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}"
732,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) external onlyOwner {
        require(_to != address(0), ""Invalid recipient address"");
        (bool success, ) = _to.call{value: _value}(_data);
        require(success, ""Transfer failed"");
        if (_log.length > 0) {
            emit LogData(_log);
        }
    }

    event LogData(bytes log);
}","[{'function': 'forceTransfer', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""forceTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_log"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid from address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid to address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""fromBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""memberName"": ""selector""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IToken {
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

contract TokenTransfer {
    IToken public token;

    constructor(address _tokenAddress) {
        token = IToken(_tokenAddress);
    }

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) external {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_value > 0, ""Value must be greater than zero"");

        uint256 fromBalance = token.balanceOf(_from);
        require(fromBalance >= _value, ""Insufficient balance"");

        // Decrease the balance of the `_from` address
        (bool success,) = address(token).call(abi.encodeWithSelector(token.transferFrom.selector, _from, _to, _value));
        require(success, ""Transfer failed"");

        emit Transfer(_from, _to, _value);
    }
}",45.15915632247925,forceTransfer,78.0,0.7195547738089562,0.3513659737140947,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'forceTransfer', 'complexity': 5}]",7.0,"pragma solidity ^0.8.0;

interface IToken {
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    event Transfer(address indexed from, address indexed to, uint256 value);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    IToken public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IToken(_tokenAddress);
    }

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) external {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_value > 0, ""Value must be greater than zero"");

        uint256 fromBalance = token.balanceOf(_from);
        require(fromBalance >= _value, ""Insufficient balance"");

        // Decrease the balance of the `_from` address
        (bool success,) = address(token).call(abi.encodeWithSelector(token.transferFrom.selector, _from, _to, _value));
        require(success, ""Transfer failed"");

        emit Transfer(_from, _to, _value);
    }
}"
442,"Ends the auction , preventing new bids from entering","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Auction {
    using SafeMath for uint256;

    enum state { active, ended }
    state public status;

    constructor() {
        status = state.active;
    }

    function endAuction() public onlyOwner {
        require(status == state.active);
        status = state.ended;
        emit Ended(block.number);
    }

    event Ended(uint256 indexed blockNumber);
}","[{'function': 'endAuction', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""endAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Status""}, ""memberName"": ""Active""}}, {""type"": ""stringLiteral"", ""value"": ""Auction must be active to end""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Status""}, ""memberName"": ""Ended""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Ended""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Auction is Ownable {
    enum Status { Active, Ended }
    Status public status;

    event Ended(uint256 blockNumber);

    constructor() {
        status = Status.Active;
    }

    function endAuction() external onlyOwner {
        require(status == Status.Active, ""Auction must be active to end"");
        status = Status.Ended;
        emit Ended(block.number);
    }
}",42.27334856987,endAuction,1.0,0.8869250990628748,0.4849576058746578,"[{'function': 'endAuction', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    enum Status { Active, Ended }
    Status public status = Status.Active;

    event Ended(uint256 blockNumber);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables are already handled in the base class constructor and here.
    }

    function endAuction() external onlyOwner {
        require(status == Status.Active, ""Auction must be active to end"");
        status = Status.Ended;
        emit Ended(block.number);
    }
}"
3580,Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeValidator {
    using SafeMath for uint256;

    uint256 private _totalAttributeTypes;
    uint256 private _maxValue;
    uint256 private _maxFundsRequired;
    uint256 private _maxValidatorFee;
    uint256 private _signatureLength;

    constructor(uint256 totalAttributeTypes, uint256 maxValue, uint256 maxFundsRequired, uint256 maxValidatorFee, uint256 signatureLength) {
        require(totalAttributeTypes > 0, ""Invalid total attribute types"");
        require(maxValue > 0, ""Invalid maximum value"");
        require(maxFundsRequired > 0, ""Invalid maximum funds required"");
        require(maxValidatorFee >= 0, ""Invalid maximum validator fee"");
        require(signatureLength > 0, ""Invalid signature length"");

        _totalAttributeTypes = totalAttributeTypes;
        _maxValue = maxValue;
        _maxFundsRequired = maxFundsRequired;
        _maxValidatorFee = maxValidatorFee;
        _signatureLength = signatureLength;
    }

    function canAddAttributeFor(address account, uint256 attributeTypeID, uint256 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) external view returns (bool) {
        require(account != address(0), ""Invalid account address"");
        require(attributeTypeID > 0 && attributeTypeID <= _totalAttributeTypes, ""Invalid attribute type ID"");
        require(value >= 0 && value <= _maxValue, ""Invalid value"");
        require(fundsRequired >= 0 && fundsRequired <= _maxFundsRequired, ""Invalid funds required"");
        require(validatorFee >= 0 && validatorFee <= _maxValidatorFee, ""Invalid validator fee"");
        require(signature.length == _signatureLength, ""Invalid signature length"");

        uint256 currentBalance = getCurrentBalanceForAccount(account);
        require(currentBalance >= fundsRequired, ""Insufficient funds"");

        bool isAttributeAdded = isAttributeAlreadyAddedForAccount(account, attributeTypeID);
        require(!isAttributeAdded, ""Attribute already added"");

        return true;
    }

    function getCurrentBalanceForAccount(address account) internal view returns (uint256) {
        // Implement the logic to get the current balance of the account
        // This is a placeholder for the actual implementation
        return 0;
    }

    function isAttributeAlreadyAddedForAccount(address account, uint256 attributeTypeID) internal view returns (bool) {
        // Implement the logic to check if the attribute is already added for the account
        // This is a placeholder for the actual implementation
        return false;
    }
}","[{'function': 'canAddAttributeFor', 'complexity': 13}, {'function': 'getCurrentBalanceForAccount', 'complexity': 0}, {'function': 'isAttributeAlreadyAddedForAccount', 'complexity': 0}]",14.0,"{""type"": ""FunctionDefinition"", ""name"": ""canAddAttributeFor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""value"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fundsRequired"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""validatorFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tx""}, ""memberName"": ""origin""}}, {""type"": ""stringLiteral"", ""value"": ""Only the caller can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""fundsRequired""}, ""right"": {""type"": ""Identifier"", ""name"": ""validatorFee""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient contract balance to cover required funds and validator fee""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isValidSignature"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""validateSignature""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""attributeTypeID""}, {""type"": ""Identifier"", ""name"": ""value""}, {""type"": ""Identifier"", ""name"": ""fundsRequired""}, {""type"": ""Identifier"", ""name"": ""validatorFee""}, {""type"": ""Identifier"", ""name"": ""signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""isValidSignature""}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributes""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributes""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""attributeTypeID""}, ""right"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AttributeManagement {
    // Assuming some role or modifier to check if the caller is authorized to add attributes
    modifier onlyAuthorized() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address public owner;

    struct Attribute {
        uint256 attributeTypeID;
        string value;
    }

    mapping(address => Attribute[]) private attributes;

    constructor() {
        owner = msg.sender;
    }

    function canAddAttributeFor(
        address account,
        uint256 attributeTypeID,
        string memory value,
        uint256 fundsRequired,
        uint256 validatorFee,
        bytes memory signature
    ) public view returns (bool) {
        require(msg.sender == tx.origin, ""Only the caller can call this function"");
        require(address(this).balance >= fundsRequired + validatorFee, ""Insufficient contract balance to cover required funds and validator fee"");

        // Validate signature logic here
        // This is a placeholder for actual signature validation logic
        bool isValidSignature = validateSignature(account, attributeTypeID, value, fundsRequired, validatorFee, signature);
        require(isValidSignature, ""Invalid signature"");

        // Check if the account already has an attribute of the same type
        for (uint256 i = 0; i < attributes[account].length; i++) {
            if (attributes[account][i].attributeTypeID == attributeTypeID) {
                return false;
            }
        }

        return true;
    }

    function validateSignature(
        address account,
        uint256 attributeTypeID,
        string memory value,
        uint256 fundsRequired,
        uint256 validatorFee,
        bytes memory signature
    ) internal pure returns (bool) {
        // Implement actual validation logic here
        return true; // Placeholder for actual implementation
    }
}",46.572200298309326,canAddAttributeFor,62.0,0.7824923173216854,0.2735781491601574,"[{'function': 'canAddAttributeFor', 'complexity': 0}, {'function': 'validateSignature', 'complexity': 0}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttributeManagement is Ownable {
    modifier onlyAuthorized() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    struct Attribute {
        uint256 attributeTypeID;
        string value;
    }

    mapping(address => Attribute[]) private attributes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
    }

    function canAddAttributeFor(
        address account,
        uint256 attributeTypeID,
        string memory value,
        uint256 fundsRequired,
        uint256 validatorFee,
        bytes memory signature
    ) public view returns (bool) {
        require(msg.sender == tx.origin, ""Only the caller can call this function"");
        require(address(this).balance >= fundsRequired + validatorFee, ""Insufficient contract balance to cover required funds and validator fee"");

        // Validate signature logic here
        // This is a placeholder for actual signature validation logic
        bool isValidSignature = validateSignature(account, attributeTypeID, value, fundsRequired, validatorFee, signature);
        require(isValidSignature, ""Invalid signature"");

        // Check if the account already has an attribute of the same type
        for (uint256 i = 0; i < attributes[account].length; i++) {
            if (attributes[account][i].attributeTypeID == attributeTypeID) {
                return false;
            }
        }

        return true;
    }

    function validateSignature(
        address account,
        uint256 attributeTypeID,
        string memory value,
        uint256 fundsRequired,
        uint256 validatorFee,
        bytes memory signature
    ) internal pure returns (bool) {
        // Implement actual validation logic here
        return true; // Placeholder for actual implementation
    }
}"
3476,Called when tokens have to be burned ( only after sale ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    bool public locked = false;
    string public contractName;
    address public depositAddress;
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    event TokensBurned(address indexed from, address indexed to, uint256 value);

    function burnTokens(uint256 _tokens) external {
        require(!locked, ""Contract is locked"");
        require(contractManager.authorize(contractName, msg.sender), ""Unauthorized access"");
        require(depositAddress != address(0), ""Deposit address not set"");
        require(_tokens != 0, ""Tokens amount must be greater than zero"");
        require(_tokens <= balances[depositAddress], ""Insufficient balance to burn tokens"");

        balances[depositAddress] = balances[depositAddress].sub(_tokens);
        totalSupply_ = totalSupply_.sub(_tokens);
        emit TokensBurned(msg.sender, depositAddress, _tokens);
    }
}","[{'function': 'burnTokens', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""depositAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Deposit address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokens""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""depositAddress""}}}, {""type"": ""stringLiteral"", ""value"": ""Burn amount exceeds balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""depositAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokens""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensBurned""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""depositAddress""}, {""type"": ""Identifier"", ""name"": ""_tokens""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuthorized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    address public depositAddress;
    bool public isLocked;

    event TokensBurned(address indexed sender, address indexed depositAddress, uint256 amount);

    modifier onlyAuthorized() {
        require(!isLocked, ""Contract is locked"");
        // Assuming contractManager and contractName are defined elsewhere in the contract
        require(contractManager.isAuthorized(msg.sender, contractName), ""Caller not authorized"");
        _;
    }

    function burnTokens(uint256 _tokens) external onlyAuthorized {
        require(_tokens > 0, ""Amount must be greater than zero"");
        require(depositAddress != address(0), ""Deposit address cannot be zero"");
        require(_tokens <= balances[depositAddress], ""Burn amount exceeds balance"");

        // Subtract the specified number of tokens from the deposit address balance
        balances[depositAddress] -= _tokens;
        totalSupply -= _tokens;

        emit TokensBurned(msg.sender, depositAddress, _tokens);
    }
}",44.17863726615906,burnTokens,27.0,0.7146953996842565,0.4237262158972421,"[{'function': 'burnTokens', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    address public depositAddress;
    bool public isLocked;

    event TokensBurned(address indexed sender, address indexed depositAddress, uint256 amount);

    modifier onlyAuthorized() {
        require(!isLocked, ""Contract is locked"");
        // Assuming contractManager and contractName are defined elsewhere in the contract
        require(contractManager.isAuthorized(msg.sender, contractName), ""Caller not authorized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        balances[depositAddress] = 1; // Set to a non-zero value for deposit balance
        totalSupply = 1000000000000000000; // Set to a non-zero value for total supply
        isLocked = true; // Ensure the contract starts locked
    }

    function burnTokens(uint256 _tokens) external onlyAuthorized {
        require(_tokens > 0, ""Amount must be greater than zero"");
        require(depositAddress != address(0), ""Deposit address cannot be zero"");
        require(_tokens <= balances[depositAddress], ""Burn amount exceeds balance"");

        // Subtract the specified number of tokens from the deposit address balance
        balances[depositAddress] -= _tokens;
        totalSupply -= _tokens;

        emit TokensBurned(msg.sender, depositAddress, _tokens);
    }
}"
1148,Reusable code to do sanity check of transfer variables,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TransferCheckWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    bool public tokenTransfersFrozen;

    function transferCheck(address _sender, address _receiver, uint256 _amount) external view returns (bool success) {
        require(!tokenTransfersFrozen, ""Token transfers are frozen"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_receiver != address(0), ""Receiver address cannot be the zero address"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        require(balances[_receiver] + _amount > balances[_receiver], ""Transfer amount exceeds available balance"");
        return true;
    }
}","[{'function': 'transferCheck', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferCheck"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""tokenTransfersFrozen""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Transfers are frozen""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_receiver""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid receiver address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBalanceReceiver"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_receiver""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newBalanceReceiver""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_receiver""}}}, {""type"": ""stringLiteral"", ""value"": ""Arithmetic overflow detected""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    bool public tokenTransfersFrozen;

    function transferCheck(address _sender, address _receiver, uint256 _amount) external view returns (bool) {
        require(!tokenTransfersFrozen, ""Transfers are frozen"");
        require(_amount > 0, ""Transfer amount must be greater than zero"");
        require(_receiver != address(0), ""Invalid receiver address"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");

        // Check for overflow and ensure safe arithmetic operations
        uint256 newBalanceReceiver = balances[_receiver] + _amount;
        require(newBalanceReceiver > balances[_receiver], ""Arithmetic overflow detected"");

        return true;
    }
}",43.160876512527466,transferCheck,11.0,0.9461493522621522,0.6498878572938049,"[{'function': 'transferCheck', 'complexity': 6}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    bool public tokenTransfersFrozen;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        balances[msg.sender] = 1000; // Initial balance for the owner
        tokenTransfersFrozen = false; // Transfers are not frozen initially
    }

    function transferCheck(address _sender, address _receiver, uint256 _amount) external view returns (bool) {
        require(!tokenTransfersFrozen, ""Transfers are frozen"");
        require(_amount > 0, ""Transfer amount must be greater than zero"");
        require(_receiver != address(0), ""Invalid receiver address"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");

        // Check for overflow and ensure safe arithmetic operations
        uint256 newBalanceReceiver = balances[_receiver] + _amount;
        require(newBalanceReceiver > balances[_receiver], ""Arithmetic overflow detected"");

        return true;
    }
}"
5952,Sets the contract that will handle a specific interface ; only the address itself or a ` manager ` defined for that address can set it,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InterfaceImplementerWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed iHash, address implementer);

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public onlyOwner {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }
}","[{'function': 'setInterfaceImplementer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setInterfaceImplementer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""iHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""implementer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""interfaces""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""index"": {""type"": ""Identifier"", ""name"": ""iHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""implementer""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InterfaceImplementerSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}, {""type"": ""Identifier"", ""name"": ""iHash""}, {""type"": ""Identifier"", ""name"": ""implementer""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canManage"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed iHash, address implementer);

    modifier canManage(address _addr) {
        // Access control logic here
        require(canManageImplementation(_addr), ""Access denied"");
        _;
    }

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public canManage(addr) {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }

    function canManageImplementation(address _addr) internal view returns (bool) {
        // Implement your access control logic here
        return true; // Example: always allow for demonstration purposes
    }
}",43.41141319274902,setInterfaceImplementer,1.0,0.9125167718370814,0.8169276475307028,"[{'function': 'setInterfaceImplementer', 'complexity': 0}, {'function': 'canManageImplementation', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed iHash, address implementer);

    modifier canManage(address _addr) {
        // Access control logic here
        require(canManageImplementation(_addr), ""Access denied"");
        _;
    }

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public canManage(addr) {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }

    function canManageImplementation(address _addr) internal view returns (bool) {
        // Implement your access control logic here
        return true; // Example: always allow for demonstration purposes
    }

    constructor() Ownable(msg.sender) {
        interfaces[address(0x111)][bytes32('init')] = address(0x111);
        interfaces[address(0x222)][bytes32('init')] = address(0x222);
        interfaces[address(0x333)][bytes32('init')] = address(0x333);
    }
}"
5131,Function to know how many tokens you will receive at current time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenPrice {
    function USD(uint256 index) external view returns (uint256);
}

abstract contract TokenCalculator is Ownable {
    using SafeMath for uint256;

    ITokenPrice public price;

    constructor(address _priceAddress) {
        price = ITokenPrice(_priceAddress);
    }

    function calculateTokens(uint256 _amountOfWei) public view returns (uint256) {
        require(_amountOfWei >= 1 szabo, ""Amount must be at least 1 szabo"");
        uint256 tokenBought;
        uint256 tokenPrice = price.USD(0);
        tokenPrice = tokenPrice.mul(36).div(10 ** 8);
        tokenBought = _amountOfWei.div(tokenPrice);
        tokenBought = tokenBought.mul(10 ** 10);
        if (_amountOfWei >= 10 ether) {
            tokenBought = tokenBought.mul(123).div(100);
        } else if (_amountOfWei >= 1 ether) {
            tokenBought = tokenBought.mul(11).div(10);
        }
        return tokenBought;
    }
}","[{'function': 'USD', 'complexity': 0}, {'function': 'calculateTokens', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amountOfWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""15"", ""subdenomination"": None}}}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be at least 1 szabo""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""tokenPriceInEther"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""tokenPriceInWei""}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}], ""isArray"": False}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""adjustedTokenPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenPriceInEther""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""36"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""tokensBought"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""adjustedTokenPrice""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""TOKEN_UNIT""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""123"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_amountOfWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""tokensBought""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""11"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}}}]}, ""FalseBody"": None}}, {""type"": ""Identifier"", ""name"": ""tokensBought""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract TokenSale {
    uint public tokenPriceInWei = 1 * 10**15; // 0.001 Ether in Wei (1 szabo)
    uint public constant TOKEN_UNIT = 10**10;

    function calculateTokens(uint _amountOfWei) external pure returns (uint) {
        require(_amountOfWei >= 1 * 10**15, ""Amount must be at least 1 szabo""); // 1 szabo is 0.000001 Ether or 1 * 10^15 Wei

        uint tokenPriceInEther = (tokenPriceInWei) / (1 ether);
        uint adjustedTokenPrice = tokenPriceInEther * 36;
        uint tokensBought = (_amountOfWei / adjustedTokenPrice) * TOKEN_UNIT;

        if (_amountOfWei >= 10 ether) {
            tokensBought = (tokensBought * 123) / 100;
        } else if (_amountOfWei >= 1 ether) {
            tokensBought = (tokensBought * 11) / 10;
        }

        return tokensBought;
    }
}",44.68001794815064,calculateTokens,36.0,0.7435746291633889,0.3242973687383174,"[{'function': 'calculateTokens', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    uint public tokenPriceInWei = 1 * 10**15; // 0.001 Ether in Wei (1 szabo)
    uint public constant TOKEN_UNIT = 10**10;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        tokenPriceInWei = 1 * 10**15; // Set to fixed value as per rule
    }

    function calculateTokens(uint _amountOfWei) external pure returns (uint) {
        require(_amountOfWei >= 1 * 10**15, ""Amount must be at least 1 szabo""); // 1 szabo is 0.000001 Ether or 1 * 10^15 Wei

        uint tokenPriceInEther = (tokenPriceInWei) / (1 ether);
        uint adjustedTokenPrice = tokenPriceInEther * 36;
        uint tokensBought = (_amountOfWei / adjustedTokenPrice) * TOKEN_UNIT;

        if (_amountOfWei >= 10 ether) {
            tokensBought = (tokensBought * 123) / 100;
        } else if (_amountOfWei >= 1 ether) {
            tokensBought = (tokensBought * 11) / 10;
        }

        return tokensBought;
    }
}"
725,Checks whether an address is whitelisted in the competition contract and competition is active,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CompetitionWhitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public isWhitelisted;

    function isCompetitionAllowed(address user) public view returns (bool) {
        return isWhitelisted[user];
    }
}","[{'function': 'isCompetitionAllowed', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkCompetitionEligibility"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isWhitelisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CompetitionChecker {
    mapping(address => bool) public isWhitelisted;

    function checkCompetitionEligibility(address user) external view returns (bool) {
        return isWhitelisted[user];
    }
}",41.507288455963135,checkCompetitionEligibility,0.0,0.9033090253146598,0.6865065103648591,"[{'function': 'checkCompetitionEligibility', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CompetitionChecker is Ownable {
    mapping(address => bool) public isWhitelisted;
    address public constant WHITELISTED_USER = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        isWhitelisted[msg.sender] = true;
    }

    function checkCompetitionEligibility(address user) external view returns (bool) {
        return isWhitelisted[user];
    }
}"
3756,The sender casts a vote in favour of confiscation of the target account 's nomin balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Voting {
    function setupVote(uint motionID) external returns (uint);
}

abstract contract VoteWrapper is Ownable {
    using SafeMath for uint;

    enum Vote { None, Yea, Nay }

    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    function voteFor(uint motionID, address votingContractAddress) external {
        require(votingContractAddress.call(abi.encodeWithSignature(""setupVote(uint256)"", motionID)), ""Failed to call setupVote"");
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] = votesFor[motionID].add(1);
        emit VotedFor(msg.sender, motionID, 1);
    }
}","[{'function': 'setupVote', 'complexity': 0}, {'function': 'voteFor', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""castYeaVote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""motionID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""weight"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""setupVote""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""motionID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""weight""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid weight""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vote""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""motionID""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Vote""}, ""memberName"": ""Yea""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""votesFor""}, ""index"": {""type"": ""Identifier"", ""name"": ""motionID""}}, ""right"": {""type"": ""Identifier"", ""name"": ""weight""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""VotedFor""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""motionID""}, {""type"": ""Identifier"", ""name"": ""weight""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Voting {
    enum Vote { None, Yea, Nay }

    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    function castYeaVote(uint motionID) external {
        // Assuming `setupVote` returns the weight of the vote based on the voter's stake or influence.
        uint weight = setupVote(motionID);

        require(weight > 0, ""Invalid weight"");

        // Record the user's ""Yea"" vote.
        vote[msg.sender][motionID] = Vote.Yea;

        // Update the total votes for this motion using a safe addition function to prevent overflow.
        votesFor[motionID] += weight;

        emit VotedFor(msg.sender, motionID, weight);
    }

    function setupVote(uint motionID) internal view returns (uint) {
        // Implement the logic to determine the weight of the vote based on the voter's stake or influence.
        return 1; // Placeholder for actual implementation.
    }
}",44.383381366729736,castYeaVote,21.0,0.8172719477863164,0.1509583259510592,"[{'function': 'castYeaVote', 'complexity': 1}, {'function': 'setupVote', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Voting is Ownable {
    enum Vote { None, Yea, Nay }

    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i) << 96);
            vote[addr][1] = Vote.Yea; // Example initialization for a specific motionID and voter
            votesFor[1] = 1; // Initialize total votes for motionID 1
        }
    }

    function castYeaVote(uint motionID) external {
        uint weight = setupVote(motionID);
        require(weight > 0, ""Invalid weight"");
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] += weight;
        emit VotedFor(msg.sender, motionID, weight);
    }

    function setupVote(uint motionID) internal view returns (uint) {
        return 1; // Placeholder for actual implementation
    }
}"
4311,Sets prizes for last tokens and sets prize pool amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, WinnersAssigned, Finished }
    pointsValidationState public pValidationState;
    uint256 public gameFinishedTime;
    uint256 public adminPool;
    uint256 public prizePool;

    function setEnd() external onlyOwner checkState(pointsValidationState.WinnersAssigned) {
        uint256 balance = address(this).balance;
        adminPool = balance.mul(10).div(100);
        prizePool = balance.mul(90).div(100);
        pValidationState = pointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
        unSetPause();
    }

    function checkState(pointsValidationState state) internal view {
        require(pValidationState == state, ""Invalid state"");
    }

    function unSetPause() internal {
        // Implementation of unSetPause logic
    }
}","[{'function': 'setEnd', 'complexity': 0}, {'function': 'checkState', 'complexity': 1}, {'function': 'unSetPause', 'complexity': 0}]",1.0,{},"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GameManager {
    enum PointsValidationState { NotStarted, InProgress, Finished, WinnersAssigned }
    PointsValidationState private pValidationState;
    uint256 public gameFinishedTime;
    address public admin;

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier checkState() {
        require(pValidationState == PointsValidationState.WinnersAssigned, ""Invalid state to finish the game"");
        _;
    }

    constructor(address _admin) {
        admin = _admin;
        pValidationState = PointsValidationState.InProgress;
    }

    function setEndOfGame() external onlyAdmin checkState {
        uint256 balance = address(this).balance;
        uint256 adminPoolAmount = balance / 10;
        uint256 prizePoolAmount = balance - adminPoolAmount;

        (bool success, ) = payable(admin).call{value: adminPoolAmount}("""");
        require(success, ""Transfer to admin failed"");

        (bool successPrize, ) = payable(msg.sender).call{value: prizePoolAmount}("""");
        require(successPrize, ""Transfer to prize pool failed"");

        pValidationState = PointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
    }

    function unSetPause() internal {
        // Placeholder for the actual pause removal logic if needed
    }
}",45.23146605491638,setEndOfGame,47.0,0.8108569276148839,0.1569943172758113,"[{'function': 'setEndOfGame', 'complexity': 2}, {'function': 'unSetPause', 'complexity': 0}]",3.0,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GameManager is Ownable {
    enum PointsValidationState { NotStarted, InProgress, Finished, WinnersAssigned }
    PointsValidationState private pValidationState;
    uint256 public gameFinishedTime;

    modifier onlyAdmin() {
        require(msg.sender == owner(), ""Only admin can call this function"");
        _;
    }

    modifier checkState() {
        require(pValidationState == PointsValidationState.WinnersAssigned, ""Invalid state to finish the game"");
        _;
    }

    constructor(address _admin) Ownable(_admin) {
        pValidationState = PointsValidationState.InProgress;
    }

    function setEndOfGame() external onlyAdmin checkState {
        uint256 balance = address(this).balance;
        uint256 adminPoolAmount = balance / 10;
        uint256 prizePoolAmount = balance - adminPoolAmount;

        (bool success, ) = payable(owner()).call{value: adminPoolAmount}("""");
        require(success, ""Transfer to admin failed"");

        (bool successPrize, ) = payable(msg.sender).call{value: prizePoolAmount}("""");
        require(successPrize, ""Transfer to prize pool failed"");

        pValidationState = PointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
    }

    function unSetPause() internal {
        // Placeholder for the actual pause removal logic if needed
    }
}"
5253,Renouncing to ownership will leave the contract without an owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function renounceOwnership() public override onlyOwner {
        emit OwnershipRenounced(owner());
        _transferOwnership(address(0));
    }
}","[{'function': 'renounceOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipRenounced""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""contract_onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipRenounced(address indexed previousOwner);

    modifier contract_onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    constructor() {
        _owner = msg.sender;
    }

    function pose() public virtual contract_onlyOwner {
        emit OwnershipRenounced(_owner);
        _owner = address(0);
    }
}",42.81216979026794,pose,2.0,0.8036642108920644,0.2889649116814955,"[{'function': 'pose', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    event OwnershipRenounced(address indexed previousOwner);

    modifier contract_onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    constructor() {
        _owner = msg.sender;
    }

    function pose() public virtual contract_onlyOwner {
        emit OwnershipRenounced(_owner);
        _owner = address(0);
    }
}"
86,` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public maxSecurityGuardDelay;

    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) external onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}","[{'function': 'setMaxSecurityGuardDelay', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMaxSecurityGuardDelay"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxSecurityGuardDelay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxSecurityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxSecurityGuardDelay""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract SecurityGuardDelay is Ownable {
    uint256 public maxSecurityGuardDelay;

    constructor(uint256 initialDelay) {
        maxSecurityGuardDelay = initialDelay;
    }

    function setMaxSecurityGuardDelay(uint256 _maxSecurityGuardDelay) external onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}",42.44990086555481,setMaxSecurityGuardDelay,0.0,0.9788746434256904,0.7611606003349892,"[{'function': 'setMaxSecurityGuardDelay', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SecurityGuardDelay is Ownable {
    uint256 public maxSecurityGuardDelay;

    constructor(uint256 initialDelay) Ownable(msg.sender) {
        maxSecurityGuardDelay = initialDelay != 0 ? initialDelay : 1;
    }

    function setMaxSecurityGuardDelay(uint256 _maxSecurityGuardDelay) external onlyOwner {
        require(_maxSecurityGuardDelay > 0, ""Delay must be greater than zero"");
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}"
3464,_addModule handles the attachment ( or replacement ) of modules for the ST,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IModuleRegistry {
    function getType() external view returns (uint8);
}

interface IModuleFactory {
    function setupCost() external view returns (uint256);
    function deploy(bytes calldata) external returns (address);
    function getName() external view returns (bytes32);
}

interface ERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ModuleRegistryWrapper is Ownable {
    using SafeMath for uint256;

    struct ModuleData {
        bytes32 name;
        address module;
    }

    mapping(uint8 => ModuleData[]) public modules;
    address public polyToken;
    uint8 constant MAX_MODULES = 10;

    event LogModuleAdded(uint8 indexed moduleType, bytes32 indexed moduleName, address indexed moduleFactory, address module, uint256 cost, uint256 budget, uint256 timestamp);

    function _addModule(address _moduleFactory, bytes memory _data, uint256 _maxCost, uint256 _budget) internal {
        IModuleRegistry moduleRegistry = IModuleRegistry(_moduleFactory);
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint8 moduleType = moduleFactory.getType();
        require(modules[moduleType].length < MAX_MODULES, ""Limit of MAX MODULES is reached"");
        uint256 moduleCost = moduleFactory.setupCost();
        require(moduleCost <= _maxCost, ""Max Cost is always be greater than module cost"");
        require(ERC20(polyToken).approve(_moduleFactory, moduleCost), ""Not able to approve the module cost"");
        address module = moduleFactory.deploy(_data);
        require(ERC20(polyToken).approve(module, _budget), ""Not able to approve the budget"");
        bytes32 moduleName = moduleFactory.getName();
        modules[moduleType].push(ModuleData(moduleName, module));
        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, block.timestamp);
    }
}","[{'function': 'getType', 'complexity': 0}, {'function': 'getName', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': '_addModule', 'complexity': 4}]",8.0,{},"pragma solidity ^0.8.0;

interface ModuleFactory {
    function createModule(bytes memory data) external returns (address);
    function getModuleName() external view returns (string memory);
}

contract ModuleRegistry {
    address public moduleFactory;

    constructor(address _moduleFactory) {
        moduleFactory = _moduleFactory;
    }

    function addModule(bytes calldata _data, uint256 _maxCost, uint256 _budget) external {
        ModuleFactory factory = ModuleFactory(moduleFactory);
        address deployedAddress = factory.createModule(_data);
        require(deployedAddress != address(0), ""Deployment failed"");

        string memory moduleName = factory.getModuleName();
        // Assuming modules is a state variable array to store ModuleData
        modules.push(ModuleData({name: moduleName, address: deployedAddress}));

        emit LogModuleAdded(moduleType, moduleName, moduleFactory, deployedAddress, _maxCost, _budget, block.timestamp);
    }
}",44.0263946056366,addModule,108.0,0.6491985320814913,0.1714262308014984,"[{'function': 'getModuleName', 'complexity': 0}, {'function': 'addModule', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface ModuleFactory {
    function createModule(bytes memory data) external returns (address);
    function getModuleName() external view returns (string memory);
}
import ""openzeppelin/SafeMath.sol"";
contract ModuleRegistry is Ownable {
    address public moduleFactory;
    ModuleData[] public modules;

    event LogModuleAdded(string indexed moduleType, string indexed moduleName, address indexed factoryAddress, address deployedAddress, uint256 maxCost, uint256 budget, uint256 timestamp);

    struct ModuleData {
        string name;
        address address;
    }

    constructor(address _moduleFactory) Ownable() {
        moduleFactory = _moduleFactory;
    }

    function addModule(bytes calldata _data, uint256 _maxCost, uint256 _budget) external {
        ModuleFactory factory = ModuleFactory(moduleFactory);
        address deployedAddress = factory.createModule(_data);
        require(deployedAddress != address(0), ""Deployment failed"");

        string memory moduleName = factory.getModuleName();
        modules.push(ModuleData({name: moduleName, address: deployedAddress}));

        emit LogModuleAdded("""", moduleName, moduleFactory, deployedAddress, _maxCost, _budget, block.timestamp);
    }
}"
2419,Return the permissions flag that are associated with Module,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionsContract is Ownable {
    using SafeMath for uint256;

    bytes32[] private permissions;

    function getPermissions() public view returns (bytes32[]) {
        return permissions;
    }
}","[{'function': 'getPermissions', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPermissions"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""permissions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract PermissionContract {
    mapping(address => bytes32[]) private permissions;

    function getPermissions() public view returns (bytes32[] memory) {
        return permissions[msg.sender];
    }
}",41.55459380149841,getPermissions,3.0,0.7382706846109846,0.6606328636027614,"[{'function': 'getPermissions', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PermissionContract is Ownable {
    mapping(address => bytes32[]) private permissions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getPermissions() public view returns (bytes32[] memory) {
        return permissions[msg.sender];
    }
}"
3265,"Called by the owner to unpause , returns to normal state","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused;

    event Unpause(uint256 timestamp);

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function _unpause() internal whenPaused {
        paused = false;
        emit Unpause(block.timestamp);
    }
}","[{'function': '_unpause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Unpause""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Pausable {
    bool internal paused = true;

    event Unpause(uint256 timestamp);

    modifier whenPaused() {
        require(paused, ""Contract is not paused"");
        _;
    }

    function _unpause() internal whenPaused {
        paused = false;
        emit Unpause(block.timestamp);
    }
}",42.07740831375122,_unpause,0.0,1.0,1.0,"[{'function': '_unpause', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Pausable is Ownable {
    bool internal paused = true;

    event Unpause(uint256 timestamp);

    modifier whenPaused() {
        require(paused, ""Contract is not paused"");
        _;
    }

    function _unpause() public onlyOwner whenPaused {
        paused = false;
        emit Unpause(block.timestamp);
    }
}"
1244,Returns all the relevant information about a specific grey .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GreyWrapper {
    using SafeMath for uint256;

    struct Grey {
        string name;
    }

    mapping(uint256 => Grey) private greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    function getGrey(uint256 _tokenId) public view returns (string memory, uint256, address, uint256, address[5] memory) {
        Grey storage grey = greys[_tokenId];
        return (grey.name, greyIndexToPrice[_tokenId], greyIndexToOwner[_tokenId], greyIndexToPreviousPrice[_tokenId], greyIndexToPreviousOwners[_tokenId]);
    }
}","[{'function': 'getGrey', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getGrey"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grey""}, ""name"": ""grey"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greys""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grey""}, ""memberName"": ""name""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToPreviousPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greyIndexToPreviousOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract GreyMarket {
    struct Grey {
        string name;
        uint256 sellingPrice;
        address owner;
        uint256 previousPrice;
        address[5] previousOwners;
    }

    mapping(uint256 => Grey) public greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    function getGrey(uint256 _tokenId) public view returns (string memory, uint256, address, uint256, address[5] memory) {
        Grey storage grey = greys[_tokenId];
        return (grey.name, greyIndexToPrice[_tokenId], greyIndexToOwner[_tokenId], greyIndexToPreviousPrice[_tokenId], greyIndexToPreviousOwners[_tokenId]);
    }
}",44.20260524749756,getGrey,0.0,1.0,1.0,"[{'function': 'getGrey', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GreyMarket is Ownable {
    struct Grey {
        string name;
        uint256 sellingPrice;
        address owner;
        uint256 previousPrice;
        address[5] previousOwners;
    }

    mapping(uint256 => Grey) public greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 10; i++) {
            greys[i] = Grey({
                name: 'initialized',
                sellingPrice: 1,
                owner: address(uint160(i + 1)),
                previousPrice: 0,
                previousOwners: [address(uint160(i + 2)), address(uint160(i + 3)), address(uint160(i + 4)), address(uint160(i + 5)), address(uint160(i + 6))]
            });
            greyIndexToPrice[i] = 1;
            greyIndexToOwner[i] = address(uint160(i + 1));
            greyIndexToPreviousPrice[i] = 0;
            for (uint256 j = 0; j < 5; j++) {
                greyIndexToPreviousOwners[i][j] = address(uint160(i + 2 + j));
            }
        }
    }

    function getGrey(uint256 _tokenId) public view returns (string memory, uint256, address, uint256, address[5] memory) {
        Grey storage grey = greys[_tokenId];
        return (grey.name, greyIndexToPrice[_tokenId], greyIndexToOwner[_tokenId], greyIndexToPreviousPrice[_tokenId], greyIndexToPreviousOwners[_tokenId]);
    }
}"
1531,This method may be deprecated or refactored to allow for multiple interfaces,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LibStorage {
    function setBool(bytes32 id, bool value) external returns (bool);
}

interface TokenXInterface {
    function setAssetCurrency(address asset, string memory currency) external returns (bool);
}

abstract contract TokenXWrapper is Ownable {
    using SafeMath for uint256;

    LibStorage public lib;
    TokenXInterface public tokenX;

    constructor(address _libAddress, address _tokenXAddress) {
        lib = LibStorage(_libAddress);
        tokenX = TokenXInterface(_tokenXAddress);
    }

    function setTokenXCurrency(address asset, string memory currency) public onlyOwner returns (bool success) {
        bytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));
        require(lib.setBool(id, true), ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."");
        require(tokenX.setAssetCurrency(asset, currency), ""Error: Failed to set asset currency."");
        return true;
    }
}","[{'function': 'setBool', 'complexity': 0}, {'function': 'setAssetCurrency', 'complexity': 0}, {'function': 'setTokenXCurrency', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTokenXCurrency"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""asset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isDeprecated""}, ""arguments"": [], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Contract is deprecated""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""tokenx""}, {""type"": ""Identifier"", ""name"": ""asset""}, {""type"": ""Identifier"", ""name"": ""currency""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IStorage""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""storageContract""}], ""names"": []}, ""memberName"": ""setValue""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""setAssetCurrency(address,string)""}, {""type"": ""Identifier"", ""name"": ""asset""}, {""type"": ""Identifier"", ""name"": ""currency""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Failed to call setAssetCurrency""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/cryptography/Keccak256.sol"";

interface IStorage {
    function setValue(bytes32 id, bool value) external;
}

contract TokenX is Ownable {
    using Keccak256 for bytes;

    address public immutable storageContract;

    constructor(address _storageContract) {
        storageContract = _storageContract;
    }

    function setTokenXCurrency(address asset, string memory currency) external onlyOwner {
        require(!isDeprecated(), ""Contract is deprecated"");

        bytes32 id = keccak256(abi.encodePacked(""tokenx"", asset, currency));
        IStorage(storageContract).setValue(id, true);

        // Call the internal function setAssetCurrency with the asset address and currency string
        (bool success, ) = address(this).call(abi.encodeWithSignature(""setAssetCurrency(address,string)"", asset, currency));
        require(success, ""Failed to call setAssetCurrency"");
    }

    // Dummy internal function for demonstration purposes
    function setAssetCurrency(address asset, string memory currency) internal {
        // Implementation of the internal function
    }

    // Dummy modifier for contract deprecation check (replace with actual logic if needed)
    bool private deprecated = false;
    function isDeprecated() public view returns (bool) {
        return deprecated;
    }
}",45.28786778450012,setTokenXCurrency,25.0,0.8198188836265415,0.3169771442867335,"[{'function': 'setValue', 'complexity': 0}, {'function': 'setTokenXCurrency', 'complexity': 3}, {'function': 'setAssetCurrency', 'complexity': 0}, {'function': 'isDeprecated', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/cryptography/Keccak256.sol"";

interface IStorage {
    function setValue(bytes32 id, bool value) external;
}
import ""openzeppelin/SafeMath.sol"";
contract TokenX is Ownable {
    using Keccak256 for bytes;

    address public immutable storageContract;

    constructor(address _storageContract) Ownable(msg.sender) {
        storageContract = _storageContract;
    }

    function setTokenXCurrency(address asset, string memory currency) external onlyOwner {
        require(!isDeprecated(), ""Contract is deprecated"");

        bytes32 id = keccak256(abi.encodePacked(""tokenx"", asset, currency));
        IStorage(storageContract).setValue(id, true);

        // Call the internal function setAssetCurrency with the asset address and currency string
        (bool success, ) = address(this).call(abi.encodeWithSignature(""setAssetCurrency(address,string)"", asset, currency));
        require(success, ""Failed to call setAssetCurrency"");
    }

    // Dummy internal function for demonstration purposes
    function setAssetCurrency(address asset, string memory currency) internal {
        // Implementation of the internal function
    }

    // Dummy modifier for contract deprecation check (replace with actual logic if needed)
    bool private deprecated = false;
    function isDeprecated() public view returns (bool) {
        return deprecated;
    }
}"
4775,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public totalTokensSold;
    uint256 public cap;

    function capReached() public view returns (bool) {
        return totalTokensSold >= cap;
    }
}","[{'function': 'capReached', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""hasReachedCap"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalTokensSold""}, ""right"": {""type"": ""Identifier"", ""name"": ""cap""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TokenSale {
    uint public cap = 1000; // Example cap value
    uint public totalTokensSold;

    function hasReachedCap() external view returns (bool) {
        return totalTokensSold >= cap;
    }
}",41.66384148597717,hasReachedCap,0.0,0.9364438313731684,0.7098108717509044,"[{'function': 'hasReachedCap', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    uint public cap = 1000; // Example cap value
    uint public totalTokensSold;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        cap = 1000;
        totalTokensSold = 0;
    }

    function hasReachedCap() external view returns (bool) {
        return totalTokensSold >= cap;
    }
}"
39,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    function createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) public payable onlyOwner {
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        // Implementation of the function
    }
}","[{'function': 'createDividendWithCheckpointAndExclusions', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maturity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_checkpointId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excluded"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_name"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_maturity""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Maturity must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expiry""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maturity""}}, {""type"": ""stringLiteral"", ""value"": ""Expiry must be after maturity""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_checkpointId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Checkpoint ID cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_name""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Name cannot be empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createDividendWithCheckpointAndExclusions""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maturity""}, {""type"": ""Identifier"", ""name"": ""_expiry""}, {""type"": ""Identifier"", ""name"": ""_checkpointId""}, {""type"": ""Identifier"", ""name"": ""_excluded""}, {""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""withPerm"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract DividendManager {
    error InsufficientPermission();

    modifier withPerm(address _caller) {
        if (!isManage(_caller)) {
            revert InsufficientPermission();
        }
        _;
    }

    function createDividend(uint256 _maturity, uint256 _expiry, bytes32 _checkpointId, address[] memory _excluded, bytes32 _name) public payable withPerm(msg.sender) {
        require(_maturity > block.timestamp, ""Maturity must be in the future"");
        require(_expiry > _maturity, ""Expiry must be after maturity"");
        require(_checkpointId != 0, ""Checkpoint ID cannot be zero"");
        require(_name != 0, ""Name cannot be empty"");

        // Call internal function to create dividend with checkpoint and exclusions
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
    }

    function isManage(address _caller) public view returns (bool) {
        // Implement your permission logic here. For example:
        // return hasRole(MANAGE_ROLE, _caller);
        // This would require a role management system to be set up.
        revert(""Not implemented""); // Placeholder for actual implementation
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, bytes32 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        // Implement the logic to create a dividend with the specified parameters.
        // This is just a placeholder for actual implementation details.
    }
}",46.07058143615723,createDividend,31.0,0.5708070287135463,0.2730265191019062,"[{'function': 'createDividend', 'complexity': 4}, {'function': 'isManage', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DividendManager is Ownable {
    error InsufficientPermission();

    modifier withPerm(address _caller) {
        if (!isManage(_caller)) {
            revert InsufficientPermission();
        }
        _;
    }

    function createDividend(uint256 _maturity, uint256 _expiry, bytes32 _checkpointId, address[] memory _excluded, bytes32 _name) public payable withPerm(msg.sender) {
        require(_maturity > block.timestamp, ""Maturity must be in the future"");
        require(_expiry > _maturity, ""Expiry must be after maturity"");
        require(_checkpointId != 0, ""Checkpoint ID cannot be zero"");
        require(_name != 0, ""Name cannot be empty"");

        // Call internal function to create dividend with checkpoint and exclusions
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
    }

    function isManage(address _caller) public view returns (bool) {
        // Implement your permission logic here. For example:
        // return hasRole(MANAGE_ROLE, _caller);
        // This would require a role management system to be set up.
        revert(""Not implemented""); // Placeholder for actual implementation
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, bytes32 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        // Implement the logic to create a dividend with the specified parameters.
        // This is just a placeholder for actual implementation details.
    }
}"
2566,Prevents the seller from cancelling an escrow .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EscrowContract {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        uint256 sellerCanCancelAfter;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
    }

    mapping(bytes32 => Escrow) public escrows;
    bytes32[] public tradeHashes;
    address public relayer;
    uint256 public constant GAS_doDisableSellerCancel = 50000;

    event SellerCancelDisabled(bytes32 indexed tradeHash);

    function doDisableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
        if (!_escrow.exists) return false;
        if (_escrow.sellerCanCancelAfter == 0) return false;
        escrows[_tradeHash].sellerCanCancelAfter = 0;
        emit SellerCancelDisabled(_tradeHash);
        if (msg.sender == relayer) {
            increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
        }
        return true;
    }

    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) public pure returns (Escrow memory, bytes32) {
        Escrow memory escrow = Escrow({
            exists: true,
            sellerCanCancelAfter: block.timestamp + 1 days, // Example value for demonstration
            seller: _seller,
            buyer: _buyer,
            value: _value,
            fee: _fee
        });

        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
        return (escrow, tradeHash);
    }

    function increaseGasSpent(bytes32 _tradeHash, uint256 _gasAmount) public {
        // Implementation of increasing gas spent
    }
}","[{'function': 'doDisableSellerCancel', 'complexity': 2}, {'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'increaseGasSpent', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""disableSellerCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_tradeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint16""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint128""}, ""name"": ""_additionalGas"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_seller""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid seller address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_buyer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid buyer address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""tradeHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tradeID""}, {""type"": ""Identifier"", ""name"": ""_seller""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_additionalGas""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""EscrowInfo""}, ""name"": ""escrow"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tradeID""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""memberName"": ""seller""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Escrow does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""memberName"": ""sellerCanCancelAfterDisabled""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Seller""s cancel period is already disabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrow""}, ""memberName"": ""sellerCanCancelAfterDisabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SellerCancelDisabled""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tradeHash""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Escrow {
    struct EscrowInfo {
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint128 additionalGas;
        bool sellerCanCancelAfterDisabled;
    }

    mapping(bytes16 => EscrowInfo) public escrows;

    event SellerCancelDisabled(bytes16 indexed tradeHash);

    function disableSellerCancel(
        bytes16 _tradeID,
        address _seller,
        address _buyer,
        uint256 _value,
        uint16 _fee,
        uint128 _additionalGas
    ) public returns (bool) {
        require(_seller != address(0), ""Invalid seller address"");
        require(_buyer != address(0), ""Invalid buyer address"");

        bytes16 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee, _additionalGas));

        EscrowInfo storage escrow = escrows[_tradeID];

        require(escrow.seller != address(0), ""Escrow does not exist"");
        require(!escrow.sellerCanCancelAfterDisabled, ""Seller's cancel period is already disabled"");

        // Disable seller's ability to cancel
        escrow.sellerCanCancelAfterDisabled = true;

        emit SellerCancelDisabled(tradeHash);

        return true;
    }
}",45.302107095718384,disableSellerCancel,50.0,0.868268588881504,0.320422943547917,"[{'function': 'disableSellerCancel', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    struct EscrowInfo {
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint128 additionalGas;
        bool sellerCanCancelAfterDisabled;
    }

    mapping(bytes16 => EscrowInfo) public escrows;

    event SellerCancelDisabled(bytes16 indexed tradeHash);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            escrows[bytes16(abi.encodePacked(""trade"", i))] = EscrowInfo({
                seller: address(uint160(i + 1)),
                buyer: address(uint160(i + 2)),
                value: uint256(i + 1),
                fee: 0, // Set to zero for simplicity
                additionalGas: uint128(i + 1),
                sellerCanCancelAfterDisabled: false
            });
        }
    }

    function disableSellerCancel(
        bytes16 _tradeID,
        address _seller,
        address _buyer,
        uint256 _value,
        uint16 _fee,
        uint128 _additionalGas
    ) public returns (bool) {
        require(_seller != address(0), ""Invalid seller address"");
        require(_buyer != address(0), ""Invalid buyer address"");

        bytes16 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee, _additionalGas));

        EscrowInfo storage escrow = escrows[_tradeID];

        require(escrow.seller != address(0), ""Escrow does not exist"");
        require(!escrow.sellerCanCancelAfterDisabled, ""Seller's cancel period is already disabled"");

        // Disable seller's ability to cancel
        escrow.sellerCanCancelAfterDisabled = true;

        emit SellerCancelDisabled(tradeHash);

        return true;
    }
}"
4877,"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Clawback is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 10 ether; // Example value, adjust as needed
    uint256 public constant OWNER_CLAWBACK_DATE = 1700889600; // Example value, adjust as needed
    uint256 public totalFunding;

    function ownerClawback() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        payable(owner()).transfer(address(this).balance);
    }
}","[{'function': 'ownerClawback', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""OWNER_CLAWBACK_DATE""}}, {""type"": ""stringLiteral"", ""value"": ""Clawback period has not yet started""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""totalFunding""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRESALE_MINIMUM_FUNDING""}}, {""type"": ""stringLiteral"", ""value"": ""Total funding is equal to or exceeds the presale minimum""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Clawback {
    address public owner;
    uint256 public totalFunding;
    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether; // Example value, adjust as needed
    uint256 public constant OWNER_CLAWBACK_DATE = 1700889600; // Example timestamp, adjust as needed

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the contract owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function reclaimFunds() public onlyOwner {
        require(block.timestamp >= OWNER_CLAWBACK_DATE, ""Clawback period has not yet started"");
        require(totalFunding < PRESALE_MINIMUM_FUNDING, ""Total funding is equal to or exceeds the presale minimum"");
        payable(owner).transfer(address(this).balance);
    }
}",43.723318338394165,reclaimFunds,5.0,0.9280686516174166,0.4596214023253259,"[{'function': 'reclaimFunds', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Clawback is Ownable {
    uint256 public totalFunding;
    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether; // Example value, adjust as needed
    uint256 public constant OWNER_CLAWBACK_DATE = 1700889600; // Example timestamp, adjust as needed

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Caller is not the contract owner"");
        _;
    }

    constructor() Ownable(msg.sender) {
        totalFunding = 1;
    }

    function reclaimFunds() public onlyOwner {
        require(block.timestamp >= OWNER_CLAWBACK_DATE, ""Clawback period has not yet started"");
        require(totalFunding < PRESALE_MINIMUM_FUNDING, ""Total funding is equal to or exceeds the presale minimum"");
        payable(owner()).transfer(address(this).balance);
    }
}"
4681,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public absoluteMinTimeLock;

    constructor(uint _absoluteMinTimeLock) {
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimelock(uint _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""Time lock must be at least the absolute minimum time lock."");
        timeLock = _newTimeLock;
    }
}","[{'function': 'setTimelock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimelock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""New timelock is less than the minimum allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newTimeLock""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TimeLockUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_newTimeLock""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyContractOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TimelockManager {
    uint public timeLock;
    uint public absoluteMinTimeLock;
    address public owner;

    event TimeLockUpdated(uint newTimeLock);

    modifier onlyContractOwner() {
        require(msg.sender == owner, ""Caller is not the contract owner"");
        _;
    }

    constructor(uint _absoluteMinTimeLock) {
        absoluteMinTimeLock = _absoluteMinTimeLock;
        owner = msg.sender;
    }

    function setTimelock(uint _newTimeLock) external onlyContractOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timelock is less than the minimum allowed"");
        timeLock = _newTimeLock;
        emit TimeLockUpdated(_newTimeLock);
    }
}",43.31083965301514,setTimelock,4.0,0.864501138047557,0.4056307377758796,"[{'function': 'setTimelock', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TimelockManager is Ownable {
    uint public timeLock;
    uint public absoluteMinTimeLock;

    event TimeLockUpdated(uint newTimeLock);

    modifier onlyContractOwner() {
        require(msg.sender == owner(), ""Caller is not the contract owner"");
        _;
    }

    constructor(uint _absoluteMinTimeLock) Ownable(""TimelockManager"") {
        absoluteMinTimeLock = _absoluteMinTimeLock;
        timeLock = 1; // Set to a non-zero value
        require(_absoluteMinTimeLock > 0, ""Minimum timelock must be greater than zero"");
    }

    function setTimelock(uint _newTimeLock) external onlyContractOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""New timelock is less than the minimum allowed"");
        timeLock = _newTimeLock;
        emit TimeLockUpdated(_newTimeLock);
    }
}"
5481,Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedTransferAndCall is Ownable {
    using SafeMath for uint256;

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        return _to.call{value: _value}(_data);
    }
}","[{'function': 'transferAndCall', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance or invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ITokenReceiver""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ITokenReceiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receiver""}, ""memberName"": ""onTokenTransfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Call to token recipient failed""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ITokenReceiver {
    function onTokenTransfer(address _from, uint256 _value, bytes memory _data) external returns (bool);
}

contract Token {
    mapping(address => uint256) public balances;
    string public name = ""MyToken"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0 && balances[msg.sender] >= _value, ""Insufficient balance or invalid amount"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0 && balances[msg.sender] >= _value, ""Insufficient balance or invalid amount"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        if (isContract(_to)) {
            ITokenReceiver receiver = ITokenReceiver(_to);
            require(receiver.onTokenTransfer(msg.sender, _value, _data), ""Call to token recipient failed"");
        }

        return true;
    }

    function isContract(address _addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(_addr) }
        return size > 0;
    }
}",47.06108570098877,transferAndCall,60.0,0.4033445454306928,0.1818419176275991,"[{'function': 'onTokenTransfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}, {'function': 'transferAndCall', 'complexity': 5}, {'function': 'isContract', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

interface ITokenReceiver {
    function onTokenTransfer(address _from, uint256 _value, bytes memory _data) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    string public name = ""MyToken"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 initialSupply) Ownable(msg.sender) {
        balances[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0 && balances[msg.sender] >= _value, ""Insufficient balance or invalid amount"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0 && balances[msg.sender] >= _value, ""Insufficient balance or invalid amount"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        if (isContract(_to)) {
            ITokenReceiver receiver = ITokenReceiver(_to);
            require(receiver.onTokenTransfer(msg.sender, _value, _data), ""Call to token recipient failed"");
        }

        return true;
    }

    function isContract(address _addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(_addr) }
        return size > 0;
    }
}"
1824,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Value must be greater than zero"");
        require(msg.sender == _from, ""Sender must match the caller"");
        require(_value <= balanceOf[_from], ""Insufficient balance"");

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Allowance exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(allowances[_from][msg.sender] >= _value, ""Allowance exceeded"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",43.950886487960815,transferFrom,21.0,0.8771288543194543,0.561514856595285,"[{'function': 'transferFrom', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance to 1 for the owner
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(allowances[_from][msg.sender] >= _value, ""Allowance exceeded"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}"
1782,Gets the EscrowDeposit based on the input id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow {
    using SafeMath for uint256;

    struct EscrowDeposit {
        address bidder;
        bytes data;
        uint256 amount;
        bool exists;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) external view returns (address, bytes memory, uint256) {
        require(escrows[_id].exists, ""Escrow does not exist"");
        EscrowDeposit storage escrow = escrows[_id];
        return (escrow.bidder, escrow.data, escrow.amount);
    }
}","[{'function': 'getEscrowDeposit', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getEscrowDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_id"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}, ""memberName"": ""exists""}, {""type"": ""stringLiteral"", ""value"": ""Escrow deposit does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""EscrowDeposit""}, ""name"": ""ed"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrows""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ed""}, ""memberName"": ""bidder""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ed""}, ""memberName"": ""data""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ed""}, ""memberName"": ""amount""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Escrow {
    struct EscrowDeposit {
        bool exists;
        address bidder;
        string data;
        uint256 amount;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) public view returns (address, string memory, uint256) {
        require(escrows[_id].exists, ""Escrow deposit does not exist"");

        EscrowDeposit storage ed = escrows[_id];
        return (ed.bidder, ed.data, ed.amount);
    }
}",42.623939037323,getEscrowDeposit,0.0,0.8952304776989409,0.6091881060666252,"[{'function': 'getEscrowDeposit', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    struct EscrowDeposit {
        bool exists;
        address bidder;
        string data;
        uint256 amount;
    }

    mapping(string => EscrowDeposit) public escrows;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getEscrowDeposit(string memory _id) public view returns (address, string memory, uint256) {
        require(escrows[_id].exists, ""Escrow deposit does not exist"");

        EscrowDeposit storage ed = escrows[_id];
        return (ed.bidder, ed.data, ed.amount);
    }
}"
3204,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balances(address account) external view returns (uint256);
    function totalBhinneka() external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalBhinneka;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalBhinneka = totalBhinneka.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to burn""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address private owner;

    event Burn(address indexed from, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply_ = initialSupply;
        balances[msg.sender] = initialSupply;
        owner = msg.sender;
    }

    function burn(uint256 _value) public onlyOwner returns (bool) {
        require(_value <= balances[msg.sender], ""Insufficient balance to burn"");
        balances[msg.sender] -= _value;
        totalSupply_ -= _value;
        emit Burn(msg.sender, _value);
        return true;
    }
}",43.736671686172485,burn,13.0,0.7946973928136349,0.4659363762200453,"[{'function': 'burn', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and you have a corresponding file for Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address private owner;

    event Burn(address indexed from, uint256 value);

    uint256 public totalSupply;

 constructor(uint256 initialSupply) Ownable(msg.sender) {
        totalSupply_ = initialSupply;
        balances[msg.sender] = initialSupply;
        owner = msg.sender;
    }

    function burn(uint256 _value) public onlyOwner returns (bool) {
        require(_value <= balances[msg.sender], ""Insufficient balance to burn"");
        balances[msg.sender] -= _value;
        totalSupply_ -= _value;
        emit Burn(msg.sender, _value);
        return true;
    }
}"
1281,Function for attester to submit attestation from their own account ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttestationContract is Ownable {
    using SafeMath for uint256;

    function attest(address _subject, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) external {
        require(_subject != address(0), ""Invalid subject address"");
        require(_requester != address(0), ""Invalid requester address"");
        require(_reward > 0, ""Reward must be greater than zero"");
        require(_requestNonce != bytes32(0), ""Request nonce cannot be empty"");

        // Assuming attestForUser is defined elsewhere in the contract or imported library
        attestForUser(_subject, msg.sender, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
    }

    function attestForUser(address _subject, address _attester, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) internal {
        // Implementation of the actual attestation logic
    }
}","[{'function': 'attest', 'complexity': 4}, {'function': 'attestForUser', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""attest"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_subject"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_requester"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_requesterSig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_dataHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_requestNonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_subjectSig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_validateSignature""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_requester""}, {""type"": ""Identifier"", ""name"": ""_requesterSig""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid requester signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_validateSignature""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_subject""}, {""type"": ""Identifier"", ""name"": ""_subjectSig""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid subject signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_requestNonceNotUsed""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_requestNonce""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Request nonce already used""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""attestationCount""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attestations""}, ""index"": {""type"": ""Identifier"", ""name"": ""attestationCount""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Attestation""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_subject""}, {""type"": ""Identifier"", ""name"": ""_requester""}, {""type"": ""Identifier"", ""name"": ""_reward""}, {""type"": ""Identifier"", ""name"": ""_requesterSig""}, {""type"": ""Identifier"", ""name"": ""_subjectSig""}, {""type"": ""Identifier"", ""name"": ""_dataHash""}, {""type"": ""Identifier"", ""name"": ""_requestNonce""}], ""names"": [""subject"", ""requester"", ""reward"", ""requesterSig"", ""subjectSig"", ""dataHash"", ""requestNonce""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AttestationCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""attestationCount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AttestationContract {
    struct Attestation {
        address subject;
        address requester;
        uint256 reward;
        bytes requesterSig;
        bytes subjectSig;
        bytes32 dataHash;
        uint256 requestNonce;
    }

    mapping(uint256 => Attestation) public attestations;
    uint256 public attestationCount;

    function attest(
        address _subject,
        address _requester,
        uint256 _reward,
        bytes memory _requesterSig,
        bytes32 _dataHash,
        uint256 _requestNonce,
        bytes memory _subjectSig
    ) public {
        require(_validateSignature(_requester, _requesterSig), ""Invalid requester signature"");
        require(_validateSignature(_subject, _subjectSig), ""Invalid subject signature"");
        require(_requestNonceNotUsed(msg.sender, _requestNonce), ""Request nonce already used"");

        attestationCount++;
        attestations[attestationCount] = Attestation({
            subject: _subject,
            requester: _requester,
            reward: _reward,
            requesterSig: _requesterSig,
            subjectSig: _subjectSig,
            dataHash: _dataHash,
            requestNonce: _requestNonce
        });

        emit AttestationCreated(attestationCount);
    }

    function _validateSignature(address signer, bytes memory signature) internal pure returns (bool) {
        // Implement ECDSA validation logic here
        return true; // Placeholder for actual implementation
    }

    function _requestNonceNotUsed(address user, uint256 nonce) internal view returns (bool) {
        // Check if the nonce has been used before
        return true; // Placeholder for actual implementation
    }

    event AttestationCreated(uint256 indexed attestationId);
}",46.87249422073364,attest,28.0,0.6872817994668918,0.3768375088451378,"[{'function': 'attest', 'complexity': 0}, {'function': '_validateSignature', 'complexity': 0}, {'function': '_requestNonceNotUsed', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttestationContract is Ownable {
    struct Attestation {
        address subject;
        address requester;
        uint256 reward;
        bytes requesterSig;
        bytes subjectSig;
        bytes32 dataHash;
        uint256 requestNonce;
    }

    mapping(uint256 => Attestation) public attestations;
    uint256 public attestationCount;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        attestationCount = 1;
    }

    function attest(
        address _subject,
        address _requester,
        uint256 _reward,
        bytes memory _requesterSig,
        bytes32 _dataHash,
        uint256 _requestNonce,
        bytes memory _subjectSig
    ) public {
        require(_validateSignature(_requester, _requesterSig), ""Invalid requester signature"");
        require(_validateSignature(_subject, _subjectSig), ""Invalid subject signature"");
        require(_requestNonceNotUsed(msg.sender, _requestNonce), ""Request nonce already used"");

        attestationCount++;
        attestations[attestationCount] = Attestation({
            subject: _subject,
            requester: _requester,
            reward: _reward,
            requesterSig: _requesterSig,
            subjectSig: _subjectSig,
            dataHash: _dataHash,
            requestNonce: _requestNonce
        });

        emit AttestationCreated(attestationCount);
    }

    function _validateSignature(address signer, bytes memory signature) internal pure returns (bool) {
        // Implement ECDSA validation logic here
        return true; // Placeholder for actual implementation
    }

    function _requestNonceNotUsed(address user, uint256 nonce) internal view returns (bool) {
        // Check if the nonce has been used before
        return true; // Placeholder for actual implementation
    }

    event AttestationCreated(uint256 indexed attestationId);
}"
4148,"Escrows the ERC721 Token , assigning ownership to this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow is Ownable {
    using SafeMath for uint256;

    address public nonFungibleContract;

    constructor(address _nonFungibleContract) {
        nonFungibleContract = _nonFungibleContract;
    }

    function escrow(address _owner, uint256 _tokenId) external onlyOwner {
        require(_owner != address(0), ""Invalid owner address"");
        (bool success, ) = nonFungibleContract.call(abi.encodeWithSelector(bytes4(keccak256(""safeTransferFrom(address,address,uint256)"")), _owner, address(this), _tokenId));
        require(success, ""Safe transfer failed"");
    }
}","[{'function': 'escrow', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferNFTToEscrow"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nonFungibleContract""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
}

contract NFTEscrow {
    IERC721 public nonFungibleContract;

    constructor(address _nonFungibleContract) {
        nonFungibleContract = IERC721(_nonFungibleContract);
    }

    function transferNFTToEscrow(address _owner, uint256 _tokenId) external {
        require(_owner != address(0), ""Invalid owner address"");
        nonFungibleContract.safeTransferFrom(_owner, address(this), _tokenId);
    }
}",42.7707622051239,transferNFTToEscrow,15.0,0.7466125918825909,0.3148414521299918,"[{'function': 'safeTransferFrom', 'complexity': 0}, {'function': 'transferNFTToEscrow', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
}
import ""openzeppelin/SafeMath.sol"";
contract NFTEscrow is Ownable {
    IERC721 public nonFungibleContract;

    constructor(address _nonFungibleContract) Ownable(msg.sender) {
        nonFungibleContract = IERC721(_nonFungibleContract);
    }

    function transferNFTToEscrow(address _owner, uint256 _tokenId) external {
        require(_owner != address(0), ""Invalid owner address"");
        nonFungibleContract.safeTransferFrom(_owner, address(this), _tokenId);
    }
}"
6515,"Computes the id for a node in a given Grove index which is sha3 ( indexId , id )","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GroveLibWrapper is Ownable {
    using SafeMath for uint256;

    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return GroveLib.computeNodeId(indexId, id);
    }
}","[{'function': 'computeNodeId', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeNodeId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""indexId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""GroveLib""}, ""memberName"": ""computeNodeId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""indexId""}, {""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/cryptography/GroveLib.sol""; // Assuming GroveLib is from OpenZeppelin's cryptography library

contract NodeIdentifier {
    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return GroveLib.computeNodeId(indexId, id);
    }
}",41.86465549468994,computeNodeId,0.0,1.0,1.0,"[{'function': 'computeNodeId', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/utils/cryptography/GroveLib.sol""; // Assuming GroveLib is from OpenZeppelin's cryptography library
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Importing Ownable contract from OpenZeppelin
import ""openzeppelin/SafeMath.sol"";
contract NodeIdentifier is Ownable {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        indexId = bytes32('init');
        id = bytes32('init');
    }

    bytes32 private indexId;
    bytes32 private id;

    function computeNodeId(bytes32 _indexId, bytes32 _id) public pure returns (bytes32) {
        return GroveLib.computeNodeId(_indexId, _id);
    }
}"
211,Uses the same signature as initializeTokenSale ( ) with :,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    bool public buyModeEth;
    address public payableTokenAddress;

    function initializeSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) internal {
        // Sale initialization logic here
    }

    function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public onlyOwner {
        buyModeEth = false;
        payableTokenAddress = _tokenAddress;
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}","[{'function': 'initializeSale', 'complexity': 0}, {'function': 'initializeTokenSaleWithToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeTokenSaleWithToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_saleStartTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_saleEndTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountForSale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_saleStartTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Sale start time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_saleEndTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_saleStartTime""}}, {""type"": ""stringLiteral"", ""value"": ""Sale end time must be after start time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amountForSale""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount for sale must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary must be a valid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token address must be a valid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""saleStartTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_saleStartTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""saleEndTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_saleEndTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""amountForSale""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amountForSale""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""right"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""payableTokenAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SaleInitialized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_saleStartTime""}, {""type"": ""Identifier"", ""name"": ""_saleEndTime""}, {""type"": ""Identifier"", ""name"": ""_price""}, {""type"": ""Identifier"", ""name"": ""_amountForSale""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""_tokenAddress""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""ownerOnly"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract TokenSale is Ownable {
    uint256 public saleStartTime;
    uint256 public saleEndTime;
    uint256 public price;
    uint256 public amountForSale;
    address public beneficiary;
    address public tokenAddress;
    bool public buyModeEth = false;
    address public payableTokenAddress;

    event SaleInitialized(uint256 saleStartTime, uint256 saleEndTime, uint256 price, uint256 amountForSale, address beneficiary, address tokenAddress);

    modifier ownerOnly() {
        require(owner() == msg.sender, ""Caller is not the contract owner"");
        _;
    }

    function initializeTokenSaleWithToken(uint256 _saleStartTime, uint256 _saleEndTime, uint256 _price, uint256 _amountForSale, address _beneficiary, address _tokenAddress) external ownerOnly {
        require(_saleStartTime > block.timestamp, ""Sale start time must be in the future"");
        require(_saleEndTime > _saleStartTime, ""Sale end time must be after start time"");
        require(_price > 0, ""Price must be greater than zero"");
        require(_amountForSale > 0, ""Amount for sale must be greater than zero"");
        require(_beneficiary != address(0), ""Beneficiary must be a valid address"");
        require(_tokenAddress != address(0), ""Token address must be a valid address"");

        saleStartTime = _saleStartTime;
        saleEndTime = _saleEndTime;
        price = _price;
        amountForSale = _amountForSale;
        beneficiary = _beneficiary;
        tokenAddress = _tokenAddress;
        payableTokenAddress = _tokenAddress;

        emit SaleInitialized(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary, _tokenAddress);
    }
}",46.9549036026001,initializeTokenSaleWithToken,70.0,0.5516974839958955,0.1305088430198699,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'initializeTokenSaleWithToken', 'complexity': 6}]",8.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    uint256 public saleStartTime;
    uint256 public saleEndTime;
    uint256 public price;
    uint256 public amountForSale;
    address public beneficiary;
    address public tokenAddress;
    bool public buyModeEth = false;
    address public payableTokenAddress;

    event SaleInitialized(uint256 saleStartTime, uint256 saleEndTime, uint256 price, uint256 amountForSale, address beneficiary, address tokenAddress);

    modifier ownerOnly() {
        require(owner() == msg.sender, ""Caller is not the contract owner"");
        _;
    }

    constructor() Ownable(msg.sender) {
        saleStartTime = 1; // Set to a fixed value greater than block.timestamp
        saleEndTime = 2; // Set to a fixed value after saleStartTime
        price = 1; // Set to a fixed value greater than zero
        amountForSale = 1; // Set to a fixed value greater than zero
        beneficiary = address(0x111); // Use the first fixed address value
        tokenAddress = address(0x222); // Use the second fixed address value
        payableTokenAddress = address(0x222); // Same as tokenAddress for demonstration purposes
    }

    function initializeTokenSaleWithToken(uint256 _saleStartTime, uint256 _saleEndTime, uint256 _price, uint256 _amountForSale, address _beneficiary, address _tokenAddress) external ownerOnly {
        require(_saleStartTime > block.timestamp, ""Sale start time must be in the future"");
        require(_saleEndTime > _saleStartTime, ""Sale end time must be after start time"");
        require(_price > 0, ""Price must be greater than zero"");
        require(_amountForSale > 0, ""Amount for sale must be greater than zero"");
        require(_beneficiary != address(0), ""Beneficiary must be a valid address"");
        require(_tokenAddress != address(0), ""Token address must be a valid address"");

        saleStartTime = _saleStartTime;
        saleEndTime = _saleEndTime;
        price = _price;
        amountForSale = _amountForSale;
        beneficiary = _beneficiary;
        tokenAddress = _tokenAddress;
        payableTokenAddress = _tokenAddress;

        emit SaleInitialized(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary, _tokenAddress);
    }
}"
5005,If this function is called again it overwrites the current allowance with _value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => bool) public frozenAccount;
    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address _spender, uint256 _value) external returns (bool success) {
        require(!frozenAccount[msg.sender]);
        assert(_spender != address(0));
        require(_value >= 0);
        allowed[msg.sender][_spender] = _value;
        return true;
    }
}","[{'function': 'approve', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be non-negative""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotFrozen"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowed;
    bool public frozenAccount;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    modifier whenNotFrozen() {
        require(!frozenAccount, ""Token transfer is frozen"");
        _;
    }

    function approve(address _spender, uint256 _value) public whenNotFrozen returns (bool) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value >= 0, ""Value must be non-negative"");

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",43.29612112045288,approve,18.0,0.9059206952160868,0.4758873293775214,"[{'function': 'approve', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowed;
    bool public frozenAccount;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    modifier whenNotFrozen() {
        require(!frozenAccount, ""Token transfer is frozen"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        frozenAccount = false;
    }

    function approve(address _spender, uint256 _value) public whenNotFrozen returns (bool) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value >= 0, ""Value must be non-negative"");

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
2436,Function for transfering tokens from one account to another .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes16 => uint256) public balances;
    address[] private allowedAddresses;
    bool public paused = false;

    modifier onlyAllowedAddresses() {
        require(_isAllowedAddress(msg.sender), ""Only allowed addresses can call this function"");
        _;
    }

    modifier onlyRegisteredAccount(bytes16 _account) {
        require(_isRegisteredAccount(_account), ""The account must be registered"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transferTokensToAccount(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowedAddresses onlyRegisteredAccount(_from) whenNotPaused {
        registerAccount(_to);
        balances[_from] = balances[_from].sub(_tokensCount);
        balances[_to] = balances[_to].add(_tokensCount);
    }

    function registerAccount(bytes16 _account) internal {
        // Implementation of the registerAccount function
    }

    function _isAllowedAddress(address _addr) internal view returns (bool) {
        for (uint i = 0; i < allowedAddresses.length; i++) {
            if (allowedAddresses[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    function _isRegisteredAccount(bytes16 _account) internal view returns (bool) {
        // Implementation of the check for registered account
        return balances[_account] > 0;
    }
}","[{'function': 'transferTokensToAccount', 'complexity': 0}, {'function': 'registerAccount', 'complexity': 0}, {'function': '_isAllowedAddress', 'complexity': 3}, {'function': '_isRegisteredAccount', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes16""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokensCount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokensCount""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid source account or insufficient balance""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""registerAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokensCount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokensCount""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAllowed"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    mapping(bytes16 => uint256) public balances;
    bytes16[] private registeredAccounts;
    bool public paused = false;

    modifier onlyAllowed() {
        require(isAllowed(msg.sender), ""Address not allowed"");
        _;
    }

    function isAllowed(bytes16 account) internal view returns (bool) {
        // Implement your logic to check if the address is allowed
        return true; // Example: always allow for simplicity
    }

    function transferTokens(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowed whenNotPaused returns (bool) {
        require(_from != 0 && balances[_from] >= _tokensCount, ""Invalid source account or insufficient balance"");

        // Register the destination account if it is not already registered
        if (balances[_to] == 0) {
            registerAccount(_to);
        }

        // Decrease the token balance of the source account
        balances[_from] -= _tokensCount;

        // Increase the token balance of the destination account
        balances[_to] += _tokensCount;

        return true;
    }

    function registerAccount(bytes16 account) internal {
        balances[account] = 0;
        registeredAccounts.push(account);
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    // Pause the contract
    function pause() public {
        paused = true;
    }

    // Unpause the contract
    function unpause() public {
        paused = false;
    }
}",45.83591198921204,transferTokens,28.0,0.6551429499863457,0.0674933209999602,"[{'function': 'isAllowed', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 3}, {'function': 'registerAccount', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming you have an Ownable contract imported
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(bytes16 => uint256) public balances;
    bytes16[] private registeredAccounts;
    bool public paused = false;

    modifier onlyAllowed() {
        require(isAllowed(msg.sender), ""Address not allowed"");
        _;
    }

    function isAllowed(bytes16 account) internal view returns (bool) {
        // Implement your logic to check if the address is allowed
        return true; // Example: always allow for simplicity
    }

    function transferTokens(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowed whenNotPaused returns (bool) {
        require(_from != 0 && balances[_from] >= _tokensCount, ""Invalid source account or insufficient balance"");

        // Register the destination account if it is not already registered
        if (balances[_to] == 0) {
            registerAccount(_to);
        }

        // Decrease the token balance of the source account
        balances[_from] -= _tokensCount;

        // Increase the token balance of the destination account
        balances[_to] += _tokensCount;

        return true;
    }

    function registerAccount(bytes16 account) internal {
        balances[account] = 0;
        registeredAccounts.push(account);
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    // Pause the contract
    function pause() public onlyOwner {
        paused = true;
    }

    // Unpause the contract
    function unpause() public onlyOwner {
        paused = false;
    }

    constructor() Ownable(msg.sender) {
        balances[bytes16('init')] = 1;
        registeredAccounts.push(bytes16('init'));
        paused = true;
    }
}"
2602,` onlyOwner ` An efficient way to confirm multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _idPayment) internal virtual {
        // Implementation of the payment confirmation logic
    }
}","[{'function': 'multiConfirm', 'complexity': 1}, {'function': 'doConfirmPayment', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiConfirm"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_idPayments"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""doConfirmPayment""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_idPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PaymentConfirmation is Ownable {
    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint256 i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _paymentId) internal {
        // Implementation of the payment confirmation logic
        require(owner() == msg.sender, ""Only owner can confirm payments"");
        // Additional logic for confirming a single payment
    }
}",42.98031044006348,multiConfirm,0.0,0.98725260170351,0.9061874434879644,"[{'function': 'multiConfirm', 'complexity': 1}, {'function': 'doConfirmPayment', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentConfirmation is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint256 i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _paymentId) internal {
        // Implementation of the payment confirmation logic
        require(owner() == msg.sender, ""Only owner can confirm payments"");
        // Additional logic for confirming a single payment
    }
}"
1905,Function used by the client to block the transfer of shares from and to a share holder,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function blockTransfer(address _shareHolder, uint _deadLine) external onlyOwner {
        // Implementation of the blockTransfer function
    }
}","[{'function': 'blockTransfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initiateBlockTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_shareHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_deadLine"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_shareHolder""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid shareholder address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_deadLine""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Deadline must be in the future""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""shareBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""shares""}, ""index"": {""type"": ""Identifier"", ""name"": ""_shareHolder""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""shareBalance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient shares to initiate a block transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""blockTransfers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_shareHolder""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BlockTransferRequest""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_shareHolder""}, {""type"": ""Identifier"", ""name"": ""shareBalance""}, {""type"": ""Identifier"", ""name"": ""_deadLine""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": [""shareholder"", ""amount"", ""deadline"", ""completed""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BlockTransferInitiated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_shareHolder""}, {""type"": ""Identifier"", ""name"": ""_deadLine""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuthorized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ShareholderBlockTransfer {
    // Mapping to store the number of shares held by each shareholder
    mapping(address => uint256) public shares;
    // Mapping to store block transfer requests
    mapping(address => BlockTransferRequest) public blockTransfers;

    struct BlockTransferRequest {
        address shareholder;
        uint256 amount;
        uint256 deadline;
        bool completed;
    }

    // Role modifier for authorized actions
    modifier onlyAuthorized() {
        require(isAuthorized(msg.sender), ""Not authorized"");
        _;
    }

    function isAuthorized(address user) public view returns (bool) {
        // Implement your authorization logic here
        return true; // Placeholder, replace with actual logic
    }

    // Function to initiate a block transfer of shares
    function initiateBlockTransfer(address _shareHolder, uint256 _deadLine) external onlyAuthorized {
        require(_shareHolder != address(0), ""Invalid shareholder address"");
        require(_deadLine > block.timestamp, ""Deadline must be in the future"");

        // Retrieve the current balance of shares for the specified shareholder
        uint256 shareBalance = shares[_shareHolder];
        require(shareBalance > 0, ""Insufficient shares to initiate a block transfer"");

        // Store the block transfer request
        blockTransfers[_shareHolder] = BlockTransferRequest({
            shareholder: _shareHolder,
            amount: shareBalance,
            deadline: _deadLine,
            completed: false
        });

        // Emit an event indicating the initiation of a block transfer
        emit BlockTransferInitiated(_shareHolder, _deadLine);
    }

    // Event triggered when a block transfer is initiated
    event BlockTransferInitiated(address indexed shareholder, uint256 deadline);
}",46.6632661819458,initiateBlockTransfer,54.0,0.328786943820848,0.0318046373494345,"[{'function': 'isAuthorized', 'complexity': 0}, {'function': 'initiateBlockTransfer', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ShareholderBlockTransfer is Ownable {
    // Mapping to store the number of shares held by each shareholder
    mapping(address => uint256) public shares;
    // Mapping to store block transfer requests
    mapping(address => BlockTransferRequest) public blockTransfers;

    struct BlockTransferRequest {
        address shareholder;
        uint256 amount;
        uint256 deadline;
        bool completed;
    }

    // Role modifier for authorized actions
    modifier onlyAuthorized() {
        require(isAuthorized(msg.sender), ""Not authorized"");
        _;
    }

    function isAuthorized(address user) public view returns (bool) {
        // Implement your authorization logic here
        return true; // Placeholder, replace with actual logic
    }

    // Constructor to initialize the contract and set the owner
    constructor() Ownable(msg.sender) {
        shares[address(0x111)] = 1;
        shares[address(0x222)] = 1;
        shares[address(0x333)] = 1;
    }

    // Function to initiate a block transfer of shares
    function initiateBlockTransfer(address _shareHolder, uint256 _deadLine) external onlyAuthorized {
        require(_shareHolder != address(0), ""Invalid shareholder address"");
        require(_deadLine > block.timestamp, ""Deadline must be in the future"");

        // Retrieve the current balance of shares for the specified shareholder
        uint256 shareBalance = shares[_shareHolder];
        require(shareBalance > 0, ""Insufficient shares to initiate a block transfer"");

        // Store the block transfer request
        blockTransfers[_shareHolder] = BlockTransferRequest({
            shareholder: _shareHolder,
            amount: shareBalance,
            deadline: _deadLine,
            completed: false
        });

        // Emit an event indicating the initiation of a block transfer
        emit BlockTransferInitiated(_shareHolder, _deadLine);
    }

    // Event triggered when a block transfer is initiated
    event BlockTransferInitiated(address indexed shareholder, uint256 deadline);
}"
6047,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(checkVestingCondition(msg.sender));
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function checkVestingCondition(address account) internal view returns (bool) {
        // Implement your vesting condition logic here
        return false;
    }

    function _transfer(address from, address to, uint256 value) internal virtual {
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balanceOf(from) >= value, ""ERC20: transfer amount exceeds balance"");

        // Subtract the amount from the sender's balance
        _balances[from] = _balances[from].sub(value);

        // Add the amount to the recipient's balance
        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);
    }

    mapping(address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}","[{'function': 'transfer', 'complexity': 1}, {'function': 'checkVestingCondition', 'complexity': 0}, {'function': '_transfer', 'complexity': 2}, {'function': 'balanceOf', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    mapping(address => uint256) public balances;

    function transfer(address _to, uint256 _value) external returns (bool success) {
        require(checkVestingCondition(msg.sender), ""Vesting condition not met"");
        return _transfer(_to, _value);
    }

    function checkVestingCondition(address user) internal view returns (bool) {
        // Implement vesting condition logic here
        // For example, check if the user has a certain balance or time-locked tokens
        return balances[user] >= _value;
    }

    function _transfer(address _to, uint256 _value) internal returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",44.15035653114319,_transfer,27.0,0.8125417003513478,0.0519983957635427,"[{'function': 'transfer', 'complexity': 1}, {'function': 'checkVestingCondition', 'complexity': 0}, {'function': '_transfer', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance of owner to 1 (never 0)
    }

    function transfer(address _to, uint256 _value) external returns (bool success) {
        require(checkVestingCondition(msg.sender), ""Vesting condition not met"");
        return _transfer(_to, _value);
    }

    function checkVestingCondition(address user) internal view returns (bool) {
        // Implement vesting condition logic here
        // For example, check if the user has a certain balance or time-locked tokens
        return balances[user] >= _value;
    }

    function _transfer(address _to, uint256 _value) internal returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}"
189,To be called by the account that holds Mio tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public lockedBalances;
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function addBalanceFor(address account, uint256 value) public onlyOwner {
        lockedBalances[account] = lockedBalances[account].add(value);
        require(token.safeTransferFrom(msg.sender, address(this), value), ""Token transfer failed"");
    }
}","[{'function': 'safeTransferFrom', 'complexity': 0}, {'function': 'addBalanceFor', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addToLockedBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockedBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenLocker {
    mapping(address => uint256) public lockedBalances;
    address public token;

    constructor(address _token) {
        token = _token;
    }

    function addToLockedBalance(address account, uint256 value) external {
        require(value > 0, ""Value must be greater than zero"");
        lockedBalances[account] += value;
        require(IERC20(token).transferFrom(msg.sender, address(this), value), ""Token transfer failed"");
    }
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}",42.95966410636902,addToLockedBalance,13.0,0.8740931028604635,0.4623855050780153,"[{'function': 'addToLockedBalance', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenLocker is Ownable {
    mapping(address => uint256) public lockedBalances;
    address public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = _token;
    }

    function addToLockedBalance(address account, uint256 value) external {
        require(value > 0, ""Value must be greater than zero"");
        lockedBalances[account] += value;
        require(IERC20(token).transferFrom(msg.sender, address(this), value), ""Token transfer failed"");
    }
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}"
3776,Ability to transfer where the sender pays the fees ( not ERC20 ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    function transferFeeIncurred(uint256 value) internal pure returns (uint256) {
        // Example logic for calculating the fee
        return value.div(100); // 1% fee
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal returns (bool) {
        require(balanceOf(sender) >= value.add(fee), ""Insufficient balance"");

        // Deduct the fee from the sender's balance
        _balances[sender] = _balances[sender].sub(value).sub(fee);

        // Add the fee to the contract balance (or any other logic)
        _balances[address(this)] = _balances[address(this)].add(fee);

        // Transfer the value to the recipient
        _balances[to] = _balances[to].add(value);

        emit Transfer(sender, to, value);
        return true;
    }

    mapping (address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}","[{'function': '_transferSenderPaysFee_byProxy', 'complexity': 0}, {'function': 'transferFeeIncurred', 'complexity': 0}, {'function': '_internalTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""_internalTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_deductFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    function transferFeeIncurred(uint256 value) internal pure returns (uint256 fee) {
        // Example logic for calculating a 1% fee
        fee = value * 1 / 100;
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal returns (bool success) {
        require(balanceOf(sender) >= value + fee, ""Insufficient balance"");

        // Deduct the fee from the sender's balance
        _deductFee(sender, fee);

        // Transfer the tokens to the recipient
        balanceOf(sender) -= value + fee;
        balanceOf(to) += value;

        emit Transfer(sender, to, value);
        return true;
    }

    function _deductFee(address sender, uint256 fee) internal {
        // Deduct the fee from the sender's balance
        require(balanceOf(sender) >= fee, ""Insufficient balance to deduct fee"");
        balanceOf(sender) -= fee;
    }

    mapping(address => uint256) private balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool success) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }
}",45.527212142944336,_internalTransfer,26.0,0.6206147564500524,0.4845967418972244,"[{'function': 'transferFeeIncurred', 'complexity': 0}, {'function': '_internalTransfer', 'complexity': 1}, {'function': '_deductFee', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}, {'function': '_transferSenderPaysFee_byProxy', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    function transferFeeIncurred(uint256 value) internal pure returns (uint256 fee) {
        // Example logic for calculating a 1% fee
        fee = value * 1 / 100;
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal returns (bool success) {
        require(balanceOf(sender) >= value + fee, ""Insufficient balance"");

        // Deduct the fee from the sender's balance
        _deductFee(sender, fee);

        // Transfer the tokens to the recipient
        balanceOf(sender) -= value + fee;
        balanceOf(to) += value;

        emit Transfer(sender, to, value);
        return true;
    }

    function _deductFee(address sender, uint256 fee) internal {
        // Deduct the fee from the sender's balance
        require(balanceOf(sender) >= fee, ""Insufficient balance to deduct fee"");
        balanceOf(sender) -= fee;
    }

    mapping(address => uint256) private balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool success) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    // Constructor
    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables
        balances[msg.sender] = 1000; // Initial balance for the owner
        balances[address(0x2222222222222222222222222222222222222222)] = 1; // Example initial balance for another address
        balances[address(0x3333333333333333333333333333333333333333)] = 1; // Example initial balance for another address
    }
}"
4464,"Returns the cost of the cosigner This cosigner does not have any risk or maintenance cost , so its free .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CostWrapper is Ownable {
    using SafeMath for uint256;

    function cost(address _address, uint256 _uint256, bytes memory _bytes1, bytes memory _bytes2) external view returns (uint256) {
        require(_address != address(0), ""Invalid address"");
        // The logic for calculating the cost is not provided in the snippet.
        return 0;
    }
}","[{'function': 'cost', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateCost"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""option1"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""option2"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract CostCalculator {
    function calculateCost(address userAddress, uint256 value, bytes memory option1, bytes memory option2) external pure returns (uint256) {
        // Placeholder for actual cost calculation logic
        return 0;
    }
}",41.421245098114014,calculateCost,9.0,0.7779773865939584,0.1391380922314838,"[{'function': 'calculateCost', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CostCalculator {
    // Fixed, safe values for instance variables
    address public constant DEFAULT_USER_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    uint256 public constant DEFAULT_VALUE = 1;
    bytes32 public constant DEFAULT_OPTION1 = bytes32('init');
    bytes32 public constant DEFAULT_OPTION2 = bytes32('init');

    // Initialize Ownable contract
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function calculateCost(address userAddress, uint256 value, bytes memory option1, bytes memory option2) external pure returns (uint256) {
        // Placeholder for actual cost calculation logic
        return 0;
    }
}"
1265,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CapReachedWrapper is Ownable {
    using SafeMath for uint256;

    bool public isFinalized;
    uint256 public finalAmountReturned;
    mapping(uint256 => uint256) public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    function capReached() public view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        }
        return mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length - 1];
    }
}","[{'function': 'capReached', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""capReached"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""isFinalized""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""finalAmountReturned""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""mintedPerTierTotal""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""mintedPerTierTotal""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokensPerTierTotal""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokensPerTierTotal""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    bool public isFinalized;
    uint256 public finalAmountReturned;
    uint256[] public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function capReached() external view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        } else {
            return mintedPerTierTotal[mintedPerTierTotal.length - 1] >= tokensPerTierTotal[tokensPerTierTotal.length - 1];
        }
    }
}",43.35628008842468,capReached,3.0,0.934806693315174,0.6840582675411029,"[{'function': 'capReached', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    bool public isFinalized;
    uint256 public finalAmountReturned;
    uint256[] public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        isFinalized = false;
        finalAmountReturned = 0;
        mintedPerTierTotal = new uint256[](3); // Assuming there are 3 tiers, adjust if necessary
        tokensPerTierTotal = new uint256[](3); // Assuming there are 3 tiers, adjust if necessary
        for (uint i = 0; i < mintedPerTierTotal.length; i++) {
            mintedPerTierTotal[i] = 1; // Set to 1 for each tier
            tokensPerTierTotal[i] = 1; // Set to 1 for each tier
        }
    }

    function capReached() external view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        } else {
            return mintedPerTierTotal[mintedPerTierTotal.length - 1] >= tokensPerTierTotal[tokensPerTierTotal.length - 1];
        }
    }
}"
4986,Returns the number of decimals the token uses .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    function decimals() public view returns (uint8 _decimals) {
        return 18; // Example implementation, adjust as needed
    }
}","[{'function': 'decimals', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDecimals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""decimals""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    uint8 public decimals;

    constructor(uint8 _decimals) {
        decimals = _decimals;
    }

    function getDecimals() public view returns (uint8) {
        return decimals;
    }
}",41.69429397583008,getDecimals,1.0,0.9342786315711394,0.314261380179443,"[{'function': 'getDecimals', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    uint8 public decimals = 16; // Set to a non-zero, safe value

    constructor() Ownable(msg.sender) {
        // No need to initialize decimals again as it's already initialized in the state variable declaration
    }

    function getDecimals() public view returns (uint8) {
        return decimals;
    }
}"
6318,Deploy a new TokenNetwork contract for the Token deployed at ` _token_address ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenNetworkFactory is Ownable {
    using SafeMath for uint256;

    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    mapping(address => address) public tokenToTokenNetworks;
    bool public tokenNetworkCreated;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    function createERC20TokenNetwork(address _token_address) external returns (address token_network_address) {
        require(tokenToTokenNetworks[_token_address] == address(0x0), ""Token network already created for this token"");
        tokenNetworkCreated = true;
        TokenNetwork token_network = new TokenNetwork(_token_address, secretRegistryAddress, chainId, settlementTimeoutMin, settlementTimeoutMax, deprecationExecutor);
        token_network_address = address(token_network);
        tokenToTokenNetworks[_token_address] = token_network_address;
        emit TokenNetworkCreated(_token_address, token_network_address);
        return token_network_address;
    }
}

abstract contract TokenNetwork {
    using SafeMath for uint256;

    address public tokenAddress;
    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    constructor(address _token_address, address _secret_registry_address, uint256 _chain_id, uint256 _settlement_timeout_min, uint256 _settlement_timeout_max, address _deprecation_executor) {
        tokenAddress = _token_address;
        secretRegistryAddress = _secret_registry_address;
        chainId = _chain_id;
        settlementTimeoutMin = _settlement_timeout_min;
        settlementTimeoutMax = _settlement_timeout_max;
        deprecationExecutor = _deprecation_executor;
    }
}","[{'function': 'createERC20TokenNetwork', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""createERC20TokenNetwork"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""token_to_token_networks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token_address""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""A TokenNetwork already exists for this token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""secretRegistryAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""chainId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""chainid""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""minimumSettlementTimeout"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""maximumSettlementTimeout"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""7"", ""subdenomination"": ""days""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""deprecationExecutor"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}, ""name"": ""tokenNetwork"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}, {""type"": ""Identifier"", ""name"": ""secretRegistryAddress""}, {""type"": ""Identifier"", ""name"": ""chainId""}, {""type"": ""Identifier"", ""name"": ""minimumSettlementTimeout""}, {""type"": ""Identifier"", ""name"": ""maximumSettlementTimeout""}, {""type"": ""Identifier"", ""name"": ""deprecationExecutor""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenNetworkAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenNetwork""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""token_to_token_networks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token_address""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenNetworkAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""token_network_created""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenNetworkCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token_address""}, {""type"": ""Identifier"", ""name"": ""tokenNetworkAddress""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenNetworkFactory {
    bool public token_network_created = false;
    mapping(address => address) public token_to_token_networks;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    function createERC20TokenNetwork(address _token_address) external {
        require(token_to_token_networks[_token_address] == address(0), ""A TokenNetwork already exists for this token"");

        // Assuming the following parameters are set in a configuration or via constructor of TokenNetwork contract
        address secretRegistryAddress = 0x0; // Example value, should be replaced with actual address
        uint256 chainId = block.chainid; // Current chain ID
        uint32 minimumSettlementTimeout = 1 days; // Example value, adjust as needed
        uint32 maximumSettlementTimeout = 7 days; // Example value, adjust as needed
        address deprecationExecutor = msg.sender; // Example value, should be replaced with actual executor

        TokenNetwork tokenNetwork = new TokenNetwork(_token_address, secretRegistryAddress, chainId, minimumSettlementTimeout, maximumSettlementTimeout, deprecationExecutor);
        address tokenNetworkAddress = address(tokenNetwork);

        token_to_token_networks[_token_address] = tokenNetworkAddress;
        token_network_created = true;

        emit TokenNetworkCreated(_token_address, tokenNetworkAddress);
    }
}

contract TokenNetwork {
    address public immutable tokenAddress;
    address public immutable secretRegistryAddress;
    uint256 public immutable chainId;
    uint32 public immutable minimumSettlementTimeout;
    uint32 public immutable maximumSettlementTimeout;
    address public immutable deprecationExecutor;

    constructor(address _tokenAddress, address _secretRegistryAddress, uint256 _chainId, uint32 _minimumSettlementTimeout, uint32 _maximumSettlementTimeout, address _deprecationExecutor) {
        tokenAddress = _tokenAddress;
        secretRegistryAddress = _secretRegistryAddress;
        chainId = _chainId;
        minimumSettlementTimeout = _minimumSettlementTimeout;
        maximumSettlementTimeout = _maximumSettlementTimeout;
        deprecationExecutor = _deprecationExecutor;
    }
}",47.96173048019409,createERC20TokenNetwork,34.0,0.8340216372434514,0.2062791696726003,"[{'function': 'createERC20TokenNetwork', 'complexity': 1}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenNetworkFactory is Ownable {
    bool public token_network_created = false;
    mapping(address => address) public token_to_token_networks;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    function createERC20TokenNetwork(address _token_address) external {
        require(token_to_token_networks[_token_address] == address(0), ""A TokenNetwork already exists for this token"");

        // Assuming the following parameters are set in a configuration or via constructor of TokenNetwork contract
        address secretRegistryAddress = 0x0; // Example value, should be replaced with actual address
        uint256 chainId = block.chainid; // Current chain ID
        uint32 minimumSettlementTimeout = 1 days; // Example value, adjust as needed
        uint32 maximumSettlementTimeout = 7 days; // Example value, adjust as needed
        address deprecationExecutor = msg.sender; // Example value, should be replaced with actual executor

        TokenNetwork tokenNetwork = new TokenNetwork(_token_address, secretRegistryAddress, chainId, minimumSettlementTimeout, maximumSettlementTimeout, deprecationExecutor);
        address tokenNetworkAddress = address(tokenNetwork);

        token_to_token_networks[_token_address] = tokenNetworkAddress;
        token_network_created = true;

        emit TokenNetworkCreated(_token_address, tokenNetworkAddress);
    }
}
import ""openzeppelin/SafeMath.sol"";
contract TokenNetwork is Ownable {
    address public immutable tokenAddress;
    address public immutable secretRegistryAddress;
    uint256 public immutable chainId;
    uint32 public immutable minimumSettlementTimeout;
    uint32 public immutable maximumSettlementTimeout;
    address public immutable deprecationExecutor;

    constructor(address _tokenAddress, address _secretRegistryAddress, uint256 _chainId, uint32 _minimumSettlementTimeout, uint32 _maximumSettlementTimeout, address _deprecationExecutor) Ownable(msg.sender) {
        tokenAddress = _tokenAddress;
        secretRegistryAddress = _secretRegistryAddress;
        chainId = _chainId;
        minimumSettlementTimeout = _minimumSettlementTimeout;
        maximumSettlementTimeout = _maximumSettlementTimeout;
        deprecationExecutor = _deprecationExecutor;
    }
}"
2003,Refund a given address for all the Ether they have contributed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public userFundedPool;

    modifier isAdmin() {
        require(owner() == msg.sender, ""Caller is not the admin"");
        _;
    }

    modifier isAdminRefundable(address _address) {
        require(_address != address(0), ""Invalid address"");
        _;
    }

    modifier userHasFundedPool(address _address) {
        require(userFundedPool[_address], ""User has not funded the pool"");
        _;
    }

    function refundAddress(address _address) public isAdmin isAdminRefundable(_address) userHasFundedPool(_address) {
        processRefundInternal(_address);
    }

    function processRefundInternal(address _address) internal {
        // Implementation of the refund logic
    }
}","[{'function': 'refundAddress', 'complexity': 0}, {'function': 'processRefundInternal', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""refundAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refundsAllowed""}, {""type"": ""stringLiteral"", ""value"": ""Refunds are not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasFundedPool""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, {""type"": ""stringLiteral"", ""value"": ""User has not funded the pool""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""processRefundInternal""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract RefundProcessor {
    address public admin;
    bool public refundsAllowed = true;

    mapping(address => bool) public hasFundedPool;

    event RefundProcessed(address indexed user);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Caller is not the admin"");
        _;
    }

    constructor(address _admin) {
        admin = _admin;
    }

    function setRefundsAllowed(bool allowed) public onlyAdmin {
        refundsAllowed = allowed;
    }

    function userHasFundedPool(address user) public view returns (bool) {
        return hasFundedPool[user];
    }

    function refundAddress(address _address) public onlyAdmin {
        require(refundsAllowed, ""Refunds are not allowed"");
        require(hasFundedPool[_address], ""User has not funded the pool"");
        processRefundInternal(_address);
    }

    function processRefundInternal(address user) internal {
        // Logic to handle refund for the user
        emit RefundProcessed(user);
    }
}",44.11999702453613,refundAddress,13.0,0.8229847412158092,0.297843850913732,"[{'function': 'setRefundsAllowed', 'complexity': 0}, {'function': 'userHasFundedPool', 'complexity': 0}, {'function': 'refundAddress', 'complexity': 2}, {'function': 'processRefundInternal', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RefundProcessor is Ownable {
    address public admin;
    bool public refundsAllowed = true;

    mapping(address => bool) public hasFundedPool;

    event RefundProcessed(address indexed user);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Caller is not the admin"");
        _;
    }

    constructor(address _admin) Ownable(_admin) {
        admin = _admin;
    }

    function setRefundsAllowed(bool allowed) public onlyAdmin {
        refundsAllowed = allowed;
    }

    function userHasFundedPool(address user) public view returns (bool) {
        return hasFundedPool[user];
    }

    function refundAddress(address _address) public onlyAdmin {
        require(refundsAllowed, ""Refunds are not allowed"");
        require(hasFundedPool[_address], ""User has not funded the pool"");
        processRefundInternal(_address);
    }

    function processRefundInternal(address user) internal {
        // Logic to handle refund for the user
        emit RefundProcessed(user);
    }
}"
1814,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint securityGuardDelay;
        uint earliestPayTime;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        if (_delay > 10**18) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}","[{'function': 'delayPayment', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""delayPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_delay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid payment ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""payment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""paid""}, ""isPrefix"": True}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""canceled""}, ""isPrefix"": True}}, {""type"": ""stringLiteral"", ""value"": ""Payment already paid or canceled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Delay exceeds maximum allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""earliestPayTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PaymentManager {
    struct Payment {
        uint256 securityGuardDelay;
        uint256 earliestPayTime;
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;
    mapping(uint256 => address) public paymentToOwner;

    function delayPayment(uint256 _idPayment, uint256 _delay) external {
        require(_idPayment < authorizedPayments.length, ""Invalid payment ID"");
        Payment storage payment = authorizedPayments[_idPayment];
        require(!payment.paid && !payment.canceled, ""Payment already paid or canceled"");
        require(payment.securityGuardDelay + _delay <= 10**18, ""Delay exceeds maximum allowed"");

        payment.securityGuardDelay += _delay;
        payment.earliestPayTime += _delay;
    }
}",43.37584137916565,delayPayment,40.0,0.6884483633187712,0.0772210553402596,"[{'function': 'delayPayment', 'complexity': 6}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentManager is Ownable {
    struct Payment {
        uint256 securityGuardDelay;
        uint256 earliestPayTime;
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;
    mapping(uint256 => address) public paymentToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            authorizedPayments.push(Payment({
                securityGuardDelay: 1,
                earliestPayTime: block.timestamp + 1 days,
                paid: false,
                canceled: false
            }));
        }
    }

    function delayPayment(uint256 _idPayment, uint256 _delay) external {
        require(_idPayment < authorizedPayments.length, ""Invalid payment ID"");
        Payment storage payment = authorizedPayments[_idPayment];
        require(!payment.paid && !payment.canceled, ""Payment already paid or canceled"");
        require(payment.securityGuardDelay + _delay <= 10**18, ""Delay exceeds maximum allowed"");

        payment.securityGuardDelay += _delay;
        payment.earliestPayTime += _delay;
    }
}"
4481,This is a private function which should be called from user-implemented external burn function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract NFToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) private _tokenOwner;
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    modifier validNFToken(uint256 tokenId) {
        require(_exists(tokenId), ""NFToken: token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    function clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            delete _tokenApprovals[tokenId];
        }
    }

    function removeNFToken(address owner, uint256 tokenId) internal {
        require(_tokenOwner[tokenId] == owner, ""NFToken: token not owned by owner"");
        delete _tokenOwner[tokenId];
        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);
    }
}","[{'function': '_burn', 'complexity': 0}, {'function': '_exists', 'complexity': 0}, {'function': 'clearApproval', 'complexity': 1}, {'function': 'removeNFToken', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeNFToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_owners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_owner""}}, {""type"": ""stringLiteral"", ""value"": ""NFToken: owner does not match token ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_owners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""isPrefix"": True}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_ownedTokensIndex""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""-"", ""subExpression"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}, ""isPrefix"": True}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_ownedTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

abstract contract NFToken {
    // Mapping from token ID to owner address
    mapping(uint256 => address) internal _owners;
    // Mapping from owner to list of owned token IDs
    mapping(address => uint256[]) internal _ownedTokens;
    // Mapping from token ID to approved address
    mapping(uint256 => address) internal _tokenApprovals;

    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);

    modifier validNFToken(uint256 _tokenId) {
        require(_exists(_tokenId), ""NFToken: token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal virtual validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    function _exists(uint256 _tokenId) internal view virtual returns (bool) {
        return _owners[_tokenId] != address(0);
    }

    function clearApproval(uint256 _tokenId) internal virtual {
        if (_tokenApprovals[_tokenId] != address(0)) {
            delete _tokenApprovals[_tokenId];
        }
    }

    function removeNFToken(address _owner, uint256 _tokenId) internal virtual {
        require(_owners[_tokenId] == _owner, ""NFToken: owner does not match token ID"");
        delete _owners[_tokenId];
        uint256 index = _ownedTokensIndex(_owner, _tokenId);
        if (index != uint256(-1)) {
            // This will emit the event with the zero address as the to address
            _ownedTokens[_owner][index] = _ownedTokens[_owner][_ownedTokens[_owner].length - 1];
            _ownedTokens[_owner].pop();
        }
    }

    function _ownedTokensIndex(address _owner, uint256 _tokenId) internal view virtual returns (uint256) {
        return _ownedTokens[_owner].indexOf(_tokenId);
    }
}",47.5855929851532,removeNFToken,20.0,0.49563768992948,0.2041687190212913,"[{'function': '_burn', 'complexity': 0}, {'function': '_exists', 'complexity': 0}, {'function': 'clearApproval', 'complexity': 1}, {'function': 'removeNFToken', 'complexity': 2}, {'function': '_ownedTokensIndex', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NFToken is Ownable {
    // Mapping from token ID to owner address
    mapping(uint256 => address) internal _owners;
    // Mapping from owner to list of owned token IDs
    mapping(address => uint256[]) internal _ownedTokens;
    // Mapping from token ID to approved address
    mapping(uint256 => address) internal _tokenApprovals;

    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);

    modifier validNFToken(uint256 _tokenId) {
        require(_exists(_tokenId), ""NFToken: token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal virtual validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    function _exists(uint256 _tokenId) internal view virtual returns (bool) {
        return _owners[_tokenId] != address(0);
    }

    function clearApproval(uint256 _tokenId) internal virtual {
        if (_tokenApprovals[_tokenId] != address(0)) {
            delete _tokenApprovals[_tokenId];
        }
    }

    function removeNFToken(address _owner, uint256 _tokenId) internal virtual {
        require(_owners[_tokenId] == _owner, ""NFToken: owner does not match token ID"");
        delete _owners[_tokenId];
        uint256 index = _ownedTokensIndex(_owner, _tokenId);
        if (index != uint256(-1)) {
            // This will emit the event with the zero address as the to address
            _ownedTokens[_owner][index] = _ownedTokens[_owner][_ownedTokens[_owner].length - 1];
            _ownedTokens[_owner].pop();
        }
    }

    function _ownedTokensIndex(address _owner, uint256 _tokenId) internal view virtual returns (uint256) {
        return _ownedTokens[_owner].indexOf(_tokenId);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 tokenId = 1;
        address ownerAddress = address(uint160(uint256(keccak256('address')) % 3));

        _owners[tokenId] = ownerAddress;
        _ownedTokens[ownerAddress].push(tokenId);
    }
}"
3728,"Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        require(_value <= balanceOf[msg.sender]);

        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }
}","[{'function': 'transfer', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be non-negative""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_value >= 0, ""Amount must be non-negative"");
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",42.854883670806885,approve,22.0,0.8090940338542286,0.6049219175380743,"[{'function': 'approve', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""Ownable/contracts/ownership/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            allowances[address(this)][address(uint160(i))] = 1;
        }
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_value >= 0, ""Amount must be non-negative"");
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
213,Get the price of a campaign Based on the Campaign id return the value paid for each proof of attention registered .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdvertisementWrapper {
    using SafeMath for uint256;

    struct CampaignPrice {
        bytes32 bidId;
        uint price;
    }

    mapping(bytes32 => uint) public campaignPrices;

    constructor(CampaignPrice[] memory initialCampaigns) {
        for (uint i = 0; i < initialCampaigns.length; i++) {
            campaignPrices[initialCampaigns[i].bidId] = initialCampaigns[i].price;
        }
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return campaignPrices[bidId];
    }
}","[{'function': 'getPriceOfCampaign', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPriceOfCampaign"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""advertisementStorage""}, ""memberName"": ""getCampaignPriceById""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""bidId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CampaignPriceRetriever {
    // Assuming advertisementStorage is an instance of a contract that stores campaign prices by bid ID
    AdvertisementStorage public advertisementStorage;

    constructor(address _advertisementStorage) {
        advertisementStorage = AdvertisementStorage(_advertisementStorage);
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return advertisementStorage.getCampaignPriceById(bidId);
    }
}",42.14543962478638,getPriceOfCampaign,2.0,0.8235161374934519,0.6859238121837058,"[{'function': 'getPriceOfCampaign', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CampaignPriceRetriever is Ownable {
    // Assuming advertisementStorage is an instance of a contract that stores campaign prices by bid ID
    AdvertisementStorage public advertisementStorage;

    constructor(address _advertisementStorage) Ownable(msg.sender) {
        advertisementStorage = AdvertisementStorage(_advertisementStorage);
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return advertisementStorage.getCampaignPriceById(bidId);
    }
}"
2236,Deposit fees into the vault for a Darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface CompatibleERC20 {
    function safeTransferFromWithFees(address from, address to, uint256 value) external returns (uint256);
}

abstract contract DarknodeDeposit is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(ERC20 => uint256)) public darknodeBalances;

    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {
        require(msg.sender == address(this));
        require(_token != address(0) || msg.value == _value);
        require(_token != address(0) && msg.value == 0);
        uint256 receivedValue = _value;
        if (_token != address(0)) {
            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);
        }
        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFromWithFees', 'complexity': 0}, {'function': 'deposit', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_darknode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect Ether amount sent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknode""}}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Ether should not be sent alongside token transfer""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""transferFrom(address,address,uint256)""}], ""names"": []}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodeBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_darknode""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract DarknodeDeposit {
    mapping(address => mapping(address => uint256)) public darknodeBalances;

    function deposit(address _darknode, address _token, uint256 _value) external payable {
        require(_value > 0, ""Value must be greater than zero"");

        if (_token == address(0)) {
            require(msg.value == _value, ""Incorrect Ether amount sent"");
            // Deposit Ether
            darknodeBalances[_darknode][address(0)] += _value;
        } else {
            require(msg.value == 0, ""Ether should not be sent alongside token transfer"");
            // Transfer tokens
            (bool success, ) = _token.call(abi.encodeWithSelector(bytes4(keccak256(""transferFrom(address,address,uint256)"")), msg.sender, address(this), _value));
            require(success, ""Token transfer failed"");
            darknodeBalances[_darknode][_token] += _value;
        }
    }
}",44.01376962661743,deposit,46.0,0.9270787040986468,0.2647746273412707,"[{'function': 'deposit', 'complexity': 5}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DarknodeDeposit is Ownable {
    mapping(address => mapping(address => uint256)) public darknodeBalances;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function deposit(address _darknode, address _token, uint256 _value) external payable {
        require(_value > 0, ""Value must be greater than zero"");

        if (_token == address(0)) {
            require(msg.value == _value, ""Incorrect Ether amount sent"");
            // Deposit Ether
            darknodeBalances[_darknode][address(0)] += _value;
        } else {
            require(msg.value == 0, ""Ether should not be sent alongside token transfer"");
            // Transfer tokens
            (bool success, ) = _token.call(abi.encodeWithSelector(bytes4(keccak256(""transferFrom(address,address,uint256)"")), msg.sender, address(this), _value));
            require(success, ""Token transfer failed"");
            darknodeBalances[_darknode][_token] += _value;
        }
    }
}"
3103,Checks whether redemption is permitted for a participant,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RedemptionPermitWrapper is Ownable {
    using SafeMath for uint256;

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public view returns (bool) {
        return true;
    }
}","[{'function': 'isRedemptionPermitted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRedemptionPermitted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""ofParticipant"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""shareQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""receiveQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract ShareRedemption {
    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public pure returns (bool) {
        return true;
    }
}",41.47160363197327,isRedemptionPermitted,0.0,0.9551033522950996,0.8725129388059689,"[{'function': 'isRedemptionPermitted', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ShareRedemption is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public pure returns (bool) {
        return true;
    }
}"
5733,Function which decodes bytes32 to array of integers,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DecodeAssetsWrapper {
    using SafeMath for uint256;

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory assets) {
        require(_potentialAssets.length > 0);

        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint numberOfAssets = 0;

        for (uint j = 0; j < _potentialAssets.length; j++) {
            uint input;
            bytes32 pot = _potentialAssets[j];
            assembly {
                input := pot
            }

            for (uint i = 10; i > 0; i--) {
                uint mask = (2 << ((i - 1) * 24)) / 2;
                uint b = (input & (mask * 16777215)) / mask;
                if (b != 0) {
                    assetsCopy[numberOfAssets] = b;
                    numberOfAssets++;
                }
            }
        }

        assets = new uint[](numberOfAssets);
        for (uint i = 0; i < numberOfAssets; i++) {
            assets[i] = assetsCopy[i];
        }
    }
}","[{'function': 'decodeAssets', 'complexity': 8}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""decodeAssets"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": ""_potentialAssets"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Input array must be non-empty""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""assetsCopy"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""count"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""asset"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_potentialAssets""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""extractedAsset"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""extractAssetIdentifier""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""asset""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""extractedAsset""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetsCopy""}, ""index"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""count""}, ""isPrefix"": False}}, ""right"": {""type"": ""Identifier"", ""name"": ""extractedAsset""}}}]}, ""FalseBody"": None}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""assets"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""count""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""count""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetsCopy""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}]}}, {""type"": ""Identifier"", ""name"": ""assets""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract AssetDecoder {
    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory) {
        require(_potentialAssets.length > 0, ""Input array must be non-empty"");

        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint count;

        for (uint i = 0; i < _potentialAssets.length; i++) {
            bytes32 asset = _potentialAssets[i];
            // Assuming specific extraction logic here, replace with actual implementation
            uint extractedAsset = extractAssetIdentifier(asset);
            if (extractedAsset != 0) {
                assetsCopy[count++] = extractedAsset;
            }
        }

        uint[] memory assets = new uint[](count);
        for (uint i = 0; i < count; i++) {
            assets[i] = assetsCopy[i];
        }

        return assets;
    }

    function extractAssetIdentifier(bytes32 asset) internal pure returns (uint) {
        // Example extraction logic, replace with actual implementation
        uint value;
        assembly {
            value := and(asset, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
        }
        return value;
    }
}",44.71075868606568,decodeAssets,50.0,0.8219219576388724,0.3910932922919078,"[{'function': 'decodeAssets', 'complexity': 6}, {'function': 'extractAssetIdentifier', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetDecoder is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory) {
        require(_potentialAssets.length > 0, ""Input array must be non-empty"");

        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint count;

        for (uint i = 0; i < _potentialAssets.length; i++) {
            bytes32 asset = _potentialAssets[i];
            // Assuming specific extraction logic here, replace with actual implementation
            uint extractedAsset = extractAssetIdentifier(asset);
            if (extractedAsset != 0) {
                assetsCopy[count++] = extractedAsset;
            }
        }

        uint[] memory assets = new uint[](count);
        for (uint i = 0; i < count; i++) {
            assets[i] = assetsCopy[i];
        }

        return assets;
    }

    function extractAssetIdentifier(bytes32 asset) internal pure returns (uint) {
        // Example extraction logic, replace with actual implementation
        uint value;
        assembly {
            value := and(asset, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
        }
        return value;
    }
}"
5459,Begins the token sale for this token instance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    function initializeTokenSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) public onlyOwner {
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}","[{'function': 'initializeTokenSale', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_saleStartTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_saleEndTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountForSale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_saleStartTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sale start time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_saleEndTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_saleStartTime""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sale end time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amountForSale""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount for sale must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary cannot be the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""saleStartTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_saleStartTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""saleEndTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_saleEndTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""pricePerToken""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""amountForSale""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amountForSale""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""right"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenSaleInitialized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_saleStartTime""}, {""type"": ""Identifier"", ""name"": ""_saleEndTime""}, {""type"": ""Identifier"", ""name"": ""_price""}, {""type"": ""Identifier"", ""name"": ""_amountForSale""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BeneficiarySet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""ownerOnly"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenSale {
    address private owner;
    uint256 public saleStartTime;
    uint256 public saleEndTime;
    uint256 public pricePerToken;
    uint256 public amountForSale;
    address public beneficiary;

    modifier ownerOnly() {
        require(msg.sender == owner, ""Caller is not the contract owner"");
        _;
    }

    event TokenSaleInitialized(uint256 saleStartTime, uint256 saleEndTime, uint256 pricePerToken, uint256 amountForSale, address beneficiary);
    event BeneficiarySet(address indexed beneficiary);

    constructor() {
        owner = msg.sender;
    }

    function initializeSale(uint256 _saleStartTime, uint256 _saleEndTime, uint256 _price, uint256 _amountForSale, address _beneficiary) external ownerOnly {
        require(_saleStartTime > block.timestamp, ""Invalid sale start time"");
        require(_saleEndTime > _saleStartTime, ""Invalid sale end time"");
        require(_price > 0, ""Price must be greater than zero"");
        require(_amountForSale > 0, ""Amount for sale must be greater than zero"");
        require(_beneficiary != address(0), ""Beneficiary cannot be the zero address"");

        saleStartTime = _saleStartTime;
        saleEndTime = _saleEndTime;
        pricePerToken = _price;
        amountForSale = _amountForSale;
        beneficiary = _beneficiary;

        emit TokenSaleInitialized(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
        emit BeneficiarySet(_beneficiary);
    }
}",46.17838001251221,initializeSale,63.0,0.5128057514289222,0.1384524881751876,"[{'function': 'initializeSale', 'complexity': 5}]",7.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    address private owner;
    uint256 public saleStartTime;
    uint256 public saleEndTime;
    uint256 public pricePerToken;
    uint256 public amountForSale;
    address public beneficiary;

    modifier ownerOnly() {
        require(msg.sender == owner, ""Caller is not the contract owner"");
        _;
    }

    event TokenSaleInitialized(uint256 saleStartTime, uint256 saleEndTime, uint256 pricePerToken, uint256 amountForSale, address beneficiary);
    event BeneficiarySet(address indexed beneficiary);

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        saleStartTime = 1;
        saleEndTime = 2;
        pricePerToken = 3;
        amountForSale = 4;
        beneficiary = address(0x111);
    }

    function initializeSale(uint256 _saleStartTime, uint256 _saleEndTime, uint256 _price, uint256 _amountForSale, address _beneficiary) external ownerOnly {
        require(_saleStartTime > block.timestamp, ""Invalid sale start time"");
        require(_saleEndTime > _saleStartTime, ""Invalid sale end time"");
        require(_price > 0, ""Price must be greater than zero"");
        require(_amountForSale > 0, ""Amount for sale must be greater than zero"");
        require(_beneficiary != address(0), ""Beneficiary cannot be the zero address"");

        saleStartTime = _saleStartTime;
        saleEndTime = _saleEndTime;
        pricePerToken = _price;
        amountForSale = _amountForSale;
        beneficiary = _beneficiary;

        emit TokenSaleInitialized(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
        emit BeneficiarySet(_beneficiary);
    }
}"
6434,Set current preICO price in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public preICOprice;

    constructor() Ownable() {}

    function setPreICOPrice(uint256 priceForPreIcoInWei) public isOwner {
        require(priceForPreIcoInWei > 0, ""The price for pre-ICO should be greater than zero"");
        require(preICOprice != priceForPreIcoInWei, ""The price for pre-ICO has not changed"");
        preICOprice = priceForPreIcoInWei;
        updatePrices();
    }
}","[{'function': 'setPreICOPrice', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreICOprice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""priceForPreIcoInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""priceForPreIcoInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""priceForPreIcoInWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""preICOprice""}}, {""type"": ""stringLiteral"", ""value"": ""New price must differ from the current preICOprice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preICOprice""}, ""right"": {""type"": ""Identifier"", ""name"": ""priceForPreIcoInWei""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PriceUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""preICOprice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    uint256 public preICOprice;

    event PriceUpdated(uint256 newPrice);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setPreICOprice(uint256 priceForPreIcoInWei) public onlyOwner {
        require(priceForPreIcoInWei > 0, ""Price must be greater than zero"");
        require(priceForPreIcoInWei != preICOprice, ""New price must differ from the current preICOprice"");

        preICOprice = priceForPreIcoInWei;
        emit PriceUpdated(preICOprice);
        updatePrices(); // Assuming this function exists and updates related pricing information.
    }

    function updatePrices() internal {
        // Implementation of the updatePrices function, if needed.
    }
}",43.64188170433045,setPreICOprice,4.0,0.9124232962772494,0.3597308678464986,"[{'function': 'setPreICOprice', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner = msg.sender;
    uint256 public preICOprice = 1;

    event PriceUpdated(uint256 newPrice);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setPreICOprice(uint256 priceForPreIcoInWei) public onlyOwner {
        require(priceForPreIcoInWei > 0, ""Price must be greater than zero"");
        require(priceForPreIcoInWei != preICOprice, ""New price must differ from the current preICOprice"");

        preICOprice = priceForPreIcoInWei;
        emit PriceUpdated(preICOprice);
        updatePrices(); // Assuming this function exists and updates related pricing information.
    }

    function updatePrices() internal {
        // Implementation of the updatePrices function, if needed.
    }
}"
30,Called in order to get the number of members on the platform,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Define membersArray as a state variable
    address[] public membersArray;

    function getMembersArrayLength() public view returns (uint256) {
        return membersArray.length;
    }
}","[{'function': 'getMembersArrayLength', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMembersLength"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""membersArray""}, ""memberName"": ""length""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract MemberContract {
    uint[] public membersArray;

    function getMembersLength() external view returns (uint) {
        return membersArray.length;
    }
}",41.557334184646606,getMembersLength,0.0,0.9617094004261492,0.4001601601922499,"[{'function': 'getMembersLength', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MemberContract is Ownable {
    uint[] public membersArray;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        membersArray = [1]; // Fixed value for initialization
    }

    function getMembersLength() external view returns (uint) {
        return membersArray.length;
    }
}"
3380,Count the number of validators defined by the jurisdiction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorCounter {
    using SafeMath for uint256;

    address[] private _validatorAccounts;

    function countValidators() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}","[{'function': 'countValidators', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""countValidatorAccounts"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_validatorAccounts""}, ""memberName"": ""length""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract ValidatorRegistry {
    address[] private _validatorAccounts;

    function countValidatorAccounts() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}",41.989399671554565,countValidatorAccounts,0.0,0.9721109040523302,0.855526185871245,"[{'function': 'countValidatorAccounts', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ValidatorRegistry is Ownable {
    address[] private _validatorAccounts;

    constructor() Ownable(msg.sender) {
        _validatorAccounts = [address(1), address(2), address(3)];
    }

    function countValidatorAccounts() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}"
5188,allows to retreive multiple exchange rates in once call,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchangeRate {
    function getExchangeRate(address numeratorToken, address denominatorToken) external view returns (uint256);
    function getTimestamp() external view returns (uint256);
}

abstract contract ExchangeRates is Ownable {
    using SafeMath for uint256;

    IExchangeRate public exchangeRateContract;

    constructor(address _exchangeRateAddress) {
        exchangeRateContract = IExchangeRate(_exchangeRateAddress);
    }

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public view returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length > 0 && denominatorTokens.length > 0);
        require(numeratorTokens.length == denominatorTokens.length, ""Lengths must be equal"");

        rateFractions = new uint256[](numeratorTokens.length * denominatorTokens.length);
        timestamps = new uint256[](numeratorTokens.length * denominatorTokens.length);

        for (uint256 i = 0; i < numeratorTokens.length; i++) {
            address numeratorToken = numeratorTokens[i];
            for (uint256 j = 0; j < denominatorTokens.length; j++) {
                address denominatorToken = denominatorTokens[j];
                uint256 rateFraction = exchangeRateContract.getExchangeRate(numeratorToken, denominatorToken);
                uint256 timestamp = exchangeRateContract.getTimestamp();
                rateFractions[i * denominatorTokens.length + j] = rateFraction;
                timestamps[i * denominatorTokens.length + j] = timestamp;
            }
        }
    }
}","[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'getExchangeRates', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""getExchangeRates"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""numeratorTokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""denominatorTokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""rateFractions"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""timestamps"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""denominatorTokens""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Arrays must have the same length""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""rateFractions""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timestamps""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}], ""names"": []}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numeratorTokens""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rateFractions""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""timestamps""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract ExchangeRateRetriever {
    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public pure returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length == denominatorTokens.length, ""Arrays must have the same length"");

        rateFractions = new uint256[](numeratorTokens.length);
        timestamps = new uint256[](numeratorTokens.length);

        for (uint i = 0; i < numeratorTokens.length; i++) {
            // Placeholder logic: Calculate exchange rate and timestamp here
            // Example calculation: Assume each token pair has a fixed exchange rate of 100
            rateFractions[i] = 100;
            timestamps[i] = block.timestamp;
        }
    }
}",43.37918257713318,getExchangeRates,69.0,0.7051238767387467,0.3636559661387895,"[{'function': 'getExchangeRates', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ExchangeRateRetriever is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public pure returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length == denominatorTokens.length, ""Arrays must have the same length"");

        rateFractions = new uint256[](numeratorTokens.length);
        timestamps = new uint256[](numeratorTokens.length);

        for (uint i = 0; i < numeratorTokens.length; i++) {
            // Placeholder logic: Calculate exchange rate and timestamp here
            // Example calculation: Assume each token pair has a fixed exchange rate of 100
            rateFractions[i] = 100;
            timestamps[i] = block.timestamp;
        }
    }
}"
316,send ` _value ` token to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    address[] public tokenHolders;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        emit LogForkAnnounced(name, url, blockNumber);
    }
}","[{'function': 'approve', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""toRecord""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    mapping(address => uint256) public balances;

    function transfer(address _to, uint256 _value) external returns (bool) {
        require(_to != address(0), ""Invalid recipient address"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        // Assuming toRecord is an external function for logging or record-keeping
        toRecord(msg.sender, _to, _value);

        return true;
    }

    // External function for record-keeping (assuming)
    function toRecord(address _from, address _to, uint256 _value) external {
        // Implementation of the logging or record-keeping logic
    }
}",43.47287058830261,transfer,18.0,0.8441655394219343,0.5026506490082758,"[{'function': 'transfer', 'complexity': 1}, {'function': 'toRecord', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance for the owner to 1
    }

    function transfer(address _to, uint256 _value) external returns (bool) {
        require(_to != address(0), ""Invalid recipient address"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        // Assuming toRecord is an external function for logging or record-keeping
        toRecord(msg.sender, _to, _value);

        return true;
    }

    // External function for record-keeping (assuming)
    function toRecord(address _from, address _to, uint256 _value) external {
        // Implementation of the logging or record-keeping logic
    }
}"
4609,"Add beneficiaries to the contract , allowing them to withdraw tokens .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    struct Info {
        bool known;
        uint256 startTime;
        uint256 totalAmount;
        uint256 releaseTime;
    }

    mapping(address => Info) private _info;

    function addBeneficiary(address beneficiary, uint256 startTime, uint256 releaseTime, uint256 amount) external onlyOwner {
        require(_info[beneficiary].known == false, ""This address is already known to the contract."");
        require(releaseTime > startTime, ""Release time must be later than the start time."");
        require(releaseTime > block.timestamp, ""End of vesting period must be somewhere in the future."");

        Info storage info = _info[beneficiary];
        info.startTime = startTime;
        info.totalAmount = amount;
        info.releaseTime = releaseTime;
        info.known = true;
    }
}","[{'function': 'addBeneficiary', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_releaseTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid beneficiary address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_releaseTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Release time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_releaseTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}, {""type"": ""stringLiteral"", ""value"": ""Release time must be after start time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""memberName"": ""known""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary already known to the contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BeneficiaryInfo""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_startTime""}, {""type"": ""Identifier"", ""name"": ""_releaseTime""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""startTime"", ""releaseTime"", ""totalAmount"", ""known""]}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract VestingContract {
    struct BeneficiaryInfo {
        uint256 startTime;
        uint256 releaseTime;
        uint256 totalAmount;
        bool known;
    }

    address public owner;
    mapping(address => BeneficiaryInfo) public beneficiaries;
    OneledgerToken public token; // Assuming OneledgerToken is a defined contract or type

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor(address _token) {
        owner = msg.sender;
        token = OneledgerToken(_token);
    }

    function addBeneficiary(address _beneficiary, uint256 _startTime, uint256 _releaseTime, uint256 _amount)
        public
        onlyOwner
    {
        require(_beneficiary != address(0), ""Invalid beneficiary address"");
        require(_releaseTime > block.timestamp, ""Release time must be in the future"");
        require(_releaseTime > _startTime, ""Release time must be after start time"");
        require(!beneficiaries[_beneficiary].known, ""Beneficiary already known to the contract"");

        beneficiaries[_beneficiary] = BeneficiaryInfo({
            startTime: _startTime,
            releaseTime: _releaseTime,
            totalAmount: _amount,
            known: true
        });
    }
}",45.060049295425415,addBeneficiary,30.0,0.7418949009582205,0.1976477155161208,"[{'function': 'addBeneficiary', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract VestingContract {
    struct BeneficiaryInfo {
        uint256 startTime;
        uint256 releaseTime;
        uint256 totalAmount;
        bool known;
    }

    address public owner;
    mapping(address => BeneficiaryInfo) public beneficiaries;
    OneledgerToken public token; // Assuming OneledgerToken is a defined contract or type

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor(address _token) {
        owner = msg.sender;
        token = OneledgerToken(_token);
    }

    function addBeneficiary(address _beneficiary, uint256 _startTime, uint256 _releaseTime, uint256 _amount)
        public
        onlyOwner
    {
        require(_beneficiary != address(0), ""Invalid beneficiary address"");
        require(_releaseTime > block.timestamp, ""Release time must be in the future"");
        require(_releaseTime > _startTime, ""Release time must be after start time"");
        require(!beneficiaries[_beneficiary].known, ""Beneficiary already known to the contract"");

        beneficiaries[_beneficiary] = BeneficiaryInfo({
            startTime: _startTime,
            releaseTime: _releaseTime,
            totalAmount: _amount,
            known: true
        });
    }
}"
5346,You must send some ETH to cover the oraclize_query fees,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    enum Stage { ToInitialize, Waiting, Running, Ended }

    uint256 public startTime;
    uint256 public endTime;
    Token public token;
    uint256 public intervalUpdate;
    Stage public currentStage = Stage.ToInitialize;
    uint256 public constant MAX_TOKENS = 10**28; // Example value, adjust as needed

    constructor(address _token) {
        require(_token != address(0));
        token = Token(_token);
    }

    function initializeCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _intervalUpdate) public payable onlyOwner mustBeAtStage(Stage.ToInitialize) {
        require(_startTime >= block.timestamp);
        require(_endTime >= _startTime);
        require(_token != address(0));
        require(msg.value > 0);
        require(isContract(_token) == true);
        require(_intervalUpdate >= 5);

        startTime = _startTime;
        endTime = _endTime;
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;
        updateEthRateWithDelay(startTime - (intervalUpdate + 30));
        emit LogCrowdsaleInit();
        assert(token.balanceOf(address(this)) == MAX_TOKENS);
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    modifier mustBeAtStage(Stage requiredStage) {
        require(currentStage == requiredStage, ""Must be at the specified stage"");
        _;
    }

    function updateEthRateWithDelay(uint256 delayTime) internal {
        // Implementation of the delay logic
    }

    event LogCrowdsaleInit();
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'initializeCrowdsale', 'complexity': 7}, {'function': 'isContract', 'complexity': 0}, {'function': 'updateEthRateWithDelay', 'complexity': 0}]",8.0,{},"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract Crowdsale {
    enum Stage { Waiting, Running, Ended }

    address public owner;
    uint public startTime;
    uint public endTime;
    address public token;
    uint public intervalUpdate;
    uint public currentStageStartTime;
    Stage public currentStage;
    uint public constant MAX_TOKENS = 1000 * 10**18; // Example max tokens

    event LogCrowdsaleInit(address indexed token, uint startTime, uint endTime);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    constructor(uint _startTime, uint _endTime, address _token, uint _intervalUpdate) {
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        require(_endTime > _startTime, ""End time must be after start time"");
        require(_token != address(0), ""Token address cannot be zero"");
        require(_intervalUpdate >= 5 seconds, ""Interval update must be at least 5 seconds"");
        require(msg.value > 0, ""Caller must send Ether with the transaction"");
        require(IERC20(_token).balanceOf(_token) == MAX_TOKENS, ""Token balance does not match MAX_TOKENS"");

        owner = msg.sender;
        startTime = _startTime;
        endTime = _endTime;
        token = _token;
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;

        emit LogCrowdsaleInit(_token, _startTime, _endTime);
    }
}",46.08062815666199,,95.0,0.0759886690341509,0.0,"[{'function': 'balanceOf', 'complexity': 0}]",0.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract Crowdsale is Ownable {
    enum Stage { Waiting, Running, Ended }

    address public owner;
    uint public startTime;
    uint public endTime;
    address public token;
    uint public intervalUpdate;
    uint public currentStageStartTime;
    Stage public currentStage;
    uint public constant MAX_TOKENS = 1000 * 10**18; // Example max tokens

    event LogCrowdsaleInit(address indexed token, uint startTime, uint endTime);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(uint _startTime, uint _endTime, address _token, uint _intervalUpdate) Ownable(_token) {
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        require(_endTime > _startTime, ""End time must be after start time"");
        require(_token != address(0), ""Token address cannot be zero"");
        require(_intervalUpdate >= 5 seconds, ""Interval update must be at least 5 seconds"");
        require(msg.value > 0, ""Caller must send Ether with the transaction"");
        require(IERC20(_token).balanceOf(_token) == MAX_TOKENS, ""Token balance does not match MAX_TOKENS"");

        owner = msg.sender;
        startTime = _startTime;
        endTime = _endTime;
        token = _token;
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;

        emit LogCrowdsaleInit(_token, _startTime, _endTime);
    }
}"
2424,Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeToken {
    function changeController(address _newController) external;
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    constructor() {}

    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public onlyOwner returns (MiniMeToken) {
        MiniMeToken newToken = MiniMeToken(_parentToken).cloneTokenWithDetails(_snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled);
        newToken.changeController(msg.sender);
        return newToken;
    }
}","[{'function': 'changeController', 'complexity': 0}, {'function': 'createCloneToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_parentToken"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_snapshotBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_tokenName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_decimalUnits"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_tokenSymbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}, ""name"": ""newToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}, {""type"": ""Identifier"", ""name"": ""_parentToken""}, {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}, {""type"": ""Identifier"", ""name"": ""_tokenName""}, {""type"": ""Identifier"", ""name"": ""_decimalUnits""}, {""type"": ""Identifier"", ""name"": ""_tokenSymbol""}, {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ConstructorEvent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newToken""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newToken""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""./MiniMeToken.sol"";

contract MiniMeTokenFactory {
    function createCloneToken(
        address _parentToken,
        uint256 _snapshotBlock,
        string memory _tokenName,
        uint8 _decimalUnits,
        string memory _tokenSymbol,
        bool _transfersEnabled
    ) external returns (address) {
        MiniMeToken newToken = new MiniMeToken(
            this, // controller
            _parentToken,
            _snapshotBlock,
            _tokenName,
            _decimalUnits,
            _tokenSymbol,
            _transfersEnabled
        );

        emit ConstructorEvent(newToken);

        return address(newToken);
    }

    event ConstructorEvent(address indexed newToken);
}",43.06018614768982,createCloneToken,11.0,0.8816560231019834,0.5982065891449534,"[{'function': 'createCloneToken', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./MiniMeToken.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MiniMeTokenFactory is Ownable {
    function createCloneToken(
        address _parentToken,
        uint256 _snapshotBlock,
        string memory _tokenName,
        uint8 _decimalUnits,
        string memory _tokenSymbol,
        bool _transfersEnabled
    ) external returns (address) {
        MiniMeToken newToken = new MiniMeToken(
            this, // controller
            _parentToken,
            _snapshotBlock,
            _tokenName,
            _decimalUnits,
            _tokenSymbol,
            _transfersEnabled
        );

        emit ConstructorEvent(newToken);

        return address(newToken);
    }

    event ConstructorEvent(address indexed newToken);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
474,Burns the coins held by the sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function burn(uint256 _value) public whenNotPaused {
        super.burn(_value);
    }
}","[{'function': 'burn', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Burn amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to burn""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is ERC20, Ownable {
    constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
    }

    function burn(uint256 _value) public whenNotPaused {
        require(_value > 0, ""Burn amount must be greater than zero"");
        address account = msg.sender;
        uint256 balance = balances[account];
        require(balance >= _value, ""Insufficient balance to burn"");

        totalSupply -= _value;
        balances[account] -= _value;

        emit Transfer(account, address(0), _value);
        emit Burn(account, _value);
    }

    event Burn(address indexed from, uint256 value);
}",43.81026101112366,burn,45.0,0.4477539205225231,0.1438891224146181,"[{'function': 'burn', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, Ownable {
    uint256 public totalSupply;

 constructor(uint256 initialSupply) ERC20(""MyToken"", ""MTK"") {
        _mint(msg.sender, initialSupply);
        initializeOwner();
    }

    function initializeOwner() internal {
        Ownable.__Ownable_init();
        transferOwnership(msg.sender);
    }

    function burn(uint256 _value) public whenNotPaused {
        require(_value > 0, ""Burn amount must be greater than zero"");
        address account = msg.sender;
        uint256 balance = balances[account];
        require(balance >= _value, ""Insufficient balance to burn"");

        totalSupply -= _value;
        balances[account] -= _value;

        emit Transfer(account, address(0), _value);
        emit Burn(account, _value);
    }

    event Burn(address indexed from, uint256 value);
}"
1413,Overwrite leaderboard name and desctiption as owner only,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BoardManager is Ownable {
    using SafeMath for uint256;

    struct Board {
        bytes32 boardName;
        string boardDescription;
        address boardOwner;
    }

    mapping(bytes32 => Board) public boards;

    function changeBoardMetadata(bytes32 boardHash, bytes32 name, string memory boardDescription) public onlyOwner returns (bool) {
        require(boards[boardHash].boardOwner == msg.sender);
        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
        return true;
    }
}","[{'function': 'changeBoardMetadata', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeBoardMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""boardHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""boardDescription"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""boardHash""}}, ""memberName"": ""boardOwner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can update the board metadata.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""boardHash""}}, ""memberName"": ""boardName""}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""boards""}, ""index"": {""type"": ""Identifier"", ""name"": ""boardHash""}}, ""memberName"": ""boardDescription""}, ""right"": {""type"": ""Identifier"", ""name"": ""boardDescription""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract BoardManager {
    struct Board {
        string boardName;
        string boardDescription;
        address boardOwner;
    }

    mapping(bytes32 => Board) public boards;

    function changeBoardMetadata(bytes32 boardHash, string memory name, string memory boardDescription) public {
        require(msg.sender == boards[boardHash].boardOwner, ""Only the owner can update the board metadata."");

        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
    }
}",42.70427823066712,changeBoardMetadata,10.0,0.9110638800153746,0.4830968512233653,"[{'function': 'changeBoardMetadata', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BoardManager is Ownable {
    struct Board {
        string boardName;
        string boardDescription;
        address boardOwner;
    }

    mapping(bytes32 => Board) public boards;

    constructor() Ownable(msg.sender) {
        // Initialize all state variables with safe, non-corner-case values
        for (bytes32 key = bytes32('a'); uint(key) < 10; key = bytes32(uint(key) + 1)) {
            boards[key] = Board({
                boardName: 'initialized',
                boardDescription: 'initialized',
                boardOwner: address(uint160(uint(key)))
            });
        }
    }

    function changeBoardMetadata(bytes32 boardHash, string memory name, string memory boardDescription) public {
        require(msg.sender == boards[boardHash].boardOwner, ""Only the owner can update the board metadata."");

        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
    }
}"
6348,"Helps to generate Collectibles/Tokens/Asset and transfer to ETH Cards , which can be redeemed using our web-app.The generation of an asset if limited via the generationSeasonController","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ETHCardCollectible is Ownable {
    using SafeMath for uint256;

    uint8 public teamId;
    uint8 public posId;
    uint256 public attributes;
    address public owner;
    uint256 public gameId;
    uint256 public playerOverrideId;
    uint256 public mlbPlayerId;
    uint256 public rewardsRedeemed;
    address public managerPrimary;
    bool public paused = false;

    constructor(address _managerPrimary) {
        managerPrimary = _managerPrimary;
    }

    function createETHCardCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external canCreate whenNotPaused returns (uint256) {
        address nftOwner = _owner;
        if (nftOwner == address(0)) {
            nftOwner = managerPrimary;
        }
        rewardsRedeemed++;
        uint32 _sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(uint64(now));
        assetDetails |= uint256(_sequenceId) << 64;
        assetDetails |= uint256(_teamId) << 96;
        assetDetails |= uint256(_posId) << 104;
        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];
        return _createNFTCollectible(_teamId, _attributes, nftOwner, 2, _nftData);
    }

    function getSequenceId(uint8 _teamId) internal pure returns (uint32) {
        // Implementation of getSequenceId logic
        return uint32(_teamId);
    }

    function _createNFTCollectible(uint8 _teamId, uint256 _attributes, address _owner, uint256 _type, uint256[5] memory _nftData) internal returns (uint256) {
        // Implementation of create NFT logic
        return 0;
    }

    modifier canCreate() {
        require(msg.sender == owner || msg.sender == managerPrimary, ""Not authorized to create collectible"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }
}","[{'function': 'createETHCardCollectible', 'complexity': 1}, {'function': 'getSequenceId', 'complexity': 0}, {'function': '_createNFTCollectible', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCollectible"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_teamId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_posId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_attributes"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_gameId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_playerOverrideId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_mlbPlayerId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""managerPrimary""}}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sequenceId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getSequenceId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_teamId""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""assetDetails"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""|"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""|"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""|"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""224"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<<"", ""left"": {""type"": ""Identifier"", ""name"": ""sequenceId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""192"", ""subdenomination"": None}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<<"", ""left"": {""type"": ""Identifier"", ""name"": ""_teamId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""160"", ""subdenomination"": None}}}, ""right"": {""type"": ""Identifier"", ""name"": ""_posId""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""nftData"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""assetDetails""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""_attributes""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""_gameId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""_playerOverrideId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nftData""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""_mlbPlayerId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""rewardsRedeemed""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createNFTCollectible""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_teamId""}, {""type"": ""Identifier"", ""name"": ""_attributes""}, {""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""nftData""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canCreate"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract CollectibleNFT {
    address public managerPrimary;
    bool public paused = false;
    uint256 public rewardsRedeemed = 0;

    modifier canCreate() {
        require(msg.sender == managerPrimary, ""Only managerPrimary can create an NFT"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function setManagerPrimary(address _managerPrimary) public {
        managerPrimary = _managerPrimary;
    }

    function pause() public {
        paused = true;
    }

    function unpause() public {
        paused = false;
    }

    function getSequenceId(uint256 _teamId) internal view returns (uint256) {
        // Placeholder for sequence ID retrieval logic
        return 0; // Replace with actual implementation
    }

    function _createNFTCollectible(
        uint256 _teamId,
        uint256 _attributes,
        address _owner,
        uint256 _type,
        uint256[] memory _nftData
    ) internal returns (uint256) {
        // Placeholder for NFT creation logic
        return 0; // Replace with actual implementation
    }

    function createCollectible(
        uint256 _teamId,
        uint256 _posId,
        uint256 _attributes,
        address _owner,
        uint256 _gameId,
        uint256 _playerOverrideId,
        uint256 _mlbPlayerId
    ) public canCreate whenNotPaused returns (uint256) {
        if (_owner == address(0)) {
            _owner = managerPrimary;
        }

        uint256 sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(block.timestamp << 224 | sequenceId << 192 | _teamId << 160 | _posId);

        uint256[] memory nftData = new uint256[](5);
        nftData[0] = assetDetails;
        nftData[1] = _attributes;
        nftData[2] = _gameId;
        nftData[3] = _playerOverrideId;
        nftData[4] = _mlbPlayerId;

        rewardsRedeemed += 1;
        return _createNFTCollectible(_teamId, _attributes, _owner, 2, nftData);
    }
}",48.86725616455078,createCollectible,57.0,0.7886013380328155,0.4121601844780762,"[{'function': 'setManagerPrimary', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'getSequenceId', 'complexity': 0}, {'function': '_createNFTCollectible', 'complexity': 0}, {'function': 'createCollectible', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CollectibleNFT is Ownable {
    address public managerPrimary;
    bool public paused = false;
    uint256 public rewardsRedeemed = 1; // Set to 1 (never 0)

    modifier canCreate() {
        require(msg.sender == managerPrimary, ""Only managerPrimary can create an NFT"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function setManagerPrimary(address _managerPrimary) public {
        managerPrimary = _managerPrimary;
    }

    function pause() public {
        paused = true;
    }

    function unpause() public {
        paused = false;
    }

    function getSequenceId(uint256 _teamId) internal view returns (uint256) {
        // Placeholder for sequence ID retrieval logic
        return 0; // Replace with actual implementation
    }

    function _createNFTCollectible(
        uint256 _teamId,
        uint256 _attributes,
        address _owner,
        uint256 _type,
        uint256[] memory _nftData
    ) internal returns (uint256) {
        // Placeholder for NFT creation logic
        return 0; // Replace with actual implementation
    }

    function createCollectible(
        uint256 _teamId,
        uint256 _posId,
        uint256 _attributes,
        address _owner,
        uint256 _gameId,
        uint256 _playerOverrideId,
        uint256 _mlbPlayerId
    ) public canCreate whenNotPaused returns (uint256) {
        if (_owner == address(0)) {
            _owner = managerPrimary;
        }

        uint256 sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(block.timestamp << 224 | sequenceId << 192 | _teamId << 160 | _posId);

        uint256[] memory nftData = new uint256[](5);
        nftData[0] = assetDetails;
        nftData[1] = _attributes;
        nftData[2] = _gameId;
        nftData[3] = _playerOverrideId;
        nftData[4] = _mlbPlayerId;

        rewardsRedeemed += 1;
        return _createNFTCollectible(_teamId, _attributes, _owner, 2, nftData);
    }
}"
6764,"This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address[]) public s_paid;
    uint256 public fee;

    modifier only_delegate() {
        require(hasRole(keccak256(""DELEGATE""), msg.sender), ""Only delegate can call this function"");
        _;
    }

    function revoke(address who, address origin) payable external only_delegate {
        require(msg.value == fee, ""Incorrect fee amount"");
        bool found = false;
        for (uint i = 0; i < s_paid[who].length; i++) {
            if (s_paid[who][i] != origin) {
                continue;
            }
            found = true;
            uint lastIndex = s_paid[who].length.sub(1);
            if (i != lastIndex) {
                s_paid[who][i] = s_paid[who][lastIndex];
            }
            s_paid[who].pop();
            break;
        }
        require(found, ""Origin not found"");
        origin.transfer(msg.value);
    }
}","[{'function': 'revoke', 'complexity': 9}]",6.0,{},"pragma solidity ^0.8.0;

contract PaymentManager {
    // Mapping to store paid origins for each address
    mapping(address => address[]) private s_paid;

    // Modifier to restrict the function to only delegates
    modifier onlyDelegate() {
        require(msg.sender == delegate, ""Only delegates can call this function"");
        _;
    }

    // Address of the delegate
    address public delegate;

    // Constructor to set the delegate
    constructor(address _delegate) {
        delegate = _delegate;
    }

    // Function to revoke a payment made by an address 'who' for a specific origin
    function revoke(address who, address origin) external payable onlyDelegate {
        require(msg.value == fee, ""Incorrect fee amount"");

        // Find the index of the origin in the s_paid[who] array
        bool found = false;
        uint256 length = s_paid[who].length;
        for (uint256 i = 0; i < length; i++) {
            if (s_paid[who][i] == origin) {
                // Replace the entry with the last element and delete the last element
                if (i != length - 1) {
                    s_paid[who][i] = s_paid[who][length - 1];
                }
                s_paid[who].pop();
                found = true;
                break;
            }
        }

        require(found, ""Origin not found"");

        // Transfer the fee back to the origin
        (bool success, ) = origin.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
    }

    // Function to set the delegate
    function setDelegate(address _delegate) external {
        require(msg.sender == delegate, ""Only the current delegate can change the delegate"");
        delegate = _delegate;
    }

    // Fallback function to accept payments (used for fee)
    receive() external payable {}
}",46.936126708984375,revoke,78.0,0.9224989991546192,0.3651567778082289,"[{'function': 'revoke', 'complexity': 10}, {'function': 'setDelegate', 'complexity': 1}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentManager is Ownable {
    // Mapping to store paid origins for each address
    mapping(address => address[]) private s_paid;

    // Address of the delegate
    address public delegate;

    // Constructor to set the delegate and initialize Ownable
    constructor(address _delegate) Ownable(msg.sender) {
        delegate = _delegate;
    }

    // Modifier to restrict the function to only delegates
    modifier onlyDelegate() {
        require(msg.sender == delegate, ""Only delegates can call this function"");
        _;
    }

    // Function to revoke a payment made by an address 'who' for a specific origin
    function revoke(address who, address origin) external payable onlyDelegate {
        require(msg.value == fee, ""Incorrect fee amount"");

        // Find the index of the origin in the s_paid[who] array
        bool found = false;
        uint256 length = s_paid[who].length;
        for (uint256 i = 0; i < length; i++) {
            if (s_paid[who][i] == origin) {
                // Replace the entry with the last element and delete the last element
                if (i != length - 1) {
                    s_paid[who][i] = s_paid[who][length - 1];
                }
                s_paid[who].pop();
                found = true;
                break;
            }
        }

        require(found, ""Origin not found"");

        // Transfer the fee back to the origin
        (bool success, ) = origin.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
    }

    // Function to set the delegate
    function setDelegate(address _delegate) external {
        require(msg.sender == delegate, ""Only the current delegate can change the delegate"");
        delegate = _delegate;
    }

    // Fallback function to accept payments (used for fee)
    receive() external payable {}
}"
5397,Transfers tokens held by timelock to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenRelease is Ownable {
    using SafeMath for uint;

    uint public releaseTime;
    uint public current_month;
    uint public month = 1 months;
    uint public twenty_percent_of_amount;
    address public beneficiary;
    IERC20 public token;

    constructor(uint _releaseTime, uint _twenty_percent_of_amount, address _beneficiary, address _token) {
        releaseTime = _releaseTime;
        current_month = 1;
        twenty_percent_of_amount = _twenty_percent_of_amount;
        beneficiary = _beneficiary;
        token = IERC20(_token);
    }

    function release() public {
        require(now >= releaseTime, ""Release time not yet reached"");
        assert(current_month <= 5);
        uint diff = now - releaseTime;
        if (diff > month) {
            releaseTime = now;
        } else {
            releaseTime = now.add(month.sub(diff));
        }
        current_month++;
        token.safeTransfer(beneficiary, twenty_percent_of_amount);
    }
}","[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'release', 'complexity': 5}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""release"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}, {""type"": ""stringLiteral"", ""value"": ""Release time not yet reached""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""current_month""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Current month exceeds 5""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""diff"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""diff""}, ""right"": {""type"": ""Identifier"", ""name"": ""MONTH""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""releaseTime""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""MONTH""}, ""right"": {""type"": ""Identifier"", ""name"": ""diff""}}], ""isArray"": False}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""current_month""}, ""isPrefix"": False}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenRelease {
    address public beneficiary;
    uint256 public releaseTime;
    uint256 public current_month = 1;
    uint256 public constant MONTH = 30 days; // Assuming a month is approximately 30 days for simplicity
    uint256 public twenty_percent_of_amount = 20; // Assume the percentage to be released is 20% of total tokens

    function release() public {
        require(block.timestamp >= releaseTime, ""Release time not yet reached"");
        require(current_month <= 5, ""Current month exceeds 5"");

        uint256 diff = block.timestamp - releaseTime;
        if (diff > MONTH) {
            releaseTime = block.timestamp;
        } else {
            releaseTime += (MONTH - diff);
        }

        current_month++;

        // Assuming token transfer logic is implemented elsewhere, e.g., in a separate function or contract
        // Example: transferTokens(beneficiary, twenty_percent_of_amount);
    }
}",44.214388608932495,release,14.0,0.8625643562478208,0.4122904921069982,"[{'function': 'release', 'complexity': 5}]",7.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenRelease is Ownable {
    address public beneficiary;
    uint256 public releaseTime;
    uint256 public current_month = 1;
    uint256 public constant MONTH = 30 days; // Assuming a month is approximately 30 days for simplicity
    uint256 public twenty_percent_of_amount = 20; // Assume the percentage to be released is 20% of total tokens

    constructor() Ownable(msg.sender) {
        beneficiary = address(0x1111111111111111111111111111111111111111); // Set beneficiary to fixed value
        releaseTime = block.timestamp;
        current_month = 1;
        MONTH = 30 days;
        twenty_percent_of_amount = 20;
    }

    function release() public {
        require(block.timestamp >= releaseTime, ""Release time not yet reached"");
        require(current_month <= 5, ""Current month exceeds 5"");

        uint256 diff = block.timestamp - releaseTime;
        if (diff > MONTH) {
            releaseTime = block.timestamp;
        } else {
            releaseTime += (MONTH - diff);
        }

        current_month++;

        // Assuming token transfer logic is implemented elsewhere, e.g., in a separate function or contract
        // Example: transferTokens(beneficiary, twenty_percent_of_amount);
    }
}"
4047,Checks if the order given offchain coincides with the order of the actual previously calculated points in the smart contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, LimitCalculated, OrderChecked }
    pointsValidationState public pValidationState;
    uint256 public winnerCounter;
    uint256 public pointsLimit;
    mapping(uint256 => uint256) public tokenToPointsMap;
    uint256[] private sortedWinners;

    constructor() {
        pValidationState = pointsValidationState.NotStarted;
    }

    function checkOrder(uint32[] memory sortedChunk) external onlyOwner checkState(pointsValidationState.LimitCalculated) {
        require(sortedChunk.length + sortedWinners.length <= winnerCounter);

        for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
            uint256 id = sortedChunk[i];
            uint256 sigId = sortedChunk[i + 1];
            require(tokenToPointsMap[id] > tokenToPointsMap[sigId] || (tokenToPointsMap[id] == tokenToPointsMap[sigId] && id < sigId));
        }

        if (sortedWinners.length != 0) {
            uint256 id2 = sortedWinners[sortedWinners.length - 1];
            uint256 sigId2 = sortedChunk[0];
            require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] || (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));
        }

        for (uint256 j = 0; j < sortedChunk.length; j++) {
            sortedWinners.push(sortedChunk[j]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[sortedWinners.length - 1] == pointsLimit);
            pValidationState = pointsValidationState.OrderChecked;
        }
    }

    modifier checkState(pointsValidationState expectedState) {
        require(pValidationState == expectedState, ""Invalid state"");
        _;
    }
}","[{'function': 'checkOrder', 'complexity': 12}]",13.0,"{""type"": ""FunctionDefinition"", ""name"": ""validateWinners"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""length"": None}, ""name"": ""sortedChunk"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}}, ""right"": {""type"": ""Identifier"", ""name"": ""winnerCounter""}}, {""type"": ""stringLiteral"", ""value"": ""Exceeds total winners allowed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""lastExistingWinner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""FalseExpression"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""stringLiteral"", ""value"": ""Elements in chunk are not sorted or invalid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""lastExistingWinner""}}, {""type"": ""stringLiteral"", ""value"": ""New winners must be greater than existing ones""}], ""names"": []}}]}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedChunk""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""winnerCounter""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sortedWinners""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""winnerCounter""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""right"": {""type"": ""Identifier"", ""name"": ""pointsLimit""}}, {""type"": ""stringLiteral"", ""value"": ""Last winner does not match pointsLimit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""pValidationState""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ValidationState""}, ""memberName"": ""OrderChecked""}}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract WinnersValidator {
    uint32[] public sortedWinners;
    enum ValidationState { NotChecked, OrderChecked }
    ValidationState public pValidationState = ValidationState.NotChecked;
    uint32 public winnerCounter;
    uint32 public pointsLimit;

    function validateWinners(uint32[] memory sortedChunk) external {
        require(sortedChunk.length + sortedWinners.length <= winnerCounter, ""Exceeds total winners allowed"");

        uint32 lastExistingWinner = sortedWinners.length > 0 ? sortedWinners[sortedWinners.length - 1] : 0;
        for (uint i = 0; i < sortedChunk.length - 1; i++) {
            require(sortedChunk[i] >= sortedChunk[i + 1], ""Elements in chunk are not sorted or invalid"");
            require(sortedChunk[i] > lastExistingWinner, ""New winners must be greater than existing ones"");
        }

        for (uint i = 0; i < sortedChunk.length; i++) {
            sortedWinners.push(sortedChunk[i]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[winnerCounter - 1] == pointsLimit, ""Last winner does not match pointsLimit"");
            pValidationState = ValidationState.OrderChecked;
        }
    }
}",45.22278141975403,validateWinners,44.0,0.7088083268651821,0.3525507926353475,"[{'function': 'validateWinners', 'complexity': 8}]",9.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WinnersValidator is Ownable {
    uint32[] public sortedWinners;
    enum ValidationState { NotChecked, OrderChecked }
    ValidationState public pValidationState = ValidationState.NotChecked;
    uint32 public winnerCounter;
    uint32 public pointsLimit;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        sortedWinners = [1]; // Start with at least one element
        pValidationState = ValidationState.NotChecked;
        winnerCounter = 1;
        pointsLimit = 1;
    }

    function validateWinners(uint32[] memory sortedChunk) external {
        require(sortedChunk.length + sortedWinners.length <= winnerCounter, ""Exceeds total winners allowed"");

        uint32 lastExistingWinner = sortedWinners.length > 0 ? sortedWinners[sortedWinners.length - 1] : 0;
        for (uint i = 0; i < sortedChunk.length - 1; i++) {
            require(sortedChunk[i] >= sortedChunk[i + 1], ""Elements in chunk are not sorted or invalid"");
            require(sortedChunk[i] > lastExistingWinner, ""New winners must be greater than existing ones"");
        }

        for (uint i = 0; i < sortedChunk.length; i++) {
            sortedWinners.push(sortedChunk[i]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[winnerCounter - 1] == pointsLimit, ""Last winner does not match pointsLimit"");
            pValidationState = ValidationState.OrderChecked;
        }
    }
}"
527,The value in HAV for a given amount of USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceOracle {
    function price() external view returns (uint);
}

abstract contract USDtoHAVWrapper is Ownable {
    using SafeMath for uint256;

    PriceOracle public oracle;

    constructor(address _oracle) {
        oracle = PriceOracle(_oracle);
    }

    function safeDiv_dec(uint usd_dec, uint price) internal pure returns (uint) {
        require(price > 0, ""SafeMath: division by zero"");
        return usd_dec.div(price);
    }

    function USDtoHAV(uint usd_dec) public view priceNotStale returns (uint) {
        uint price = oracle.price();
        require(price > 0, ""Price is stale or incorrect"");
        return safeDiv_dec(usd_dec, price);
    }

    modifier priceNotStale() {
        require(oracle.price() != 0, ""Price is not available or has expired"");
        _;
    }
}","[{'function': 'price', 'complexity': 0}, {'function': 'safeDiv_dec', 'complexity': 1}, {'function': 'USDtoHAV', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""USDtoHAV"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""usd_dec"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""usd_dec""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount of USD must be greater than zero""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeDiv_dec""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usd_dec""}, {""type"": ""Identifier"", ""name"": ""price""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""priceNotStale"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract HavvenExchange {
    uint public price; // Current exchange rate from USD to HAV

    modifier priceNotStale() {
        require(price != 0, ""Price data is stale or not available"");
        _;
    }

    function setPrice(uint newPrice) external {
        price = newPrice;
    }

    function USDtoHAV(uint usd_dec) public view priceNotStale returns (uint) {
        require(usd_dec != 0, ""Amount of USD must be greater than zero"");
        return safeDiv_dec(usd_dec, price);
    }

    function safeDiv_dec(uint a, uint b) internal pure returns (uint) {
        // Ensure no overflow/underflow and handle division by zero
        require(b > 0, ""Division by zero is not allowed"");
        return a / b;
    }
}",43.8653359413147,safeDiv_dec,6.0,0.7322879469254671,0.1650879108620306,"[{'function': 'setPrice', 'complexity': 0}, {'function': 'USDtoHAV', 'complexity': 1}, {'function': 'safeDiv_dec', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HavvenExchange is Ownable {
    uint public price = 1; // Current exchange rate from USD to HAV

    modifier priceNotStale() {
        require(price != 0, ""Price data is stale or not available"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        price = 1;
    }

    function setPrice(uint newPrice) external onlyOwner {
        require(newPrice != 0, ""Amount of USD must be greater than zero"");
        price = newPrice;
    }

    function USDtoHAV(uint usd_dec) public view priceNotStale returns (uint) {
        require(usd_dec != 0, ""Amount of USD must be greater than zero"");
        return safeDiv_dec(usd_dec, price);
    }

    function safeDiv_dec(uint a, uint b) internal pure returns (uint) {
        // Ensure no overflow/underflow and handle division by zero
        require(b > 0, ""Division by zero is not allowed"");
        return a / b;
    }
}"
3318,Return hash containing all of the information about the burnCarbonDollar ( ) metatransaction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MetaBurnHashWrapper is Ownable {
    using SafeMath for uint256;

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}","[{'function': 'metaBurnHash', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""metaBurnHash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_stablecoin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_reward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""metaBurnCarbonDollar""}, {""type"": ""Identifier"", ""name"": ""_stablecoin""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}, {""type"": ""Identifier"", ""name"": ""_reward""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract CarbonDollarMetaBurn {
    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}",41.97078490257263,metaBurnHash,0.0,0.9694241353762268,0.9414356817218076,"[{'function': 'metaBurnHash', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CarbonDollarMetaBurn {
    address public constant STABLECOIN = 0x1111111111111111111111111111111111111111; // Replace with actual stablecoin address
    uint256 public constant AMOUNT = 1;
    uint256 public constant NONCE = 1;
    uint256 public constant REWARD = 1;
    bool public initialized = true;
    bytes32 public metaBurnHash;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        STABLECOIN = 0x1111111111111111111111111111111111111111; // Replace with actual stablecoin address
        AMOUNT = 1;
        NONCE = 1;
        REWARD = 1;
        initialized = true;

        // Call parent contract constructor
        Ownable(msg.sender);
    }

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}"
1663,Access point for the oracle to update the price of havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public price;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 days; // Example value, adjust as needed

    event PriceUpdated(uint newPrice, uint timeSent);

    function updatePrice(uint newPrice, uint timeSent) external onlyOwner {
        require(lastPriceUpdateTime < timeSent && timeSent < now.add(ORACLE_FUTURE_LIMIT), ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        price = newPrice;
        lastPriceUpdateTime = timeSent;
        emit PriceUpdated(newPrice, timeSent);
    }
}","[{'function': 'updatePrice', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}}, {""type"": ""stringLiteral"", ""value"": ""Timestamp must be greater than the last update time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""ORACLE_FUTURE_LIMIT""}}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}, {""type"": ""stringLiteral"", ""value"": ""Timestamp exceeds future limit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PriceUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newPrice""}, {""type"": ""Identifier"", ""name"": ""timeSent""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AssetPriceUpdater {
    uint public price;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 days; // Example limit, adjust as needed

    event PriceUpdated(uint newPrice, uint timeSent);

    function updatePrice(uint newPrice, uint timeSent) external {
        require(timeSent > lastPriceUpdateTime, ""Timestamp must be greater than the last update time"");
        require(block.timestamp + ORACLE_FUTURE_LIMIT >= timeSent, ""Timestamp exceeds future limit"");

        price = newPrice;
        lastPriceUpdateTime = timeSent;

        emit PriceUpdated(newPrice, timeSent);
    }
}",42.89285039901733,updatePrice,13.0,0.9012870399848292,0.511010850509463,"[{'function': 'updatePrice', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetPriceUpdater is Ownable {
    uint public price = 1;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 days; // Example limit, adjust as needed

    event PriceUpdated(uint newPrice, uint timeSent);

    constructor() Ownable(msg.sender) {
        lastPriceUpdateTime = block.timestamp;
    }

    function updatePrice(uint newPrice, uint timeSent) external {
        require(timeSent > lastPriceUpdateTime, ""Timestamp must be greater than the last update time"");
        require(block.timestamp + ORACLE_FUTURE_LIMIT >= timeSent, ""Timestamp exceeds future limit"");

        price = newPrice;
        lastPriceUpdateTime = timeSent;

        emit PriceUpdated(newPrice, timeSent);
    }
}"
6383,Approve address to become creator of that pack,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetPackApproval {
    using SafeMath for uint256;

    struct AssetPack {
        address creator;
    }

    mapping(uint => AssetPack) public assetPacks;
    mapping(uint => address) public approvedTakeover;

    function approveTakeover(uint _assetPackId, address _newCreator) public {
        require(assetPacks[_assetPackId].creator == msg.sender);
        approvedTakeover[_assetPackId] = _newCreator;
    }
}","[{'function': 'approveTakeover', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveTakeover"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_assetPackId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newCreator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedTakeover""}, ""index"": {""type"": ""Identifier"", ""name"": ""_assetPackId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newCreator""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCreator"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_assetPackId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AssetPack {
    mapping(uint => address) public approvedTakeover;
    mapping(uint => address) public creators;

    modifier onlyCreator(uint _assetPackId) {
        require(msg.sender == creators[_assetPackId], ""Only the current creator can approve a takeover."");
        _;
    }

    function approveTakeover(uint _assetPackId, address _newCreator) public onlyCreator(_assetPackId) {
        approvedTakeover[_assetPackId] = _newCreator;
    }
}",42.67087125778198,approveTakeover,11.0,0.7174903393434287,0.5526605605089993,"[{'function': 'approveTakeover', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetPack is Ownable {
    mapping(uint => address) public approvedTakeover;
    mapping(uint => address) public creators;

    modifier onlyCreator(uint _assetPackId) {
        require(msg.sender == creators[_assetPackId], ""Only the current creator can approve a takeover."");
        _;
    }

    function approveTakeover(uint _assetPackId, address _newCreator) public onlyCreator(_assetPackId) {
        approvedTakeover[_assetPackId] = _newCreator;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= type(uint).max; ++i) {
            if (approvedTakeover[i] == address(0)) {
                approvedTakeover[i] = address(uint160(i + 1)); // Example: 0x1111111111111111111111111111111111111111 to 0x2222222222222222222222222222222222222222
            }
            if (creators[i] == address(0)) {
                creators[i] = address(uint160(i + 2)); // Example: 0x2222222222222222222222222222222222222222 to 0x3333333333333333333333333333333333333333
            }
        }
    }
}"
5701,Returns the division of two numbers Function used for division operations inside the smartcontract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DivisionWrapper is Ownable {
    using SafeMath for uint256;

    function division(uint numerator, uint denominator) public view onlyOwner returns (uint result) {
        require(denominator != 0, ""Division by zero"");
        return numerator.div(denominator);
    }
}","[{'function': 'division', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""division"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numerator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""denominator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""result"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""denominator""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Division by zero is not allowed""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""numerator""}, ""right"": {""type"": ""Identifier"", ""name"": ""denominator""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract Division {
    function division(uint256 numerator, uint256 denominator) public pure returns (uint256 result) {
        require(denominator != 0, ""Division by zero is not allowed"");
        return numerator / denominator;
    }
}",41.763909101486206,division,3.0,0.82145620620378,0.4180999216775964,"[{'function': 'division', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Division is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function division(uint256 numerator, uint256 denominator) public pure returns (uint256 result) {
        require(denominator != 0, ""Division by zero is not allowed"");
        return numerator / denominator;
    }
}"
2851,Function used by the creator to set the presale limits,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PresaleAmountLimits {
    using SafeMath for uint256;

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public pure {
        require(_minPresaleAmount > 0, ""Minimum presale amount must be greater than 0"");
        require(_maxPresaleAmount > 0, ""Maximum presale amount must be greater than 0"");
        require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount"");
    }
}","[{'function': 'setPresaleAmountLimits', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPresaleAmountLimits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minPresaleAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxPresaleAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_minPresaleAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxPresaleAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Minimum presale amount must be less than or equal to maximum presale amount.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldMin"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""minPresaleAmount""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldMax"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""maxPresaleAmount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minPresaleAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minPresaleAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxPresaleAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxPresaleAmount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PresaleAmountLimitsSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldMin""}, {""type"": ""Identifier"", ""name"": ""_minPresaleAmount""}, {""type"": ""Identifier"", ""name"": ""oldMax""}, {""type"": ""Identifier"", ""name"": ""_maxPresaleAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    address public owner;
    uint256 public minPresaleAmount;
    uint256 public maxPresaleAmount;

    event PresaleAmountLimitsSet(uint256 oldMin, uint256 newMin, uint256 oldMax, uint256 newMax);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public onlyOwner {
        require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount."");

        uint256 oldMin = minPresaleAmount;
        uint256 oldMax = maxPresaleAmount;

        minPresaleAmount = _minPresaleAmount;
        maxPresaleAmount = _maxPresaleAmount;

        emit PresaleAmountLimitsSet(oldMin, _minPresaleAmount, oldMax, _maxPresaleAmount);
    }
}",44.18487668037415,setPresaleAmountLimits,21.0,0.6138882661792929,0.44742040379977,"[{'function': 'setPresaleAmountLimits', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    address public owner;
    uint256 public minPresaleAmount;
    uint256 public maxPresaleAmount;

    event PresaleAmountLimitsSet(uint256 oldMin, uint256 newMin, uint256 oldMax, uint256 newMax);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) Ownable(msg.sender) {
        minPresaleAmount = _minPresaleAmount;
        maxPresaleAmount = _maxPresaleAmount;
    }

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public onlyOwner {
        require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount."");

        uint256 oldMin = minPresaleAmount;
        uint256 oldMax = maxPresaleAmount;

        minPresaleAmount = _minPresaleAmount;
        maxPresaleAmount = _maxPresaleAmount;

        emit PresaleAmountLimitsSet(oldMin, _minPresaleAmount, oldMax, _maxPresaleAmount);
    }
}"
5928,Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Authorizable is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address indexed operator, address indexed owner);

    function authorizeOperator(address _operator) public override onlyOwner {
        require(_operator != msg.sender, ""The operator must be different from the sender."");
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}","[{'function': 'authorizeOperator', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""authorizeOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""mAuthorized""}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuthorizedOperator""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenManager {
    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address indexed operator, address indexed user);

    function authorizeOperator(address _operator) public {
        require(_operator != msg.sender);
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}",42.23355770111084,authorizeOperator,2.0,0.9599345508994036,0.5810450716061213,"[{'function': 'authorizeOperator', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenManager is Ownable {
    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address indexed operator, address indexed user);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function authorizeOperator(address _operator) public {
        require(_operator != msg.sender);
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}"
1383,Performs allowance transfer of asset balance between holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAsset {
    function __transferFromWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    IAsset public asset;

    constructor(address _assetAddress) {
        asset = IAsset(_assetAddress);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return asset.__transferFromWithReference(_from, _to, _value, """", msg.sender);
        }
        return false;
    }
}","[{'function': '__transferFromWithReference', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 1}]",2.0,{},"pragma solidity ^0.8.0;

contract AssetTransfer {
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        // Assuming the asset contract has an internal function __transferFromWithReference
        return __transferFromWithReference(_from, _to, _value);
    }

    function __transferFromWithReference(address _from, address _to, uint256 _value) internal returns (bool success) {
        // Logic for transferring assets with an optional reference string and the sender's address
        // This is a placeholder for the actual implementation of the asset contract's internal function
        require(_to != address(0), ""Invalid recipient address"");

        // Perform the transfer operation
        // Example: Assuming the asset contract has a balance mapping and an allowance mapping
        AssetContract assetContract = AssetContract(assetAddress);
        require(assetContract.allowance(_from, msg.sender) >= _value, ""Allowance exceeded"");
        require(assetContract.balanceOf(_from) >= _value, ""Insufficient balance"");

        // Transfer the assets
        assetContract.transferFrom(_from, _to, _value);

        // Emit an event related to the transfer
        emit Transfer(_from, _to, _value);

        return true;
    }

    // Placeholder for the actual implementation of the asset contract's internal function
    address public assetAddress;

    struct AssetContract {
        mapping(address => uint256) balanceOf;
        mapping(address => uint256) allowance;
        function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",46.47721147537232,__transferFromWithReference,19.0,0.6845362305874225,0.1508645721815672,"[{'function': 'transferFrom', 'complexity': 1}, {'function': '__transferFromWithReference', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract AssetTransfer is Ownable {
    address public assetAddress;
    uint256 public balanceOf;
    uint256 public allowance;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        assetAddress = 0x1111111111111111111111111111111111111111; // Replace with the actual asset contract address
        balanceOf = 1; // Set to a fixed, non-zero value
        allowance = 1; // Set to a fixed, non-zero value
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        return __transferFromWithReference(_from, _to, _value);
    }

    function __transferFromWithReference(address _from, address _to, uint256 _value) internal returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");

        AssetContract assetContract = AssetContract(assetAddress);
        require(assetContract.allowance(_from, msg.sender) >= _value, ""Allowance exceeded"");
        require(assetContract.balanceOf(_from) >= _value, ""Insufficient balance"");

        assetContract.transferFrom(_from, _to, _value);

        emit Transfer(_from, _to, _value);

        return true;
    }

    struct AssetContract {
        mapping(address => uint256) balanceOf;
        mapping(address => uint256) allowance;
        function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}"
5667,Returns the address currently assigned ownership of a given token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract {
    using SafeMath for uint256;

    address[] public tokenIndexToOwner;

    function ownerOf(uint _tokenId) external view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0));
        return tokenIndexToOwner[_tokenId];
    }
}","[{'function': 'ownerOf', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token does not exist""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract ERC721 {
    mapping(uint256 => address) private tokenIndexToOwner;

    function ownerOf(uint256 _tokenId) public view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0), ""Token does not exist"");
        return tokenIndexToOwner[_tokenId];
    }
}",43.66987466812134,ownerOf,1.0,0.9805993530500322,0.6029987316381817,"[{'function': 'ownerOf', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ERC721 {
    mapping(uint256 => address) private tokenIndexToOwner;
    address public constant owner = 0x1111111111111111111111111111111111111111; // fixed address value
    bool public constant initialized = true; // fixed boolean value

    constructor() ERC721(owner, initialized) {}

    function ownerOf(uint256 _tokenId) public view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0), ""Token does not exist"");
        return tokenIndexToOwner[_tokenId];
    }
}"
5392,"Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract LoanContract is Ownable {
    using SafeMath for uint256;

    struct Loan {
        address lender;
        address approvedTransfer;
    }

    mapping(uint256 => Loan) public loans;
    mapping(address => uint256) public lendersBalance;

    event Transfer(address indexed from, address indexed to, uint256 index);

    function transfer(address to, uint256 index) public returns (bool) {
        Loan storage loan = loans[index];
        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);
        require(to != address(0));
        loan.lender = to;
        loan.approvedTransfer = address(0);
        lendersBalance[msg.sender] = lendersBalance[msg.sender].sub(1);
        lendersBalance[to] = lendersBalance[to].add(1);
        emit Transfer(loan.lender, to, index);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferLoan"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Loan""}, ""name"": ""loan"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""currentLender"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""lender""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""lender""}, ""right"": {""type"": ""Identifier"", ""name"": ""to""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loan""}, ""memberName"": ""approvedTransfer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lendersBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""currentLender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lendersBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""currentLender""}}, ""isPrefix"": False}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lendersBalance""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""isPrefix"": False}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentLender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyLenderOrApproved"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""index""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract LoanTransfer {
    struct Loan {
        address lender;
        address approvedTransfer;
        // Other loan details...
    }

    mapping(uint256 => Loan) public loans;
    mapping(address => uint256) public lendersBalance;
    address[] public lendersList;

    event Transfer(address indexed from, address indexed to, uint256 index);

    modifier onlyLenderOrApproved(uint256 index) {
        require(msg.sender == loans[index].lender || msg.sender == loans[index].approvedTransfer, ""Not authorized"");
        _;
    }

    function transferLoan(address to, uint256 index) public onlyLenderOrApproved(index) {
        require(to != address(0), ""Invalid recipient address"");

        Loan storage loan = loans[index];
        address currentLender = loan.lender;

        // Update the loan's ownership details
        loan.lender = to;
        loan.approvedTransfer = address(0);

        // Adjust balances in the lendersBalance mapping
        if (lendersBalance[currentLender] > 0) {
            lendersBalance[currentLender]--;
        }
        lendersBalance[to]++;

        // Emit the Transfer event
        emit Transfer(currentLender, to, index);
    }
}",44.76386833190918,transferLoan,48.0,0.7578189641656181,0.3795633975215161,"[{'function': 'transferLoan', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoanTransfer is Ownable {
    struct Loan {
        address lender;
        address approvedTransfer;
        // Other loan details...
    }

    mapping(uint256 => Loan) public loans;
    mapping(address => uint256) public lendersBalance;
    address[] public lendersList;

    event Transfer(address indexed from, address indexed to, uint256 index);

    modifier onlyLenderOrApproved(uint256 index) {
        require(msg.sender == loans[index].lender || msg.sender == loans[index].approvedTransfer, ""Not authorized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < lendersList.length; i++) {
            lendersBalance[lendersList[i]] = 1;
        }
    }

    function transferLoan(address to, uint256 index) public onlyLenderOrApproved(index) {
        require(to != address(0), ""Invalid recipient address"");

        Loan storage loan = loans[index];
        address currentLender = loan.lender;

        // Update the loan's ownership details
        loan.lender = to;
        loan.approvedTransfer = address(0);

        // Adjust balances in the lendersBalance mapping
        if (lendersBalance[currentLender] > 0) {
            lendersBalance[currentLender]--;
        }
        lendersBalance[to]++;

        // Emit the Transfer event
        emit Transfer(currentLender, to, index);
    }
}"
6100,Allows a grant recipient to claim their vested tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenVesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 yearsClaimed;
        uint256 totalClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    IERC20 public token;

    event GrantTokensClaimed(address indexed recipient, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function calculateGrantClaim(address _recipient) internal view returns (uint256 yearsVested, uint256 amountVested) {
        // Implementation of the calculation logic for calculating vested tokens
        // This is a placeholder and should be replaced with actual implementation
        yearsVested = 0; // Example value
        amountVested = 0; // Example value
    }

    function claimVestedTokens(address _recipient) external {
        uint256 yearsVested;
        uint256 amountVested;
        (yearsVested, amountVested) = calculateGrantClaim(_recipient);
        require(amountVested > 0, ""amountVested is 0"");
        Grant storage tokenGrant = tokenGrants[_recipient];
        tokenGrant.yearsClaimed = yearsVested;
        tokenGrant.totalClaimed = tokenGrant.totalClaimed.add(amountVested);
        require(token.transfer(_recipient, amountVested), ""no tokens"");
        emit GrantTokensClaimed(_recipient, amountVested);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 0}, {'function': 'claimVestedTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimVestedTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""amountVested"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113640520>}, {""type"": ""VariableDeclaration"", ""name"": ""yearsVested"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1136404b0>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateGrantClaim""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenGrants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_recipient""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amountVested""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""amountVested is 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenGrant""}, ""name"": ""grant"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenGrants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_recipient""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""yearsClaimed""}, ""right"": {""type"": ""Identifier"", ""name"": ""yearsVested""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""totalClaimed""}, ""right"": {""type"": ""Identifier"", ""name"": ""amountVested""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""No tokens transferred""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""GrantTokensClaimed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""Identifier"", ""name"": ""amountVested""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract VestedTokenClaim {
    struct TokenGrant {
        uint256 value;
        uint256 totalClaimed;
        uint256 yearsClaimed;
        uint256 start;
        uint256 cliff;
        uint256 vesting;
    }

    mapping(address => TokenGrant) public tokenGrants;

    event GrantTokensClaimed(address indexed recipient, uint256 amountVested);

    function claimVestedTokens(address _recipient) external {
        require(_recipient != address(0), ""Invalid recipient"");

        (uint256 amountVested, uint256 yearsVested) = calculateGrantClaim(tokenGrants[_recipient]);

        require(amountVested > 0, ""amountVested is 0"");

        TokenGrant storage grant = tokenGrants[_recipient];
        grant.yearsClaimed += yearsVested;
        grant.totalClaimed += amountVested;

        bool success = transferTokens(_recipient, amountVested);
        require(success, ""No tokens transferred"");

        emit GrantTokensClaimed(_recipient, amountVested);
    }

    function calculateGrantClaim(TokenGrant memory grant) internal view returns (uint256 amountVested, uint256 yearsVested) {
        if (block.timestamp < grant.cliff) {
            return (0, 0);
        } else if (block.timestamp >= grant.vesting) {
            return (grant.value, (grant.vesting - grant.start) / 31536000); // Assuming a year is 31536000 seconds
        } else {
            uint256 time = block.timestamp;
            amountVested = grant.value * (time - grant.start) / (grant.vesting - grant.start);
            yearsVested = (time - grant.start) / 31536000; // Assuming a year is 31536000 seconds
        }
    }

    function transferTokens(address recipient, uint256 amount) internal returns (bool success) {
        // Implement token transfer logic here
        // This would typically involve calling the token contract's transfer method
        return true; // Placeholder for actual implementation
    }
}",49.06532549858093,claimVestedTokens,31.0,0.89392893867355,0.4770845031563421,"[{'function': 'claimVestedTokens', 'complexity': 3}, {'function': 'calculateGrantClaim', 'complexity': 2}, {'function': 'transferTokens', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VestedTokenClaim is Ownable {
    struct TokenGrant {
        uint256 value;
        uint256 totalClaimed;
        uint256 yearsClaimed;
        uint256 start;
        uint256 cliff;
        uint256 vesting;
    }

    mapping(address => TokenGrant) public tokenGrants;

    event GrantTokensClaimed(address indexed recipient, uint256 amountVested);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            tokenGrants[address(uint160(uint256(keccak256(abi.encodePacked('recipient', i)))))] = TokenGrant({
                value: 1 ether, // Set to 1 ether (not 0)
                totalClaimed: 0,
                yearsClaimed: 0,
                start: block.timestamp,
                cliff: block.timestamp + 365 days, // Assuming a year is 365 days for simplicity
                vesting: block.timestamp + 365 * 7 days // Vesting period of 7 years
            });
        }
    }

    function claimVestedTokens(address _recipient) external {
        require(_recipient != address(0), ""Invalid recipient"");

        (uint256 amountVested, uint256 yearsVested) = calculateGrantClaim(tokenGrants[_recipient]);

        require(amountVested > 0, ""amountVested is 0"");

        TokenGrant storage grant = tokenGrants[_recipient];
        grant.yearsClaimed += yearsVested;
        grant.totalClaimed += amountVested;

        bool success = transferTokens(_recipient, amountVested);
        require(success, ""No tokens transferred"");

        emit GrantTokensClaimed(_recipient, amountVested);
    }

    function calculateGrantClaim(TokenGrant memory grant) internal view returns (uint256 amountVested, uint256 yearsVested) {
        if (block.timestamp < grant.cliff) {
            return (0, 0);
        } else if (block.timestamp >= grant.vesting) {
            return (grant.value, (grant.vesting - grant.start) / 31536000); // Assuming a year is 31536000 seconds
        } else {
            uint256 time = block.timestamp;
            amountVested = grant.value * (time - grant.start) / (grant.vesting - grant.start);
            yearsVested = (time - grant.start) / 31536000; // Assuming a year is 31536000 seconds
        }
    }

    function transferTokens(address recipient, uint256 amount) internal returns (bool success) {
        // Implement token transfer logic here
        // This would typically involve calling the token contract's transfer method
        return true; // Placeholder for actual implementation
    }
}"
949,Emits ERC20 Approval event on this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function emitApprove(address _from, address _spender, uint _value) public onlyChronoBankPlatform {
        emit Approval(_from, _spender, _value);
    }
}","[{'function': 'emitApprove', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyChronoBankPlatform"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenApproval {
    address public chronoBankPlatform;

    modifier onlyChronoBankPlatform() {
        require(msg.sender == chronoBankPlatform, ""Caller is not the ChronoBankPlatform"");
        _;
    }

    event Approval(address indexed _from, address indexed _spender, uint256 _value);

    function approve(address _from, address _spender, uint256 _value) external onlyChronoBankPlatform {
        emit Approval(_from, _spender, _value);
    }
}",42.39078402519226,approve,0.0,0.9461399480426836,0.7227186387739215,"[{'function': 'approve', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval {
    address public chronoBankPlatform;
    bool public initialized = true;
    bytes32 public initBytes32 = bytes32('init');

    modifier onlyChronoBankPlatform() {
        require(msg.sender == chronoBankPlatform, ""Caller is not the ChronoBankPlatform"");
        _;
    }

    constructor() {
        // Initialize instance variables
        chronoBankPlatform = 0x1111111111111111111111111111111111111111; // Replace with actual address
        initialized = true;
        initBytes32 = bytes32('init');
    }

    event Approval(address indexed _from, address indexed _spender, uint256 _value);

    function approve(address _from, address _spender, uint256 _value) external onlyChronoBankPlatform {
        emit Approval(_from, _spender, _value);
    }
}"
6735,Makes checkmark and deposits tokens on profiterole account to pay them later as bonuses for Treasury shares holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Treasury {
    function addDistributionPeriod() external;
}

abstract contract BonusDistributor is Ownable {
    using SafeMath for uint256;

    ERC20Interface public bonusToken;
    address public wallet;
    mapping(uint => Deposit) public distributionDeposits;
    uint public firstDepositDate;
    uint public lastDepositDate;
    bytes32 constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = 0x0;
    bytes32 constant PROFITEROLE_ERROR_TRANSFER_ERROR = 0x1;
    uint constant OK = 0;

    struct Deposit {
        uint amount;
        uint nextDepositDate;
        uint claimedAmount;
    }

    event DepositPendingAdded(uint indexed amount, address indexed depositor, uint indexed timestamp);

    modifier onlyDistributionSource() {
        require(msg.sender == wallet, ""Only the distribution source can call this function"");
        _;
    }

    constructor(address _bonusToken, address _wallet) {
        bonusToken = ERC20Interface(_bonusToken);
        wallet = _wallet;
    }

    function distributeBonuses(uint _amount) public onlyDistributionSource returns (uint) {
        ERC20Interface _bonusToken = ERC20Interface(bonusToken);
        if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {
            return uint(_emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE));
        }
        if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {
            return uint(_emitError(PROFITEROLE_ERROR_TRANSFER_ERROR));
        }
        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }
        uint _lastDepositDate = lastDepositDate;
        if (_lastDepositDate != 0) {
            distributionDeposits[_lastDepositDate].nextDepositDate = block.timestamp;
        }
        lastDepositDate = block.timestamp;
        distributionDeposits[block.timestamp] = Deposit(_amount, 0, 0);
        Treasury(treasury).addDistributionPeriod();
        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
        return OK;
    }

    function _emitError(bytes32 errorCode) internal pure returns (bytes4) {
        return bytes4(errorCode);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'addDistributionPeriod', 'complexity': 0}, {'function': 'distributeBonuses', 'complexity': 5}, {'function': '_emitError', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeBonuses"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bonusToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""firstDepositDate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""firstDepositDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastDepositDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""distributionDeposits""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DepositRecord""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": [""amount"", ""recipient"", ""timestamp""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DepositPendingAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyDistributionSource"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ERC20Interface {
    function transferFrom(address sender, address recipient, uint amount) external returns (bool);
}

contract BonusDistribution {
    ERC20Interface public bonusToken;
    address public distributionSource;
    mapping(uint => DepositRecord) public distributionDeposits;
    uint public firstDepositDate;
    uint public lastDepositDate;
    struct DepositRecord {
        uint amount;
        address recipient;
        uint timestamp;
    }

    modifier onlyDistributionSource() {
        require(msg.sender == distributionSource, ""Only distribution source can call this function"");
        _;
    }

    constructor(address _bonusToken, address _distributionSource) {
        bonusToken = ERC20Interface(_bonusToken);
        distributionSource = _distributionSource;
    }

    function distributeBonuses(uint _amount, address payable _recipient) external onlyDistributionSource {
        require(bonusToken.transferFrom(msg.sender, _recipient, _amount), ""Transfer failed"");

        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }
        lastDepositDate = block.timestamp;

        distributionDeposits[block.timestamp] = DepositRecord({
            amount: _amount,
            recipient: _recipient,
            timestamp: block.timestamp
        });

        // Assuming treasury is a contract that handles distribution periods
        // treasury.addDistributionPeriod();

        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
    }

    event DepositPendingAdded(uint amount, address indexed sender, uint timestamp);
}",45.93221545219421,distributeBonuses,41.0,0.6190241598950177,0.2727949966067391,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'distributeBonuses', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

interface ERC20Interface {
    function transferFrom(address sender, address recipient, uint amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract BonusDistribution is Ownable {
    ERC20Interface public bonusToken;
    address public distributionSource;
    mapping(uint => DepositRecord) public distributionDeposits;
    uint public firstDepositDate;
    uint public lastDepositDate;
    struct DepositRecord {
        uint amount;
        address recipient;
        uint timestamp;
    }

    modifier onlyDistributionSource() {
        require(msg.sender == distributionSource, ""Only distribution source can call this function"");
        _;
    }

    constructor(address _bonusToken, address _distributionSource) Ownable(msg.sender) {
        bonusToken = ERC20Interface(_bonusToken);
        distributionSource = _distributionSource;
        firstDepositDate = 1; // Set to a non-zero value
        lastDepositDate = 1; // Set to a non-zero value
    }

    function distributeBonuses(uint _amount, address payable _recipient) external onlyDistributionSource {
        require(bonusToken.transferFrom(msg.sender, _recipient, _amount), ""Transfer failed"");

        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }
        lastDepositDate = block.timestamp;

        distributionDeposits[block.timestamp] = DepositRecord({
            amount: _amount,
            recipient: _recipient,
            timestamp: block.timestamp
        });

        // Assuming treasury is a contract that handles distribution periods
        // treasury.addDistributionPeriod();

        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
    }

    event DepositPendingAdded(uint amount, address indexed sender, uint timestamp);
}"
2614,Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}","[{'function': 'setApprovalForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Self-approval is not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerOperators""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AssetApproval {
    mapping(address => mapping(address => bool)) public ownerOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != msg.sender, ""Self-approval is not allowed"");
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}",42.21134400367737,setApprovalForAll,8.0,0.8699416377206893,0.6168042940860896,"[{'function': 'setApprovalForAll', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetApproval is Ownable {
    mapping(address => mapping(address => bool)) public ownerOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != msg.sender, ""Self-approval is not allowed"");
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}"
5641,Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for uint256;

    function destroy() public onlyOwner {
        selfdestruct(owner());
    }
}","[{'function': 'destroy', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract DestroyContract {
    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function destroy() public onlyOwner {
        selfdestruct(payable(owner));
    }
}",42.06152701377869,destroy,1.0,0.9808910725774034,0.7138099644618784,"[{'function': 'destroy', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DestroyContract is Ownable {
    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function destroy() public onlyOwner {
        selfdestruct(payable(owner));
    }
}"
2847,Change the wallet where ether will be sent to when tokens are bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContractManager {
    function authorize(string memory contractName, address user) external view returns (bool);
}

abstract contract WalletWrapper is Ownable {
    using SafeMath for uint256;

    IContractManager public contractManager;
    string public contractName;
    address public wallet;

    event WalletAddressChanged(address indexed oldAddress, address indexed newAddress);

    constructor(IContractManager _contractManager, string memory _contractName, address _wallet) {
        contractManager = _contractManager;
        contractName = _contractName;
        wallet = _wallet;
    }

    function setWalletAddress(address _walletAddress) external {
        require(contractManager.authorize(contractName, msg.sender));
        require(_walletAddress != address(0));
        require(_walletAddress != wallet);
        address oldAddress = wallet;
        wallet = _walletAddress;
        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}","[{'function': 'authorize', 'complexity': 0}, {'function': 'setWalletAddress', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setWalletAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_walletAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_walletAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid wallet address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_walletAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""wallet""}}, {""type"": ""stringLiteral"", ""value"": ""New wallet address is the same as the current one""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""wallet""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""wallet""}, ""right"": {""type"": ""Identifier"", ""name"": ""_walletAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WalletAddressChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldAddress""}, {""type"": ""Identifier"", ""name"": ""_walletAddress""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyContractManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address public wallet;
    address private contractManager;
    string public contractName;

    event WalletAddressChanged(address indexed oldAddress, address indexed newAddress);

    modifier onlyContractManager() {
        require(msg.sender == contractManager, ""Only contract manager can call this function"");
        _;
    }

    constructor(address _contractManager, string memory _contractName, address _initialWallet) {
        contractManager = _contractManager;
        contractName = _contractName;
        wallet = _initialWallet;
    }

    function setWalletAddress(address _walletAddress) external onlyContractManager {
        require(_walletAddress != address(0), ""Invalid wallet address"");
        require(_walletAddress != wallet, ""New wallet address is the same as the current one"");

        address oldAddress = wallet;
        wallet = _walletAddress;

        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}",43.60437870025635,setWalletAddress,12.0,0.844619340628112,0.6238438720612289,"[{'function': 'setWalletAddress', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public wallet;
    address private contractManager;
    string public contractName;

    event WalletAddressChanged(address indexed oldAddress, address indexed newAddress);

    modifier onlyContractManager() {
        require(msg.sender == contractManager, ""Only contract manager can call this function"");
        _;
    }

    constructor(address _contractManager, string memory _contractName, address _initialWallet) Ownable(_contractManager) {
        contractManager = _contractManager;
        contractName = _contractName;
        wallet = _initialWallet;
    }

    function setWalletAddress(address _walletAddress) external onlyContractManager {
        require(_walletAddress != address(0), ""Invalid wallet address"");
        require(_walletAddress != wallet, ""New wallet address is the same as the current one"");

        address oldAddress = wallet;
        wallet = _walletAddress;

        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}"
6644,"challenge the provided proposal ID , and put tokens at stake to do so .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Voting {
    struct Poll {
        uint commitStageLen;
        uint revealStageLen;
        uint quorum;
    }
    function startPoll(uint quorum, uint commitStageLen, uint revealStageLen) external returns (uint pollID);
    function pollMap(uint pollID) external view returns (uint commitEndDate, uint revealEndDate, bool resolved);
}

abstract contract ChallengeReparameterization {
    using SafeMath for uint;

    struct ParamProposal {
        uint deposit;
        uint challengeID;
    }

    struct Challenge {
        address challenger;
        uint rewardPool;
        uint stake;
        bool resolved;
        uint winningTokens;
    }

    mapping(bytes32 => ParamProposal) public proposals;
    mapping(uint => Challenge) public challenges;
    Token public token;
    Voting public voting;

    function get(string memory key) internal pure returns (uint value) {
        // This should be implemented to return the correct values based on the key.
        // For demonstration, let's assume it returns some fixed values.
        if (keccak256(abi.encodePacked(key)) == keccak256(""pDispensationPct"")) {
            return 10; // Example value for pDispensationPct
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pVoteQuorum"")) {
            return 30; // Example value for pVoteQuorum
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pCommitStageLen"")) {
            return 1 days; // Example value for commit stage length
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pRevealStageLen"")) {
            return 1 days; // Example value for reveal stage length
        }
        revert(""Unknown key"");
    }

    function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {
        ParamProposal memory prop = proposals[_propID];
        uint deposit = prop.deposit;
        require(propExists(_propID) && prop.challengeID == 0, ""Invalid proposal"");
        uint pollID = voting.startPoll(get(""pVoteQuorum""), get(""pCommitStageLen""), get(""pRevealStageLen""));
        challenges[pollID] = Challenge({
            challenger: msg.sender,
            rewardPool: SafeMath.sub(100, get(""pDispensationPct"")).mul(deposit).div(100),
            stake: deposit,
            resolved: false,
            winningTokens: 0
        });
        proposals[_propID].challengeID = pollID;
        require(token.transferFrom(msg.sender, address(this), deposit), ""Token transfer failed"");
        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);
        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
        return pollID;
    }

    function propExists(bytes32 _propID) internal view returns (bool) {
        return proposals[_propID].deposit > 0;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'pollMap', 'complexity': 0}, {'function': 'get', 'complexity': 4}, {'function': 'challengeReparameterization', 'complexity': 3}, {'function': 'propExists', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""challengeReparameterization"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_propID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_propID""}}, ""memberName"": ""challengeID""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Proposal already challenged""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Proposal""}, ""name"": ""proposal"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_propID""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""deposit"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""deposit""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""deposit""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No deposit for the proposal""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""pollID"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""votingContract""}, ""memberName"": ""startPoll""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": ""days""}, {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": ""days""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""quorum"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113643770>}, {""type"": ""VariableDeclaration"", ""name"": ""commitEndDate"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113642190>}, {""type"": ""VariableDeclaration"", ""name"": ""revealEndDate"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113643380>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""votingContract""}, ""memberName"": ""getPollDetails""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""pollID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""challenges""}, ""index"": {""type"": ""Identifier"", ""name"": ""pollID""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Challenge""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""deposit""}, {""type"": ""BooleanLiteral"", ""value"": False}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": [""challenger"", ""stake"", ""resolved"", ""winningTokens""]}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_propID""}}, ""memberName"": ""challengeID""}, ""right"": {""type"": ""Identifier"", ""name"": ""pollID""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""votingContract""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""deposit""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_NewChallenge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_propID""}, {""type"": ""Identifier"", ""name"": ""pollID""}, {""type"": ""Identifier"", ""name"": ""commitEndDate""}, {""type"": ""Identifier"", ""name"": ""revealEndDate""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface Voting {
    function startPoll(uint256 quorum, uint256 commitStageLength, uint256 revealStageLength) external returns (uint256);
    function getPollDetails(uint256 pollID) external view returns (uint256, uint256, uint256);
}

contract ParameterProposal {
    struct Proposal {
        address proposer;
        uint256 deposit;
        uint256 challengeID;
    }

    struct Challenge {
        address challenger;
        uint256 stake;
        bool resolved;
        uint256 winningTokens;
    }

    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => Challenge) public challenges;
    Voting public votingContract;
    uint256 public nextChallengeID;

    event _NewChallenge(uint256 propID, uint256 pollID, uint256 commitEndDate, uint256 revealEndDate, address challenger);

    constructor(address _votingContractAddress) {
        votingContract = Voting(_votingContractAddress);
    }

    function challengeReparameterization(uint256 _propID) public {
        require(proposals[_propID].challengeID == 0, ""Proposal already challenged"");

        Proposal storage proposal = proposals[_propID];
        uint256 deposit = proposal.deposit;
        require(deposit > 0, ""No deposit for the proposal"");

        // Start a new voting poll
        uint256 pollID = votingContract.startPoll(1, 3 days, 3 days); // Example quorum and stage lengths
        (uint256 quorum, uint256 commitEndDate, uint256 revealEndDate) = votingContract.getPollDetails(pollID);

        // Create a new Challenge struct
        challenges[pollID] = Challenge({
            challenger: msg.sender,
            stake: deposit,
            resolved: false,
            winningTokens: 0
        });

        // Update the proposal to link it with the challenge
        proposals[_propID].challengeID = pollID;

        // Transfer the deposit amount from the challenger's account to this contract
        require(IERC20(votingContract).transferFrom(msg.sender, address(this), deposit), ""Token transfer failed"");

        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
    }
}",48.22801566123962,challengeReparameterization,58.0,0.8587017621642411,0.377645311303909,"[{'function': 'getPollDetails', 'complexity': 0}, {'function': 'challengeReparameterization', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;

interface Voting {
    function startPoll(uint256 quorum, uint256 commitStageLength, uint256 revealStageLength) external returns (uint256);
    function getPollDetails(uint256 pollID) external view returns (uint256, uint256, uint256);
}

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract ParameterProposal is Ownable {
    struct Proposal {
        address proposer;
        uint256 deposit;
        uint256 challengeID;
    }

    struct Challenge {
        address challenger;
        uint256 stake;
        bool resolved;
        uint256 winningTokens;
    }

    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => Challenge) public challenges;
    Voting public votingContract;
    uint256 public nextChallengeID;

    event _NewChallenge(uint256 propID, uint256 pollID, uint256 commitEndDate, uint256 revealEndDate, address challenger);

    constructor(address _votingContractAddress) Ownable(msg.sender) {
        votingContract = Voting(_votingContractAddress);
    }

    function challengeReparameterization(uint256 _propID) public {
        require(proposals[_propID].challengeID == 0, ""Proposal already challenged"");

        Proposal storage proposal = proposals[_propID];
        uint256 deposit = proposal.deposit;
        require(deposit > 0, ""No deposit for the proposal"");

        // Start a new voting poll
        uint256 pollID = votingContract.startPoll(1, 3 days, 3 days); // Example quorum and stage lengths
        (uint256 quorum, uint256 commitEndDate, uint256 revealEndDate) = votingContract.getPollDetails(pollID);

        // Create a new Challenge struct
        challenges[pollID] = Challenge({
            challenger: msg.sender,
            stake: deposit,
            resolved: false,
            winningTokens: 0
        });

        // Update the proposal to link it with the challenge
        proposals[_propID].challengeID = pollID;

        // Transfer the deposit amount from the challenger's account to this contract
        require(IERC20(votingContract).transferFrom(msg.sender, address(this), deposit), ""Token transfer failed"");

        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
    }
}"
3277,Computes ( _numerator / _denominator ) 10 _scale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract FractionJoiner is Ownable {
    using SafeMath for uint256;

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) public pure returns (uint256) {
        if (_scale >= 0) {
            require(_scale <= 77, ""Scale must be between 0 and 77"");
            return _numerator.mul(10 ** uint256(_scale)).div(_denominator);
        } else {
            return (_numerator / _denominator) / 10 ** uint256(-_scale);
        }
    }
}","[{'function': 'joinFraction', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""joinFraction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_numerator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_denominator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""int16""}, ""name"": ""_scale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_scale""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""77"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Scale exceeds allowed limit to prevent overflow""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_scale""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_numerator""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_scale""}], ""names"": []}}], ""isArray"": False}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""_denominator""}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""_numerator""}, ""right"": {""type"": ""Identifier"", ""name"": ""_denominator""}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""-"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""_scale""}, ""isPrefix"": True}], ""names"": []}}], ""isArray"": False}}], ""isArray"": False}]}}]}, ""visibility"": ""private"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract FractionCalculator {
    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) {
        require(_scale <= 77, ""Scale exceeds allowed limit to prevent overflow"");

        if (_scale >= 0) {
            return (_numerator * (10 ** uint256(_scale))) / _denominator;
        } else {
            return ((_numerator / _denominator) / (10 ** uint256(-_scale)));
        }
    }
}",42.86247777938843,joinFraction,9.0,0.9082448164750933,0.6355164836810908,"[{'function': 'joinFraction', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FractionCalculator is Ownable {
    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _numerator = 1;
        _denominator = 1;
        _scale = 0; // Default scale set to neutral value for multiplication/division operations
    }

    uint256 private constant INITIAL_SCALE = 0; // Placeholder value for ERC20-like initialization
    uint256 private _numerator;
    uint256 private _denominator;
    int16 private _scale;

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) {
        require(_scale <= 77, ""Scale exceeds allowed limit to prevent overflow"");

        if (_scale >= 0) {
            return (_numerator * (10 ** uint256(_scale))) / _denominator;
        } else {
            return ((_numerator / _denominator) / (10 ** uint256(-_scale)));
        }
    }
}"
5822,Get current amount of tokens on Vault address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRntToken {
    function balanceOf() external view returns (uint256);
}

abstract contract Vault is Ownable {
    using SafeMath for uint256;

    IRntToken public rntToken;

    constructor(address _rntToken) {
        rntToken = IRntToken(_rntToken);
    }

    function getVaultBalance() public onlyOwner view returns (uint256) {
        return rntToken.balanceOf();
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getVaultBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getVaultBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IRntToken""}, ""name"": ""rntToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IRntToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rntTokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rntToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAllowedAddresses"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

interface IRntToken {
    function balanceOf(address account) external view returns (uint256);
}

contract Vault {
    address private immutable rntTokenAddress;
    mapping(address => bool) private allowedAddresses;

    constructor(address _rntTokenAddress, address[] memory _allowedAddresses) {
        rntTokenAddress = _rntTokenAddress;
        for (uint i = 0; i < _allowedAddresses.length; i++) {
            allowedAddresses[_allowedAddresses[i]] = true;
        }
    }

    modifier onlyAllowedAddresses() {
        require(allowedAddresses[msg.sender], ""Not an allowed address"");
        _;
    }

    function getVaultBalance() public view onlyAllowedAddresses returns (uint256) {
        IRntToken rntToken = IRntToken(rntTokenAddress);
        return rntToken.balanceOf(address(this));
    }
}",43.4644467830658,getVaultBalance,9.0,0.7708361661412556,0.3156347233429006,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getVaultBalance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

interface IRntToken {
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract Vault is Ownable {
    address private immutable rntTokenAddress;
    mapping(address => bool) private allowedAddresses;

    mapping(address => uint256) public balanceOf;

 constructor(address _rntTokenAddress, address[] memory _allowedAddresses) Ownable(msg.sender) {
        rntTokenAddress = _rntTokenAddress;
        for (uint i = 0; i < _allowedAddresses.length; i++) {
            allowedAddresses[_allowedAddresses[i]] = true;
        }
    }

    modifier onlyAllowedAddresses() {
        require(allowedAddresses[msg.sender], ""Not an allowed address"");
        _;
    }

    function getVaultBalance() public view onlyAllowedAddresses returns (uint256) {
        IRntToken rntToken = IRntToken(rntTokenAddress);
        return rntToken.balanceOf(address(this));
    }
}"
1522,Transfer an amount of currency token from msg.sender account to another specified account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFxUSD {
    function getFxUSDAmount(string memory currency, uint amount) external view returns (uint);
}

interface ITransfer {
    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) external returns (bool success);
}

abstract contract Data {
    using SafeMath for uint;
    mapping(address => uint) public accountSpendingAmounts;
    IFxUSD public fxUSDContract;
    ITransfer public transferContract;

    function getFeeContract(Data storage self, address tokenAddress) internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(Data storage self, address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(Data storage self, address account, uint amount) internal returns (bool success) {
        self.accountSpendingAmounts[account] = amount;
        return true;
    }
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint;
    Data private dataInstance;

    constructor(address _dataAddress, address _fxUSDAddress, address _transferAddress) {
        dataInstance = Data(_dataAddress);
        fxUSDContract = IFxUSD(_fxUSDAddress);
        transferContract = ITransfer(_transferAddress);
    }

    function transfer(string memory currency, address to, uint amount, bytes memory data) public onlyOwner returns (bool success) {
        require(to != address(0), ""Error: `to` address cannot be null."");
        require(amount > 0, ""Error: `amount` must be greater than zero"");
        address feeContract = getFeeContract();
        uint fees = calculateFees(feeContract, amount);
        require(setAccountSpendingAmount(msg.sender, fxUSDContract.getFxUSDAmount(currency, amount)), ""Error: Unable to set spending amount for account."");
        require(forceTransfer(currency, msg.sender, to, amount, data), ""Error: Unable to transfer funds to account."");
        require(forceTransfer(currency, msg.sender, feeContract, fees, getFeeMsg(feeContract)), ""Error: Unable to transfer fees to fee contract."");
        return true;
    }

    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) internal returns (bool success) {
        // Implementation of forceTransfer logic
        require(transferContract.forceTransfer(currency, from, to, amount, data), ""Error: Transfer failed"");
        return true;
    }

    function getFeeContract() internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(address account, uint amount) internal returns (bool success) {
        dataInstance.accountSpendingAmounts[account] = amount;
        return true;
    }
}","[{'function': 'getFxUSDAmount', 'complexity': 0}, {'function': 'forceTransfer', 'complexity': -1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'forceTransfer', 'complexity': 1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}]",9.0,{},"pragma solidity ^0.8.0;

contract CurrencyTransfer {
    address public feeContract;

    constructor(address _feeContract) {
        feeContract = _feeContract;
    }

    function transferCurrency(string memory currency, address to, uint amount, bytes memory data) external returns (bool success) {
        require(to != address(0), ""Invalid recipient address"");
        require(amount > 0, ""Amount must be greater than zero"");

        // Assuming this function updates the sender's spending limit in USD equivalent of the transfer amount
        updateSpendingLimit(amount);

        // Force transfer to the recipient
        (bool sentToRecipient, ) = to.call{value: 0}(abi.encodeWithSignature(""transfer(address,uint256)"", address(this), amount));
        require(sentToRecipient, ""Failed to send currency to recipient"");

        // Force transfer fees to the fee contract
        (bool sentToFeeContract, ) = feeContract.call{value: 0}(abi.encodeWithSignature(""transfer(address,uint256)"", address(this), calculateFees(amount)));
        require(sentToFeeContract, ""Failed to send fees to fee contract"");

        success = true;
    }

    function updateSpendingLimit(uint amount) internal {
        // Logic to update the sender's spending limit in USD equivalent of the transfer amount
        // This is a placeholder for actual implementation
    }

    function calculateFees(uint amount) internal returns (uint fees) {
        // Calculate transaction fees based on the transfer amount
        // This is a placeholder for actual calculation logic
        fees = amount * 1 / 100; // Example: 1% fee
    }
}",45.85307908058167,transferCurrency,83.0,0.8868380065977826,0.3194057920931089,"[{'function': 'transferCurrency', 'complexity': 4}, {'function': 'updateSpendingLimit', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CurrencyTransfer is Ownable {
    address public feeContract;

    constructor(address _feeContract) Ownable(msg.sender) {
        feeContract = _feeContract;
    }

    function transferCurrency(string memory currency, address to, uint amount, bytes memory data) external returns (bool success) {
        require(to != address(0), ""Invalid recipient address"");
        require(amount > 0, ""Amount must be greater than zero"");

        // Assuming this function updates the sender's spending limit in USD equivalent of the transfer amount
        updateSpendingLimit(amount);

        // Force transfer to the recipient
        (bool sentToRecipient, ) = to.call{value: 0}(abi.encodeWithSignature(""transfer(address,uint256)"", address(this), amount));
        require(sentToRecipient, ""Failed to send currency to recipient"");

        // Force transfer fees to the fee contract
        (bool sentToFeeContract, ) = feeContract.call{value: 0}(abi.encodeWithSignature(""transfer(address,uint256)"", address(this), calculateFees(amount)));
        require(sentToFeeContract, ""Failed to send fees to fee contract"");

        success = true;
    }

    function updateSpendingLimit(uint amount) internal {
        // Logic to update the sender's spending limit in USD equivalent of the transfer amount
        // This is a placeholder for actual implementation
    }

    function calculateFees(uint amount) internal returns (uint fees) {
        // Calculate transaction fees based on the transfer amount
        // This is a placeholder for actual calculation logic
        fees = amount * 1 / 100; // Example: 1% fee
    }
}"
3064,Sender should check whether he has enough tokens to be transferred,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public onlyOwner {
        require(_recipients.length == _values.length);
        uint length = _recipients.length;
        for (uint i = 0; i < length; i++) {
            transfer(_recipients[i], _values[i]);
        }
    }
}","[{'function': 'batchTransfer', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""batchTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_values"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_values""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Recipients and values arrays must have the same length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_values""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract BatchTransfer {
    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public payable {
        require(_recipients.length == _values.length, ""Recipients and values arrays must have the same length"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            // Transfer Ether to each recipient
            payable(_recipients[i]).transfer(_values[i]);
        }
    }
}",42.76062917709351,batchTransfer,10.0,0.9296442775762024,0.4244963328127102,"[{'function': 'batchTransfer', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BatchTransfer is Ownable {
    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public payable {
        require(_recipients.length == _values.length, ""Recipients and values arrays must have the same length"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            // Transfer Ether to each recipient
            payable(_recipients[i]).transfer(_values[i]);
        }
    }
}"
6408,"owners : send ` value ` of tokens to address ` to ` , can be called if crowdsale failed and some of the investors refunded the ether","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenSender is Ownable {
    using SafeMath for uint256;

    IERC20 public m_token;
    enum State { ACTIVE, REFUNDING }
    State public currentState = State.REFUNDING;

    modifier validAddress(address to) {
        require(to != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bytes memory data = abi.encodePacked(msg.sig, msg.data);
        require(isOwner(txHash), ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State state) {
        require(currentState == state, ""Function not allowed in current state"");
        _;
    }

    constructor(address tokenAddress) {
        m_token = IERC20(tokenAddress);
    }

    function sendTokens(address to, uint value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(State.REFUNDING) {
        require(value > 0 && m_token.balanceOf(this) >= value);
        m_token.transfer(to, value);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'sendTokens', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid transfer amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlyManyOwners"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""requiresState"", ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""REFUNDING""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

contract TokenSender {
    address public owner;
    IERC20 private tokenContract;
    string public state = ""REFUNDING"";

    modifier validAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners() {
        // This should be implemented based on the actual multi-owner logic.
        require(msg.sender == owner, ""Only multiple owners can call this function"");
        _;
    }

    modifier requiresState(string memory requiredState) {
        require(keccak256(abi.encodePacked(state)) == keccak256(abi.encodePacked(requiredState)), ""Contract state must be REFUNDING"");
        _;
    }

    constructor(address _tokenContract, address _owner) {
        tokenContract = IERC20(_tokenContract);
        owner = _owner;
    }

    function sendTokens(address to, uint value) public validAddress(to) onlyManyOwners requiresState(""REFUNDING"") {
        require(value > 0 && value <= tokenContract.balanceOf(address(this)), ""Invalid transfer amount"");
        bool success = tokenContract.transfer(to, value);
        require(success, ""Token transfer failed"");
    }
}",45.27624034881592,sendTokens,19.0,0.8936622493819769,0.4311929694131552,"[{'function': 'transfer', 'complexity': 0}, {'function': 'sendTokens', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSender is Ownable {
    address public owner;
    IERC20 private tokenContract;
    string public state = ""REFUNDING"";

    modifier validAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners() {
        // This should be implemented based on the actual multi-owner logic.
        require(msg.sender == owner, ""Only multiple owners can call this function"");
        _;
    }

    modifier requiresState(string memory requiredState) {
        require(keccak256(abi.encodePacked(state)) == keccak256(abi.encodePacked(requiredState)), ""Contract state must be REFUNDING"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenContract, address _owner) Ownable(_owner) {
        tokenContract = IERC20(_tokenContract);
        owner = _owner;
    }

    function sendTokens(address to, uint value) public validAddress(to) onlyManyOwners requiresState(""REFUNDING"") {
        require(value > 0 && value <= tokenContract.balanceOf(address(this)), ""Invalid transfer amount"");
        bool success = tokenContract.transfer(to, value);
        require(success, ""Token transfer failed"");
    }
}"
6613,Sets the ` _newManager ` as manager for the ` _addr ` address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IManager {
    function getManager(address _addr) external view returns (address);
}

abstract contract ManagerWrapper is Ownable, SafeMath {
    mapping(address => address) public managers;
    event ManagerChanged(address indexed addr, address newManager);

    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, ""Not the manager"");
        managers[_addr] = (_newManager == _addr ? 0 : _newManager);
        emit ManagerChanged(_addr, _newManager);
    }
}","[{'function': 'getManager', 'complexity': 0}, {'function': 'setManager', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newManager""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newManager""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ManagerChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_addr""}, {""type"": ""Identifier"", ""name"": ""_newManager""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ManagerUpdater {
    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address newManager);

    modifier onlyManager(address _addr) {
        require(msg.sender == managers[_addr], ""Not the manager"");
        _;
    }

    function updateManager(address _addr, address _newManager) public {
        if (managers[_addr] != _newManager) {
            managers[_addr] = _newManager;
            emit ManagerChanged(_addr, _newManager);
        } else {
            managers[_addr] = address(0);
        }
    }
}",42.81652760505676,updateManager,19.0,0.787819578632072,0.3434493733252607,"[{'function': 'updateManager', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ManagerUpdater is Ownable {
    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address newManager);

    modifier onlyManager(address _addr) {
        require(msg.sender == managers[_addr], ""Not the manager"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            managers[address(uint160(i))] = address(uint160(i));
        }
    }

    function updateManager(address _addr, address _newManager) public {
        if (managers[_addr] != _newManager) {
            managers[_addr] = _newManager;
            emit ManagerChanged(_addr, _newManager);
        } else {
            managers[_addr] = address(0);
        }
    }
}"
799,Returns all the relevant information about a specific collectible .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Collectible {
    using SafeMath for uint256;

    struct Token {
        uint256 price;
        address owner;
    }

    mapping(uint256 => Token) public collectibleIdx;

    function getInitialPriceOfToken(uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate initial price of token
        return 0; // Placeholder, replace with actual implementation
    }

    function getNextPrice(uint256 currentPrice, uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate next selling price
        return currentPrice.mul(110).div(100); // Example: increase by 10%
    }

    function getToken(uint256 _tokenId) public view returns (
        uint256 tokenId,
        uint256 sellingPrice,
        address owner,
        uint256 nextSellingPrice
    ) {
        tokenId = _tokenId;
        Token storage token = collectibleIdx[_tokenId];
        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(_tokenId);
        }
        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
    }
}","[{'function': 'getInitialPriceOfToken', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getToken', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""nextSellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}, ""name"": ""token"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectibleIdx""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""price""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getInitialPriceOfToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""owner""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nextSellingPrice""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextPrice""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sellingPrice""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TokenCollector {
    struct Token {
        uint256 price;
        address owner;
    }

    mapping(uint256 => Token) public collectibleIdx;

    function getToken(uint256 _tokenId) public view returns (uint256 sellingPrice, address owner, uint256 nextSellingPrice) {
        Token storage token = collectibleIdx[_tokenId];
        require(token.owner != address(0), ""Token does not exist"");

        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(_tokenId);
        }

        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
    }

    function getInitialPriceOfToken(uint256 _tokenId) internal view returns (uint256) {
        // Placeholder for the logic to retrieve the initial price of a token.
        Token storage token = collectibleIdx[_tokenId];
        return token.price; // Assume this is the correct value or some other calculation.
    }

    function getNextPrice(uint256 currentPrice, uint256 _tokenId) internal view returns (uint256) {
        // Placeholder for the logic to calculate the next selling price based on current price and tokenId.
        return currentPrice + (_tokenId % 10); // Example calculation; adjust as needed.
    }
}",45.440678119659424,getToken,16.0,0.8870590620608652,0.7310738196196732,"[{'function': 'getToken', 'complexity': 2}, {'function': 'getInitialPriceOfToken', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenCollector is Ownable {
    struct Token {
        uint256 price;
        address owner;
    }

    mapping(uint256 => Token) public collectibleIdx;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            collectibleIdx[i] = Token({price: 1, owner: address(uint160(uint256(keccak256(abi.encodePacked(""owner"", i)))))});
        }
    }

    function getToken(uint256 _tokenId) public view returns (uint256 sellingPrice, address owner, uint256 nextSellingPrice) {
        Token storage token = collectibleIdx[_tokenId];
        require(token.owner != address(0), ""Token does not exist"");

        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(_tokenId);
        }

        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
    }

    function getInitialPriceOfToken(uint256 _tokenId) internal view returns (uint256) {
        // Placeholder for the logic to retrieve the initial price of a token.
        Token storage token = collectibleIdx[_tokenId];
        return token.price; // Assume this is the correct value or some other calculation.
    }

    function getNextPrice(uint256 currentPrice, uint256 _tokenId) internal view returns (uint256) {
        // Placeholder for the logic to calculate the next selling price based on current price and tokenId.
        return currentPrice + (_tokenId % 10); // Example calculation; adjust as needed.
    }
}"
5627,Changing versions does not affect existing tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract STFactoryWrapper is Ownable {
    using SafeMath for uint256;

    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external onlyOwner {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        // Assuming _setProtocolVersion is a function in the STFactory contract
        (bool success, ) = _STFactoryAddress.call(abi.encodeWithSignature(""setProtocolVersion(uint8, uint8, uint8)"", _major, _minor, _patch));
        require(success, ""External call failed"");
    }
}","[{'function': 'setProtocolVersion', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setProtocolVersion"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_STFactoryAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_major"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_minor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_patch"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_STFactoryAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""0x address is not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_setProtocolVersion""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_STFactoryAddress""}, {""type"": ""Identifier"", ""name"": ""_major""}, {""type"": ""Identifier"", ""name"": ""_minor""}, {""type"": ""Identifier"", ""name"": ""_patch""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ProtocolVersionSetter {
    // Mapping to store the protocol version for each STFactory address
    mapping(address => uint32) public protocolVersions;

    // Modifier to check if the caller is the contract owner
    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    // The address of the contract owner
    address private owner;

    // Constructor to initialize the contract with the deployer as the owner
    constructor() {
        owner = msg.sender;
    }

    // Function to set a new protocol version for a specified STFactory address
    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) public onlyOwner {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        _setProtocolVersion(_STFactoryAddress, _major, _minor, _patch);
    }

    // Internal function to set the protocol version for a specified STFactory address
    function _setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) internal {
        uint32 version = (uint32(_major) << 16) | (uint32(_minor) << 8) | uint32(_patch);
        protocolVersions[_STFactoryAddress] = version;
    }
}",45.31933760643005,_setProtocolVersion,10.0,0.7864147891027995,0.1808252850209916,"[{'function': 'setProtocolVersion', 'complexity': 1}, {'function': '_setProtocolVersion', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ProtocolVersionSetter is Ownable {
    // Mapping to store the protocol version for each STFactory address
    mapping(address => uint32) public protocolVersions;

    // Constructor to initialize the contract with the deployer as the owner
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    // Function to set a new protocol version for a specified STFactory address
    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) public onlyOwner {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        _setProtocolVersion(_STFactoryAddress, _major, _minor, _patch);
    }

    // Internal function to set the protocol version for a specified STFactory address
    function _setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) internal {
        uint32 version = (uint32(_major) << 16) | (uint32(_minor) << 8) | uint32(_patch);
        protocolVersions[_STFactoryAddress] = version;
    }
}"
2373,Transfers tokens from a specified wallet address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
        require(_to != address(0), ""Invalid address."");
        return super.transferFrom(_from, _to, _value);
    }
}","[{'function': 'transferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address.""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canTransfer"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    modifier canTransfer(address _from) {
        require(_from != address(0), ""Invalid address."");
        // Assuming there's a way to check if the transfer is allowed for `_from` in the superclass or modifier logic.
        _;
    }

    function transferTokens(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool success) {
        require(_to != address(0), ""Invalid address.""); // Additional check for `_to` not being the zero address.
        // Assuming there's a way to call transferFrom in the superclass or an equivalent function.
        return super.transferFrom(_from, _to, _value);
    }
}",43.23811316490173,transferTokens,0.0,0.9852853466987068,0.5645648539473355,"[{'function': 'transferTokens', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    modifier canTransfer(address _from) {
        require(_from != address(0), ""Invalid address."");
        // Assuming there's a way to check if the transfer is allowed for `_from` in the superclass or modifier logic.
        _;
    }

    function transferTokens(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool success) {
        require(_to != address(0), ""Invalid address.""); // Additional check for `_to` not being the zero address.
        // Assuming there's a way to call transferFrom in the superclass or an equivalent function.
        return super.transferFrom(_from, _to, _value);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables:
        // uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
3161,"Set `` _price_start '' , `` _price_constant1 '' and `` _price_exponent1 '' `` _price_constant2 '' and `` _price_exponent2 '' as the new starting price , price constant and price exponent for the auction price .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionDeployed, AuctionSetUp }
    Stages public stage;

    uint256 public price_start;
    uint256 public price_constant1;
    uint256 public price_exponent1;
    uint256 public price_constant2;
    uint256 public price_exponent2;

    function changePriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) public onlyOwner {
        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);
        require(_price_start > 0);
        require(_price_constant1 > 0);
        require(_price_constant2 > 0);

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}","[{'function': 'changePriceCurveSettings', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPriceCurveSettings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_start"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_constant1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_exponent1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_constant2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price_exponent2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price_start""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Starting price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant1""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_price_constant2""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Constants must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_start""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_start""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_constant1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_constant1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_exponent1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_exponent1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_constant2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_constant2""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""price_exponent2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_price_exponent2""}}}]}, ""visibility"": ""internal"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyDuringSetup"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Auction {
    enum Stage { AuctionDeployed, AuctionSetUp }
    Stage public currentStage;

    uint256 public price_start;
    uint256 public price_constant1;
    uint256 public price_exponent1;
    uint256 public price_constant2;
    uint256 public price_exponent2;

    modifier onlyDuringSetup() {
        require(currentStage == Stage.AuctionSetUp || currentStage == Stage.AuctionDeployed, ""Invalid stage for this operation"");
        _;
    }

    function setPriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) internal onlyDuringSetup {
        require(_price_start > 0, ""Starting price must be greater than zero"");
        require(_price_constant1 > 0 && _price_constant2 > 0, ""Constants must be greater than zero"");

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}",44.99890756607056,setPriceCurveSettings,21.0,0.7850727359872247,0.6136880802757985,"[{'function': 'setPriceCurveSettings', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    enum Stage { AuctionDeployed, AuctionSetUp }
    Stage public currentStage;

    uint256 public price_start = 1;
    uint256 public price_constant1 = 1;
    uint256 public price_exponent1 = 1;
    uint256 public price_constant2 = 1;
    uint256 public price_exponent2 = 1;

    modifier onlyDuringSetup() {
        require(currentStage == Stage.AuctionSetUp || currentStage == Stage.AuctionDeployed, ""Invalid stage for this operation"");
        _;
    }

    constructor() Ownable(msg.sender) {
        currentStage = Stage.AuctionDeployed;
    }

    function setPriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) internal onlyDuringSetup {
        require(_price_start > 0, ""Starting price must be greater than zero"");
        require(_price_constant1 > 0 && _price_constant2 > 0, ""Constants must be greater than zero"");

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}"
1809,Nominate a new owner of this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    address public nominatedOwner;

    event OwnerNominated(address indexed newOwner);

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
}","[{'function': 'nominateNewOwner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""nominateNewOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""nominatedOwner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_owner""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnerNominated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    address private nominatedOwner;

    event OwnerNominated(address indexed newOwner);

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Caller is not the owner"");
        _;
    }

    constructor() {
        _owner = msg.sender;
    }

    function nominateNewOwner(address _owner) public onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
}",42.62111949920654,nominateNewOwner,0.0,0.9786856587865076,0.8492326635760689,"[{'function': 'nominateNewOwner', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;
    address private nominatedOwner;

    event OwnerNominated(address indexed newOwner);

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Caller is not the owner"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _owner = msg.sender;
    }

    function nominateNewOwner(address _owner) public onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
}"
5765,set minimal amount of ether which can be used to buy tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public minSellAmount;

    function setMinSellAmount(uint256 _minSellAmount) public onlyOwner {
        minSellAmount = _minSellAmount;
    }
}","[{'function': 'setMinSellAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinSellAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minSellAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minSellAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minSellAmount""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is Ownable {
    uint256 public minSellAmount;

    function setMinSellAmount(uint256 _minSellAmount) external onlyOwner {
        minSellAmount = _minSellAmount;
    }
}",42.04992246627808,setMinSellAmount,0.0,0.9745468316284812,0.7611606003349892,"[{'function': 'setMinSellAmount', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    uint256 public minSellAmount;

    constructor() Ownable(msg.sender) {
        minSellAmount = 1;
    }

    function setMinSellAmount(uint256 _minSellAmount) external onlyOwner {
        minSellAmount = _minSellAmount;
    }
}"
1032,Obtain the quantity which the next schedule entry will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingWrapper is Ownable {
    using SafeMath for uint256;

    uint constant QUANTITY_INDEX = 1;

    function getNextVestingEntry(address account) internal view returns (uint[] memory entry) {
        // This should be implemented by the actual contract that uses this wrapper.
        // For demonstration purposes, let's assume it returns a fixed array for any address.
        return [0, 100]; // Example: vesting quantity is 100 for any account
    }

    function getNextVestingQuantity(address account) external view returns (uint) {
        uint[] memory entry = getNextVestingEntry(account);
        return entry[QUANTITY_INDEX];
    }
}","[{'function': 'getNextVestingEntry', 'complexity': 0}, {'function': 'getNextVestingQuantity', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNextVestingQuantity"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""VestingEntry""}, ""length"": None}, ""name"": ""entries"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingEntries""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""entries""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No vesting entries found for this account""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""entries""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""quantity""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract VestingContract {
    struct VestingEntry {
        uint256 quantity;
        // other fields...
    }

    mapping(address => VestingEntry[]) private vestingEntries;

    function getNextVestingQuantity(address account) public view returns (uint256) {
        VestingEntry[] memory entries = vestingEntries[account];
        require(entries.length > 0, ""No vesting entries found for this account"");
        return entries[0].quantity; // Assuming QUANTITY_INDEX is 0 based on the provided logic
    }
}",42.35971999168396,getNextVestingQuantity,12.0,0.6909999702161831,0.0754325072438952,"[{'function': 'getNextVestingQuantity', 'complexity': 1}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VestingContract is Ownable {
    struct VestingEntry {
        uint256 quantity;
        // other fields...
    }

    mapping(address => VestingEntry[]) private vestingEntries;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
        vestingEntries[address(0x111)] = [VestingEntry({quantity: 1})];
        vestingEntries[address(0x222)] = [VestingEntry({quantity: 1})];
        vestingEntries[address(0x333)] = [VestingEntry({quantity: 1})];
    }

    function getNextVestingQuantity(address account) public view returns (uint256) {
        VestingEntry[] memory entries = vestingEntries[account];
        require(entries.length > 0, ""No vesting entries found for this account"");
        return entries[0].quantity; // Assuming QUANTITY_INDEX is 0 based on the provided logic
    }
}"
2223,Verifies that two token requirements can be matched and that the tokens are formatted correctly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenVerifier is Ownable {
    using SafeMath for uint256;

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        return ((uint32(_buyTokens) == uint32(_sellToken >> 32)) && (uint32(_sellToken) == uint32(_buyTokens >> 32)) && (uint32(_buyTokens >> 32) <= uint32(_buyTokens)));
    }
}","[{'function': 'verifyTokens', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_buyTokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_sellToken"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""upperBuy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""_buyTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""upperSell"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">>"", ""left"": {""type"": ""Identifier"", ""name"": ""_sellToken""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""lowerBuy"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""_buyTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0xFFFFFFFF"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""lowerSell"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&"", ""left"": {""type"": ""Identifier"", ""name"": ""_sellToken""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0xFFFFFFFF"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""condition1"", ""storageLocation"": None}], ""initialValue"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""lowerBuy""}, ""right"": {""type"": ""Identifier"", ""name"": ""upperSell""}}], ""isArray"": False}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""condition2"", ""storageLocation"": None}], ""initialValue"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""lowerSell""}, ""right"": {""type"": ""Identifier"", ""name"": ""upperBuy""}}], ""isArray"": False}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""condition3"", ""storageLocation"": None}], ""initialValue"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""upperBuy""}, ""right"": {""type"": ""Identifier"", ""name"": ""lowerBuy""}}], ""isArray"": False}}, {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""condition1""}, ""right"": {""type"": ""Identifier"", ""name"": ""condition2""}}, ""right"": {""type"": ""Identifier"", ""name"": ""condition3""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","contract TokenVerifier {
    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        // Extract upper 32 bits of both tokens
        uint32 upperBuy = uint32(_buyTokens >> 32);
        uint32 upperSell = uint32(_sellToken >> 32);

        // Extract lower 32 bits of both tokens
        uint32 lowerBuy = uint32(_buyTokens & 0xFFFFFFFF);
        uint32 lowerSell = uint32(_sellToken & 0xFFFFFFFF);

        // Check conditions
        bool condition1 = (lowerBuy == upperSell);
        bool condition2 = (lowerSell == upperBuy);
        bool condition3 = (upperBuy <= lowerBuy);

        return condition1 && condition2 && condition3;
    }
}",43.436004400253296,verifyTokens,46.0,0.771649700238109,0.2714597955398389,"[{'function': 'verifyTokens', 'complexity': 0}]",4.0,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenVerifier is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        // Extract upper 32 bits of both tokens
        uint32 upperBuy = uint32(_buyTokens >> 32);
        uint32 upperSell = uint32(_sellToken >> 32);

        // Extract lower 32 bits of both tokens
        uint32 lowerBuy = uint32(_buyTokens & 0xFFFFFFFF);
        uint32 lowerSell = uint32(_sellToken & 0xFFFFFFFF);

        // Check conditions
        bool condition1 = (lowerBuy == upperSell);
        bool condition2 = (lowerSell == upperBuy);
        bool condition3 = (upperBuy <= lowerBuy);

        return condition1 && condition2 && condition3;
    }
}"
3500,"Transfers ` amount ` of ` token ` to ` dest ` , only used internally , and does not throw , will always return ` true ` or ` false `","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract PaymentWrapper is Ownable {
    using SafeMath for uint256;

    event Withdraw(uint indexed idDeposit, address indexed dest, ERC20 token, uint amount);

    function doPayment(uint _idDeposit, address _dest, ERC20 _token, uint _amount) public onlyOwner returns (bool) {
        if (_amount == 0) return true;
        if (address(_token) == address(0)) {
            require(_dest.send(_amount), ""Transfer failed"");
        } else {
            require(_token.transfer(_dest, _amount), ""Token transfer failed"");
        }
        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'doPayment', 'complexity': 3}]",5.0,{},"pragma solidity ^0.8.0;

contract PaymentHandler {
    event Withdraw(uint256 _idDeposit, address indexed _dest, address indexed _token, uint256 _amount);

    function doPayment(uint256 _idDeposit, address _dest, address _token, uint256 _amount) external returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");

        if (_token == address(0)) {
            // Native Ether transfer
            (bool success, ) = payable(_dest).call{value: _amount}("""");
            if (!success) return false;
        } else {
            // ERC20 token transfer
            bool success = IERC20(_token).transfer(_dest, _amount);
            if (!success) return false;
        }

        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}",43.7020115852356,doPayment,45.0,0.869243527439824,0.3533721514794337,"[{'function': 'doPayment', 'complexity': 6}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentHandler is Ownable {
    event Withdraw(uint256 _idDeposit, address indexed _dest, address indexed _token, uint256 _amount);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function doPayment(uint256 _idDeposit, address _dest, address _token, uint256 _amount) external returns (bool) {
        require(_amount > 0, ""Amount must be greater than zero"");

        if (_token == address(0)) {
            // Native Ether transfer
            (bool success, ) = payable(_dest).call{value: _amount}("""");
            if (!success) return false;
        } else {
            // ERC20 token transfer
            bool success = IERC20(_token).transfer(_dest, _amount);
            if (!success) return false;
        }

        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}"
4517,returns the block number when the order being last modified .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;

    struct Order {
        uint256 blockNumber;
    }

    mapping(uint256 => Order) public orders;

    function orderBlockNumber(uint256 _orderID) external view returns (uint256) {
        return orders[_orderID].blockNumber;
    }
}","[{'function': 'orderBlockNumber', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""orderBlockNumber"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_orderID""}}, ""memberName"": ""blockNumber""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract OrderBook {
    struct Order {
        bytes32 orderID;
        uint blockNumber;
    }

    mapping(bytes32 => Order) public orders;

    function orderBlockNumber(bytes32 _orderID) external view returns (uint) {
        return orders[_orderID].blockNumber;
    }
}",42.07351922988892,orderBlockNumber,0.0,0.965728108983234,0.6128081331864039,"[{'function': 'orderBlockNumber', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OrderBook is Ownable {
    struct Order {
        bytes32 orderID;
        uint blockNumber;
    }

    mapping(bytes32 => Order) public orders;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            bytes memory addressBytes = abi.encodePacked(uint256(i));
            orders[keccak256(addressBytes)] = Order({orderID: keccak256(addressBytes), blockNumber: uint256(1)});
        }
    }

    function orderBlockNumber(bytes32 _orderID) external view returns (uint) {
        return orders[_orderID].blockNumber;
    }
}"
868,batch send the current balance to the new version contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;
function migrateByAdmin_DQV (uint256[] inputs) external onlyAdmin {
    uint256 data = inputs[2];
    address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];
    address newContract = address(inputs[0]);
    for (uint256 i = 1; i < inputs.length; i += 4) {
        uint256 gasFee = inputs[i];
        data = inputs[i + 1];
        address user = userId2Address[data & USER_MASK];
        bytes32 hash = keccak256(this, gasFee, data & SIGN_MASK | uint256(token), newContract);
        require(verify(hash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 2]), bytes32(inputs[i + 3])));
        if (gasFee > 0) {
            uint256 paymentMethod = data & PAYMENT_METHOD_MASK;
            if (paymentMethod == PAY_BY_JOY) {
                balances[joyToken][user] = balances[joyToken][user].sub(gasFee);
                balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(gasFee);
            } else if (paymentMethod == PAY_BY_TOKEN) {
                balances[token][user] = balances[token][user].sub(gasFee);
                balances[token][joysoWallet] = balances[token][joysoWallet].add(gasFee);
            } else {
                balances[0][user] = balances[0][user].sub(gasFee);
                balances[0][joysoWallet] = balances[0][joysoWallet].add(gasFee);
            }
        }
        uint256 amount = balances[token][user];
        balances[token][user] = 0;
        if (token == 0) {
            Migratable(newContract).migrate.value(amount)(user, amount, token);
        } else {
            ERC20(token).approve(newContract, amount);
            Migratable(newContract).migrate(user, amount, token);
        }
    }
}
}","[{'function': 'migrateByAdmin_DQV ', 'complexity': 15}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""migrateUsers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""inputs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newContractAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint160""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""gasFee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""userId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""paymentMethod"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""data"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""userId""}, {""type"": ""Identifier"", ""name"": ""paymentMethod""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""verify""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""inputs""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}}}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Signature verification failed""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""gasFee""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenAddress""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""userAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint160""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""userId""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""userAddress""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gasFee""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateBalance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""userId""}, {""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newContractAddress""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newContractAddress""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""migrate(address,uint256,address)""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint160""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""userId""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}, {""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Migration call failed""}], ""names"": []}}]}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract MigrationContract {
    address public admin;

    constructor() {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    function migrateUsers(uint256[] memory inputs) public onlyAdmin {
        address newContractAddress = address(uint160(inputs[0]));
        uint256 tokenAddress = inputs[1];

        for (uint256 i = 3; i < inputs.length; i += 4) {
            uint256 gasFee = inputs[i];
            uint256 userId = inputs[i + 1];
            uint256 paymentMethod = inputs[i + 2];
            bytes memory data = abi.encodePacked(userId, paymentMethod);

            require(verify(keccak256(data), inputs[i + 3]), ""Signature verification failed"");

            if (gasFee > 0) {
                uint256 balance;
                if (tokenAddress == 0) {
                    // Ether migration
                    address payable userAddress = payable(address(uint160(userId)));
                    userAddress.transfer(gasFee);
                } else {
                    // ERC20 token migration
                    IERC20 token = IERC20(address(tokenAddress));
                    balance = calculateBalance(userId, tokenAddress);
                    require(token.approve(newContractAddress, balance), ""Approval failed"");
                    (bool success, ) = newContractAddress.call(abi.encodeWithSignature(""migrate(address,uint256,address)"", address(uint160(userId)), balance, tokenAddress));
                    require(success, ""Migration call failed"");
                }
            }
        }
    }

    function verify(bytes32 hash, uint256 signature) internal pure returns (bool) {
        // Implement your verification logic here
        return true;
    }

    function calculateBalance(uint256 userId, uint256 tokenAddress) internal view returns (uint256) {
        // Implement the logic to calculate user balance of the specified token
        return 0;
    }
}",47.98614168167114,migrateUsers,84.0,0.5791011314089076,0.2412996106334811,"[{'function': 'approve', 'complexity': 0}, {'function': 'migrateUsers', 'complexity': 10}, {'function': 'verify', 'complexity': 0}, {'function': 'calculateBalance', 'complexity': 0}]",9.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract MigrationContract is Ownable {
    address public admin;

    constructor() Ownable(msg.sender) {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    function migrateUsers(uint256[] memory inputs) public onlyAdmin {
        address newContractAddress = address(uint160(inputs[0]));
        uint256 tokenAddress = inputs[1];

        for (uint256 i = 3; i < inputs.length; i += 4) {
            uint256 gasFee = inputs[i];
            uint256 userId = inputs[i + 1];
            uint256 paymentMethod = inputs[i + 2];
            bytes memory data = abi.encodePacked(userId, paymentMethod);

            require(verify(keccak256(data), inputs[i + 3]), ""Signature verification failed"");

            if (gasFee > 0) {
                uint256 balance;
                if (tokenAddress == 0) {
                    // Ether migration
                    address payable userAddress = payable(address(uint160(userId)));
                    userAddress.transfer(gasFee);
                } else {
                    // ERC20 token migration
                    IERC20 token = IERC20(address(tokenAddress));
                    balance = calculateBalance(userId, tokenAddress);
                    require(token.approve(newContractAddress, balance), ""Approval failed"");
                    (bool success, ) = newContractAddress.call(abi.encodeWithSignature(""migrate(address,uint256,address)"", address(uint160(userId)), balance, tokenAddress));
                    require(success, ""Migration call failed"");
                }
            }
        }
    }

    function verify(bytes32 hash, uint256 signature) internal pure returns (bool) {
        // Implement your verification logic here
        return true;
    }

    function calculateBalance(uint256 userId, uint256 tokenAddress) internal view returns (uint256) {
        // Implement the logic to calculate user balance of the specified token
        return 0;
    }
}"
2092,Get a player 's current instant pot winnings .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    struct TeamData {
        uint256 mask;
        uint256 keys;
    }

    struct PlayerTeamData {
        uint256 mask;
        uint256 keys;
    }

    mapping(uint256 => mapping(uint256 => TeamData)) public teams_;
    mapping(uint256 => mapping(uint256 => mapping(uint256 => PlayerTeamData))) public playerTeams_;

    modifier isActivated(uint256 _gameID) {
        require(_gameID > 0 && _gameID < 10, ""Game must be activated"");
        _;
    }

    modifier isValidTeam(uint256 _gameID, uint256 _team) {
        require(_team > 0 && _team <= 3, ""Invalid team"");
        _;
    }

    function getPlayerInstWinning(uint256 _gameID, uint256 _pID, uint256 _team) public view isActivated(_gameID) isValidTeam(_gameID, _team) returns (uint256) {
        return (((teams_[_gameID][_team].mask).mul(playerTeams_[_pID][_gameID][_team].keys)) / (1000000000000000000)).sub(playerTeams_[_pID][_gameID][_team].mask));
    }
}","[{'function': 'getPlayerInstWinning', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateWinningAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_gameID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_pID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_team"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isActivated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_gameID""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Game is not activated""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isValidTeam""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_gameID""}, {""type"": ""Identifier"", ""name"": ""_team""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid team for this game""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""maskValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""teams_""}, ""index"": {""type"": ""Identifier"", ""name"": ""_gameID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_team""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""participationKey"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""playerTeams_""}, ""index"": {""type"": ""Identifier"", ""name"": ""_gameID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_pID""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_team""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""result"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""maskValue""}, ""right"": {""type"": ""Identifier"", ""name"": ""participationKey""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""/="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""Identifier"", ""name"": ""maskValue""}}}, {""type"": ""Identifier"", ""name"": ""result""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract GameCalculator {
    // Assuming teams_ is a mapping from (gameID => teamID => maskValue)
    mapping(uint256 => mapping(uint256 => uint256)) public teams_;
    // Assuming playerTeams_ is a mapping from (gameID, playerID, teamID) => participationKey
    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) public playerTeams_;

    function calculateWinningAmount(uint256 _gameID, uint256 _pID, uint256 _team) public view returns (uint256) {
        require(isActivated(_gameID), ""Game is not activated"");
        require(isValidTeam(_gameID, _team), ""Invalid team for this game"");

        // Retrieve the mask value associated with the team in the specified game
        uint256 maskValue = teams_[_gameID][_team];

        // Assuming playerTeams_ is indexed by (gameID, playerID, teamID) and holds some key representing participation
        uint256 participationKey = playerTeams_[_gameID][_pID][_team];

        // Calculate the winning amount
        uint256 result = maskValue * participationKey;
        result /= 1e18; // Convert to a more manageable unit by dividing by 10^18

        // Subtract the mask value associated with the player's participation in that team
        result -= maskValue;

        return result;
    }

    function isActivated(uint256 _gameID) public view returns (bool) {
        // Implement your logic to check if the game is activated
        return true; // Placeholder, replace with actual implementation
    }

    function isValidTeam(uint256 _gameID, uint256 _team) public view returns (bool) {
        // Implement your logic to validate team number for the specified game
        return true; // Placeholder, replace with actual implementation
    }
}",46.85707187652588,calculateWinningAmount,43.0,0.7149382066675349,0.1718778387496682,"[{'function': 'calculateWinningAmount', 'complexity': 2}, {'function': 'isActivated', 'complexity': 0}, {'function': 'isValidTeam', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GameCalculator is Ownable {
    // Assuming teams_ is a mapping from (gameID => teamID => maskValue)
    mapping(uint256 => mapping(uint256 => uint256)) public teams_;
    // Assuming playerTeams_ is a mapping from (gameID, playerID, teamID) => participationKey
    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) public playerTeams_;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint256 gameID = 1; ; ++gameID) {
            for (uint256 teamID = 1; ; ++teamID) {
                teams_[gameID][teamID] = 1; // Set to 1 (never 0)
            }
        }
    }

    function calculateWinningAmount(uint256 _gameID, uint256 _pID, uint256 _team) public view returns (uint256) {
        require(isActivated(_gameID), ""Game is not activated"");
        require(isValidTeam(_gameID, _team), ""Invalid team for this game"");

        // Retrieve the mask value associated with the team in the specified game
        uint256 maskValue = teams_[_gameID][_team];

        // Assuming playerTeams_ is indexed by (gameID, playerID, teamID) and holds some key representing participation
        uint256 participationKey = playerTeams_[_gameID][_pID][_team];

        // Calculate the winning amount
        uint256 result = maskValue * participationKey;
        result /= 1e18; // Convert to a more manageable unit by dividing by 10^18

        // Subtract the mask value associated with the player's participation in that team
        result -= maskValue;

        return result;
    }

    function isActivated(uint256 _gameID) public view returns (bool) {
        // Implement your logic to check if the game is activated
        return true; // Placeholder, replace with actual implementation
    }

    function isValidTeam(uint256 _gameID, uint256 _team) public view returns (bool) {
        // Implement your logic to validate team number for the specified game
        return true; // Placeholder, replace with actual implementation
    }
}"
1597,add more ether to use in oraclize queries,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/SafeMath.sol"";

abstract contract TopUpContract is Ownable {
    using SafeMath for uint256;

    function topUp() external payable {
        // Function implementation here
    }
}","[{'function': 'topUp', 'complexity': 0}]",1.0,{},"pragma solidity ^0.8.0;

contract TopUpContract {
    receive() external payable {}
}",40.96756887435913,,0.0,0.534870282726292,0.0,[],,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TopUpContract is Ownable {
    receive() external payable {}

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        uint256 private _someUint = 1;
        address private _someAddress = address(0x111);
        bool private _someBool = true;
        string memory _someString = 'initialized';
        bytes32 private _someBytes32 = keccak256(abi.encodePacked('init'));
    }
}"
3185,To check if an address is a contract or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractChecker is Ownable {
    using SafeMath for uint256;

    function isContract(address addr) public pure returns (bool _isContract) {
        require(addr != address(0));
        uint256 length;
        assembly {
            length := extcodesize(addr)
        }
        return (length > 0);
    }
}","[{'function': 'isContract', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_isContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract ContractChecker {
    function isContract(address addr) public view returns (bool _isContract) {
        require(addr != address(0), ""Invalid address"");
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",41.76912832260132,isContract,2.0,0.9332851544358692,0.6262487387458678,"[{'function': 'isContract', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ContractChecker is Ownable {
    function isContract(address addr) public view returns (bool _isContract) {
        require(addr != address(0), ""Invalid address"");
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
146,Add to the amount this member has bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function addAmountBoughtAsMember(address _member, uint256 _amountBought) external onlyOwner {
        // Add the logic to update the member's amount bought here.
        // For example:
        // members[_member] = members[_member].add(_amountBought);
    }
}","[{'function': 'addAmountBoughtAsMember', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addTokensBought"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_member"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amountBought"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_member""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid member address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amountBought""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount bought must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenBalances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_member""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amountBought""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenPurchase {
    mapping(address => uint256) public tokenBalances;

    function addTokensBought(address _member, uint256 _amountBought) external {
        require(_member != address(0), ""Invalid member address"");
        require(_amountBought > 0, ""Amount bought must be greater than zero"");

        tokenBalances[_member] += _amountBought;
    }
}",42.11360311508179,addTokensBought,29.0,0.5483063047627301,0.190823723949337,"[{'function': 'addTokensBought', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenPurchase is Ownable {
    mapping(address => uint256) public tokenBalances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            tokenBalances[addr] = 1;
        }
    }

    function addTokensBought(address _member, uint256 _amountBought) external {
        require(_member != address(0), ""Invalid member address"");
        require(_amountBought > 0, ""Amount bought must be greater than zero"");

        tokenBalances[_member] += _amountBought;
    }
}"
5173,` msg.sender ` approves ` spender ` to spend ` value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Success }
    State public state = State.Initial;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function getState() internal pure returns (State) {
        return State.Success;
    }

    function approve(address spender, uint256 value) external returns (bool ok) {
        require(getState() == State.Success, ""Contract not in success state"");
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}","[{'function': 'getState', 'complexity': 0}, {'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Cannot increase allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) private _allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address spender, uint256 value) public returns (bool) {
        require(_allowed[msg.sender][spender] == 0 || value == 0, ""Cannot increase allowance"");
        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}",42.88890790939331,approve,9.0,0.8216967464067038,0.5626817433992164,"[{'function': 'approve', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for an Ownable contract
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) private _allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables according to the rules provided
        _allowed[msg.sender][address(0x111)] = 1;
        _allowed[msg.sender][address(0x222)] = 1;
        _allowed[msg.sender][address(0x333)] = 1;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(_allowed[msg.sender][spender] == 0 || value == 0, ""Cannot increase allowance"");
        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}"
4527,Funtion to let users claim their tokens at the end of ico process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenReward {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaim is Ownable {
    using SafeMath for uint256;

    enum State { Pending, Successful, Failed }
    State public state = State.Pending;

    mapping(address => uint256) public pending;
    ITokenReward public tokenReward;

    event LogContributorsPayout(address indexed user, uint256 amount);

    function claimTokensByUser() public {
        require(state == State.Successful, ""State must be Successful"");
        uint256 temp = pending[msg.sender];
        pending[msg.sender] = 0;
        require(tokenReward.transfer(msg.sender, temp), ""Token transfer failed"");
        emit LogContributorsPayout(msg.sender, temp);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokensByUser', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokensByUser"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""state""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Successful""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Contract state is not successful""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountToClaim"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pending""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amountToClaim""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to claim""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pending""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenReward""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amountToClaim""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogContributorsPayout""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amountToClaim""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

contract TokenRewardSystem {
    IERC20 public tokenReward;
    mapping(address => uint256) public pending;
    string public state = ""Successful"";

    event LogContributorsPayout(address indexed contributor, uint256 amount);

    constructor(address _tokenAddress) {
        tokenReward = IERC20(_tokenAddress);
    }

    function claimTokensByUser() external {
        require(keccak256(bytes(state)) == keccak256(bytes(""Successful"")), ""Contract state is not successful"");
        uint256 amountToClaim = pending[msg.sender];
        require(amountToClaim > 0, ""No tokens to claim"");

        pending[msg.sender] = 0;
        tokenReward.transfer(msg.sender, amountToClaim);

        emit LogContributorsPayout(msg.sender, amountToClaim);
    }
}",43.81185293197632,claimTokensByUser,18.0,0.8094619841203063,0.2498375039765565,"[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokensByUser', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenRewardSystem is Ownable {
    IERC20 public tokenReward;
    mapping(address => uint256) public pending;
    string public state = ""Successful"";

    event LogContributorsPayout(address indexed contributor, uint256 amount);

    constructor(address _tokenAddress) Ownable(msg.sender) {
        tokenReward = IERC20(_tokenAddress);
    }

    function claimTokensByUser() external {
        require(keccak256(bytes(state)) == keccak256(bytes(""Successful"")), ""Contract state is not successful"");
        uint256 amountToClaim = pending[msg.sender];
        require(amountToClaim > 0, ""No tokens to claim"");

        pending[msg.sender] = 0;
        tokenReward.transfer(msg.sender, amountToClaim);

        emit LogContributorsPayout(msg.sender, amountToClaim);
    }
}"
5993,"Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(uint256 => address) private tokenOwnerMap;
    mapping(address => bool) public approvedContractAddresses;

    function ownerOf(uint256 _tokenId) public view returns (address) {
        return tokenOwnerMap[_tokenId];
    }

    function isSenderApprovedFor(uint256 _tokenId) public view returns (bool) {
        return approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin;
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_from == ownerOf(_tokenId), ""wrong owner"");
        require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin), ""not an approved sender"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);
    }

    function _clearApprovalAndTransfer(address from, address to, uint256 tokenId) internal {
        require(from != address(0));
        require(to != address(0));
        require(ownerOf(tokenId) == from);

        // Clear existing approval
        delete tokenOwnerMap[tokenId];

        // Transfer ownership
        tokenOwnerMap[tokenId] = to;
    }
}","[{'function': 'ownerOf', 'complexity': 0}, {'function': 'isSenderApprovedFor', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': '_clearApprovalAndTransfer', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""stringLiteral"", ""value"": ""Not the current owner""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedTransfers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedContractAddresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tx""}, ""memberName"": ""origin""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}}, {""type"": ""stringLiteral"", ""value"": ""Sender not approved to transfer""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_clearApprovalAndTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    mapping(uint256 => address) public tokenOwner;
    mapping(address => mapping(address => bool)) public approvedContractAddresses;
    mapping(uint256 => address) public approvedTransfers;

    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) external {
        require(_from == tokenOwner[_tokenId], ""Not the current owner"");

        if (msg.sender != _from) {
            require(approvedTransfers[_tokenId] == msg.sender || approvedContractAddresses[msg.sender] && tx.origin == tokenOwner[_tokenId], ""Sender not approved to transfer"");
        }

        _clearApprovalAndTransfer(_to, _tokenId);
    }

    function _clearApprovalAndTransfer(address _to, uint256 _tokenId) internal {
        if (approvedTransfers[_tokenId] != address(0)) {
            approvedTransfers[_tokenId] = address(0);
        }
        tokenOwner[_tokenId] = _to;
    }
}",45.183228492736816,transferFrom,24.0,0.7406978654487117,0.0383178090081421,"[{'function': 'transferFrom', 'complexity': 0}, {'function': '_clearApprovalAndTransfer', 'complexity': 1}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(uint256 => address) public tokenOwner;
    mapping(address => mapping(address => bool)) public approvedContractAddresses;
    mapping(uint256 => address) public approvedTransfers;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) external {
        require(_from == tokenOwner[_tokenId], ""Not the current owner"");

        if (msg.sender != _from) {
            require(approvedTransfers[_tokenId] == msg.sender || approvedContractAddresses[msg.sender] && tx.origin == tokenOwner[_tokenId], ""Sender not approved to transfer"");
        }

        _clearApprovalAndTransfer(_to, _tokenId);
    }

    function _clearApprovalAndTransfer(address _to, uint256 _tokenId) internal {
        if (approvedTransfers[_tokenId] != address(0)) {
            approvedTransfers[_tokenId] = address(0);
        }
        tokenOwner[_tokenId] = _to;
    }
}"
2061,Checks if the notary 's signature to close the ` DataResponse ` is valid .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NotaryVerifier is Ownable {
    using SafeMath for uint256;

    function isNotaryVeredictValid(address order, address seller, address notary, bool wasAudited, bool isDataValid, bytes memory notarySignature) public pure returns (bool) {
        require(order != address(0));
        require(seller != address(0));
        require(notary != address(0));
        bytes32 hash = keccak256(abi.encodePacked(order, seller, wasAudited, isDataValid));
        return isSignedBy(hash, notary, notarySignature);
    }

    function isSignedBy(bytes32 hash, address signer, bytes memory signature) internal pure returns (bool) {
        require(signer != address(0));
        return signer == ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)), 27 + uint8(signature[64]), signature[:64], signature[64]);
    }
}","[{'function': 'isNotaryVeredictValid', 'complexity': 3}, {'function': 'isSignedBy', 'complexity': 1}]",4.0,{},"pragma solidity ^0.8.0;

contract NotaryVerifier {
    // Function to validate the notary's verdict on an order
    function validateNotaryVerdict(
        address order,
        address seller,
        address notary,
        bool wasAudited,
        bool isDataValid,
        bytes memory notarySignature
    ) public pure returns (bool) {
        // Check if the addresses are not zero
        require(order != address(0), ""Order address must be non-zero"");
        require(seller != address(0), ""Seller address must be non-zero"");
        require(notary != address(0), ""Notary address must be non-zero"");

        // Ensure the order data is valid before hashing
        require(wasAudited, ""Order must have been audited"");
        require(isDataValid, ""Order data must be valid"");

        // Compute the hash of the order details
        bytes32 hash = keccak256(abi.encodePacked(order, seller));

        // Verify if the provided signature matches the computed hash for the given notary address
        return isSignedBy(notary, hash, notarySignature);
    }

    // Function to verify if a signature matches a given hash and address
    function isSignedBy(address signer, bytes32 hash, bytes memory signature) internal pure returns (bool) {
        require(signature.length == 65, ""Invalid signature length"");

        // ECDSA recovery id
        uint8 v = uint8(signature[0]);
        bytes32 r = bytes32(signature[1:33]);
        bytes32 s = bytes32(signature[33:65]);

        // Check if the signature is valid for the given hash and signer address
        return ecrecover(hash, v, r, s) == signer;
    }
}",46.3739960193634,validateNotaryVerdict,0.0,0.9351289191554604,0.4105199487500858,"[{'function': 'validateNotaryVerdict', 'complexity': 0}, {'function': 'isSignedBy', 'complexity': 1}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NotaryVerifier is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    // Function to validate the notary's verdict on an order
    function validateNotaryVerdict(
        address order,
        address seller,
        address notary,
        bool wasAudited,
        bool isDataValid,
        bytes memory notarySignature
    ) public pure returns (bool) {
        // Check if the addresses are not zero
        require(order != address(0), ""Order address must be non-zero"");
        require(seller != address(0), ""Seller address must be non-zero"");
        require(notary != address(0), ""Notary address must be non-zero"");

        // Ensure the order data is valid before hashing
        require(wasAudited, ""Order must have been audited"");
        require(isDataValid, ""Order data must be valid"");

        // Compute the hash of the order details
        bytes32 hash = keccak256(abi.encodePacked(order, seller));

        // Verify if the provided signature matches the computed hash for the given notary address
        return isSignedBy(notary, hash, notarySignature);
    }

    // Function to verify if a signature matches a given hash and address
    function isSignedBy(address signer, bytes32 hash, bytes memory signature) internal pure returns (bool) {
        require(signature.length == 65, ""Invalid signature length"");

        // ECDSA recovery id
        uint8 v = uint8(signature[0]);
        bytes32 r = bytes32(signature[1:33]);
        bytes32 s = bytes32(signature[33:65]);

        // Check if the signature is valid for the given hash and signer address
        return ecrecover(hash, v, r, s) == signer;
    }
}"
1609,Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeTokenFactory {
    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) external returns (MiniMeToken);
}

abstract contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    address public factory;
    string public name;
    uint8 public decimals;
    string public symbol;
    bool public transfersEnabled;
    uint256 public snapshotBlock;

    constructor(address _factory, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) {
        factory = _factory;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        transfersEnabled = _transfersEnabled;
        snapshotBlock = _snapshotBlock > block.number ? block.number : _snapshotBlock;
    }

    function changeController(address _newController) public onlyOwner {
        require(_newController != address(0), ""Invalid controller address"");
        // Controller logic here
    }
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    MiniMeTokenFactory public tokenFactory;

    event NewCloneToken(address indexed cloneTokenAddress, uint256 snapshotBlock);

    constructor(MiniMeTokenFactory _tokenFactory) {
        tokenFactory = _tokenFactory;
    }

    function createCloneToken(string memory _cloneTokenName, uint8 _cloneDecimalUnits, string memory _cloneTokenSymbol, uint256 _snapshotBlock, bool _transfersEnabled) public returns (address) {
        if (_snapshotBlock > block.number) {
            _snapshotBlock = block.number;
        }
        MiniMeToken cloneToken = tokenFactory.createCloneToken(address(this), _snapshotBlock, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled);
        cloneToken.changeController(msg.sender);
        emit NewCloneToken(address(cloneToken), _snapshotBlock);
        return address(cloneToken);
    }
}","[{'function': 'createCloneToken', 'complexity': 0}, {'function': 'changeController', 'complexity': 1}, {'function': 'createCloneToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_cloneTokenName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_cloneDecimalUnits"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_cloneTokenSymbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_snapshotBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}, {""type"": ""stringLiteral"", ""value"": ""Snapshot block must be less than or equal to the current block number""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeTokenFactory""}, ""name"": ""tokenFactory"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeTokenFactory""}}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""cloneTokenAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenFactory""}, ""memberName"": ""createClone""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_cloneTokenName""}, {""type"": ""Identifier"", ""name"": ""_cloneDecimalUnits""}, {""type"": ""Identifier"", ""name"": ""_cloneTokenSymbol""}, {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""MiniMeToken""}, ""name"": ""cloneToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MiniMeToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cloneTokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""cloneToken""}, ""memberName"": ""changeController""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NewCloneToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""cloneTokenAddress""}, {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""cloneTokenAddress""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/presets/MiniMeTokenFactory.sol"";

contract TokenClone {
    using SafeMath for uint256;

    function createCloneToken(
        string memory _cloneTokenName,
        uint8 _cloneDecimalUnits,
        string memory _cloneTokenSymbol,
        uint256 _snapshotBlock,
        bool _transfersEnabled
    ) external returns (address) {
        require(_snapshotBlock <= block.number, ""Snapshot block must be less than or equal to the current block number"");

        MiniMeTokenFactory tokenFactory = new MiniMeTokenFactory();
        address cloneTokenAddress = tokenFactory.createClone(
            this, // Parent token is this contract
            0,   // No controller set initially
            _cloneTokenName,
            _cloneDecimalUnits,
            _cloneTokenSymbol,
            _transfersEnabled
        );

        MiniMeToken cloneToken = MiniMeToken(cloneTokenAddress);
        cloneToken.changeController(msg.sender);

        emit NewCloneToken(cloneTokenAddress, _snapshotBlock);

        return cloneTokenAddress;
    }

    event NewCloneToken(address indexed cloneTokenAddress, uint256 snapshotBlock);
}",44.65478658676148,createCloneToken,24.0,0.8495261359141513,0.4278143481332616,"[{'function': 'createCloneToken', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/presets/MiniMeTokenFactory.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenClone is Ownable, MiniMeTokenFactory {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function createCloneToken(
        string memory _cloneTokenName,
        uint8 _cloneDecimalUnits,
        string memory _cloneTokenSymbol,
        uint256 _snapshotBlock,
        bool _transfersEnabled
    ) external returns (address) {
        require(_snapshotBlock <= block.number, ""Snapshot block must be less than or equal to the current block number"");

        MiniMeTokenFactory tokenFactory = new MiniMeTokenFactory();
        address cloneTokenAddress = tokenFactory.createClone(
            this, // Parent token is this contract
            0,   // No controller set initially
            _cloneTokenName,
            _cloneDecimalUnits,
            _cloneTokenSymbol,
            _transfersEnabled
        );

        MiniMeToken cloneToken = MiniMeToken(cloneTokenAddress);
        cloneToken.changeController(msg.sender);

        emit NewCloneToken(cloneTokenAddress, _snapshotBlock);

        return cloneTokenAddress;
    }

    event NewCloneToken(address indexed cloneTokenAddress, uint256 snapshotBlock);
}"
2752,"If you lock 50 % , the lockout time is six months .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _lockupBalances;
    mapping(address => uint256) private _lockupExpireTime;
    address public owner;
    uint256 public constant LOCKUP_TERM = 30 days; // Example lockup term, adjust as needed

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    function distribute(address _to, uint256 _value, uint256 _lockupRate) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_to != address(this));
        require(_lockupBalances[_to] == 0);
        require(_value <= _balances[owner]);
        require(_lockupRate == 50 || _lockupRate == 100);

        uint256 lockupValue = _value.mul(_lockupRate).div(100);
        uint256 givenValue = _value.sub(lockupValue);
        uint256 ExpireTime = now + LOCKUP_TERM;

        if (_lockupRate == 100) {
            ExpireTime += LOCKUP_TERM;
        }

        _balances[owner] = _balances[owner].sub(_value);
        _balances[_to] = _balances[_to].add(givenValue);
        _lockupBalances[_to] = _lockupBalances[_to].add(lockupValue);
        _lockupExpireTime[_to] = ExpireTime;

        emit Transfer(owner, _to, _value);

        return true;
    }
}","[{'function': 'distribute', 'complexity': 7}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_lockupRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""50"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Lockup rate must be either 50% or 100%""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to transfer""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lockupAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""isArray"": False}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""transferAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""Identifier"", ""name"": ""lockupAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""transferAmount""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_lockupRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockups""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""lockupAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lockups""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""lockupEndTime""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""365"", ""subdenomination"": ""days""}}}}]}, ""FalseBody"": None}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""transferAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenDistribution {
    address public owner;

    event Transfer(address indexed to, uint256 value);

    struct Lockup {
        uint256 amount;
        uint256 lockupEndTime;
    }

    mapping(address => uint256) balances;
    mapping(address => Lockup) lockups;

    constructor() {
        owner = msg.sender;
    }

    function transferTokens(address _to, uint256 _value, uint256 _lockupRate) public {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Transfer amount must be greater than zero"");
        require(_lockupRate == 50 || _lockupRate == 100, ""Lockup rate must be either 50% or 100%"");

        require(balances[owner] >= _value, ""Insufficient balance to transfer"");

        uint256 lockupAmount = (_lockupRate * _value) / 100;
        uint256 transferAmount = _value - lockupAmount;

        balances[owner] -= _value;
        balances[_to] += transferAmount;

        if (_lockupRate == 100) {
            lockups[_to].amount = lockupAmount;
            lockups[_to].lockupEndTime = block.timestamp + 365 days; // Assuming a year as the default lockup period
        }

        emit Transfer(_to, transferAmount);
    }
}",45.68663120269776,transferTokens,68.0,0.7312360265612474,0.3268625246852937,"[{'function': 'transferTokens', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenDistribution is Ownable {
    address public owner = msg.sender;

    event Transfer(address indexed to, uint256 value);

    struct Lockup {
        uint256 amount;
        uint256 lockupEndTime;
    }

    mapping(address => uint256) balances;
    mapping(address => Lockup) lockups;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        balances[owner] = 1; // Set to 1 (never 0)
    }

    function transferTokens(address _to, uint256 _value, uint256 _lockupRate) public {
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Transfer amount must be greater than zero"");
        require(_lockupRate == 50 || _lockupRate == 100, ""Lockup rate must be either 50% or 100%"");

        require(balances[owner] >= _value, ""Insufficient balance to transfer"");

        uint256 lockupAmount = (_lockupRate * _value) / 100;
        uint256 transferAmount = _value - lockupAmount;

        balances[owner] -= _value;
        balances[_to] += transferAmount;

        if (_lockupRate == 100) {
            lockups[_to].amount = lockupAmount;
            lockups[_to].lockupEndTime = block.timestamp + 365 days; // Assuming a year as the default lockup period
        }

        emit Transfer(_to, transferAmount);
    }
}"
6641,Make bulk transfer of tokens to many addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        // Implementation of the transfer function
    }

    function transferToMany(address[] memory _addrs, uint256[] memory _amounts) public returns (bool) {
        require(_addrs.length == _amounts.length);
        for (uint256 i = 0; i < _addrs.length; i++) {
            require(transfer(_addrs[i], _amounts[i]));
        }
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transferToMany', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferMultiple"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_addrs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""_amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Address and amount length mismatch""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""totalAmount"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""memberName"": ""balance""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalAmount""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}]}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TransferBatch""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_addrs""}, {""type"": ""Identifier"", ""name"": ""_amounts""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract MultiTransfer {
    // Event triggered when multiple transfers are completed successfully
    event TransferBatch(address[] _addrs, uint[] _amounts);

    // Function to transfer multiple amounts of Ether to a list of addresses
    function transferMultiple(address[] memory _addrs, uint[] memory _amounts) public payable returns (bool) {
        require(_addrs.length == _amounts.length, ""Address and amount length mismatch"");

        uint totalAmount;
        for (uint i = 0; i < _addrs.length; i++) {
            require(_addrs[i] != address(0), ""Invalid recipient address"");
            require(msg.sender.balance >= _amounts[i], ""Insufficient balance to transfer"");

            // Subtract the amount from the caller's balance
            totalAmount += _amounts[i];
        }

        for (uint i = 0; i < _addrs.length; i++) {
            payable(_addrs[i]).transfer(_amounts[i]);
        }

        // Emit the event after all transfers are completed successfully
        emit TransferBatch(_addrs, _amounts);

        return true;
    }
}",44.5494110584259,transferMultiple,54.0,0.6943150800669169,0.230291699719592,"[{'function': 'transferMultiple', 'complexity': 5}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiTransfer is Ownable {
    // Event triggered when multiple transfers are completed successfully
    event TransferBatch(address[] _addrs, uint[] _amounts);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    // Function to transfer multiple amounts of Ether to a list of addresses
    function transferMultiple(address[] memory _addrs, uint[] memory _amounts) public payable returns (bool) {
        require(_addrs.length == _amounts.length, ""Address and amount length mismatch"");

        uint totalAmount;
        for (uint i = 0; i < _addrs.length; i++) {
            require(_addrs[i] != address(0), ""Invalid recipient address"");
            require(msg.sender.balance >= _amounts[i], ""Insufficient balance to transfer"");

            // Subtract the amount from the caller's balance
            totalAmount += _amounts[i];
        }

        for (uint i = 0; i < _addrs.length; i++) {
            payable(_addrs[i]).transfer(_amounts[i]);
        }

        // Emit the event after all transfers are completed successfully
        emit TransferBatch(_addrs, _amounts);

        return true;
    }
}"
2380,The contract address is always the message sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721ReceiverWrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4) {
        require(_operator == address(this), ""Only this contract can receive ERC721 tokens"");
        require(_data.length > 0, ""Data must be non-empty"");
        require(_from != address(0), ""From address cannot be zero"");
        require(_tokenId > 0, ""Token ID must be greater than zero"");

        // Handle the ERC721 token transfer

        return IERC721Receiver(_operator).onERC721Received.selector;
    }
}","[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'onERC721Received', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""onERC721Received"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0x150b7a09"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract ERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) public pure returns (bytes4) {
        return 0x150b7a09;
    }
}",41.68682193756104,onERC721Received,37.0,0.4597005592959468,0.0438104524177525,"[{'function': 'onERC721Received', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ERC721Receiver is Ownable {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) public pure returns (bytes4) {
        return 0x150b7a09;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
4661,"Sends an ` _amount ` of ` baseToken ` to ` _to ` from this contract , and it can only be called by the contract itself","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

abstract contract WrappedTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public baseToken;

    constructor(IERC20 _baseToken) {
        baseToken = _baseToken;
    }

    function transfer(address _to, uint256 _amount) external onlyOwner {
        if (address(baseToken) != 0) {
            require(baseToken.transfer(_to, _amount));
        } else {
            require(_to.send(_amount));
        }
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",4.0,{},"pragma solidity ^0.8.0;

contract TokenTransfer {
    address public baseToken; // Assuming this is a state variable to check if tokens are being transferred

    function transferTokensOrEther(address _to, uint256 _amount) external {
        require(_to != address(0), ""Invalid recipient address"");

        if (baseToken != address(0)) {
            // Assuming baseToken has a transfer method that returns a boolean indicating success
            bool success = IERC20(baseToken).transfer(_to, _amount);
            require(success, ""Transfer of tokens failed"");
        } else {
            // Send Ether directly to the recipient
            (bool sent, ) = _to.call{value: _amount}("""");
            require(sent, ""Failed to send Ether"");
        }
    }
}

// Assuming IERC20 is a standard interface for ERC20 tokens
interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}",43.870983600616455,transferTokensOrEther,22.0,0.7965651912733142,0.1919663675173337,"[{'function': 'transferTokensOrEther', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    address public baseToken;
    uint256 public constant BASE_TOKEN_VALUE = 1; // Set to a fixed value (never 0)
    bool public initialized = true; // Set to true

    constructor() Ownable(msg.sender) {
        baseToken = address(0x1111111111111111111111111111111111111111); // Use a fixed address
        // Initialize other state variables as needed
    }

    function transferTokensOrEther(address _to, uint256 _amount) external {
        require(_to != address(0), ""Invalid recipient address"");

        if (baseToken != address(0)) {
            bool success = IERC20(baseToken).transfer(_to, _amount);
            require(success, ""Transfer of tokens failed"");
        } else {
            // Send Ether directly to the recipient
            (bool sent, ) = _to.call{value: _amount}("""");
            require(sent, ""Failed to send Ether"");
        }
    }
}

// Assuming IERC20 is a standard interface for ERC20 tokens
interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}"
3343,Allow pre-approved user to take ownership of a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) public onlyOwner {
        // Implementation of the takeOwnership function
    }
}","[{'function': 'takeOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_exists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""NFT does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""currentOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""currentOwner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Caller already owns this NFT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isApprovedOrOwner""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not approved to transfer this NFT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentOwner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract NFTMarketplace is Ownable {
    IERC721 public nftContract;

    event OwnershipTransferred(uint256 indexed tokenId, address indexed previousOwner, address indexed newOwner);

    constructor(address _nftAddress) {
        nftContract = IERC721(_nftAddress);
    }

    function takeOwnership(uint256 _tokenId) public {
        require(_exists(_tokenId), ""NFT does not exist"");
        address currentOwner = ownerOf(_tokenId);
        require(currentOwner != msg.sender, ""Caller already owns this NFT"");
        require(isApprovedOrOwner(msg.sender, _tokenId), ""Caller is not approved to transfer this NFT"");

        safeTransferFrom(currentOwner, msg.sender, _tokenId);
    }

    function ownerOf(uint256 tokenId) public view returns (address owner) {
        return nftContract.ownerOf(tokenId);
    }

    function isApprovedOrOwner(address user, uint256 tokenId) internal view returns (bool) {
        address spender = nftContract.getApproved(tokenId);
        if (spender == user || nftContract.isApprovedForAll(nftContract.ownerOf(tokenId), user)) {
            return true;
        }
        return false;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        require(to != address(0), ""Invalid target address"");
        nftContract.safeTransferFrom(from, to, tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return nftContract.ownerOf(tokenId) != address(0);
    }
}",47.17880940437317,takeOwnership,42.0,0.3426078857868314,0.0824949456648747,"[{'function': 'takeOwnership', 'complexity': 3}, {'function': 'ownerOf', 'complexity': 0}, {'function': 'isApprovedOrOwner', 'complexity': 2}, {'function': 'safeTransferFrom', 'complexity': 1}, {'function': '_exists', 'complexity': 0}]",5.0,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NFTMarketplace is Ownable {
    IERC721 public nftContract;

    event OwnershipTransferred(uint256 indexed tokenId, address indexed previousOwner, address indexed newOwner);

    constructor(address _nftAddress) Ownable(msg.sender) {
        nftContract = IERC721(_nftAddress);
    }

    function takeOwnership(uint256 _tokenId) public {
        require(_exists(_tokenId), ""NFT does not exist"");
        address currentOwner = ownerOf(_tokenId);
        require(currentOwner != msg.sender, ""Caller already owns this NFT"");
        require(isApprovedOrOwner(msg.sender, _tokenId), ""Caller is not approved to transfer this NFT"");

        safeTransferFrom(currentOwner, msg.sender, _tokenId);
    }

    function ownerOf(uint256 tokenId) public view returns (address owner) {
        return nftContract.ownerOf(tokenId);
    }

    function isApprovedOrOwner(address user, uint256 tokenId) internal view returns (bool) {
        address spender = nftContract.getApproved(tokenId);
        if (spender == user || nftContract.isApprovedForAll(nftContract.ownerOf(tokenId), user)) {
            return true;
        }
        return false;
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        require(to != address(0), ""Invalid target address"");
        nftContract.safeTransferFrom(from, to, tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return nftContract.ownerOf(tokenId) != address(0);
    }
}"
6562,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) external payable returns (bool) {
        return true;
    }
}","[{'function': 'proxyPayment', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""makeProxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner address""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentReceived""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract ProxyPayment {
    function makeProxyPayment(address _owner) external payable returns (bool success) {
        require(_owner != address(0), ""Invalid owner address"");
        // Additional checks can be added here, such as ensuring the caller has permission to act on behalf of _owner.
        // For example:
        // require(hasPermission(_owner, msg.sender), ""Caller does not have permission to make payment on behalf of this owner."");

        // Example logic for emitting an event (if needed):
        emit PaymentReceived(msg.sender, _owner, msg.value);

        return true;
    }

    // Example modifier or role checking can be added here if necessary.

    event PaymentReceived(address indexed from, address indexed to, uint256 amount);
}",43.04386830329895,makeProxyPayment,17.0,0.5899691952783646,0.0929483324855429,"[{'function': 'makeProxyPayment', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ProxyPayment is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function makeProxyPayment(address _owner) external payable returns (bool success) {
        require(_owner != address(0), ""Invalid owner address"");
        // Additional checks can be added here, such as ensuring the caller has permission to act on behalf of _owner.
        // For example:
        // require(hasPermission(_owner, msg.sender), ""Caller does not have permission to make payment on behalf of this owner."");

        // Example logic for emitting an event (if needed):
        emit PaymentReceived(msg.sender, _owner, msg.value);

        return true;
    }

    // Example modifier or role checking can be added here if necessary.

    event PaymentReceived(address indexed from, address indexed to, uint256 amount);
}"
52,Function to claim any token stuck on contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface token {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Successful }
    State public state = State.Initial;

    address public creator;

    constructor(address _creator) {
        creator = _creator;
    }

    function claimTokens(token _address) public {
        require(state == State.Successful);
        require(msg.sender == creator);
        uint256 remainder = _address.balanceOf(address(this));
        require(_address.transfer(creator, remainder), ""Transfer failed"");
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""successful""}, {""type"": ""stringLiteral"", ""value"": ""Contract is not in a successful state""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    bool public successful;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract creator can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function claimTokens(address token) external onlyOwner {
        require(successful, ""Contract is not in a successful state"");
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(owner, balance);
    }
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}",43.02613735198975,claimTokens,19.0,0.8530467644697538,0.2355725524994431,"[{'function': 'claimTokens', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool public successful = true; // Set to true instead of false, as it's not initialized in the original mapping(address => uint256) public balanceOf;

 constructor

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract creator can call this function"");
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are already initialized in the parent mapping(address => uint256) public balanceOf;

 constructor
    }

    function claimTokens(address token) external onlyOwner {
        require(successful, ""Contract is not in a successful state"");
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(owner(), balance);
    }
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}"
5414,Performs allowance transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _smbl, string memory _reference, address _sender) external returns (uint);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;

    constructor(address _chronoBankPlatform) {
        chronoBankPlatform = ChronoBankPlatform(_chronoBankPlatform);
    }

    function __transferFromWithReference(address _from, address _to, uint _value, string memory _reference, address _sender) public onlyOwner {
        require(chronoBankPlatform.proxyTransferFromWithReference(_from, _to, _value, bytes32(""smbl""), _reference, _sender) == 0, ""Transfer failed"");
    }
}","[{'function': 'proxyTransferFromWithReference', 'complexity': 0}, {'function': '__transferFromWithReference', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyTransferFromWithReference"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_reference"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""chronoBankPlatform""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""proxyTransferFromWithReference(address,address,uint256,string,address)""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_reference""}, {""type"": ""Identifier"", ""name"": ""_sender""}], ""names"": []}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Proxy transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAccess"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenProxy {
    address public chronoBankPlatform;
    uint256 public OK = 1; // Assuming 'OK' is a constant representing success in the 'proxyTransferFromWithReference' method.

    modifier onlyAccess() {
        require(msg.sender == owner, ""Only authorized addresses can call this function"");
        _;
    }

    constructor(address _chronoBankPlatform) {
        chronoBankPlatform = _chronoBankPlatform;
    }

    function proxyTransferFromWithReference(
        address _from,
        address _to,
        uint256 _value,
        string memory _reference,
        address _sender
    ) public onlyAccess returns (bool) {
        // Assuming the 'proxyTransferFromWithReference' method signature in the chronoBankPlatform contract is similar to this:
        require(chronoBankPlatform.call(abi.encodeWithSignature(""proxyTransferFromWithReference(address,address,uint256,string,address)"", _from, _to, _value, _reference, _sender)), ""Proxy transfer failed"");
        return true;
    }
}",44.07284331321716,proxyTransferFromWithReference,12.0,0.9025533467871762,0.3115768268340919,"[{'function': 'proxyTransferFromWithReference', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenProxy is Ownable {
    address public chronoBankPlatform;
    uint256 public OK = 1; // Assuming 'OK' is a constant representing success in the 'proxyTransferFromWithReference' method.

    modifier onlyAccess() {
        require(msg.sender == owner, ""Only authorized addresses can call this function"");
        _;
    }

    constructor(address _chronoBankPlatform) Ownable(msg.sender) {
        chronoBankPlatform = _chronoBankPlatform;
    }

    function proxyTransferFromWithReference(
        address _from,
        address _to,
        uint256 _value,
        string memory _reference,
        address _sender
    ) public onlyAccess returns (bool) {
        // Assuming the 'proxyTransferFromWithReference' method signature in the chronoBankPlatform contract is similar to this:
        require(chronoBankPlatform.call(abi.encodeWithSignature(""proxyTransferFromWithReference(address,address,uint256,string,address)"", _from, _to, _value, _reference, _sender)), ""Proxy transfer failed"");
        return true;
    }
}"
3148,Finalize the auction - sets the final XCH token price and changes the auction stage after no bids are allowed anymore .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function transfer(address to, uint256 value) external returns (bool);
    function burn(uint256 amount) external;
}

abstract contract AuctionContract is Ownable {
    using SafeMath for uint256;

    enum Stages { NotStarted, AuctionStarted, AuctionEnded, AuctionCanceled }

    TokenInterface public token;
    address public walletAddress;
    uint256 public minPrice;
    uint256 public numTokensAuctioned;
    uint256 public softCap;
    uint256 public receivedWei;
    uint256 public endTime;
    uint256 public finalPrice;
    uint256 public tokenMultiplier;
    Stages public stage;

    event AuctionEnded(uint256 indexed finalPrice);
    event AuctionCanceled();

    constructor(address _token, address _walletAddress, uint256 _minPrice, uint256 _numTokensAuctioned, uint256 _softCap, uint256 _tokenMultiplier) {
        token = TokenInterface(_token);
        walletAddress = _walletAddress;
        minPrice = _minPrice;
        numTokensAuctioned = _numTokensAuctioned;
        softCap = _softCap;
        tokenMultiplier = _tokenMultiplier;
        stage = Stages.NotStarted;
    }

    function price() public view returns (uint256) {
        // Implement the logic to return the current price if needed
        return 0; // Placeholder, replace with actual implementation
    }

    function missingFundsToEndAuction() public view returns (uint256) {
        uint256 requiredWei = softCap;
        uint256 collectedWei = receivedWei;
        if (collectedWei >= requiredWei) {
            return 0;
        } else {
            return requiredWei - collectedWei;
        }
    }

    function finalizeAuction() public atStage(Stages.AuctionStarted) {
        require(price() == minPrice);
        endTime = block.timestamp;
        if (receivedWei < softCap) {
            token.transfer(walletAddress, numTokensAuctioned);
            stage = Stages.AuctionCanceled;
            emit AuctionCanceled();
            return;
        }
        walletAddress.transfer(receivedWei);
        uint256 missingFunds = missingFundsToEndAuction();
        if (missingFunds > 0) {
            uint256 soldTokens = tokenMultiplier.mul(receivedWei).div(price());
            uint256 burnTokens = numTokensAuctioned.sub(soldTokens);
            token.burn(burnTokens);
            numTokensAuctioned -= burnTokens;
        }
        finalPrice = tokenMultiplier.mul(receivedWei).div(numTokensAuctioned);
        stage = Stages.AuctionEnded;
        emit AuctionEnded(finalPrice);
        assert(finalPrice > 0);
    }
}","[{'function': 'burn', 'complexity': 0}, {'function': 'price', 'complexity': 0}, {'function': 'missingFundsToEndAuction', 'complexity': 4}, {'function': 'finalizeAuction', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""endTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""softCap""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""walletAddress""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""AuctionCanceled""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionCanceled""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""walletAddress""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""missingFunds"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""softCap""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""missingFunds""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""soldTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}}], ""isArray"": False}, ""right"": {""type"": ""Identifier"", ""name"": ""softCap""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""burnTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}, ""right"": {""type"": ""Identifier"", ""name"": ""soldTokens""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalPrice""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""numTokensAuctioned""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""finalPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Final price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""stage""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stage""}, ""memberName"": ""AuctionEnded""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AuctionEnded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalPrice""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyDuringAuction"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Auction {
    enum Stage { AuctionStarted, AuctionEnded, AuctionCanceled }

    address public walletAddress;
    uint256 public softCap;
    uint256 public numTokensAuctioned;
    uint256 public endTime;
    Stage public stage;
    uint256 public finalPrice;

    event AuctionCanceled(uint256 amountReturned);
    event AuctionEnded(uint256 finalPrice);

    modifier onlyDuringAuction() {
        require(stage == Stage.AuctionStarted, ""Auction not started"");
        _;
    }

    constructor(address _walletAddress, uint256 _softCap, uint256 _numTokensAuctioned) {
        walletAddress = _walletAddress;
        softCap = _softCap;
        numTokensAuctioned = _numTokensAuctioned;
        stage = Stage.AuctionStarted;
    }

    function finalizeAuction() external onlyDuringAuction {
        endTime = block.timestamp;

        if (address(this).balance < softCap) {
            payable(walletAddress).transfer(numTokensAuctioned);
            stage = Stage.AuctionCanceled;
            emit AuctionCanceled(numTokensAuctioned);
        } else {
            payable(walletAddress).transfer(address(this).balance);

            uint256 missingFunds = address(this).balance - softCap;
            if (missingFunds > 0) {
                uint256 soldTokens = (address(this).balance * numTokensAuctioned) / softCap;
                uint256 burnTokens = numTokensAuctioned - soldTokens;
                // Assuming a function to burn tokens is available in the token contract
                // Example: tokenContract.burn(burnTokens);
                // Decrease numTokensAuctioned by burnTokens;
            }

            finalPrice = address(this).balance / numTokensAuctioned;
            require(finalPrice > 0, ""Final price must be greater than zero"");
            stage = Stage.AuctionEnded;
            emit AuctionEnded(finalPrice);
        }
    }
}",47.49993014335632,finalizeAuction,37.0,0.8972737740547083,0.2976999445477562,"[{'function': 'finalizeAuction', 'complexity': 4}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
// Assuming a token contract with burn function is available
// import ""YourTokenContract"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    enum Stage { AuctionStarted, AuctionEnded, AuctionCanceled }

    address public walletAddress;
    uint256 public softCap;
    uint256 public numTokensAuctioned;
    uint256 public endTime;
    Stage public stage;
    uint256 public finalPrice;

    event AuctionCanceled(uint256 amountReturned);
    event AuctionEnded(uint256 finalPrice);

    modifier onlyDuringAuction() {
        require(stage == Stage.AuctionStarted, ""Auction not started"");
        _;
    }

    constructor(address _walletAddress, uint256 _softCap, uint256 _numTokensAuctioned) Ownable(msg.sender) {
        walletAddress = _walletAddress;
        softCap = _softCap;
        numTokensAuctioned = _numTokensAuctioned;
        stage = Stage.AuctionStarted;
    }

    function finalizeAuction() external onlyDuringAuction {
        endTime = block.timestamp;

        if (address(this).balance < softCap) {
            payable(walletAddress).transfer(numTokensAuctioned);
            stage = Stage.AuctionCanceled;
            emit AuctionCanceled(numTokensAuctioned);
        } else {
            payable(walletAddress).transfer(address(this).balance);

            uint256 missingFunds = address(this).balance - softCap;
            if (missingFunds > 0) {
                uint256 soldTokens = (address(this).balance * numTokensAuctioned) / softCap;
                uint256 burnTokens = numTokensAuctioned - soldTokens;
                // Assuming a function to burn tokens is available in the token contract
                // Example: tokenContract.burn(burnTokens);
                // Decrease numTokensAuctioned by burnTokens;
            }

            finalPrice = address(this).balance / numTokensAuctioned;
            require(finalPrice > 0, ""Final price must be greater than zero"");
            stage = Stage.AuctionEnded;
            emit AuctionEnded(finalPrice);
        }
    }
}"
1735,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint earliestPayTime;
        uint securityGuardDelay;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}","[{'function': 'delayPayment', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_delay"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid payment ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""payment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""paid""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Payment has already been paid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""canceled""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Payment has been canceled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}, ""right"": {""type"": ""Identifier"", ""name"": ""maxSecurityGuardDelay""}}, {""type"": ""stringLiteral"", ""value"": ""Delay exceeds maximum allowed delay""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""securityGuardDelay""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""earliestPayTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delay""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract SecurityGuardContract {
    struct Payment {
        bool paid;
        bool canceled;
        uint256 securityGuardDelay;
        uint256 earliestPayTime;
    }

    Payment[] public authorizedPayments;
    uint256 public maxSecurityGuardDelay;

    constructor(uint256 _maxSecurityGuardDelay) {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }

    function pose(uint256 _idPayment, uint256 _delay) external {
        require(_idPayment < authorizedPayments.length, ""Invalid payment ID"");

        Payment storage payment = authorizedPayments[_idPayment];

        require(!payment.paid, ""Payment has already been paid"");
        require(!payment.canceled, ""Payment has been canceled"");
        require(payment.securityGuardDelay + _delay <= maxSecurityGuardDelay, ""Delay exceeds maximum allowed delay"");

        payment.securityGuardDelay += _delay;
        payment.earliestPayTime += _delay;
    }
}",44.35790753364563,pose,33.0,0.7537170209496109,0.0710254992628131,"[{'function': 'pose', 'complexity': 6}]",5.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SecurityGuardContract is Ownable {
    struct Payment {
        bool paid;
        bool canceled;
        uint256 securityGuardDelay;
        uint256 earliestPayTime;
    }

    Payment[] public authorizedPayments;
    uint256 public maxSecurityGuardDelay;

    constructor(uint256 _maxSecurityGuardDelay) Ownable() {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }

    function pose(uint256 _idPayment, uint256 _delay) external {
        require(_idPayment < authorizedPayments.length, ""Invalid payment ID"");

        Payment storage payment = authorizedPayments[_idPayment];

        require(!payment.paid, ""Payment has already been paid"");
        require(!payment.canceled, ""Payment has been canceled"");
        require(payment.securityGuardDelay + _delay <= maxSecurityGuardDelay, ""Delay exceeds maximum allowed delay"");

        payment.securityGuardDelay += _delay;
        payment.earliestPayTime += _delay;
    }
}"
170,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent, ""Time must be later than last update"");
        require(timeSent < (block.timestamp + ORACLE_FUTURE_LIMIT), ""Time must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}","[{'function': 'updatePrices', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newEthPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newHavvenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""ORACLE_FUTURE_LIMIT""}}}}, {""type"": ""stringLiteral"", ""value"": ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newEthPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newHavvenPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PricesUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOracle"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PriceUpdater {
    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    address public oracle;

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint timeSent);

    modifier onlyOracle() {
        require(msg.sender == oracle, ""Only the oracle can call this function"");
        _;
    }

    constructor(address _oracle) {
        oracle = _oracle;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < block.timestamp + ORACLE_FUTURE_LIMIT,
            ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");

        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;

        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}",45.01621842384338,updatePrices,10.0,0.9092341010502156,0.7307449583202811,"[{'function': 'updatePrices', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceUpdater is Ownable {
    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    address public oracle;

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint timeSent);

    modifier onlyOracle() {
        require(msg.sender == oracle, ""Only the oracle can call this function"");
        _;
    }

    constructor(address _oracle) Ownable(msg.sender) {
        oracle = _oracle;
        usdToEthPrice = 1; // Set to 1
        usdToHavPrice = 1; // Set to 1
        lastPriceUpdateTime = block.timestamp; // Initialize with current timestamp
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < block.timestamp + ORACLE_FUTURE_LIMIT,
            ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");

        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;

        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}"
5043,This function burns all B2BK tokens on the address that caused this function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed user, uint256 amount);

    function burn() external isFinalized {
        uint256 _balance = balanceOf[msg.sender];
        assert(_balance > 0);
        totalSupply = totalSupply.sub(_balance);
        balanceOf[msg.sender] = 0;
        emit Burn(msg.sender, _balance);
    }
}","[{'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Burner has no tokens to burn""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_balance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed burner, uint256 amount);

    function burn() public {
        uint256 _balance = balanceOf[msg.sender];
        require(_balance > 0, ""Burner has no tokens to burn"");

        totalSupply -= _balance;
        balanceOf[msg.sender] = 0;

        emit Burn(msg.sender, _balance);
    }
}",42.76958227157593,burn,5.0,0.9050829923947176,0.5256386897562152,"[{'function': 'burn', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""Ownable/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply = 1000000000000000000; // Set to 1 (never 0)

    event Burn(address indexed burner, uint256 amount);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = totalSupply; // Set the owner's balance to totalSupply (1)
    }

    function burn() public {
        uint256 _balance = balanceOf[msg.sender];
        require(_balance > 0, ""Burner has no tokens to burn"");

        totalSupply -= _balance;
        balanceOf[msg.sender] = 0;

        emit Burn(msg.sender, _balance);
    }
}"
3040,This function returns the signature of configure function,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getInitFunction() public pure returns (bytes4) {
        return 0x0;
    }
}","[{'function': 'getInitFunction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getInitFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""init()""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract MyContract {
    function getInitFunction() public pure returns (bytes4) {
        return bytes4(keccak256(""init()""));
    }
}",41.45714974403381,getInitFunction,5.0,0.7882009414442889,0.473968384351404,"[{'function': 'getInitFunction', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';
    uint256 public constant DEFAULT_UINT256 = 1;

    constructor() {
        _initialize();
    }

    function getInitFunction() public pure returns (bytes4) {
        return bytes4(keccak256(""init()""));
    }

    function _initialize() internal {
        // Initialize state variables
        address[0] = DEFAULT_ADDRESS;
        bool[0] = DEFAULT_BOOL;
        bytes32[0] = DEFAULT_BYTES32;
        string[0] = DEFAULT_STRING;
        uint256[0] = DEFAULT_UINT256;

        // Call parent contract constructors
        constructor() Ownable(DEFAULT_ADDRESS);
    }
}"
4025,Converts WT0 to CarbonUSD for the user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ConversionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;
    bool public paused = false;

    event ConvertedToCUSD(address indexed user, uint256 amount);

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _burn(address account, uint256 amount) internal {
        require(balances[account] >= amount, ""Burn amount exceeds balance"");
        balances[account] = balances[account].sub(amount);
    }

    function _mintCUSD(address account, uint256 amount) internal {
        balances[account] = balances[account].add(amount);
    }

    function convertWT(uint256 _amount) public whenNotPaused requiresPermission {
        require(balanceOf(msg.sender) >= _amount, ""Conversion amount should be less than balance"");
        _burn(msg.sender, _amount);
        _mintCUSD(msg.sender, _amount);
        emit ConvertedToCUSD(msg.sender, _amount);
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': '_burn', 'complexity': 1}, {'function': '_mintCUSD', 'complexity': 0}, {'function': 'convertWT', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""convertWT"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""MINTER_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller does not have sufficient permissions""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance of WT tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ConvertedToCUSD""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

contract MyToken is ERC20, AccessControl, Pausable {
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    event ConvertedToCUSD(address indexed user, uint256 amount);

    constructor() ERC20(""MyToken"", ""MTK"") {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
    }

    function convertWT(uint256 _amount) public whenNotPaused {
        require(hasRole(MINTER_ROLE, msg.sender), ""Caller does not have sufficient permissions"");
        require(_amount <= balanceOf(msg.sender), ""Insufficient balance of WT tokens"");

        _burn(msg.sender, _amount);
        _mint(msg.sender, _amount); // Assuming _mintCUSD is a placeholder for the actual mint function for CUSD tokens

        emit ConvertedToCUSD(msg.sender, _amount);
    }
}",44.83553457260132,convertWT,12.0,0.8776351177372363,0.3842200900331626,"[{'function': 'convertWT', 'complexity': 2}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is ERC20, AccessControl, Pausable, Ownable {
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    event ConvertedToCUSD(address indexed user, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor() ERC20(""MyToken"", ""MTK"") {
        __Ownable_init();
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
    }

    function convertWT(uint256 _amount) public whenNotPaused {
        require(hasRole(MINTER_ROLE, msg.sender), ""Caller does not have sufficient permissions"");
        require(_amount <= balanceOf(msg.sender), ""Insufficient balance of WT tokens"");

        _burn(msg.sender, _amount);
        _mint(msg.sender, _amount); // Assuming _mintCUSD is a placeholder for the actual mint function for CUSD tokens

        emit ConvertedToCUSD(msg.sender, _amount);
    }
}"
281,Announces intent to cancel tokens using ` slowCancel `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Offer {
        address maker;
        uint256 availableAmount;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint256) public announcedCancellations;
    uint256 public cancelAnnounceDelay;

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint256 canCancelAt);

    function announceCancel(bytes32 _offerHash) external {
        Offer memory offer = offers[_offerHash];
        require(offer.maker == msg.sender, ""Invalid sender"");
        require(offer.availableAmount > 0, ""Offer already cancelled"");
        uint256 canCancelAt = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = canCancelAt;
        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);
    }
}","[{'function': 'announceCancel', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_offerHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Offer""}, ""name"": ""offer"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_offerHash""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""availableAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Offer already cancelled""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""cancellationTimestamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""cancelAnnounceDelay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""announcedCancellations""}, ""index"": {""type"": ""Identifier"", ""name"": ""_offerHash""}}, ""right"": {""type"": ""Identifier"", ""name"": ""cancellationTimestamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CancelAnnounce""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""cancellationTimestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract OfferManager {
    struct Offer {
        address maker;
        uint availableAmount;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint) public announcedCancellations;
    uint public cancelAnnounceDelay;

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint timestamp);

    modifier onlyMaker(bytes32 _offerHash) {
        require(offers[_offerHash].maker == msg.sender, ""Invalid sender"");
        _;
    }

    function announceCancel(bytes32 _offerHash) public {
        Offer storage offer = offers[_offerHash];
        require(offer.availableAmount > 0, ""Offer already cancelled"");

        uint cancellationTimestamp = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = cancellationTimestamp;

        emit CancelAnnounce(msg.sender, _offerHash, cancellationTimestamp);
    }
}",44.7777783870697,announceCancel,9.0,0.8302457941912418,0.4811787239978132,"[{'function': 'announceCancel', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OfferManager is Ownable {
    struct Offer {
        address maker;
        uint availableAmount;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint) public announcedCancellations;
    uint public cancelAnnounceDelay;

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint timestamp);

    modifier onlyMaker(bytes32 _offerHash) {
        require(offers[_offerHash].maker == msg.sender, ""Invalid sender"");
        _;
    }

    constructor() Ownable(msg.sender) {
        offers = {};
        announcedCancellations = {};
        cancelAnnounceDelay = 1 days; // Set to a fixed value of 1 day
    }

    function announceCancel(bytes32 _offerHash) public {
        Offer storage offer = offers[_offerHash];
        require(offer.availableAmount > 0, ""Offer already cancelled"");

        uint cancellationTimestamp = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = cancellationTimestamp;

        emit CancelAnnounce(msg.sender, _offerHash, cancellationTimestamp);
    }
}"
5915,This is public rather than external so we can call super.unpause without using an expensive CALL .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool private paused = false;

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0));
        require(siringAuction != address(0));
        require(geneScience != address(0));
        require(lottery != address(0));
        require(variation != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}","[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""saleAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Sale auction must be set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""siringAuction""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Siring auction must be set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""geneScience""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Gene science must be set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""lottery""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Lottery must be set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""variation""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Variation must be set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""newContractAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New contract address should not be set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""unpause""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyCEO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

abstract contract Pausable {
    bool private paused = true;
    address private ceoAddress;

    event Unpause();

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    modifier onlyCEO() {
        require(msg.sender == ceoAddress, ""Only CEO can call this function"");
        _;
    }

    function pause() public virtual {
        paused = true;
    }

    function unpause() public virtual whenPaused onlyCEO {
        paused = false;
        emit Unpause();
    }
}

contract MyContract is Pausable {
    address public saleAuction;
    address public siringAuction;
    address public geneScience;
    address public lottery;
    address public variation;
    address public newContractAddress;

    constructor(address _ceo) {
        ceoAddress = _ceo;
    }

    function unpause() public override whenPaused onlyCEO {
        require(saleAuction != address(0), ""Sale auction must be set"");
        require(siringAuction != address(0), ""Siring auction must be set"");
        require(geneScience != address(0), ""Gene science must be set"");
        require(lottery != address(0), ""Lottery must be set"");
        require(variation != address(0), ""Variation must be set"");
        require(newContractAddress == address(0), ""New contract address should not be set"");

        super.unpause();
    }
}",45.40493893623352,unpause,6.0,0.9693530473521076,0.5412205897526057,"[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'unpause', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Pausable is Ownable {
    bool private paused = true;
    address private ceoAddress;

    event Unpause();

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    modifier onlyCEO() {
        require(msg.sender == ceoAddress, ""Only CEO can call this function"");
        _;
    }

    function pause() public virtual {
        paused = true;
    }

    function unpause() public virtual whenPaused onlyCEO {
        paused = false;
        emit Unpause();
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Pausable {
    address public saleAuction;
    address public siringAuction;
    address public geneScience;
    address public lottery;
    address public variation;
    address public newContractAddress;

    constructor(address _ceo) Ownable(_ceo) {
        ceoAddress = _ceo;
        saleAuction = address(0x111);
        siringAuction = address(0x222);
        geneScience = address(0x333);
        lottery = address(0x444);
        variation = address(0x555);
    }

    function unpause() public override whenPaused onlyCEO {
        require(saleAuction != address(0), ""Sale auction must be set"");
        require(siringAuction != address(0), ""Siring auction must be set"");
        require(geneScience != address(0), ""Gene science must be set"");
        require(lottery != address(0), ""Lottery must be set"");
        require(variation != address(0), ""Variation must be set"");
        require(newContractAddress == address(0), ""New contract address should not be set"");

        super.unpause();
    }
}"
1091,"owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IContract {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    event EtherSent(address indexed to, uint256 value);

    struct State {
        bool succeeded;
    }

    mapping(bytes32 => bool) private manyOwners;
    mapping(address => State) public states;

    modifier validAddress(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bool allowed = manyOwners[txHash];
        require(allowed, ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State memory state) {
        require(state.succeeded, ""Function cannot be called in current state"");
        _;
    }

    function sendEther(address to, uint256 value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(states[msg.sender]) {
        require(value > 0 && address(this).balance >= value, ""Insufficient balance"");
        (bool success,) = to.call{value: value}("""");
        require(success, ""Transfer failed"");
        emit EtherSent(to, value);
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sendEther', 'complexity': 4}]",4.0,{},"pragma solidity ^0.8.0;

contract MyContract {
    event EtherSent(address indexed _to, uint _value);

    modifier validAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    function sendEther(address payable to, uint value) public validAddress(to) {
        require(value > 0, ""Value must be greater than zero"");
        require(address(this).balance >= value, ""Contract does not have sufficient balance"");

        (bool success, ) = to.call{value: value}("""");
        require(success, ""Transfer failed"");

        emit EtherSent(to, value);
    }
}",43.01512050628662,sendEther,0.0,0.8351529064420528,0.6632542085796613,"[{'function': 'sendEther', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    event EtherSent(address indexed _to, uint _value);

    modifier validAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    function sendEther(address payable to, uint value) public validAddress(to) {
        require(value > 0, ""Value must be greater than zero"");
        require(address(this).balance >= value, ""Contract does not have sufficient balance"");

        (bool success, ) = to.call{value: value}("""");
        require(success, ""Transfer failed"");

        emit EtherSent(to, value);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
2215,Notifies the controller about an approval allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovalWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_amount.add(1).sub(1) == _amount, ""SafeMath: addition overflow"");
        require(_owner != address(0), ""_owner is zero address"");
        require(_spender != address(0), ""_spender is zero address"");

        emit Approval(_owner, _spender, _amount);

        return true;
    }
}","[{'function': 'onApprove', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenApproval {
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    function approve(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_owner != address(0), ""Invalid owner address"");
        require(_spender != address(0), ""Invalid spender address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        // Assuming there is a mapping to track allowances
        // allowance[_owner][_spender] = _amount;

        emit Approval(_owner, _spender, _amount);
        return true;
    }
}",43.15855312347412,approve,9.0,0.8622653030528318,0.5884845080756766,"[{'function': 'approve', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    mapping(address => mapping(address => uint256)) public allowance;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_owner != address(0), ""Invalid owner address"");
        require(_spender != address(0), ""Invalid spender address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        allowance[_owner][_spender] = _amount;

        emit Approval(_owner, _spender, _amount);
        return true;
    }
}"
5767,Withdraws tokens other than DGZ to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function anyTokenWithdrawal(address _address, uint _amount) public onlyOwner {
        require(_address != address(tokenReward), ""Cannot withdraw from the reward token."");
        StandardToken token = StandardToken(_address);
        token.transfer(beneficiary, _amount);
        TokensWithdrawn(beneficiary, _address, _amount);
    }
}","[{'function': 'anyTokenWithdrawal', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""anyTokenWithdrawal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot withdraw from the same contract""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""StandardToken""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""StandardToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensWithdraw""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface StandardToken {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenReward {
    address public tokenAddress;

    constructor(address _tokenAddress) {
        tokenAddress = _tokenAddress;
    }

    event TokensWithdraw(address indexed beneficiary, address indexed tokenAddress, uint256 amount);

    function anyTokenWithdrawal(address _address, uint256 _amount) external {
        require(_address != address(this), ""Cannot withdraw from the same contract"");

        StandardToken token = StandardToken(_address);
        bool success = token.transfer(msg.sender, _amount);
        require(success, ""Transfer failed"");

        emit TokensWithdraw(msg.sender, _address, _amount);
    }
}",43.540701150894165,anyTokenWithdrawal,12.0,0.8159928811901332,0.497814496553105,"[{'function': 'transfer', 'complexity': 0}, {'function': 'anyTokenWithdrawal', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

interface StandardToken {
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenReward is Ownable {
    address public tokenAddress;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        tokenAddress = _tokenAddress;
    }

    event TokensWithdraw(address indexed beneficiary, address indexed tokenAddress, uint256 amount);

    function anyTokenWithdrawal(address _address, uint256 _amount) external {
        require(_address != address(this), ""Cannot withdraw from the same contract"");

        StandardToken token = StandardToken(_address);
        bool success = token.transfer(msg.sender, _amount);
        require(success, ""Transfer failed"");

        emit TokensWithdraw(msg.sender, _address, _amount);
    }
}"
3863,Claim token after token sale based on stake .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EthealTokenWrapper {
    using SafeMath for uint256;

    address public ethealController;
    mapping(address => uint256) public stakes;
    uint256 public rate;
    uint256 public tokenBalance;
    bool public paused = false;

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokens);

    modifier afterSaleSuccess() {
        // Assuming some condition for sale success is checked here.
        require(true, ""Sale must have succeeded"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {
        uint256 stake = stakes[_beneficiary];
        require(stake > 0);
        stakes[_beneficiary] = 0;
        uint256 tokens = stake.mul(rate);
        tokenBalance = tokenBalance.sub(tokens);
        ethealController.call(abi.encodeWithSignature(""addHodlerStake(address,uint256)"", _beneficiary, tokens.mul(2)));
        require(ethealController.call(abi.encodeWithSignature(""ethealToken()"")).delegatecall(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _beneficiary, tokens)));
        emit TokenClaimed(msg.sender, _beneficiary, stake, tokens);
    }
}","[{'function': 'claimTokenFor', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokenFor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary must have a stake greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""Identifier"", ""name"": ""rate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ethealToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""tokenAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ethealController""}, ""memberName"": ""updateStake""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenClaimed""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, {""type"": ""Identifier"", ""name"": ""tokenAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""afterSaleSuccess"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

interface IEthealController {
    function updateStake(address beneficiary, uint256 amount) external;
}

contract EthealTokenClaim is Ownable, Pausable {
    IERC20 private ethealToken;
    IEthealController private ethealController;
    mapping(address => uint256) public stakes;
    uint256 public rate = 10; // Example rate for token conversion

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokens);

    modifier afterSaleSuccess() {
        require(saleSuccessful(), ""Sale must be successful to claim tokens"");
        _;
    }

    constructor(address _ethealToken, address _ethealController) {
        ethealToken = IERC20(_ethealToken);
        ethealController = IEthealController(_ethealController);
    }

    function claimTokenFor(address _beneficiary) public whenNotPaused afterSaleSuccess {
        require(stakes[_beneficiary] > 0, ""Beneficiary must have a stake greater than zero"");

        uint256 tokenAmount = stakes[_beneficiary] * rate;

        // Transfer tokens to the beneficiary
        ethealToken.transfer(_beneficiary, tokenAmount);

        // Update the ethealController with the new stake value
        ethealController.updateStake(_beneficiary, stakes[_beneficiary]);

        // Reset the stake to zero
        stakes[_beneficiary] = 0;

        emit TokenClaimed(msg.sender, _beneficiary, stakes[_beneficiary], tokenAmount);
    }

    function setRate(uint256 _rate) public onlyOwner {
        rate = _rate;
    }

    function setEthealToken(address _ethealToken) public onlyOwner {
        ethealToken = IERC20(_ethealToken);
    }

    function setEthealController(address _ethealController) public onlyOwner {
        ethealController = IEthealController(_ethealController);
    }

    function saleSuccessful() internal view returns (bool) {
        // Implement your logic to check if the sale is successful
        return true; // Placeholder, replace with actual logic
    }
}",48.36160373687744,claimTokenFor,49.0,0.6700855606879965,0.1590856386902667,"[{'function': 'updateStake', 'complexity': 0}, {'function': 'claimTokenFor', 'complexity': 1}, {'function': 'setRate', 'complexity': 0}, {'function': 'setEthealToken', 'complexity': 0}, {'function': 'setEthealController', 'complexity': 0}, {'function': 'saleSuccessful', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/security/Pausable.sol"";

interface IEthealController {
    function updateStake(address beneficiary, uint256 amount) external;
}
import ""openzeppelin/SafeMath.sol"";
contract EthealTokenClaim is Ownable, Pausable {
    IERC20 private ethealToken;
    IEthealController private ethealController;
    mapping(address => uint256) public stakes;
    uint256 public rate = 10; // Example rate for token conversion

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokens);

    modifier afterSaleSuccess() {
        require(saleSuccessful(), ""Sale must be successful to claim tokens"");
        _;
    }

    constructor(address _ethealToken, address _ethealController) Ownable(msg.sender) {
        ethealToken = IERC20(_ethealToken);
        ethealController = IEthealController(_ethealController);
        stakes[_etheralController] = 1; // Initialize to a safe non-zero value
    }

    function claimTokenFor(address _beneficiary) public whenNotPaused afterSaleSuccess {
        require(stakes[_beneficiary] > 0, ""Beneficiary must have a stake greater than zero"");

        uint256 tokenAmount = stakes[_beneficiary] * rate;

        // Transfer tokens to the beneficiary
        ethealToken.transfer(_beneficiary, tokenAmount);

        // Update the ethealController with the new stake value
        ethealController.updateStake(_beneficiary, stakes[_beneficiary]);

        // Reset the stake to zero
        stakes[_beneficiary] = 0;

        emit TokenClaimed(msg.sender, _beneficiary, stakes[_beneficiary], tokenAmount);
    }

    function setRate(uint256 _rate) public onlyOwner {
        rate = _rate;
    }

    function setEthealToken(address _ethealToken) public onlyOwner {
        ethealToken = IERC20(_ethealToken);
    }

    function setEthealController(address _ethealController) public onlyOwner {
        ethealController = IEthealController(_ethealController);
    }

    function saleSuccessful() internal view returns (bool) {
        // Implement your logic to check if the sale is successful
        return true; // Placeholder, replace with actual logic
    }
}"
6728,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event ForceTransfer(address indexed sender, address indexed from, address indexed to, uint256 value, bool verified, bytes log);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) public onlyController {
        require(_to != address(0));
        require(_value <= balances[_from]);
        bool verified = _updateTransfer(_from, _to, _value, _data);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit ForceTransfer(msg.sender, _from, _to, _value, verified, _log);
        emit Transfer(_from, _to, _value);
    }

    function _updateTransfer(address _from, address _to, uint256 _value, bytes memory _data) internal returns (bool) {
        // Implement the logic for updating transfer here
        return true; // Placeholder
    }
}","[{'function': 'forceTransfer', 'complexity': 2}, {'function': '_updateTransfer', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""forceTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ForceTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    event ForceTransfer(address indexed from, address indexed to, uint256 value, bytes data, bool log);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data) public {
        require(_to != address(0), ""Invalid recipient address"");
        require(balances[_from] >= _value, ""Insufficient balance"");

        balances[_from] -= _value;
        balances[_to] += _value;

        emit Transfer(_from, _to, _value);
        emit ForceTransfer(_from, _to, _value, _data, true);
    }
}",43.21899724006653,forceTransfer,32.0,0.7606946628090954,0.4764619752911081,"[{'function': 'forceTransfer', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    event ForceTransfer(address indexed from, address indexed to, uint256 value, bytes data, bool log);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe non-corner-case values
        balances[owner()] = 1; // Set balance for the owner to 1
    }

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data) public {
        require(_to != address(0), ""Invalid recipient address"");
        require(balances[_from] >= _value, ""Insufficient balance"");

        balances[_from] -= _value;
        balances[_to] += _value;

        emit Transfer(_from, _to, _value);
        emit ForceTransfer(_from, _to, _value, _data, true);
    }
}"
691,Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Validator {
    using SafeMath for uint256;

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        require(validator != address(0), ""Invalid validator address"");
        require(attributeTypeID > 0, ""Invalid attribute type ID"");
        return true;
    }
}","[{'function': 'canIssueAttributeType', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""canIssueAttributeType"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validatorsByAttributeType""}, ""index"": {""type"": ""Identifier"", ""name"": ""validator""}}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AttributeIssuer {
    mapping(address => mapping(uint256 => bool)) public validatorsByAttributeType;

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        return validatorsByAttributeType[validator][attributeTypeID];
    }
}",41.94264531135559,canIssueAttributeType,15.0,0.6944510284352059,0.2169763121601481,"[{'function': 'canIssueAttributeType', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttributeIssuer is Ownable {
    mapping(address => mapping(uint256 => bool)) public validatorsByAttributeType;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            validatorsByAttributeType[addr][i] = true;
        }
    }

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        return validatorsByAttributeType[validator][attributeTypeID];
    }
}"
876,Initialize Finance app for Vault at ` _vault ` with period length of ` @ transformTime ( _periodDuration ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface Vault {
    function isContract() external view returns (bool);
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool inactive;
    }

    Vault public vault;
    Settings public settings;
    mapping(uint => Payment) public payments;
    uint public paymentsNextIndex;
    uint public transactionsNextIndex;

    event Initialized();

    error VaultNotContract(string message);
    error InitPeriodTooShort(string message);

    constructor() {
        settings.periodDuration = 0;
    }

    function initialize(Vault _vault, uint64 _periodDuration) external onlyOwner {
        require(_vault.isContract(), ""ERROR_VAULT_NOT_CONTRACT"");
        vault = _vault;
        if (_periodDuration < 1 days) revert InitPeriodTooShort(""ERROR_INIT_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        payments[0].inactive = true;
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;
        _newPeriod(getTimestamp64());
    }

    function getTimestamp64() internal view returns (uint64) {
        return uint64(block.timestamp);
    }

    struct Settings {
        uint64 periodDuration;
    }
}","[{'function': 'isContract', 'complexity': 0}, {'function': 'initialize', 'complexity': 1}, {'function': 'getTimestamp64', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_vault"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_vault""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid vault address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_vault""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Provided address is not a contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""86400"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Period duration must be at least 1 day""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""vault""}, ""right"": {""type"": ""Identifier"", ""name"": ""_vault""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""initialized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""inactive""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paymentsNextIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transactionsNextIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""initialized""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOnce"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract VaultContract {
    address public vault;
    struct Settings {
        uint64 periodDuration;
    }
    Settings public settings;
    bool private initialized;
    mapping(uint => Payment) public payments;
    uint public paymentsNextIndex;
    mapping(uint => Transaction) public transactions;
    uint public transactionsNextIndex;

    struct Payment {
        bool inactive;
    }

    struct Transaction {
        address payable recipient;
        uint amount;
    }

    event initialized();

    modifier onlyOnce() {
        require(!initialized, ""Contract already initialized"");
        _;
    }

    function initialize(address _vault, uint64 _periodDuration) external onlyOnce {
        require(_vault != address(0), ""Invalid vault address"");
        require(_isContract(_vault), ""Provided address is not a contract"");
        require(_periodDuration >= 86400, ""Period duration must be at least 1 day"");

        vault = _vault;
        settings.periodDuration = _periodDuration;
        initialized = true;

        // Initialize payments and transactions
        payments[0].inactive = true;
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;

        emit initialized();
    }

    function _isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",45.24409580230713,initialize,25.0,0.9076946016589408,0.2668395727648782,"[{'function': 'initialize', 'complexity': 3}, {'function': '_isContract', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VaultContract is Ownable {
    address public vault;
    struct Settings {
        uint64 periodDuration;
    }
    Settings public settings;
    bool private initialized;
    mapping(uint => Payment) public payments;
    uint public paymentsNextIndex;
    mapping(uint => Transaction) public transactions;
    uint public transactionsNextIndex;

    struct Payment {
        bool inactive;
    }

    struct Transaction {
        address payable recipient;
        uint amount;
    }

    event initialized();

    modifier onlyOnce() {
        require(!initialized, ""Contract already initialized"");
        _;
    }

    constructor(address _vault, uint64 _periodDuration) Ownable(msg.sender) {
        initialize(_vault, _periodDuration);
    }

    function initialize(address _vault, uint64 _periodDuration) public onlyOnce {
        require(_vault != address(0), ""Invalid vault address"");
        require(_isContract(_vault), ""Provided address is not a contract"");
        require(_periodDuration >= 86400, ""Period duration must be at least 1 day"");

        vault = _vault;
        settings.periodDuration = _periodDuration;
        initialized = true;

        // Initialize payments and transactions
        payments[0].inactive = true;
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;

        emit initialized();
    }

    function _isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
2491,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableTransfers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_transfersEnabled"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transfersEnabled""}, ""right"": {""type"": ""Identifier"", ""name"": ""_transfersEnabled""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyToken {
    bool public transfersEnabled;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
        transfersEnabled = true; // Default to enabled
    }

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}",42.23103475570679,enableTransfers,0.0,1.0,1.0,"[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    bool public transfersEnabled;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        transfersEnabled = true; // Default to enabled
    }

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}"
1924,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    address private _crowdsaleAgent;

    modifier onlyCrowdsaleAgent() {
        require(_crowdsaleAgent == msg.sender, ""Only crowdsale agent can call this function"");
        _;
    }

    constructor(address crowdsaleAgent) {
        _crowdsaleAgent = crowdsaleAgent;
    }

    function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
}","[{'function': 'mintToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balances;
    address public owner;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** decimals;
        balances[msg.sender] = totalSupply;
        owner = msg.sender;
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(balances[msg.sender] >= value, ""Insufficient balance"");
        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }
}

contract MyToken is Token {
    mapping(address => bool) public CrowdsaleAgents;

    modifier onlyCrowdsaleAgent() {
        require(CrowdsaleAgents[msg.sender], ""Only crowdsale agents can call this function"");
        _;
    }

    constructor(uint256 initialSupply) Token(""MyToken"", ""MTK"", 18, initialSupply) {}

    function mintToken(address target, uint256 mintedAmount) external onlyCrowdsaleAgent {
        balances[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), target, mintedAmount);
    }
}",46.80724239349365,transfer,22.0,0.713590020409917,0.0460883079310115,"[{'function': 'transfer', 'complexity': 1}, {'function': 'mintToken', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(uint256 initialSupply) {
        require(initialSupply > 0, ""Initial supply must be greater than zero"");
        totalSupply = initialSupply * 10 ** decimals;
        balances[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(balances[msg.sender] >= value, ""Insufficient balance"");
        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Token {
    mapping(address => bool) public CrowdsaleAgents;

    modifier onlyCrowdsaleAgent() {
        require(CrowdsaleAgents[msg.sender], ""Only crowdsale agents can call this function"");
        _;
    }

    constructor(uint256 initialSupply) Token(""MyToken"", ""MTK"", 18, initialSupply) {}

    function mintToken(address target, uint256 mintedAmount) external onlyCrowdsaleAgent {
        balances[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), target, mintedAmount);
    }
}"
2485,"if there is an unresolvable problem , users can call to this function to get a refund .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256[]) public ownedTokens;
    uint256 public constant STARTING_PRICE = 1 ether; // Example value, adjust as needed

    modifier hasFinalized() {
        require(finalized, ""Function can only be called after the event has finalized"");
        _;
    }

    bool public finalized = true; // Set to false if there's an initialization phase or other conditions

    function emergencyWithdraw() external hasFinalized {
        uint256 balance = STARTING_PRICE.mul(ownedTokens[msg.sender].length);
        delete ownedTokens[msg.sender];
        msg.sender.transfer(balance);
    }
}","[{'function': 'emergencyWithdraw', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""emergencyWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceToWithdraw"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""STARTING_PRICE""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownedTokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""length""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownedTokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balanceToWithdraw""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""hasFinalized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => address[]) private ownedTokens;
    uint256 public constant STARTING_PRICE = 1 ether; // Example price, adjust as needed

    modifier hasFinalized() {
        require(ownedTokens[msg.sender].length > 0, ""User has not finalized their participation"");
        _;
    }

    function emergencyWithdraw() external hasFinalized {
        uint256 balanceToWithdraw = STARTING_PRICE * ownedTokens[msg.sender].length;
        delete ownedTokens[msg.sender]; // Remove the list of owned tokens for the caller
        payable(msg.sender).transfer(balanceToWithdraw); // Transfer the calculated balance to the caller's address
    }
}",43.11982703208923,emergencyWithdraw,4.0,0.9337464538693804,0.196526218434423,"[{'function': 'emergencyWithdraw', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => address[]) private ownedTokens;
    uint256 public constant STARTING_PRICE = 1 ether; // Example price, adjust as needed

    modifier hasFinalized() {
        require(ownedTokens[msg.sender].length > 0, ""User has not finalized their participation"");
        _;
    }

    constructor() Ownable(msg.sender) {
        ownedTokens[owner()] = [address(0x111), address(0x222), address(0x333)]; // Initialize with fixed addresses
    }

    function emergencyWithdraw() external hasFinalized {
        uint256 balanceToWithdraw = STARTING_PRICE * ownedTokens[msg.sender].length;
        delete ownedTokens[msg.sender]; // Remove the list of owned tokens for the caller
        payable(msg.sender).transfer(balanceToWithdraw); // Transfer the calculated balance to the caller's address
    }
}"
1164,Allows recovery addresses to trigger the recovery process for an Identity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentityRecovery {
    using SafeMath for uint256;

    struct RecoveryLog {
        uint timestamp;
        bytes32 membersHash;
    }

    struct AssociatedAddresses {
        address[] members;
    }

    struct Identity {
        AssociatedAddresses associatedAddresses;
    }

    mapping(uint => Identity) public identityDirectory;
    mapping(uint => RecoveryLog) public recoveryLogs;
    mapping(uint => address) public recoveryAddressChangeLogs;
    uint8 private constant RECOVERY_PERMISSION = 27;

    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp) public {
        require(_identityExists(ein), ""Identity does not exist."");
        require(_hasIdentity(newAssociatedAddress, false), ""New associated address is not a valid identity."");
        require(canRecover(ein), ""Cannot trigger recovery yet."");
        require(isSigned(newAssociatedAddress, keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), ""I authorize being added to this Identity via recovery."", ein, newAssociatedAddress, timestamp))), ""Permission denied."");
        require(canChangeRecoveryAddress(ein) || msg.sender == recoveryAddressChangeLogs[ein], ""Only the current or previously removed recovery address can trigger recovery."");

        Identity storage _identity = identityDirectory[ein];
        recoveryLogs[ein] = RecoveryLog(block.timestamp, keccak256(abi.encodePacked(_identity.associatedAddresses.members)));
        emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);
        resetIdentityData(_identity, msg.sender, false);
        addAssociatedAddress(ein, newAssociatedAddress);
    }

    function _identityExists(uint ein) internal view returns (bool) {
        return address(uint160(uint256(keccak256(abi.encodePacked(""identity"", ein)))) % 10**40) != address(0);
    }

    function _hasIdentity(address addr, bool isRecoveryAddress) internal view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function canRecover(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function isSigned(address signer, bytes32 hash) internal pure returns (bool) {
        require(signer != address(0), ""ECDSA: invalid signature"");
        return signer == ecrecover(hash, v, r, s);
    }

    function canChangeRecoveryAddress(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function resetIdentityData(Identity storage identity, address newOwner, bool isRecoveryAddress) internal {
        // Implementation omitted for brevity
    }

    function addAssociatedAddress(uint ein, address newAssociatedAddress) internal {
        // Implementation omitted for brevity
    }

    event RecoveryTriggered(address indexed initiator, uint indexed ein, address[] members, address newAssociatedAddress);
}","[{'function': 'triggerRecovery', 'complexity': 6}, {'function': '_identityExists', 'complexity': 0}, {'function': '_hasIdentity', 'complexity': 0}, {'function': 'canRecover', 'complexity': 0}, {'function': 'isSigned', 'complexity': 1}, {'function': 'canChangeRecoveryAddress', 'complexity': 0}, {'function': 'resetIdentityData', 'complexity': 0}, {'function': 'addAssociatedAddress', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""triggerRecovery"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""ein"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAssociatedAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""timestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""identityDirectory""}, ""index"": {""type"": ""Identifier"", ""name"": ""ein""}}, ""memberName"": ""isActive""}, {""type"": ""stringLiteral"", ""value"": ""Identity is not active""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Identity""}, ""name"": ""identity"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""identityDirectory""}, ""index"": {""type"": ""Identifier"", ""name"": ""ein""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""identity""}, ""memberName"": ""currentAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""messageHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newAssociatedAddress""}, {""type"": ""Identifier"", ""name"": ""timestamp""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ecrecover""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""\\x19Ethereum Signed Message:\\n32""}, {""type"": ""Identifier"", ""name"": ""messageHash""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""v""}, {""type"": ""Identifier"", ""name"": ""r""}, {""type"": ""Identifier"", ""name"": ""s""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Signature is not valid""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""RecoveryLog""}, ""name"": ""log"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recoveryLogs""}, ""index"": {""type"": ""Identifier"", ""name"": ""ein""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""log""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""log""}, ""memberName"": ""previousAddresses""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""identity""}, ""memberName"": ""associatedAddresses""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RecoveryTriggered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""ein""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""log""}, ""memberName"": ""previousAddresses""}, {""type"": ""Identifier"", ""name"": ""newAssociatedAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""resetIdentityData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ein""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addAssociatedAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ein""}, {""type"": ""Identifier"", ""name"": ""newAssociatedAddress""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Sender is not the current or recently removed recovery address""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract IdentityRecovery {
    struct RecoveryLog {
        uint256 timestamp;
        address[] previousAddresses;
    }

    struct Identity {
        address[] associatedAddresses;
        address currentAddress;
        bool isActive;
    }

    mapping(bytes32 => RecoveryLog) public recoveryLogs;
    mapping(bytes32 => Identity) public identityDirectory;

    event RecoveryTriggered(address indexed sender, bytes32 ein, address[] previousAddresses, address newAddress);

    function triggerRecovery(bytes32 ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint256 timestamp) public {
        require(identityDirectory[ein].isActive, ""Identity is not active"");

        Identity storage identity = identityDirectory[ein];
        address sender = msg.sender;

        if (identity.currentAddress == sender || hasRole(sender)) {
            bytes32 messageHash = keccak256(abi.encodePacked(newAssociatedAddress, timestamp));
            require(ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", messageHash)), v, r, s) == sender, ""Signature is not valid"");

            RecoveryLog storage log = recoveryLogs[ein];
            log.timestamp = block.timestamp;
            log.previousAddresses = identity.associatedAddresses;

            emit RecoveryTriggered(sender, ein, log.previousAddresses, newAssociatedAddress);

            // Reset identity-related data and add the new associated address
            resetIdentityData(ein);
            addAssociatedAddress(ein, newAssociatedAddress);
        } else {
            revert(""Sender is not the current or recently removed recovery address"");
        }
    }

    function hasRole(address addr) internal view returns (bool) {
        // Implement role checking logic here if needed
        return false;
    }

    function resetIdentityData(bytes32 ein) internal {
        identityDirectory[ein].associatedAddresses.push(msg.sender);
        identityDirectory[ein].currentAddress = address(0);
        identityDirectory[ein].isActive = false;
    }

    function addAssociatedAddress(bytes32 ein, address newAddress) internal {
        identityDirectory[ein].associatedAddresses.push(newAddress);
    }
}",47.775129318237305,triggerRecovery,85.0,0.8459158676623164,0.2879934813613349,"[{'function': 'triggerRecovery', 'complexity': 4}, {'function': 'hasRole', 'complexity': 0}, {'function': 'resetIdentityData', 'complexity': 0}, {'function': 'addAssociatedAddress', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract IdentityRecovery is Ownable {
    struct RecoveryLog {
        uint256 timestamp;
        address[] previousAddresses;
    }

    struct Identity {
        address[] associatedAddresses;
        address currentAddress;
        bool isActive;
    }

    mapping(bytes32 => RecoveryLog) public recoveryLogs;
    mapping(bytes32 => Identity) public identityDirectory;

    event RecoveryTriggered(address indexed sender, bytes32 ein, address[] previousAddresses, address newAddress);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (bytes32 key = 0x11111111; uint256(key) <= 0xFFFFFFFF; key++) {
            identityDirectory[key] = Identity({
                associatedAddresses: [address(0x11111111)],
                currentAddress: address(0x11111111),
                isActive: true
            });
        }
    }

    function triggerRecovery(bytes32 ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint256 timestamp) public {
        require(identityDirectory[ein].isActive, ""Identity is not active"");

        Identity storage identity = identityDirectory[ein];
        address sender = msg.sender;

        if (identity.currentAddress == sender || hasRole(sender)) {
            bytes32 messageHash = keccak256(abi.encodePacked(newAssociatedAddress, timestamp));
            require(ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", messageHash)), v, r, s) == sender, ""Signature is not valid"");

            RecoveryLog storage log = recoveryLogs[ein];
            log.timestamp = block.timestamp;
            log.previousAddresses = identity.associatedAddresses;

            emit RecoveryTriggered(sender, ein, log.previousAddresses, newAssociatedAddress);

            // Reset identity-related data and add the new associated address
            resetIdentityData(ein);
            addAssociatedAddress(ein, newAssociatedAddress);
        } else {
            revert(""Sender is not the current or recently removed recovery address"");
        }
    }

    function hasRole(address addr) internal view returns (bool) {
        // Implement role checking logic here if needed
        return false;
    }

    function resetIdentityData(bytes32 ein) internal {
        identityDirectory[ein].associatedAddresses.push(msg.sender);
        identityDirectory[ein].currentAddress = address(0);
        identityDirectory[ein].isActive = false;
    }

    function addAssociatedAddress(bytes32 ein, address newAddress) internal {
        identityDirectory[ein].associatedAddresses.push(newAddress);
    }
}"
461,Checks whether a contract implements an ERC165 interface or not without using nor updating the cache .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

abstract contract ImplementsERC165InterfaceNoCache is Ownable {
    using SafeMath for uint256;

    bytes4 constant ERC165ID = 0x01ffc9a7;
    bytes4 constant INVALID_ID = 0xffffffff;

    function noThrowCall(address _contract, bytes4 _interfaceId) internal view returns (uint256 success, uint256 result) {
        (success, result) = address(_contract).staticcall(abi.encodeWithSelector(ERC165.supportsInterface.selector, _interfaceId));
    }

    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;
        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }
}","[{'function': 'supportsInterface', 'complexity': 0}, {'function': 'noThrowCall', 'complexity': 0}, {'function': 'implementsERC165InterfaceNoCache', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""implementsERC165InterfaceNoCache"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""_interfaceId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""success"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x11309f8c0>}, {""type"": ""VariableDeclaration"", ""name"": ""result"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x11309fd20>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contract""}], ""names"": []}, ""memberName"": ""staticcall""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0x01ffc9a7"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_interfaceId""}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""success""}, ""isPrefix"": True}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""decode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""result""}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""isArray"": False}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contract""}], ""names"": []}, ""memberName"": ""staticcall""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0xffffffff"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""decode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""result""}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""isArray"": False}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contract""}], ""names"": []}, ""memberName"": ""staticcall""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_interfaceId""}], ""names"": []}], ""names"": []}, ""memberName"": ""success""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_contract""}], ""names"": []}, ""memberName"": ""staticcall""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSelector""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_interfaceId""}], ""names"": []}], ""names"": []}}}, {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""decode""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""result""}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""isArray"": False}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract ERC165Checker {
    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        // Step 1: Check if the contract supports the interface using `noThrowCall` with ERC165ID.
        (bool success, bytes memory result) = address(_contract).staticcall(abi.encodeWithSelector(0x01ffc9a7, _interfaceId));
        if (!success || abi.decode(result, (uint256)) != 0) {
            return false;
        }

        // Step 2: Check if the contract does not support an invalid interface using `noThrowCall` with INVALID_ID.
        result = address(_contract).staticcall(abi.encodeWithSelector(0xffffffff));
        if (success || abi.decode(result, (uint256)) == 1) {
            return false;
        }

        // Step 3: Check if the contract supports the specified interface using `noThrowCall` with _interfaceId.
        success = address(_contract).staticcall(abi.encodeWithSelector(_interfaceId)).success;
        result = address(_contract).staticcall(abi.encodeWithSelector(_interfaceId)));
        return success && abi.decode(result, (uint256)) == 1;
    }
}",45.02402305603027,implementsERC165InterfaceNoCache,60.0,0.6797055432807054,0.2224136726088163,"[{'function': 'implementsERC165InterfaceNoCache', 'complexity': 5}]",6.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ERC165Checker {
    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        // Step 1: Check if the contract supports the interface using `noThrowCall` with ERC165ID.
        (bool success, bytes memory result) = address(_contract).staticcall(abi.encodeWithSelector(0x01ffc9a7, _interfaceId));
        if (!success || abi.decode(result, (uint256)) != 0) {
            return false;
        }

        // Step 2: Check if the contract does not support an invalid interface using `noThrowCall` with INVALID_ID.
        result = address(_contract).staticcall(abi.encodeWithSelector(0xffffffff));
        if (success || abi.decode(result, (uint256)) == 1) {
            return false;
        }

        // Step 3: Check if the contract supports the specified interface using `noThrowCall` with _interfaceId.
        success = address(_contract).staticcall(abi.encodeWithSelector(_interfaceId)).success;
        result = address(_contract).staticcall(abi.encodeWithSelector(_interfaceId)));
        return success && abi.decode(result, (uint256)) == 1;
    }
}"
3202,Retreive account ID associated with a user 's address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public accountByAddress;

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address));
        return accountByAddress[_address];
    }

    function addressBelongsToAccount(address _address) internal view virtual returns (bool);
}","[{'function': 'accountIdForAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""accountIdForAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addressBelongsToAccount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""The provided address does not belong to an account""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accountByAddress""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => uint256) public accountByAddress;

    function addressBelongsToAccount(address _address) internal view returns (bool) {
        // Implement the logic to check if the address belongs to an account
        return accountByAddress[_address] != 0;
    }

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address), ""The provided address does not belong to an account"");
        return accountByAddress[_address];
    }
}",43.77727484703064,addressBelongsToAccount,1.0,0.8046207738391257,0.1378894112588712,"[{'function': 'addressBelongsToAccount', 'complexity': 0}, {'function': 'accountIdForAddress', 'complexity': 1}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => uint256) public accountByAddress;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    constructor() Ownable(msg.sender) {
        accountByAddress[DEFAULT_ADDRESS] = 1;
        accountByAddress[msg.sender] = 1; // Initialize with a non-zero value
    }

    function addressBelongsToAccount(address _address) internal view returns (bool) {
        return accountByAddress[_address] != 0;
    }

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address), ""The provided address does not belong to an account"");
        return accountByAddress[_address];
    }
}"
5007,Get the index of PixelCon ` ( _tokenId ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        require(_tokenId != 0, ""Invalid token ID"");
        // Assuming the logic to retrieve the index is implemented here.
        return uint64(_tokenId);
    }
}","[{'function': 'getTokenIndex', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIndices""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token ID not found""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIndices""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TokenIndexRetriever {
    mapping(uint256 => uint64) private tokenIndices;

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        require(tokenIndices[_tokenId] != 0, ""Token ID not found"");
        return tokenIndices[_tokenId];
    }
}",41.96485614776611,getTokenIndex,4.0,0.7839407639427312,0.3626930152379609,"[{'function': 'getTokenIndex', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenIndexRetriever is Ownable {
    mapping(uint256 => uint64) private tokenIndices;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        tokenIndices[1] = 1; // Example initialization for a specific tokenId
        tokenIndices[2] = 2; // Example initialization for another tokenId
        tokenIndices[3] = 3; // Example initialization for yet another tokenId
    }

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        require(tokenIndices[_tokenId] != 0, ""Token ID not found"");
        return tokenIndices[_tokenId];
    }
}"
1993,Throws if ` _tokenId ` is not a valid NFT .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public idToApprovals;

    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address) {
        return idToApprovals[_tokenId];
    }
}","[{'function': 'getApproved', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getApproved"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""idToApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validNFToken"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract NFToken {
    mapping(uint256 => address) public idToApprovals;

    modifier validNFToken(uint256 _tokenId) {
        require(_exists(_tokenId), ""NFT does not exist"");
        _;
    }

    function getApproved(uint256 _tokenId)
        public
        view
        validNFToken(_tokenId)
        returns (address)
    {
        return idToApprovals[_tokenId];
    }

    function _exists(uint256 _tokenId) internal pure returns (bool) {
        // Implement the logic to check if the token exists
        // This is a placeholder implementation and should be replaced with actual logic
        return true; // Placeholder for actual existence check
    }
}",43.197142362594604,getApproved,0.0,1.0,1.0,"[{'function': 'getApproved', 'complexity': 0}, {'function': '_exists', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract NFToken is Ownable {
    mapping(uint256 => address) public idToApprovals;
    uint256 public tokenId = 1; // Set to a fixed value (never 0)
    bool public initialized = true; // Set to true

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        idToApprovals[tokenId] = msg.sender;
    }

    modifier validNFToken(uint256 _tokenId) {
        require(_exists(_tokenId), ""NFT does not exist"");
        _;
    }

    function getApproved(uint256 _tokenId)
        public
        view
        validNFToken(_tokenId)
        returns (address)
    {
        return idToApprovals[_tokenId];
    }

    function _exists(uint256 _tokenId) internal pure returns (bool) {
        // Implement the logic to check if the token exists
        // This is a placeholder implementation and should be replaced with actual logic
        return true; // Placeholder for actual existence check
    }
}"
3377,Check the total supply of the token ~ ERC-20 Standard,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 internal totalSupply_;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint8 _decimals) {
        totalSupply_ = totalSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() external constant returns (uint256) {
        return totalSupply_;
    }
}","[{'function': 'totalSupply', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""totalSupply""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    uint256 public totalSupply;

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply;
    }

    function totalSupply() public view returns (uint256) {
        return totalSupply;
    }
}",41.88603615760803,totalSupply,0.0,0.959675015722895,0.5445178846139404,"[{'function': 'totalSupply', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    uint256 public totalSupply;

    constructor() Ownable(msg.sender) {
        totalSupply = 1000000000000000000;
    }

    function totalSupply() public view returns (uint256) {
        return totalSupply;
    }
}"
1589,Transfer Spork tokens from ` msg.sender ` to another account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        if (balances[_to].add(_amount).lte(balances[_to])) return false;
        if (balances[msg.sender].lt(_amount)) return false;
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""stringLiteral"", ""value"": ""Overflow detected""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""success""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        require(_amount <= balances[msg.sender], ""Insufficient balance"");
        require(balances[_to] + _amount >= balances[_to], ""Overflow detected"");

        balances[msg.sender] -= _amount;
        balances[_to] += _amount;

        emit Transfer(msg.sender, _to, _amount);
        success = true;
    }
}",42.889798641204834,transfer,32.0,0.7473390221417839,0.3732048216387185,"[{'function': 'transfer', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance of owner to 1 (never 0)
    }

    function transfer(address _to, uint256 _amount) public returns (bool success) {
        require(_amount <= balances[msg.sender], ""Insufficient balance"");
        require(balances[_to] + _amount >= balances[_to], ""Overflow detected"");

        balances[msg.sender] -= _amount;
        balances[_to] += _amount;

        emit Transfer(msg.sender, _to, _amount);
        success = true;
    }
}"
1356,Set value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint) public uIntStorage;

    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool success) {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        uIntStorage[_key] = _value;
        return true;
    }

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(""ROLE_PLATFORM_OPERATIVE_REPRESENTATIVE"") {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'setUint', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""uIntStorage""}, ""index"": {""type"": ""Identifier"", ""name"": ""_key""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    mapping(bytes32 => uint) public uIntStorage;

    function setUint(bytes32 _key, uint _value) external onlyOwner returns (bool) {
        uIntStorage[_key] = _value;
        return true;
    }
}",42.028385639190674,setUint,29.0,0.5314615516882434,0.0071610242519276,"[{'function': 'setUint', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(bytes32 => uint) public uIntStorage;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        uIntStorage[bytes32('init')] = 1;
    }

    function setUint(bytes32 _key, uint _value) external onlyOwner returns (bool) {
        require(_value != 0, ""Value must not be zero""); // Ensure value is non-zero
        uIntStorage[_key] = _value;
        return true;
    }
}"
232,get token price in cents depending on the current date,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;
    address private constant ROLE_PLATFORM_OPERATIVE = 0x0; // Placeholder for platform operator representative role

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function getPrice() public view returns (uint) {
        for (uint i = c_priceChangeDates.length - 2; i > 0; i--) {
            if (getTime() >= c_priceChangeDates[i]) {
                return c_tokenPrices[i];
            }
        }
        return c_tokenPrices[0];
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'getPrice', 'complexity': 3}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""int""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""int""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""c_priceChangeDates""}, ""memberName"": ""length""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""c_priceChangeDates""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""c_tokenPrices""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}}]}, ""FalseBody"": None}]}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""c_tokenPrices""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TokenPrice {
    uint[] private c_tokenPrices;
    uint[] private c_priceChangeDates;

    function getPrice() public view returns (uint) {
        for (int i = int(c_priceChangeDates.length) - 2; i >= 0; i--) {
            if (block.timestamp >= c_priceChangeDates[uint(i)]) {
                return c_tokenPrices[uint(i)];
            }
        }
        return c_tokenPrices[0];
    }
}",42.800039768218994,getPrice,34.0,0.8934691810809359,0.4747587535373448,"[{'function': 'getPrice', 'complexity': 3}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenPrice is Ownable {
    uint[] private c_tokenPrices = [1, 2, 3]; // Initialize to safe non-zero values
    uint[] private c_priceChangeDates = [block.timestamp + 1 days, block.timestamp + 2 days, block.timestamp + 3 days]; // Initialize to increasing future timestamps

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already initialized in the declaration
    }

    function getPrice() public view returns (uint) {
        for (int i = int(c_priceChangeDates.length) - 2; i >= 0; i--) {
            if (block.timestamp >= c_priceChangeDates[uint(i)]) {
                return c_tokenPrices[uint(i)];
            }
        }
        return c_tokenPrices[0];
    }
}"
5169,Set the Havven contract that the issuance controller uses to issue Havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HavvenWrapper is Ownable {
    using SafeMath for uint256;

    Havven public havven;

    event HavvenUpdated(Havven indexed newHavven);

    function setHavven(Havven _havven) external onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}","[{'function': 'setHavven', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setHavven"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_havven"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""havven""}, ""right"": {""type"": ""Identifier"", ""name"": ""_havven""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""HavvenUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_havven""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract HavvenSetter {
    address public havven;
    address public owner;

    event HavvenUpdated(address indexed newHavven);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setHavven(address _havven) external onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}",42.29560160636902,setHavven,1.0,0.9619191961129548,0.8492326635760689,"[{'function': 'setHavven', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HavvenSetter is Ownable {
    address public havven;

    event HavvenUpdated(address indexed newHavven);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        havven = msg.sender;
    }

    function setHavven(address _havven) external onlyOwner {
        require(_havven != address(0), ""Invalid address"");
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}"
277,sell new tokens during the round 0 all except logo,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public halted = false;
    mapping(address => bool) public signers;

    function setHalted(bool _halted) external onlyOwner {
        halted = _halted;
    }

    function addSigner(address signer) external onlyOwner {
        signers[signer] = true;
    }

    function removeSigner(address signer) external onlyOwner {
        signers[signer] = false;
    }

    function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 v, bytes32 r, bytes32 s) public notHalted() payable {
        address recoveredSigner = verify(keccak256(abi.encodePacked(msg.sender)), v, r, s);
        require(signers[recoveredSigner] == true);
        require(msg.value > 0);
        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        // Implementation of the buy logic
    }
}","[{'function': 'setHalted', 'complexity': 0}, {'function': 'addSigner', 'complexity': 0}, {'function': 'removeSigner', 'complexity': 0}, {'function': 'verify', 'complexity': 0}, {'function': 'buy', 'complexity': 2}, {'function': 'internalBuy', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""x"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""y"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sizeA"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sizeB"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Payment must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ecrecover""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""x""}, {""type"": ""Identifier"", ""name"": ""y""}, {""type"": ""Identifier"", ""name"": ""sizeA""}, {""type"": ""Identifier"", ""name"": ""sizeB""}], ""names"": []}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_v""}, {""type"": ""Identifier"", ""name"": ""_r""}, {""type"": ""Identifier"", ""name"": ""_s""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""signers""}, ""index"": {""type"": ""Identifier"", ""name"": ""signer""}}, {""type"": ""stringLiteral"", ""value"": ""Unauthorized signer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""internalBuy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""x""}, {""type"": ""Identifier"", ""name"": ""y""}, {""type"": ""Identifier"", ""name"": ""sizeA""}, {""type"": ""Identifier"", ""name"": ""sizeB""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""notHalted"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract PurchaseContract {
    mapping(address => bool) public signers;
    bool public halted = false;

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 _v, bytes32 _r, bytes32 _s) public payable notHalted {
        require(msg.value > 0, ""Payment must be greater than zero"");

        address signer = ecrecover(keccak256(abi.encodePacked(x, y, sizeA, sizeB)), _v, _r, _s);
        require(signers[signer], ""Unauthorized signer"");

        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        // Implementation of the core purchase logic and state updates
    }

    function halt() public {
        halted = true;
    }

    function unhalt() public {
        halted = false;
    }
}",45.46640634536743,buy,21.0,0.8991781091274769,0.4742831940474888,"[{'function': 'buy', 'complexity': 2}, {'function': 'internalBuy', 'complexity': 0}, {'function': 'halt', 'complexity': 0}, {'function': 'unhalt', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract PurchaseContract is Ownable {
    mapping(address => bool) public signers;
    bool public halted = false;

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 _v, bytes32 _r, bytes32 _s) public payable notHalted {
        require(msg.value > 0, ""Payment must be greater than zero"");

        address signer = ecrecover(keccak256(abi.encodePacked(x, y, sizeA, sizeB)), _v, _r, _s);
        require(signers[signer], ""Unauthorized signer"");

        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        // Implementation of the core purchase logic and state updates
    }

    function halt() public notHalted {
        halted = true;
    }

    function unhalt() public notHalted {
        halted = false;
    }
}"
3181,This function is disabled during the funding .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function getState() external view returns (uint8);
    function balances(address) external view returns (uint256);
    function upgradeAgent() external view returns (address);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _token) {
        token = IToken(_token);
    }

    function transfer(address to, uint256 value) external returns (bool ok) {
        require(getState() == 0, ""State is not Success"");
        require(to != address(0), ""Invalid recipient address"");
        require(to != token.upgradeAgent(), ""Recipient is upgrade agent"");

        uint256 senderBalance = token.balances(msg.sender);
        if (senderBalance >= value && value > 0) {
            senderBalance = senderBalance.sub(value);
            token.balances(msg.sender) = senderBalance;
            token.balances(to) = token.balances(to).add(value);
            emit Transfer(msg.sender, to, value);
            return true;
        }
        return false;
    }

    function getState() internal view returns (uint8) {
        return token.getState();
    }
}","[{'function': 'upgradeAgent', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'getState', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to cover the transfer amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot transfer to zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot transfer to the upgrade agent address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyInState"", ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Success""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    address public upgradeAgent;
    mapping(address => uint256) public balances;
    string public state = ""Success"";

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyInState(string memory expectedState) {
        require(keccak256(abi.encodePacked(state)) == keccak256(abi.encodePacked(expectedState)), ""Contract state is not in Success"");
        _;
    }

    modifier onlyValidAddress(address addr) {
        require(addr != address(0), ""Cannot transfer to zero address"");
        require(addr != upgradeAgent, ""Cannot transfer to the upgrade agent address"");
        _;
    }

    function transfer(address to, uint256 value) public onlyInState(""Success"") returns (bool success) {
        require(value > 0, ""Transfer value must be greater than zero"");
        require(balances[msg.sender] >= value, ""Insufficient balance to cover the transfer amount"");
        require(to != address(0), ""Cannot transfer to zero address"");
        require(to != upgradeAgent, ""Cannot transfer to the upgrade agent address"");

        balances[msg.sender] -= value;
        balances[to] += value;

        emit Transfer(msg.sender, to, value);
        return true;
    }
}",45.12001657485962,transfer,33.0,0.7484084993021962,0.3531397666080338,"[{'function': 'transfer', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    address public upgradeAgent;
    mapping(address => uint256) public balances;
    string public state = ""Success"";

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyInState(string memory expectedState) {
        require(keccak256(abi.encodePacked(state)) == keccak256(abi.encodePacked(expectedState)), ""Contract state is not in Success"");
        _;
    }

    modifier onlyValidAddress(address addr) {
        require(addr != address(0), ""Cannot transfer to zero address"");
        require(addr != upgradeAgent, ""Cannot transfer to the upgrade agent address"");
        _;
    }

    constructor() Ownable(msg.sender) {
        upgradeAgent = 0x1111111111111111111111111111111111111111; // Replace with your desired address
        balances[msg.sender] = 1000; // Initialize balance to a fixed value
        state = 'initialized'; // Initialize state to a fixed string
    }

    function transfer(address to, uint256 value) public onlyInState(""Success"") returns (bool success) {
        require(value > 0, ""Transfer value must be greater than zero"");
        require(balances[msg.sender] >= value, ""Insufficient balance to cover the transfer amount"");
        require(to != address(0), ""Cannot transfer to zero address"");
        require(to != upgradeAgent, ""Cannot transfer to the upgrade agent address"");

        balances[msg.sender] -= value;
        balances[to] += value;

        emit Transfer(msg.sender, to, value);
        return true;
    }
}"
4086,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

   function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
}

}","[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isApprovedForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operatorApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AssetManagement {
    // Mapping to store approval status for each owner-operator pair
    mapping(address => mapping(address => bool)) private operatorApprovals;

    // Function to check if an operator is approved to manage all assets of a given owner
    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}",42.03435826301575,isApprovedForAll,15.0,0.6943348627320222,0.840435017870011,"[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetManagement is Ownable {
    // Mapping to store approval status for each owner-operator pair
    mapping(address => mapping(address => bool)) private operatorApprovals;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    // Function to check if an operator is approved to manage all assets of a given owner
    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}"
79,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public memeIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerOf(_tokenId) == _owner;
    }

    function ownerOf(uint256 _tokenId) public pure returns (address) {
        // This is a placeholder for the actual implementation of ownerOf.
        // The real implementation should be provided by the contract that inherits this wrapper.
        require(false, ""ownerOf not implemented"");
    }
}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}, {'function': 'ownerOf', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_owns""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not the owner of the token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""memeIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenApproval {
    mapping(uint256 => address) public memeIndexToApproved;

    function approve(address _to, uint256 _tokenId) external {
        require(_owns(msg.sender, _tokenId), ""Caller is not the owner of the token"");
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerByTokenId[_tokenId] == _owner;
    }

    mapping(uint256 => address) public approvedTransfers;
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
}",43.54735279083252,approve,1.0,0.9901378361488836,0.689836378159368,"[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval {
    mapping(uint256 => address) public memeIndexToApproved;

    function approve(address _to, uint256 _tokenId) external {
        require(_owns(msg.sender, _tokenId), ""Caller is not the owner of the token"");
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerByTokenId[_tokenId] == _owner;
    }

    mapping(uint256 => address) public approvedTransfers;
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenApprovalContract is TokenApproval {
    constructor() TokenApproval() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            memeIndexToApproved[i] = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
        }
    }
}"
3424,Get the name of collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollectionRegistry is Ownable {
    using SafeMath for uint256;

    uint256 public totalCollections;
    mapping(uint64 => bytes8) private collectionNames;

    modifier validIndex(uint64 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (bytes8) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        return collectionNames[_collectionIndex];
    }

    function setTotalCollections(uint256 newTotalCollections) public onlyOwner {
        totalCollections = newTotalCollections;
    }

    function setCollectionName(uint64 _collectionIndex, bytes8 _name) public onlyOwner validIndex(_collectionIndex) {
        collectionNames[_collectionIndex] = _name;
    }
}","[{'function': 'getCollectionName', 'complexity': 1}, {'function': 'setTotalCollections', 'complexity': 0}, {'function': 'setCollectionName', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""addCollection"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionNames""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""right"": {""type"": ""Identifier"", ""name"": ""name""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""totalCollections""}, ""right"": {""type"": ""Identifier"", ""name"": ""index""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalCollections""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract CollectionRegistry {
    mapping(uint64 => string) private collectionNames;
    uint64 public totalCollections;

    modifier validIndex(uint64 index) {
        require(index < totalCollections, ""Collection does not exist"");
        _;
    }

    function addCollection(uint64 index, string memory name) public {
        collectionNames[index] = name;
        if (totalCollections <= index) {
            totalCollections = index + 1;
        }
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (string memory) {
        return collectionNames[_collectionIndex];
    }
}",43.19415497779846,addCollection,12.0,0.6922936918400268,0.0232154358013989,"[{'function': 'addCollection', 'complexity': 1}, {'function': 'getCollectionName', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CollectionRegistry is Ownable {
    mapping(uint64 => string) private collectionNames;
    uint64 public totalCollections;

    modifier validIndex(uint64 index) {
        require(index < totalCollections, ""Collection does not exist"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        totalCollections = 1; // Never set to 0
    }

    function addCollection(uint64 index, string memory name) public {
        collectionNames[index] = name;
        if (totalCollections <= index) {
            totalCollections = index + 1;
        }
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (string memory) {
        return collectionNames[_collectionIndex];
    }
}"
4496,This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ICOContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoEndDate;
    bool public paused = false;

    mapping(address => bool) public whitelistedAddresses;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        require(whitelistedAddresses[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
        icoEndDate = _date;
    }
}","[{'function': 'setICOEndDate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setICOEndDate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_date"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""icoEndDate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ICO end date has already been set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoEndDate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_date""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyWhitelisted"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ICO {
    uint public icoEndDate;
    bool public paused = false;
    mapping(address => bool) public whitelist;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        require(whitelist[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    function setICOEndDate(uint _date) public whenNotPaused onlyWhitelisted {
        require(icoEndDate == 0, ""ICO end date has already been set"");
        icoEndDate = _date;
    }
}",42.91448855400085,setICOEndDate,7.0,0.8254178022593197,0.2826845419324588,"[{'function': 'setICOEndDate', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ICO is Ownable {
    uint public icoEndDate = 1;
    bool public paused = false;
    mapping(address => bool) public whitelist;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        require(whitelist[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    constructor() Ownable(msg.sender) {
        icoEndDate = 1;
        paused = false;
        whitelist[address(0x111)] = true;
        whitelist[address(0x222)] = true;
        whitelist[address(0x333)] = true;
    }

    function setICOEndDate(uint _date) public whenNotPaused onlyWhitelisted {
        require(icoEndDate == 1, ""ICO end date has already been set"");
        icoEndDate = _date;
    }
}"
1334,Adding ` _backer.address ( ) ` as an early backer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct backerData {
        uint tokenPrice;
        uint tokenAmount;
        bytes32 privatePhraseHash;
        bool claimed;
        bool redeemed;
        uint rank;
    }

    address[] public earlyBackerList;
    address[] public backersAddresses;
    mapping(address => backerData[]) public backers;
    uint public prepaidUnits;
    uint public claimedUnits;
    uint public promissoryUnits;
    uint public lastPrice;
    uint public numOfBackers;

    event AddedPrepaidTokensEvent(address indexed backer, uint indexed index, uint tokenPrice, uint tokenAmount);

    modifier founderCall() {
        require(msg.sender == owner(), ""Only the founder can call this function"");
        _;
    }

    function setPrepaid(address _backer, uint _tokenPrice, uint _tokenAmount, string memory _privatePhrase, uint _backerRank) external founderCall returns (uint) {
        require(_tokenPrice > 0 && _tokenAmount > 0);
        require(claimedUnits == 0);
        require(_tokenAmount.add(prepaidUnits).add(claimedUnits) <= promissoryUnits);
        if (earlyBackerList.length == numOfBackers && backers[_backer].length == 0) {
            earlyBackerList.push(_backer);
            backersAddresses.push(_backer);
        }
        backers[_backer].push(backerData(_tokenPrice, _tokenAmount, keccak256(abi.encodePacked(_privatePhrase, _backer)), true, false, _backerRank));
        prepaidUnits = prepaidUnits.add(_tokenAmount);
        lastPrice = _tokenPrice;
        emit AddedPrepaidTokensEvent(_backer, backers[_backer].length - 1, _tokenPrice, _tokenAmount);
        return backers[_backer].length - 1;
    }
}","[{'function': 'setPrepaid', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBacker"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_backer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_tokenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_tokenAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_privatePhrase"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_backerRank"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Backer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backer""}, {""type"": ""Identifier"", ""name"": ""_tokenPrice""}, {""type"": ""Identifier"", ""name"": ""_tokenAmount""}, {""type"": ""Identifier"", ""name"": ""_privatePhrase""}, {""type"": ""Identifier"", ""name"": ""_backerRank""}], ""names"": [""addr"", ""tokenPrice"", ""tokenAmount"", ""privatePhrase"", ""backerRank""]}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backersAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""earlyBackerList""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""backersAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backer""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""prepaidUnits""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenPrice""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AddedPrepaidTokensEvent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backer""}, {""type"": ""Identifier"", ""name"": ""_tokenPrice""}, {""type"": ""Identifier"", ""name"": ""_tokenAmount""}, {""type"": ""Identifier"", ""name"": ""_privatePhrase""}, {""type"": ""Identifier"", ""name"": ""_backerRank""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyNewBacker"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""validInput"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PrepaidEntry {
    uint public constant MAX_BACKERS = 100; // Predefined limit for backers
    uint public prepaidUnits;
    uint public lastPrice;
    address[] public earlyBackerList;
    mapping(address => bool) public backersAddresses;
    mapping(address => Backer) public backers;

    struct Backer {
        address addr;
        uint tokenPrice;
        uint tokenAmount;
        string privatePhrase;
        uint backerRank;
    }

    event AddedPrepaidTokensEvent(address indexed backer, uint tokenPrice, uint tokenAmount, string privatePhrase, uint backerRank);

    modifier onlyNewBacker() {
        require(!backersAddresses[_backer], ""Backer already exists"");
        _;
    }

    modifier validInput() {
        require(_tokenPrice > 0 && _tokenAmount > 0, ""Token price or amount must be greater than zero"");
        require(prepaidUnits + _tokenAmount <= MAX_BACKERS * lastPrice, ""Exceeds the predefined limit and units have already been claimed"");
        _;
    }

    function addBacker(address _backer, uint _tokenPrice, uint _tokenAmount, string memory _privatePhrase, uint _backerRank) public onlyNewBacker validInput {
        backers[_backer] = Backer({
            addr: _backer,
            tokenPrice: _tokenPrice,
            tokenAmount: _tokenAmount,
            privatePhrase: _privatePhrase,
            backerRank: _backerRank
        });

        if (!backersAddresses[_backer]) {
            earlyBackerList.push(_backer);
            backersAddresses[_backer] = true;
        }

        prepaidUnits += _tokenAmount;
        lastPrice = _tokenPrice;

        emit AddedPrepaidTokensEvent(_backer, _tokenPrice, _tokenAmount, _privatePhrase, _backerRank);
    }
}",47.007715702056885,addBacker,68.0,0.5663439570874647,0.2539699105716878,"[{'function': 'addBacker', 'complexity': 2}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PrepaidEntry is Ownable {
    uint public constant MAX_BACKERS = 100; // Predefined limit for backers
    uint public prepaidUnits;
    uint public lastPrice;
    address[] public earlyBackerList;
    mapping(address => bool) public backersAddresses;
    mapping(address => Backer) public backers;

    struct Backer {
        address addr;
        uint tokenPrice;
        uint tokenAmount;
        string privatePhrase;
        uint backerRank;
    }

    event AddedPrepaidTokensEvent(address indexed backer, uint tokenPrice, uint tokenAmount, string privatePhrase, uint backerRank);

    modifier onlyNewBacker() {
        require(!backersAddresses[_backer], ""Backer already exists"");
        _;
    }

    modifier validInput() {
        require(_tokenPrice > 0 && _tokenAmount > 0, ""Token price or amount must be greater than zero"");
        require(prepaidUnits + _tokenAmount <= MAX_BACKERS * lastPrice, ""Exceeds the predefined limit and units have already been claimed"");
        _;
    }

    constructor() Ownable(msg.sender) {
        prepaidUnits = 1; // Set to 1 (never 0)
        lastPrice = 1 ether; // Use a fixed value for Ether, adjust as needed
        earlyBackerList = [address(0x111), address(0x222), address(0x333)]; // Fixed addresses
    }

    function addBacker(address _backer, uint _tokenPrice, uint _tokenAmount, string memory _privatePhrase, uint _backerRank) public onlyNewBacker validInput {
        backers[_backer] = Backer({
            addr: _backer,
            tokenPrice: _tokenPrice,
            tokenAmount: _tokenAmount,
            privatePhrase: _privatePhrase,
            backerRank: _backerRank
        });

        if (!backersAddresses[_backer]) {
            earlyBackerList.push(_backer);
            backersAddresses[_backer] = true;
        }

        prepaidUnits += _tokenAmount;
        lastPrice = _tokenPrice;

        emit AddedPrepaidTokensEvent(_backer, _tokenPrice, _tokenAmount, _privatePhrase, _backerRank);
    }
}"
517,Used to intialize the variables of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public maxHolderPercentage;

    modifier onlyFactory() {
        require(msg.sender == factory, ""Only the factory can call this function"");
        _;
    }

    address private factory;

    constructor() {
        // Initialize the factory address in the constructor or later
    }

    function configure(uint256 _maxHolderPercentage) public onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}","[{'function': 'configure', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""configure"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxHolderPercentage"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxHolderPercentage""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxHolderPercentage""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyFactory"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenConfiguration {
    address public factoryContract;
    uint256 public maxHolderPercentage;

    modifier onlyFactory() {
        require(msg.sender == factoryContract, ""Only the factory contract can call this function"");
        _;
    }

    constructor(address _factoryContract) {
        factoryContract = _factoryContract;
    }

    function configure(uint256 _maxHolderPercentage) external onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}",42.07995319366455,configure,0.0,0.9705677373400704,0.7611606003349892,"[{'function': 'configure', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenConfiguration is Ownable {
    address public factoryContract;
    uint256 public maxHolderPercentage;

    modifier onlyFactory() {
        require(msg.sender == factoryContract, ""Only the factory contract can call this function"");
        _;
    }

    constructor(address _factoryContract) Ownable(msg.sender) {
        factoryContract = _factoryContract;
        maxHolderPercentage = 1; // Set to a non-zero value
    }

    function configure(uint256 _maxHolderPercentage) external onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}"
3727,Core logic of the ` decreaseApproval ` function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20Store {
    function allowed(address _owner, address _spender) external view returns (uint256);
    function setAllowance(address _owner, address _spender, uint256 _value) external;
}

interface IERC20Proxy {
    function emitApproval(address _owner, address _spender, uint256 _value) external;
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20Store public erc20Store;
    IERC20Proxy public erc20Proxy;

    constructor(address _erc20Store, address _erc20Proxy) {
        erc20Store = IERC20Store(_erc20Store);
        erc20Proxy = IERC20Proxy(_erc20Proxy);
    }

    function decreaseApprovalWithSender(address _sender, address _spender, uint256 _subtractedValue) public onlyOwner returns (bool) {
        require(_spender != address(0));
        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);
        uint256 newAllowance = currentAllowance.sub(_subtractedValue);
        require(newAllowance <= currentAllowance);
        erc20Store.setAllowance(_sender, _spender, newAllowance);
        erc20Proxy.emitApproval(_sender, _spender, newAllowance);
        return true;
    }
}","[{'function': 'setAllowance', 'complexity': 0}, {'function': 'emitApproval', 'complexity': 0}, {'function': 'decreaseApprovalWithSender', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_subtractedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: spender cannot be the zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20Store""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_subtractedValue""}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: decreased allowance below zero""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_subtractedValue""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20Store""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""newAllowance""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""newAllowance""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract ERC20Proxy {
    event Approval(address indexed owner, address indexed spender, uint256 value);

    IERC20 public erc20Store;

    constructor(address _erc20Store) {
        erc20Store = IERC20(_erc20Store);
    }

    function decreaseAllowance(address _sender, address _spender, uint256 _subtractedValue) external {
        require(_spender != address(0), ""ERC20: spender cannot be the zero address"");

        uint256 currentAllowance = erc20Store.allowance(_sender, _spender);
        require(currentAllowance >= _subtractedValue, ""ERC20: decreased allowance below zero"");

        if (currentAllowance != type(uint256).max) {
            uint256 newAllowance = currentAllowance - _subtractedValue;
            erc20Store.approve(_spender, newAllowance);
            emit Approval(_sender, _spender, newAllowance);
        }
    }
}",45.12222003936768,decreaseAllowance,28.0,0.9205490832841166,0.4247460251257268,"[{'function': 'approve', 'complexity': 0}, {'function': 'decreaseAllowance', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract ERC20Proxy {
    event Approval(address indexed owner, address indexed spender, uint256 value);

    IERC20 public erc20Store;

    constructor(address _erc20Store) {
        erc20Store = IERC20(_erc20Store);
    }

    function decreaseAllowance(address _sender, address _spender, uint256 _subtractedValue) external {
        require(_spender != address(0), ""ERC20: spender cannot be the zero address"");

        uint256 currentAllowance = erc20Store.allowance(_sender, _spender);
        require(currentAllowance >= _subtractedValue, ""ERC20: decreased allowance below zero"");

        if (currentAllowance != type(uint256).max) {
            uint256 newAllowance = currentAllowance - _subtractedValue;
            erc20Store.approve(_spender, newAllowance);
            emit Approval(_sender, _spender, newAllowance);
        }
    }
}"
5953,"Sets the address of another contract to handle the requests of this contract , it can be used to deprecate this Oracle","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    address public fallback;

    function setFallback(address _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}","[{'function': 'setFallback', 'complexity': 0}]",1.0,{},"pragma solidity ^0.8.0;

contract MyContract {
    address public fallback;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setFallback(address _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}",42.678054094314575,setFallback,0.0,1.0,1.0,"[{'function': 'setFallback', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and you have a corresponding contract named Ownable
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public fallback;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function setFallback(address _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}"
6776,Sends fees to the request burning address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public requestBurnerContract;

    constructor(address _requestBurnerContract) {
        requestBurnerContract = _requestBurnerContract;
    }

    function collectForREQBurning(uint256 _amount) internal {
        require(_amount > 0, ""Amount must be greater than zero"");
        (bool success, ) = requestBurnerContract.call{value: _amount}("""");
        require(success, ""Transfer failed"");
    }
}","[{'function': 'collectForREQBurning', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""requestBurnerContract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

contract TokenBurner {
    address public requestBurnerContract;

    constructor(address _requestBurnerContract) {
        requestBurnerContract = _requestBurnerContract;
    }

    function burn(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        IERC20 token = IERC20(requestBurnerContract);
        require(token.transfer(address(0), _amount), ""Transfer failed"");
    }
}",42.86850929260254,burn,29.0,0.8803616422962839,0.5234165630928878,"[{'function': 'transfer', 'complexity': 0}, {'function': 'burn', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenBurner is Ownable {
    address public requestBurnerContract;

    constructor(address _requestBurnerContract) Ownable(msg.sender) {
        requestBurnerContract = _requestBurnerContract;
    }

    function burn(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        IERC20 token = IERC20(requestBurnerContract);
        require(token.transfer(address(0), _amount), ""Transfer failed"");
    }
}"
1286,Verifies a broker 's signature for an order opening .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public brokers;

    function verifyOpenSignature(address _trader, bytes memory _signature, bytes32 _orderID) external view returns (bool) {
        bytes memory data = abi.encodePacked(""Republic Protocol: open: "", _trader, _orderID);
        address signer = Utils.addr(data, _signature);
        return brokers[signer];
    }
}","[{'function': 'verifyOpenSignature', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyOpenSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_trader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Republic Protocol: open: ""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_trader""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_orderID""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""utils""}, ""memberName"": ""addr""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hash""}, {""type"": ""Identifier"", ""name"": ""_signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""brokers""}, ""index"": {""type"": ""Identifier"", ""name"": ""signer""}}, {""type"": ""stringLiteral"", ""value"": ""Signer is not a broker""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""brokers""}, ""index"": {""type"": ""Identifier"", ""name"": ""signer""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

interface Utils {
    function addr(bytes32 hash, bytes memory signature) external pure returns (address);
}

contract OrderVerifier {
    mapping(address => bool) public brokers;
    Utils public utils;

    constructor(address _utilsAddress) {
        utils = Utils(_utilsAddress);
    }

    function verifyOpenSignature(address _trader, bytes memory _signature, uint256 _orderID) public view returns (bool) {
        bytes32 hash = keccak256(abi.encodePacked(""Republic Protocol: open: "", abi.encodePacked(_trader), abi.encodePacked(_orderID)));
        address signer = utils.addr(hash, _signature);
        require(brokers[signer], ""Signer is not a broker"");
        return brokers[signer];
    }
}",43.54649138450623,verifyOpenSignature,15.0,0.7336921434975086,0.4455904874747113,"[{'function': 'addr', 'complexity': -1}, {'function': 'verifyOpenSignature', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

interface Utils {
    function addr(bytes32 hash, bytes memory signature) external pure returns (address);
}
import ""openzeppelin/SafeMath.sol"";
contract OrderVerifier is Ownable {
    mapping(address => bool) public brokers;
    Utils public utils;

    // Initialize all instance variables to fixed, safe, non-corner-case values
    address public constant DEFAULT_BROKER = 0x1111111111111111111111111111111111111111; // Replace with actual address
    uint256 public constant DEFAULT_ORDER_ID = 1;
    bytes32 public constant DEFAULT_SIGNATURE_HASH = keccak256(""init"");
    bool public constant DEFAULT_BROKER_STATUS = true;

    constructor() Ownable(msg.sender) {
        utils = Utils(DEFAULT_BROKER);
        brokers[msg.sender] = DEFAULT_BROKER_STATUS;
    }

    function verifyOpenSignature(address _trader, bytes memory _signature, uint256 _orderID) public view returns (bool) {
        bytes32 hash = keccak256(abi.encodePacked(""Republic Protocol: open: "", abi.encodePacked(_trader), abi.encodePacked(_orderID)));
        address signer = utils.addr(hash, _signature);
        require(brokers[signer], ""Signer is not a broker"");
        return brokers[signer];
    }
}"
5432,Set the minimum required havven balance to have standing to bring a motion .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public minStandingBalance;

    function setMinStandingBalance(uint balance) external onlyOwner {
        minStandingBalance = balance;
    }
}","[{'function': 'setMinStandingBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinStandingBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minStandingBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    uint public minStandingBalance;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor(uint initialMinStandingBalance) {
        owner = msg.sender;
        minStandingBalance = initialMinStandingBalance;
    }

    function setMinStandingBalance(uint balance) public onlyOwner {
        minStandingBalance = balance;
    }
}",42.455357789993286,setMinStandingBalance,0.0,0.9720556930280148,0.7611606003349892,"[{'function': 'setMinStandingBalance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint public minStandingBalance;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        _;
    }

    constructor(uint initialMinStandingBalance) Ownable(msg.sender) {
        minStandingBalance = initialMinStandingBalance;
    }

    function setMinStandingBalance(uint balance) public onlyOwner {
        minStandingBalance = balance;
    }
}"
6260,"Opens a new channel or tops up an existing one , compatibility with ERC 223 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token;
    mapping(address => bool) public trusted_contracts;

    constructor(address _token, address[] memory _trustedContracts) {
        require(_token != address(0), ""Invalid token address"");
        token = _token;
        for (uint i = 0; i < _trustedContracts.length; i++) {
            trusted_contracts[_trustedContracts[i]] = true;
        }
    }

    function createChannelPrivate(address _sender, address _receiver, uint256 _deposit) internal virtual;

    function updateInternalBalanceStructs(address _sender, address _receiver, uint32 _openBlockNumber, uint256 _deposit) internal virtual;

    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) external {
        require(msg.sender == token, ""Sender must be the token contract"");
        require(_deposit <= type(uint192).max, ""Deposit exceeds uint192 limit"");
        uint256 deposit = uint256(_deposit);
        require(deposit == _deposit, ""Deposit conversion overflow"");

        uint256 length = _data.length;
        require(length == 40 || length == 44, ""Invalid data length"");

        address channel_sender_address = addressFromBytes(_data, 0x20);
        require(_sender_address == channel_sender_address || trusted_contracts[_sender_address], ""Unauthorized sender"");

        address channel_receiver_address = addressFromBytes(_data, 0x34);
        if (length == 40) {
            createChannelPrivate(channel_sender_address, channel_receiver_address, deposit);
        } else {
            uint32 open_block_number = uint32(blockNumberFromBytes(_data, 0x48));
            updateInternalBalanceStructs(channel_sender_address, channel_receiver_address, open_block_number, deposit);
        }
    }

    function addressFromBytes(bytes memory _data, uint256 offset) internal pure returns (address addr) {
        assembly {
            addr := mload(add(_data, add(0x20, offset)))
        }
    }

    function blockNumberFromBytes(bytes memory _data, uint256 offset) internal pure returns (uint32 block_number) {
        assembly {
            block_number := mload(add(_data, add(0x48, offset)))
        }
    }
}","[{'function': 'createChannelPrivate', 'complexity': 0}, {'function': 'updateInternalBalanceStructs', 'complexity': 0}, {'function': 'tokenFallback', 'complexity': 8}, {'function': 'addressFromBytes', 'complexity': 0}, {'function': 'blockNumberFromBytes', 'complexity': 0}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenFallback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_deposit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_sender_address""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Sender must be the token contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_deposit""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint192""}], ""names"": []}, ""memberName"": ""max""}}, {""type"": ""stringLiteral"", ""value"": ""Deposit amount exceeds uint192 limit""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_data""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""40"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_data"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x14""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""receiver""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_data"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x28""}]}]}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isValidAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isValidAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receiver""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid receiver address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isTrusted"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""trustedContracts""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_sender_address""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""trustedContracts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isTrusted""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""Identifier"", ""name"": ""isTrusted""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_sender_address""}}}, {""type"": ""stringLiteral"", ""value"": ""Sender must be the channel sender or a trusted contract""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ChannelCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""receiver""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint192""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_deposit""}], ""names"": []}], ""names"": []}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_data""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""44"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""openingBlockNumber"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_data"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x14""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""receiver""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_data"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x28""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""openingBlockNumber""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_data"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x3C""}]}]}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isValidAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isValidAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receiver""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid receiver address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isTrusted"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""trustedContracts""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_sender_address""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""trustedContracts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isTrusted""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""Identifier"", ""name"": ""isTrusted""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_sender_address""}}}, {""type"": ""stringLiteral"", ""value"": ""Sender must be the channel sender or a trusted contract""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ChannelUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""receiver""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint192""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_deposit""}], ""names"": []}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Invalid data length""}], ""names"": []}}]}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PrivateChannelManager {
    // Assuming trustedContracts is an array of addresses that are allowed to call this function
    address[] public trustedContracts;

    event ChannelCreated(address indexed sender, address indexed receiver, uint192 deposit);
    event ChannelUpdated(address indexed sender, address indexed receiver, uint192 deposit);

    // Function to handle token fallback and process channel creation or update
    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) public {
        require(_sender_address == msg.sender, ""Sender must be the token contract"");
        require(_deposit <= type(uint192).max, ""Deposit amount exceeds uint192 limit"");

        if (_data.length == 40) {
            // Extract sender and receiver addresses from _data (40 bytes for channel creation)
            address sender;
            address receiver;
            assembly {
                sender := mload(add(_data, 0x14))
                receiver := mload(add(_data, 0x28))
            }
            require(isValidAddress(sender), ""Invalid sender address"");
            require(isValidAddress(receiver), ""Invalid receiver address"");

            // Check if the sender is trusted or matches the channel sender address
            bool isTrusted = false;
            for (uint i = 0; i < trustedContracts.length; i++) {
                if (_sender_address == trustedContracts[i]) {
                    isTrusted = true;
                    break;
                }
            }
            require(isTrusted || sender == _sender_address, ""Sender must be the channel sender or a trusted contract"");

            // Create new private channel
            emit ChannelCreated(sender, receiver, uint192(_deposit));
        } else if (_data.length == 44) {
            // Extract sender and receiver addresses from _data (44 bytes for channel update)
            address sender;
            address receiver;
            uint32 openingBlockNumber;
            assembly {
                sender := mload(add(_data, 0x14))
                receiver := mload(add(_data, 0x28))
                openingBlockNumber := mload(add(_data, 0x3C))
            }
            require(isValidAddress(sender), ""Invalid sender address"");
            require(isValidAddress(receiver), ""Invalid receiver address"");

            // Check if the sender is trusted or matches the channel sender address
            bool isTrusted = false;
            for (uint i = 0; i < trustedContracts.length; i++) {
                if (_sender_address == trustedContracts[i]) {
                    isTrusted = true;
                    break;
                }
            }
            require(isTrusted || sender == _sender_address, ""Sender must be the channel sender or a trusted contract"");

            // Update existing private channel
            emit ChannelUpdated(sender, receiver, uint192(_deposit));
        } else {
            revert(""Invalid data length"");
        }
    }

    function isValidAddress(address addr) internal pure returns (bool) {
        return addr != address(0);
    }
}",50.43728446960449,tokenFallback,68.0,0.6107108847413233,0.174131810796403,"[{'function': 'tokenFallback', 'complexity': 24}, {'function': 'isValidAddress', 'complexity': 0}]",18.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PrivateChannelManager is Ownable {
    // Assuming trustedContracts is an array of addresses that are allowed to call this function
    address[] public trustedContracts;

    event ChannelCreated(address indexed sender, address indexed receiver, uint192 deposit);
    event ChannelUpdated(address indexed sender, address indexed receiver, uint192 deposit);

    // Function to handle token fallback and process channel creation or update
    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) public {
        require(_sender_address == msg.sender, ""Sender must be the token contract"");
        require(_deposit <= type(uint192).max, ""Deposit amount exceeds uint192 limit"");

        if (_data.length == 40) {
            // Extract sender and receiver addresses from _data (40 bytes for channel creation)
            address sender;
            address receiver;
            assembly {
                sender := mload(add(_data, 0x14))
                receiver := mload(add(_data, 0x28))
            }
            require(isValidAddress(sender), ""Invalid sender address"");
            require(isValidAddress(receiver), ""Invalid receiver address"");

            // Check if the sender is trusted or matches the channel sender address
            bool isTrusted = false;
            for (uint i = 0; i < trustedContracts.length; i++) {
                if (_sender_address == trustedContracts[i]) {
                    isTrusted = true;
                    break;
                }
            }
            require(isTrusted || sender == _sender_address, ""Sender must be the channel sender or a trusted contract"");

            // Create new private channel
            emit ChannelCreated(sender, receiver, uint192(_deposit));
        } else if (_data.length == 44) {
            // Extract sender and receiver addresses from _data (44 bytes for channel update)
            address sender;
            address receiver;
            uint32 openingBlockNumber;
            assembly {
                sender := mload(add(_data, 0x14))
                receiver := mload(add(_data, 0x28))
                openingBlockNumber := mload(add(_data, 0x3C))
            }
            require(isValidAddress(sender), ""Invalid sender address"");
            require(isValidAddress(receiver), ""Invalid receiver address"");

            // Check if the sender is trusted or matches the channel sender address
            bool isTrusted = false;
            for (uint i = 0; i < trustedContracts.length; i++) {
                if (_sender_address == trustedContracts[i]) {
                    isTrusted = true;
                    break;
                }
            }
            require(isTrusted || sender == _sender_address, ""Sender must be the channel sender or a trusted contract"");

            // Update existing private channel
            emit ChannelUpdated(sender, receiver, uint192(_deposit));
        } else {
            revert(""Invalid data length"");
        }
    }

    function isValidAddress(address addr) internal pure returns (bool) {
        return addr != address(0);
    }
}"
3890,Transfers ETH according to the data held within the specified payment id ( internal function ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LiquidPledging {
    function confirmPayment(uint64, uint256) external;
}

struct Payment {
    uint256 amount;
    address dest;
    uint64 ref;
    PaymentStatus state;
}

enum PaymentStatus { Pending, Paid }

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    LiquidPledging public liquidPledging;
    Payment[] public payments;

    event ConfirmPayment(uint256 indexed idPayment, uint64 ref);

    function doConfirmPayment(uint256 _idPayment) external onlyOwner {
        require(_idPayment < payments.length);
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending);
        p.state = PaymentStatus.Paid;
        liquidPledging.confirmPayment(uint64(p.ref), p.amount);
        payable(p.dest).transfer(p.amount);
        emit ConfirmPayment(_idPayment, p.ref);
    }
}","[{'function': 'confirmPayment', 'complexity': 0}, {'function': 'doConfirmPayment', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""doConfirmPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""p"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentStatus""}, ""memberName"": ""Pending""}}, {""type"": ""stringLiteral"", ""value"": ""Payment is not pending""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentStatus""}, ""memberName"": ""Paid""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""liquidPledgingAddress""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""confirmPayment(uint256,address,uint256)""}, {""type"": ""Identifier"", ""name"": ""_idPayment""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""destination""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""amount""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Confirmation failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ConfirmPayment""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_idPayment""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""reference""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyValidPaymentIndex"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_idPayment""}]}, {""type"": ""ModifierInvocation"", ""name"": ""paymentIsPending"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_idPayment""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PaymentContract {
    enum PaymentStatus { Pending, Paid }

    struct Payment {
        uint id;
        address payable destination;
        uint amount;
        PaymentStatus state;
        string reference;
    }

    Payment[] public payments;
    address public liquidPledgingAddress;

    event ConfirmPayment(uint indexed paymentId, string reference);

    modifier onlyValidPaymentIndex(uint _idPayment) {
        require(_idPayment < payments.length, ""Invalid payment index"");
        _;
    }

    modifier paymentIsPending(uint _idPayment) {
        require(payments[_idPayment].state == PaymentStatus.Pending, ""Payment is not pending"");
        _;
    }

    constructor(address _liquidPledgingAddress) {
        liquidPledgingAddress = _liquidPledgingAddress;
    }

    function addPayment(uint _id, address payable _destination, uint _amount, string memory _reference) public {
        payments.push(Payment(_id, _destination, _amount, PaymentStatus.Pending));
    }

    function doConfirmPayment(uint _idPayment)
        public
        onlyValidPaymentIndex(_idPayment)
        paymentIsPending(_idPayment)
    {
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending, ""Payment is not pending"");

        // Change the state of the payment to Paid
        p.state = PaymentStatus.Paid;

        // Call the confirmPayment function on the liquidPledging contract
        (bool success, ) = liquidPledgingAddress.call(abi.encodeWithSignature(""confirmPayment(uint256,address,uint256)"", _idPayment, p.destination, p.amount));
        require(success, ""Confirmation failed"");

        // Emit the ConfirmPayment event
        emit ConfirmPayment(_idPayment, p.reference);
    }
}",46.9950065612793,doConfirmPayment,23.0,0.8714378975692314,0.1992344248802873,"[{'function': 'addPayment', 'complexity': 0}, {'function': 'doConfirmPayment', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentContract is Ownable {
    enum PaymentStatus { Pending, Paid }

    struct Payment {
        uint id;
        address payable destination;
        uint amount;
        PaymentStatus state;
        string reference;
    }

    Payment[] public payments;
    address public liquidPledgingAddress;

    event ConfirmPayment(uint indexed paymentId, string reference);

    modifier onlyValidPaymentIndex(uint _idPayment) {
        require(_idPayment < payments.length, ""Invalid payment index"");
        _;
    }

    modifier paymentIsPending(uint _idPayment) {
        require(payments[_idPayment].state == PaymentStatus.Pending, ""Payment is not pending"");
        _;
    }

    constructor(address _liquidPledgingAddress) Ownable() {
        liquidPledgingAddress = _liquidPledgingAddress;
        // Initialize state variables with safe, non-corner-case values
        uint placeholderValue = 1; // Use a fixed value for uint256
        address payable firstAddress = payable(address(uint160(uint256(keccak256('first')))));
        bool isTrue = true;
        string memory initializedString = 'initialized';
        bytes32 initBytes = bytes32('init');
    }

    function addPayment(uint _id, address payable _destination, uint _amount, string memory _reference) public {
        payments.push(Payment(_id, _destination, _amount, PaymentStatus.Pending, _reference));
    }

    function doConfirmPayment(uint _idPayment)
        public
        onlyValidPaymentIndex(_idPayment)
        paymentIsPending(_idPayment)
    {
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending, ""Payment is not pending"");

        // Change the state of the payment to Paid
        p.state = PaymentStatus.Paid;

        // Call the confirmPayment function on the liquidPledging contract
        (bool success, ) = liquidPledgingAddress.call(abi.encodeWithSignature(""confirmPayment(uint256,address,uint256)"", _idPayment, p.destination, p.amount));
        require(success, ""Confirmation failed"");

        // Emit the ConfirmPayment event
        emit ConfirmPayment(_idPayment, p.reference);
    }
}"
3719,only the admin is allowed to change the admin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public admin;

    event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);

    modifier validate_address(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    function changeAdmin(address newAdmin) public validate_address(newAdmin) onlyOwner {
        if (admin == newAdmin) revert();
        emit AdminOwnershipTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}","[{'function': 'changeAdmin', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newAdmin""}, ""right"": {""type"": ""Identifier"", ""name"": ""admin""}}, {""type"": ""stringLiteral"", ""value"": ""The new admin is the same as the current admin""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldAdmin"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""admin""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""admin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAdmin""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AdminOwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldAdmin""}, {""type"": ""Identifier"", ""name"": ""newAdmin""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validate_address"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""newAdmin""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AdminContract {
    address public admin;

    event AdminOwnershipTransferred(address indexed oldAdmin, address indexed newAdmin);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only the current admin can call this function"");
        _;
    }

    modifier validate_address(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    constructor(address initialAdmin) {
        admin = initialAdmin;
    }

    function changeAdmin(address newAdmin) public validate_address(newAdmin) {
        require(newAdmin != admin, ""The new admin is the same as the current admin"");
        address oldAdmin = admin;
        admin = newAdmin;
        emit AdminOwnershipTransferred(oldAdmin, newAdmin);
    }
}",43.41410446166992,changeAdmin,15.0,0.8755215686947847,0.3581883824640628,"[{'function': 'changeAdmin', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AdminContract is Ownable {
    address public admin;

    event AdminOwnershipTransferred(address indexed oldAdmin, address indexed newAdmin);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only the current admin can call this function"");
        _;
    }

    modifier validate_address(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    constructor(address initialAdmin) Ownable(initialAdmin) {
        admin = initialAdmin;
    }

    function changeAdmin(address newAdmin) public validate_address(newAdmin) {
        require(newAdmin != admin, ""The new admin is the same as the current admin"");
        address oldAdmin = admin;
        admin = newAdmin;
        emit AdminOwnershipTransferred(oldAdmin, newAdmin);
    }
}"
4898,Announces intent to withdraw tokens using ` slowWithdraw `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AnnounceWithdrawalWrapper is Ownable {
    using SafeMath for uint256;

    struct AnnouncedWithdrawal {
        uint256 canWithdrawAt;
        uint256 amount;
    }

    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;
    uint256 public withdrawAnnounceDelay;

    constructor(uint256 _withdrawAnnounceDelay) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }

    function announceWithdraw(address _token, uint256 _amount) external onlyOwner {
        require(_amount <= balances[msg.sender][_token], ""Amount too high"");
        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];
        uint256 canWithdrawAt = block.timestamp + withdrawAnnounceDelay;
        announcement.canWithdrawAt = canWithdrawAt;
        announcement.amount = _amount;
        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
    }
}","[{'function': 'announceWithdraw', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""announceWithdrawal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to announce withdrawal""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""canWithdrawAt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""withdrawAnnounceDelay""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""announcedWithdrawals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WithdrawalAnnouncement""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""canWithdrawAt""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": [""canWithdrawAt"", ""amount""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WithdrawAnnounce""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""canWithdrawAt""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenWithdrawer {
    struct WithdrawalAnnouncement {
        uint256 canWithdrawAt;
        uint256 amount;
    }

    mapping(address => mapping(address => WithdrawalAnnouncement)) public announcedWithdrawals;
    uint256 public withdrawAnnounceDelay;

    event WithdrawAnnounce(address indexed user, address indexed token, uint256 amount, uint256 canWithdrawAt);

    constructor(uint256 _withdrawAnnounceDelay) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }

    function announceWithdrawal(address _token, uint256 _amount) external {
        require(_amount <= IERC20(_token).balanceOf(msg.sender), ""Insufficient balance to announce withdrawal"");

        uint256 canWithdrawAt = block.timestamp + withdrawAnnounceDelay;
        announcedWithdrawals[msg.sender][_token] = WithdrawalAnnouncement({canWithdrawAt: canWithdrawAt, amount: _amount});

        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
    }
}",45.000892162323,announceWithdrawal,25.0,0.8069691545058765,0.4219430593333205,"[{'function': 'transfer', 'complexity': 0}, {'function': 'announceWithdrawal', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenWithdrawer {
    struct WithdrawalAnnouncement {
        uint256 canWithdrawAt;
        uint256 amount;
    }

    mapping(address => mapping(address => WithdrawalAnnouncement)) public announcedWithdrawals;
    uint256 public withdrawAnnounceDelay;

    event WithdrawAnnounce(address indexed user, address indexed token, uint256 amount, uint256 canWithdrawAt);

    mapping(address => uint256) public balanceOf;

 constructor(uint256 _withdrawAnnounceDelay) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }

    function announceWithdrawal(address _token, uint256 _amount) external {
        require(_amount <= IERC20(_token).balanceOf(msg.sender), ""Insufficient balance to announce withdrawal"");

        uint256 canWithdrawAt = block.timestamp + withdrawAnnounceDelay;
        announcedWithdrawals[msg.sender][_token] = WithdrawalAnnouncement({canWithdrawAt: canWithdrawAt, amount: _amount});

        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
    }
}"
2359,Count the number of attribute types defined by the registry .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeCounter {
    using SafeMath for uint256;

    uint256[] private _attributeTypes;

    function countAttributeTypes() external view returns (uint256) {
        return _attributeTypes.length;
    }
}","[{'function': 'countAttributeTypes', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""countAttributeTypes"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AttributeTracker {
    // Define a mapping to store unique attribute types
    mapping(bytes32 => bool) private attributeTypes;

    // Function to count the total number of unique attribute types
    function countAttributeTypes() public view returns (uint256) {
        return attributeTypes.length;
    }
}",42.06180024147034,countAttributeTypes,0.0,0.9725519128126,0.6298129992394241,"[{'function': 'countAttributeTypes', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttributeTracker is Ownable {
    // Define a mapping to store unique attribute types
    mapping(bytes32 => bool) private attributeTypes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        attributeTypes[bytes32('init')] = true;
    }

    // Function to count the total number of unique attribute types
    function countAttributeTypes() public view returns (uint256) {
        return attributeTypes.length;
    }
}"
239,Register a new child universe after a fork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IUniverse {
    function getWinningChildUniverse() external view returns (address);
}

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'getWinningChildUniverse', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""initialize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""initialized""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract UniverseManager {
    address public owner;
    bool public initialized = false;
    uint256 public latest_universe;

    modifier onlyInitialized() {
        require(initialized, ""Contract not initialized"");
        _;
    }

    function initialize() public {
        owner = msg.sender;
        initialized = true;
    }

    function getWinningChildUniverse(uint256 universe) internal view returns (uint256) {
        // Placeholder for the logic to retrieve the winning child universe
        // This should be implemented based on the actual business logic of your application
        return 0; // Example placeholder, replace with actual implementation
    }

    function pose() public onlyInitialized {
        uint256 winningChild = getWinningChildUniverse(latest_universe);
        latest_universe = winningChild;
    }
}",43.54512453079224,getWinningChildUniverse,28.0,0.4209635219812122,0.0064861557883338,"[{'function': 'initialize', 'complexity': 0}, {'function': 'getWinningChildUniverse', 'complexity': 0}, {'function': 'pose', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract UniverseManager is Ownable {
    bool public initialized = false;
    uint256 public latest_universe;

    modifier onlyInitialized() {
        require(initialized, ""Contract not initialized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        initialized = true;
        latest_universe = 1; // Set to a non-zero value
    }

    function getWinningChildUniverse(uint256 universe) internal view returns (uint256) {
        // Placeholder for the logic to retrieve the winning child universe
        // This should be implemented based on the actual business logic of your application
        return 0; // Example placeholder, replace with actual implementation
    }

    function pose() public onlyInitialized {
        uint256 winningChild = getWinningChildUniverse(latest_universe);
        latest_universe = winningChild;
    }
}"
4301,` callPlugins ` calls ` callPluginsPledge ` once for the transfer context and once for the receiving context .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint amount) internal returns (uint allowedAmount) {
        allowedAmount = amount;
        allowedAmount = callPluginsPledge(before, fromPledge, fromPledge, toPledge, allowedAmount);
        allowedAmount = callPluginsPledge(before, toPledge, fromPledge, toPledge, allowedAmount);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'callPlugins', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""callPlugins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""before"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""fromPledge"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""toPledge"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""allowedAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_callPluginsPledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fromPledge""}, {""type"": ""Identifier"", ""name"": ""fromPledge""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Failed to process plugin call for ""from"" pledge""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_callPluginsPledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""toPledge""}, {""type"": ""Identifier"", ""name"": ""toPledge""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Failed to process plugin call for ""to"" pledge""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PledgeManager {
    uint public allowedAmount;

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint amount) external {
        allowedAmount = amount;

        // Assuming callPluginsPledge is a function that can be called with the pledge identifiers and possibly other parameters.
        require(_callPluginsPledge(fromPledge, fromPledge), ""Failed to process plugin call for 'from' pledge"");
        require(_callPluginsPledge(toPledge, toPledge), ""Failed to process plugin call for 'to' pledge"");
    }

    function _callPluginsPledge(uint64 pledgeId, uint64 otherPledgeId) internal returns (bool) {
        // Placeholder logic for the internal call. This should be implemented based on actual requirements of the plugins.
        return true; // Assuming all calls are successful for simplicity.
    }
}",43.83251929283142,callPlugins,24.0,0.570621481971249,0.0213908431401124,"[{'function': 'callPlugins', 'complexity': 2}, {'function': '_callPluginsPledge', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PledgeManager is Ownable {
    uint public allowedAmount;

    constructor() Ownable(msg.sender) {
        allowedAmount = 1; // Set to a non-zero, safe value for uint
    }

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint amount) external {
        allowedAmount = amount;

        require(_callPluginsPledge(fromPledge, fromPledge), ""Failed to process plugin call for 'from' pledge"");
        require(_callPluginsPledge(toPledge, toPledge), ""Failed to process plugin call for 'to' pledge"");
    }

    function _callPluginsPledge(uint64 pledgeId, uint64 otherPledgeId) internal returns (bool) {
        return true; // Assuming all calls are successful for simplicity.
    }
}"
2476,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed user, uint256 value);

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;

        emit Burn(msg.sender, _value);
        return true;
    }
}",43.22731947898865,burn,9.0,0.7948648078541071,0.6280519500667606,"[{'function': 'burn', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed user, uint256 value);

    constructor() Ownable(msg.sender) {
        balanceOf[owner()] = 1; // Initialize the owner's balance to 1
        totalSupply = 1000000000000000000; // Initialize total supply to 1
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");

        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;

        emit Burn(msg.sender, _value);
        return true;
    }
}"
2621,Only registrations in future can be removed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function unregister(
        bytes32 _key,
        address _address,
        uint _timestamp,
        uint _gasLimit,
        uint _gasPrice
    ) external returns (uint) {
        // Function body here
    }
}","[{'function': 'unregister', 'complexity': 0}]",1.0,{},"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract UnregisterFunction {
    event Unregistered(bytes32 indexed key, address indexed address, uint timestamp);

    function unregisterAddress(bytes32 _key, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) external {
        require(msg.sender != address(0), ""Invalid caller address"");
        require(_gasLimit > 0 && _gasPrice > 0, ""Gas limit and gas price must be greater than zero"");

        // Additional checks can be added here if needed (e.g., timestamp constraints)

        emit Unregistered(_key, _address, _timestamp);
    }
}",43.57411599159241,unregisterAddress,0.0,0.6072455983813982,0.2093551469484865,"[{'function': 'unregisterAddress', 'complexity': 3}]",4.0,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract UnregisterFunction is Ownable {
    event Unregistered(bytes32 indexed key, address indexed address, uint timestamp);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function unregisterAddress(bytes32 _key, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) external {
        require(msg.sender != address(0), ""Invalid caller address"");
        require(_gasLimit > 0 && _gasPrice > 0, ""Gas limit and gas price must be greater than zero"");

        // Additional checks can be added here if needed (e.g., timestamp constraints)

        emit Unregistered(_key, _address, _timestamp);
    }
}"
2632,the goal the campaign must reach in order for it to succeed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Crowdfunding {
    using SafeMath for uint256;

    uint256 public totalAmountRaised;

    function amountRaised() public view returns (uint256) {
        return totalAmountRaised;
    }
}","[{'function': 'amountRaised', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""amountRaised"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""amount""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Crowdfunding {
    uint256 public amount;

    function amountRaised() external view returns (uint256) {
        return amount;
    }
}",41.44529724121094,amountRaised,0.0,0.925120410503023,0.6298129992394241,"[{'function': 'amountRaised', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Crowdfunding is Ownable {
    uint256 public amount = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function amountRaised() external view returns (uint256) {
        return amount;
    }
}"
827,approving image to be taken from specific address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract MarketplaceWrapper is Ownable {
    using SafeMath for uint256;

    address public marketplaceContract;

    constructor(address _marketplaceContract) {
        require(_marketplaceContract != address(0), ""Invalid marketplace contract address"");
        marketplaceContract = _marketplaceContract;
    }

    function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyOwner {
        require(msg.sender == marketplaceContract, ""Only the marketplace contract can call this function"");
        require(isApprovedOrOwner(_from, _imageId), ""The token is not approved or owned by the sender"");
        clearApproval(_from, _imageId);
        removeTokenFrom(_from, _imageId);
        addTokenTo(_to, _imageId);
        emit Transfer(_from, _to, _imageId);
    }
}","[{'function': 'transferFromMarketplace', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFromMarketplace"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_imageId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isApprovedOrOwner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""The caller is not approved or the owner of the image""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_from""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getApproved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldOwner""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""removeTokenFromOwner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldOwner""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""addTokenToOwner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldOwner""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_imageId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyMarketplaceContract"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Marketplace {
    // Define the marketplace contract address
    address private _marketplaceContract;

    // Constructor to set the marketplace contract address
    constructor(address marketplace) {
        _marketplaceContract = marketplace;
    }

    // Modifier to ensure only the marketplace contract can call this function
    modifier onlyMarketplaceContract() {
        require(msg.sender == _marketplaceContract, ""Only the marketplace contract can call this function"");
        _;
    }

    // Function to transfer an image from one address to another within the marketplace
    function transferFromMarketplace(address _from, address _to, uint256 _imageId) external onlyMarketplaceContract {
        require(_isApprovedOrOwner(_from, msg.sender, _imageId), ""The caller is not approved or the owner of the image"");

        // Clear any existing approval for the image from the current owner
        address oldOwner = _from;
        delete getApproved(oldOwner, _imageId);

        // Remove the image from the list of tokens owned by the current owner
        removeTokenFromOwner(oldOwner, _imageId);

        // Add the image to the list of tokens owned by the new owner
        addTokenToOwner(_to, _imageId);

        // Emit a Transfer event with details of the transfer
        emit Transfer(oldOwner, _to, _imageId);
    }

    // Placeholder for getApproved function (assuming it exists in some contract)
    function getApproved(address owner, uint256 tokenId) internal pure returns (address) {
        return address(0); // Placeholder implementation
    }

    // Placeholder for removeTokenFromOwner function (assuming it exists in some contract)
    function removeTokenFromOwner(address owner, uint256 tokenId) internal {
        // Implementation to remove the token from the owner's list
    }

    // Placeholder for addTokenToOwner function (assuming it exists in some contract)
    function addTokenToOwner(address owner, uint256 tokenId) internal {
        // Implementation to add the token to the new owner's list
    }

    // Event emitted when a transfer occurs
    event Transfer(address from, address to, uint256 imageId);
}",47.512272357940674,transferFromMarketplace,12.0,0.9008269925075204,0.2931510548816473,"[{'function': 'transferFromMarketplace', 'complexity': 1}, {'function': 'getApproved', 'complexity': 0}, {'function': 'removeTokenFromOwner', 'complexity': 0}, {'function': 'addTokenToOwner', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Marketplace is Ownable {
    // Define the marketplace contract address
    address private _marketplaceContract;

    // Constructor to set the marketplace contract address
    constructor(address marketplace) Ownable(msg.sender) {
        _marketplaceContract = marketplace;
    }

    // Modifier to ensure only the marketplace contract can call this function
    modifier onlyMarketplaceContract() {
        require(msg.sender == _marketplaceContract, ""Only the marketplace contract can call this function"");
        _;
    }

    // Function to transfer an image from one address to another within the marketplace
    function transferFromMarketplace(address _from, address _to, uint256 _imageId) external onlyMarketplaceContract {
        require(_isApprovedOrOwner(_from, msg.sender, _imageId), ""The caller is not approved or the owner of the image"");

        // Clear any existing approval for the image from the current owner
        address oldOwner = _from;
        delete getApproved(oldOwner, _imageId);

        // Remove the image from the list of tokens owned by the current owner
        removeTokenFromOwner(oldOwner, _imageId);

        // Add the image to the list of tokens owned by the new owner
        addTokenToOwner(_to, _imageId);

        // Emit a Transfer event with details of the transfer
        emit Transfer(oldOwner, _to, _imageId);
    }

    // Placeholder for getApproved function (assuming it exists in some contract)
    function getApproved(address owner, uint256 tokenId) internal pure returns (address) {
        return address(0); // Placeholder implementation
    }

    // Placeholder for removeTokenFromOwner function (assuming it exists in some contract)
    function removeTokenFromOwner(address owner, uint256 tokenId) internal {
        // Implementation to remove the token from the owner's list
    }

    // Placeholder for addTokenToOwner function (assuming it exists in some contract)
    function addTokenToOwner(address owner, uint256 tokenId) internal {
        // Implementation to add the token to the new owner's list
    }

    // Event emitted when a transfer occurs
    event Transfer(address from, address to, uint256 imageId);
}"
3458,"http : //solidity.readthedocs.io/en/develop/contracts.html # fallback-function we dont need recieve ETH always , only in State.Sale from externally accounts .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum State { Sale, Paused }
    State public currentState = State.Sale;

    function byTokens() internal view virtual;

    modifier atState(State state) {
        require(currentState == state, ""Not in the correct state"");
        _;
    }

    function () external payable atState(State.Sale) {
        byTokens();
    }
}","[{'function': 'byTokens', 'complexity': 0}, {'function': '', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""purchaseTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""byTokens""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""atState"", ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""State""}, ""memberName"": ""Sale""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract TokenSale {
    enum State { Sale, Paused }
    State public currentState = State.Sale;

    modifier atState(State state) {
        require(currentState == state, ""Invalid state for this operation"");
        _;
    }

    function purchaseTokens() external payable atState(State.Sale) {
        byTokens();
    }

    function byTokens() internal {
        // Logic to modify state variables related to token purchases
    }
}",42.370485067367554,purchaseTokens,,0.951396717062517,0.8761560783209453,"[{'function': 'purchaseTokens', 'complexity': 0}, {'function': 'byTokens', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    enum State { Sale, Paused }
    State public currentState = State.Sale;

    modifier atState(State state) {
        require(currentState == state, ""Invalid state for this operation"");
        _;
    }

    function purchaseTokens() external payable atState(State.Sale) {
        byTokens();
    }

    function byTokens() internal {
        // Logic to modify state variables related to token purchases
    }
}"
5648,Creates a checkpoint that can be used to query historical balances / totalSuppy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CheckpointModule is Ownable {
    using SafeMath for uint256;

    event LogCheckpointCreated(uint256 indexed checkpointId, uint256 timestamp);

    uint256 public currentCheckpointId = 0;
    constanst CHECKPOINT_KEY = bytes32(""CHECKPOINT_KEY"");

    modifier onlyModule(bytes32 moduleKey, bool allowed) {
        require(moduleKey == CHECKPOINT_KEY && allowed, ""Only the module can call this function."");
        _;
    }

    function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns (uint256) {
        require(currentCheckpointId < type(uint256).max.sub(1));
        currentCheckpointId = currentCheckpointId.add(1);
        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
        return currentCheckpointId;
    }
}","[{'function': 'createCheckpoint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCheckpoint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Checkpoint ID would overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, ""isPrefix"": False}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogCheckpointCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentCheckpointId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract CheckpointTracker {
    uint256 public currentCheckpointId = 0;

    event LogCheckpointCreated(uint256 indexed checkpointId, uint256 timestamp);

    function createCheckpoint() external {
        require(currentCheckpointId < type(uint256).max - 1, ""Checkpoint ID would overflow"");

        currentCheckpointId++;

        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
    }
}",42.25123310089111,createCheckpoint,15.0,0.6847334891670875,0.3522058714748809,"[{'function': 'createCheckpoint', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CheckpointTracker is Ownable {
    uint256 public currentCheckpointId = 1; // Set to 1 (never 0)

    event LogCheckpointCreated(uint256 indexed checkpointId, uint256 timestamp);

    constructor() Ownable(msg.sender) {
        // No need to initialize other variables as they are already set correctly in their declarations.
    }

    function createCheckpoint() external {
        require(currentCheckpointId < type(uint256).max - 1, ""Checkpoint ID would overflow"");

        currentCheckpointId++;

        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
    }
}"
5200,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Invalid value"");
        require(msg.sender == _from || msg.sender == _to, ""Only the sender or recipient can call this function"");

        uint256 fromBalance = balanceOf[_from];
        require(_value <= fromBalance, ""Insufficient funds"");
        balanceOf[_from] = fromBalance.sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Allowance insufficient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    uint256 public totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(allowed[_from][msg.sender] >= _value, ""Allowance insufficient"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }
}",44.00729775428772,transferFrom,33.0,0.8123286280526574,0.3542183459993809,"[{'function': 'transferFrom', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    uint256 public totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        balances[msg.sender] = 1000; // Initial balance for the owner
        totalSupply = 1000000000000000000; // Total supply set to 1
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(balances[_from] >= _value, ""Insufficient balance"");
        require(allowed[_from][msg.sender] >= _value, ""Allowance insufficient"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }
}"
5602,Allows the owner to destroy the contract and return the tokens to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for IERC20;
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function destroy() public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");
        token.transfer(owner(), balance);
        selfdestruct(payable(owner()));
    }
}","[{'function': 'destroy', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract DestroyContract is Ownable {
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function destroy() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Token transfer failed"");
        selfdestruct(payable(owner()));
    }
}",43.00785183906555,destroy,10.0,0.9625087918917076,0.6978272351322288,"[{'function': 'destroy', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DestroyContract is Ownable {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    function destroy() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Token transfer failed"");
        selfdestruct(payable(owner()));
    }
}"
1932,Called to obtain the loyalty reward balance of any given member,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 stakeBalance;
        uint256 previouslyAppliedLoyaltyBalance;
    }

    mapping(address => Member) public members;
    uint256 public loyaltyPeriodDays;
    uint256 public loyaltyRewardAmount;

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256 loyaltyReward) {
        require(members[memberAddress].startOfLoyaltyRewardEligibility != 0, ""Member not eligible for loyalty rewards"");
        uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;
        Member storage thisMember = members[memberAddress];
        uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;
        loyaltyReward = thisMember.previouslyAppliedLoyaltyBalance;
        if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {
            uint256 numWholePeriods = elapsedTimeSinceEligible / loyaltyPeriodSeconds;
            uint256 rewardForEachPeriod = thisMember.stakeBalance * loyaltyRewardAmount / 100;
            loyaltyReward += rewardForEachPeriod * numWholePeriods;
        }
    }
}","[{'function': 'getLoyaltyRewardBalance', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLoyaltyRewardBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""memberAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""loyaltyReward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Member""}, ""name"": ""member"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""memberAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""member""}, ""memberName"": ""startOfLoyaltyRewardEligibility""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Member not eligible for rewards""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSecondsInPeriod"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""loyaltyPeriodDays""}, ""right"": {""type"": ""Identifier"", ""name"": ""SECONDS_IN_DAY""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""elapsedTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""member""}, ""memberName"": ""startOfLoyaltyRewardEligibility""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSecondsInPeriod""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""wholePeriodsPassed"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""elapsedTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSecondsInPeriod""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""loyaltyReward""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""member""}, ""memberName"": ""stakeBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""loyaltyRewardAmount""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""wholePeriodsPassed""}}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""loyaltyReward""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""member""}, ""memberName"": ""previouslyAppliedLoyaltyBalance""}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract LoyaltyRewards {
    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 previouslyAppliedLoyaltyBalance;
        uint256 stakeBalance;
    }

    mapping(address => Member) public members;
    uint256 public loyaltyPeriodDays;
    uint256 public constant SECONDS_IN_DAY = 86400;
    uint256 public loyaltyRewardAmount; // in percentage points (e.g., 10% is 10)

    constructor(uint256 _loyaltyPeriodDays, uint256 _loyaltyRewardAmount) {
        loyaltyPeriodDays = _loyaltyPeriodDays;
        loyaltyRewardAmount = _loyaltyRewardAmount;
    }

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256 loyaltyReward) {
        Member storage member = members[memberAddress];
        require(member.startOfLoyaltyRewardEligibility > 0, ""Member not eligible for rewards"");

        uint256 totalSecondsInPeriod = loyaltyPeriodDays * SECONDS_IN_DAY;
        uint256 elapsedTime = block.timestamp - member.startOfLoyaltyRewardEligibility;

        if (elapsedTime >= totalSecondsInPeriod) {
            uint256 wholePeriodsPassed = elapsedTime / totalSecondsInPeriod;
            loyaltyReward = member.stakeBalance * loyaltyRewardAmount / 100 * wholePeriodsPassed;
        } else {
            loyaltyReward = member.previouslyAppliedLoyaltyBalance;
        }
    }
}",46.07111930847168,getLoyaltyRewardBalance,21.0,0.886916698217873,0.3739756099066731,"[{'function': 'getLoyaltyRewardBalance', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoyaltyRewards is Ownable {
    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 previouslyAppliedLoyaltyBalance;
        uint256 stakeBalance;
    }

    mapping(address => Member) public members;
    uint256 public loyaltyPeriodDays;
    uint256 public constant SECONDS_IN_DAY = 86400;
    uint256 public loyaltyRewardAmount; // in percentage points (e.g., 10% is 10)

    constructor(uint256 _loyaltyPeriodDays, uint256 _loyaltyRewardAmount) Ownable(msg.sender) {
        loyaltyPeriodDays = _loyaltyPeriodDays;
        loyaltyRewardAmount = _loyaltyRewardAmount;
    }

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256 loyaltyReward) {
        Member storage member = members[memberAddress];
        require(member.startOfLoyaltyRewardEligibility > 0, ""Member not eligible for rewards"");

        uint256 totalSecondsInPeriod = loyaltyPeriodDays * SECONDS_IN_DAY;
        uint256 elapsedTime = block.timestamp - member.startOfLoyaltyRewardEligibility;

        if (elapsedTime >= totalSecondsInPeriod) {
            uint256 wholePeriodsPassed = elapsedTime / totalSecondsInPeriod;
            loyaltyReward = member.stakeBalance * loyaltyRewardAmount / 100 * wholePeriodsPassed;
        } else {
            loyaltyReward = member.previouslyAppliedLoyaltyBalance;
        }
    }
}"
4568,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfersEnabled() external view returns (bool);
    function doTransfer(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
    }

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(token.transfersEnabled(), ""Transfers are disabled"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        return token.doTransfer(msg.sender, _to, _amount);
    }
}","[{'function': 'doTransfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""doTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    bool public transfersEnabled = true; // Default to enabled for simplicity

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal returns (bool success) {
        // Implement the actual transfer logic here
        // This is a placeholder for where you would implement your token transfer logic
        require(balanceOf(from) >= amount, ""Insufficient balance"");
        balances[from] -= amount;
        balances[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }

    mapping(address => uint256) public balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",44.18627405166626,doTransfer,22.0,0.7913895617671098,0.1179874979501843,"[{'function': 'transfer', 'complexity': 1}, {'function': 'doTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    bool public transfersEnabled = true; // Default to enabled for simplicity
    mapping(address => uint256) public balances;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        transfersEnabled = true;
        balances[owner()] = 1; // Set balance of owner to 1
        balances[address(0x111)] = 1; // Set balance of first address to 1
        balances[address(0x222)] = 1; // Set balance of second address to 1
    }

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal returns (bool success) {
        // Implement the actual transfer logic here
        require(balanceOf(from) >= amount, ""Insufficient balance"");
        balances[from] -= amount;
        balances[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}"
5799,Set the contract address of the rent auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RentAuction {
    function isRentAuction() external view returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    RentAuction public rentAuctionContract;

    function setRentAuctionContractAddress(address _address) external onlyOwner {
        RentAuction _contract = RentAuction(_address);
        require(_contract.isRentAuction());
        rentAuctionContract = _contract;
    }
}","[{'function': 'isRentAuction', 'complexity': 0}, {'function': 'setRentAuctionContractAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRentAuctionAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""RentAuction""}, ""name"": ""newRentAuction"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RentAuction""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newRentAuction""}, ""memberName"": ""isRentAuction""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Provided address is not a valid Rent Auction contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""rentAuctionContract""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRentAuction""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""./Ownable.sol""; // Assuming you have an Ownable contract for ownership management

contract RentAuction {
    function isRentAuction() public pure returns (bool) {
        return true; // Placeholder implementation, should be replaced with actual logic
    }
}

contract RentalContractManager is Ownable {
    RentAuction private rentAuctionContract;

    function setRentAuctionAddress(address _address) external onlyOwner {
        require(_address != address(0), ""Invalid address"");

        // Assuming the RentAuction contract has a method to verify itself
        RentAuction newRentAuction = RentAuction(_address);
        require(newRentAuction.isRentAuction(), ""Provided address is not a valid Rent Auction contract"");

        rentAuctionContract = newRentAuction;
    }
}",43.40039873123169,setRentAuctionAddress,10.0,0.8264120152637493,0.250882103436531,"[{'function': 'isRentAuction', 'complexity': 0}, {'function': 'setRentAuctionAddress', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""./Ownable.sol""; // Assuming you have an Ownable contract for ownership management
import ""openzeppelin/SafeMath.sol"";
contract RentAuction {
    function isRentAuction() public pure returns (bool) {
        return true; // Placeholder implementation, should be replaced with actual logic
    }
}
import ""openzeppelin/SafeMath.sol"";
contract RentalContractManager is Ownable {
    RentAuction private rentAuctionContract;

    constructor(address _rentAuctionAddress) {
        require(_rentAuctionAddress != address(0), ""Invalid address"");

        // Assuming the RentAuction contract has a method to verify itself
        RentAuction newRentAuction = RentAuction(_rentAuctionAddress);
        require(newRentAuction.isRentAuction(), ""Provided address is not a valid Rent Auction contract"");

        rentAuctionContract = newRentAuction;
    }

    function setRentAuctionAddress(address _address) external onlyOwner {
        require(_address != address(0), ""Invalid address"");

        // Assuming the RentAuction contract has a method to verify itself
        RentAuction newRentAuction = RentAuction(_address);
        require(newRentAuction.isRentAuction(), ""Provided address is not a valid Rent Auction contract"");

        rentAuctionContract = newRentAuction;
    }
}"
694,Withdraw any accumulated fees to the specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for address;

    function withdraw(address payable addr) public onlyOwner {
        uint256 balance = address(this).balance;
        addr.transfer(balance);
    }
}","[{'function': 'withdraw', 'complexity': 0}]",1.0,{},"pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Withdrawable is Ownable {
    function withdrawFunds(address payable addr) public onlyOwner {
        uint256 balance = address(this).balance;
        (bool success, ) = addr.call{value: balance}("""");
        require(success, ""Transfer failed."");
    }
}",44.08309531211853,transferOwnership,18.0,0.6909781832342718,0.095178892383286,"[{'function': 'owner', 'complexity': 0}, {'function': 'transferOwnership', 'complexity': 1}, {'function': 'withdrawFunds', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Withdrawable is Ownable {
    function withdrawFunds(address payable addr) public onlyOwner {
        uint256 balance = address(this).balance;
        (bool success, ) = addr.call{value: balance}("""");
        require(success, ""Transfer failed."");
    }
}"
6751,Returns the amount of tokens approved by the owner that can be transferred to the spender 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance (address tokenOwner, address spender) public view returns (uint remaining) {
    return allowed[tokenOwner][spender];
}
}","[{'function': 'allowance ', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowances;

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowances[_owner][_spender];
    }
}",41.61079406738281,allowance,0.0,0.9114674838187408,0.3915926973299294,"[{'function': 'allowance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        allowances[address(0x111)][address(0x222)] = 1;
        allowances[address(0x222)][address(0x333)] = 1;
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowances[_owner][_spender];
    }
}"
2680,Assigns bonus tokens to the specific contributor .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BonusAssignment {
    using SafeMath for uint256;

    uint256 public bonusProvided;
    mapping(address => uint256) public bonusHolders;

    event BonusAssigned(address indexed investor, uint256 bonus);

    function assignBonus(address _investor, uint256 _bonus) internal {
        if (_bonus == 0) {
            return;
        }
        bonusProvided = bonusProvided.add(_bonus);
        bonusHolders[_investor] = bonusHolders[_investor].add(_bonus);
        emit BonusAssigned(_investor, _bonus);
    }
}","[{'function': 'assignBonus', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""assignBonus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_investor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_bonus"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_bonus""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Bonus must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""bonusProvided""}, ""right"": {""type"": ""Identifier"", ""name"": ""_bonus""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bonusHolders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_investor""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_bonus""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BonusAssigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_investor""}, {""type"": ""Identifier"", ""name"": ""_bonus""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract BonusAssignment {
    uint public bonusProvided;
    mapping(address => uint) public bonusHolders;

    event BonusAssigned(address indexed investor, uint amount);

    function assignBonus(address _investor, uint _bonus) external {
        require(_bonus > 0, ""Bonus must be greater than zero"");

        bonusProvided += _bonus;
        bonusHolders[_investor] += _bonus;

        emit BonusAssigned(_investor, _bonus);
    }
}",42.36477899551392,assignBonus,12.0,0.6700013543475963,0.3400746271486868,"[{'function': 'assignBonus', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BonusAssignment is Ownable {
    uint public bonusProvided = 1;
    mapping(address => uint) public bonusHolders;

    event BonusAssigned(address indexed investor, uint amount);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe non-corner-case values
        bonusProvided = 1;
        for (uint i = 0; i < 3; i++) {
            if (i == 0) bonusHolders[address(0x111)] = 1;
            else if (i == 1) bonusHolders[address(0x222)] = 1;
            else if (i == 2) bonusHolders[address(0x333)] = 1;
        }
    }

    function assignBonus(address _investor, uint _bonus) external {
        require(_bonus > 0, ""Bonus must be greater than zero"");

        bonusProvided += _bonus;
        bonusHolders[_investor] += _bonus;

        emit BonusAssigned(_investor, _bonus);
    }
}"
3939,"Change the address of the registryAdmin , who has the privilege to create new accounts","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public registryAdmin;

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}","[{'function': 'setRegistryAdmin', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRegistryAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newRegistryAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_oldRegistryAdmin"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""registryAdmin""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""registryAdmin""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newRegistryAdmin""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address public registryAdmin;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address initialRegistryAdmin) {
        registryAdmin = initialRegistryAdmin;
    }

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}",42.28540015220642,setRegistryAdmin,0.0,1.0,1.0,"[{'function': 'setRegistryAdmin', 'complexity': 0}]",7.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public owner;
    address public registryAdmin;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor(address initialRegistryAdmin) {
        owner = msg.sender;
        registryAdmin = initialRegistryAdmin;
    }

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}"
3322,"Returns the contribution to be used as part of the transaction , and any refund value if expected .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Contribution {
        uint256 amount;
        bool processed;
    }

    mapping(address => Contribution) public contributions;
    uint256 public preSaleCap;

    event PresaleCapUpdated(uint256 newCap);
    event AllowedContributionCheck(uint256 allowedContribution, AllowedContributionState state);

    enum AllowedContributionState { WhitelistClosed, Whitelisted }

    function processContribution() public isValidContribution returns (uint256, uint256) {
        if (!honourWhitelist()) {
            var (allowedContribution, refundAmount) = getAllowedContribution();
            AllowedContributionCheck(allowedContribution, AllowedContributionState.WhitelistClosed);
            preSaleCap = preSaleCap.sub(allowedContribution);
            PresaleCapUpdated(preSaleCap);
            return (allowedContribution, refundAmount);
        }

        var (whiteListedAllowedContribution, whiteListedRefundAmount) = getAllowedContribution();
        if (whitelist[msg.sender] > 0) {
            return processWhitelistedContribution(whiteListedAllowedContribution, whiteListedRefundAmount);
        }

        revert();
    }

    function isValidContribution() internal view returns (bool) {
        // Implement your validation logic here
        return true;
    }

    function honourWhitelist() internal view returns (bool) {
        // Implement your whitelist check logic here
        return false;
    }

    function getAllowedContribution() internal view returns (uint256, uint256) {
        // Implement your logic to calculate allowed contribution and refund amount here
        return (0, 0);
    }

    function processWhitelistedContribution(uint256 whiteListedAllowedContribution, uint256 whiteListedRefundAmount) internal returns (uint256, uint256) {
        // Implement your logic for processing whitelisted contributions here
        return (whiteListedAllowedContribution, whiteListedRefundAmount);
    }
}","[{'function': 'processContribution', 'complexity': 3}, {'function': 'isValidContribution', 'complexity': 0}, {'function': 'honourWhitelist', 'complexity': 0}, {'function': 'getAllowedContribution', 'complexity': 0}, {'function': 'processWhitelistedContribution', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAllowedContribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowedContribution"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refundAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""allowedContribution""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""refundAmount""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""allowedContribution""}}}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract PreSale {
    uint256 public preSaleCap;
    mapping(address => bool) public whitelist;
    event PresaleCapUpdated(uint256 newPreSaleCap);

    modifier isValidContribution() {
        require(msg.value > 0, ""Invalid contribution amount"");
        _;
    }

    function honourWhitelist() internal view returns (bool) {
        return whitelist[msg.sender];
    }

    function getAllowedContribution() internal pure returns (uint256 allowedContribution, uint256 refundAmount) {
        // Placeholder for actual logic to determine allowed contribution and refund amount
        allowedContribution = msg.value / 2; // Example: allow half of the contribution
        refundAmount = msg.value - allowedContribution;
    }

    function AllowedContributionCheck() internal view returns (uint256) {
        // Placeholder for actual logic to check allowed contribution
        return preSaleCap > 0 ? preSaleCap : 0; // Example: allow up to the current cap
    }

    function processWhitelistedContribution(uint256 amount) internal {
        require(whitelist[msg.sender], ""Sender not whitelisted"");
        // Process the contribution based on whitelist status
    }

    function processContribution() private isValidContribution returns (uint256 allowedContribution, uint256 refundAmount) {
        if (!honourWhitelist()) {
            (allowedContribution, refundAmount) = getAllowedContribution();
            require(allowedContribution > 0, ""No whitelist contribution allowed"");
            preSaleCap -= allowedContribution;
            emit PresaleCapUpdated(preSaleCap);
        } else {
            processWhitelistedContribution(msg.value);
            // If whitelisted, adjust the logic accordingly
        }
    }
}",46.63130450248718,processContribution,18.0,0.7485121869916365,0.3293337133953108,"[{'function': 'honourWhitelist', 'complexity': 0}, {'function': 'getAllowedContribution', 'complexity': 0}, {'function': 'AllowedContributionCheck', 'complexity': 0}, {'function': 'processWhitelistedContribution', 'complexity': 1}, {'function': 'processContribution', 'complexity': 3}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PreSale is Ownable {
    uint256 public preSaleCap = 1; // Set to 1 (never 0)
    mapping(address => bool) public whitelist;
    event PresaleCapUpdated(uint256 newPreSaleCap);

    modifier isValidContribution() {
        require(msg.value > 0, ""Invalid contribution amount"");
        _;
    }

    function honourWhitelist() internal view returns (bool) {
        return whitelist[msg.sender];
    }

    function getAllowedContribution() internal pure returns (uint256 allowedContribution, uint256 refundAmount) {
        // Placeholder for actual logic to determine allowed contribution and refund amount
        allowedContribution = msg.value / 2; // Example: allow half of the contribution
        refundAmount = msg.value - allowedContribution;
    }

    function AllowedContributionCheck() internal view returns (uint256) {
        // Placeholder for actual logic to check allowed contribution
        return preSaleCap > 0 ? preSaleCap : 0; // Example: allow up to the current cap
    }

    function processWhitelistedContribution(uint256 amount) internal {
        require(whitelist[msg.sender], ""Sender not whitelisted"");
        // Process the contribution based on whitelist status
    }

    function processContribution() private isValidContribution returns (uint256 allowedContribution, uint256 refundAmount) {
        if (!honourWhitelist()) {
            (allowedContribution, refundAmount) = getAllowedContribution();
            require(allowedContribution > 0, ""No whitelist contribution allowed"");
            preSaleCap -= allowedContribution;
            emit PresaleCapUpdated(preSaleCap);
        } else {
            processWhitelistedContribution(msg.value);
            // If whitelisted, adjust the logic accordingly
        }
    }

    constructor() Ownable(msg.sender) {
        preSaleCap = 1; // Set to 1 (never 0)
        whitelist[address(0x111)] = true;
        whitelist[address(0x222)] = true;
        whitelist[address(0x333)] = true;
    }
}"
3650,Method for setting a registered issuer firm authority,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface StorageInterface {
    function setBool(bytes32 id, bool value) external returns (bool);
    function setString(bytes32 id, string memory value) external returns (bool);
}

abstract contract Data {
    using SafeMath for uint256;
    StorageInterface public storageContract;

    constructor(address _storageAddress) {
        storageContract = StorageInterface(_storageAddress);
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) internal returns (bool success) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");
        bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));
        require(storageContract.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        require(storageContract.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        return true;
    }

    function isRegisteredFirm(string memory firm) internal view returns (bool) {
        // Implement the logic to check if a firm is registered
        // This is just a placeholder implementation
        bytes32 id = keccak256(abi.encodePacked(""registered.firm"", firm));
        return true; // Replace with actual storage retrieval logic
    }
}","[{'function': 'setString', 'complexity': 0}, {'function': 'setRegisteredAuthority', 'complexity': 3}, {'function': 'isRegisteredFirm', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRegisteredAuthority"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""issuerFirm"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""authorityAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isRegisteredFirm""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""issuerFirm""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Error: `issuerFirm` must be registered.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id_a"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registered.authority""}, {""type"": ""Identifier"", ""name"": ""issuerFirm""}, {""type"": ""Identifier"", ""name"": ""authorityAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id_b"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registered.authority.firm""}, {""type"": ""Identifier"", ""name"": ""authorityAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""Storage""}, ""memberName"": ""setBool""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id_a""}, {""type"": ""Identifier"", ""name"": ""approved""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""Storage""}, ""memberName"": ""setString""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id_b""}, {""type"": ""Identifier"", ""name"": ""issuerFirm""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract.""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Data {
    struct StorageData {
        mapping(bytes32 => bool) registeredAuthority;
        mapping(bytes32 => string) authorityFirmMapping;
    }

    StorageData private storageData;

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool) {
        bytes32 id_a = keccak256(abi.encodePacked('registered.authority', issuerFirm, msg.sender));
        return storageData.registeredAuthority[id_a];
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) public returns (bool) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");

        bytes32 id_a = keccak256(abi.encodePacked('registered.authority', issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked('registered.authority.firm', authorityAddress));

        if (!self.Storage.setBool(id_a, approved)) {
            revert(""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        }

        if (!self.Storage.setString(id_b, issuerFirm)) {
            revert(""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        }

        return true;
    }
}",45.55098366737366,setRegisteredAuthority,10.0,0.8437236204803087,0.739047781857385,"[{'function': 'isRegisteredFirm', 'complexity': 0}, {'function': 'setRegisteredAuthority', 'complexity': 5}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Data is Ownable {
    struct StorageData {
        mapping(bytes32 => bool) registeredAuthority;
        mapping(bytes32 => string) authorityFirmMapping;
    }

    StorageData private storageData;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        storageData = StorageData({
            registeredAuthority: {},
            authorityFirmMapping: {}
        });
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool) {
        bytes32 id_a = keccak256(abi.encodePacked('registered.authority', issuerFirm, msg.sender));
        return storageData.registeredAuthority[id_a];
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) public returns (bool) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");

        bytes32 id_a = keccak256(abi.encodePacked('registered.authority', issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked('registered.authority.firm', authorityAddress));

        if (!self.Storage.setBool(id_a, approved)) {
            revert(""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        }

        if (!self.Storage.setString(id_b, issuerFirm)) {
            revert(""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        }

        return true;
    }
}"
4267,"Returns holder id for the specified address , creates it if needed .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderRegistration {
    using SafeMath for uint256;

    struct HoldersData {
        uint countryCode;
        bool operational;
        uint sendLimPerDay;
        uint sendLimPerMonth;
        uint holderAddressCount;
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
    }

    bytes32[] public holderIndex;
    mapping(bytes32 => uint) public holderAddress2Id;
    uint public holdersCount;
    mapping(address => bytes32) public holderAddress2ExternalId;
    HoldersData[] public holders;
    address public oracle;

    uint constant MAX_TOKEN_HOLDER_NUMBER = 10000;
    uint constant OK = 1;

    modifier onlyOracleOrOwner() {
        require(msg.sender == owner() || msg.sender == oracle, ""Only owner or oracle can call this function"");
        _;
    }

    constructor() {
        holdersCount = 0;
    }

    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {
        require(_holderAddress != address(0));
        require(holderIndex[_externalHolderId] == bytes32(0));
        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];
        require(_holderIndex == 0);
        _createCountryId(_countryCode);
        _holderIndex = holdersCount.add(1);
        holdersCount = _holderIndex;
        HoldersData storage _holderData = holders[_holderIndex];
        _holderData.countryCode = _countryCode;
        _holderData.operational = true;
        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;
        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;
        uint _firstAddressIndex = 1;
        _holderData.holderAddressCount = _firstAddressIndex;
        _holderData.address2Index[_holderAddress] = _firstAddressIndex;
        _holderData.index2Address[_firstAddressIndex] = _holderAddress;
        holderIndex[_externalHolderId] = bytes32(_holderIndex);
        holderAddress2Id[_holderAddress] = _externalHolderId;
        emit HolderRegistered(_externalHolderId, _holderIndex, _countryCode);
        return OK;
    }

    function _createCountryId(uint _countryCode) internal {
        // Implementation for creating country ID
    }

    event HolderRegistered(bytes32 indexed externalHolderId, uint indexed holderIndex, uint countryCode);
}","[{'function': 'registerHolder', 'complexity': 3}, {'function': '_createCountryId', 'complexity': 0}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerHolder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_externalHolderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_holderAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_countryCode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""countryId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createCountryId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_countryCode""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newHolderIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""holdersCount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""holdersCount""}, ""isPrefix"": False}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Holder""}, ""name"": ""newHolder"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Holder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_holderAddress""}, {""type"": ""Identifier"", ""name"": ""countryId""}, {""type"": ""BooleanLiteral"", ""value"": True}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": [""addr"", ""countryCode"", ""operationalStatus"", ""sendingLimits""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""newHolderIndex""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newHolder""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newHolderIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderAddress2Id""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_externalHolderId""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""HolderRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_externalHolderId""}, {""type"": ""Identifier"", ""name"": ""newHolderIndex""}, {""type"": ""Identifier"", ""name"": ""countryId""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""OK""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyValidAddress"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_holderAddress""}]}, {""type"": ""ModifierInvocation"", ""name"": ""onlyUnregistered"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_externalHolderId""}, {""type"": ""Identifier"", ""name"": ""_holderAddress""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract HolderRegistry {
    // State variables
    uint256 public holdersCount;
    mapping(uint256 => Holder) public holders;
    mapping(bytes32 => uint256) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    mapping(uint256 => Country) public countries;
    uint256 public countryCount;

    // Structs
    struct Holder {
        address addr;
        uint256 countryCode;
        bool operationalStatus;
        uint256 sendingLimits;
    }

    struct Country {
        bool exists;
    }

    // Events
    event HolderRegistered(bytes32 indexed externalHolderId, uint256 holderIndex, uint256 countryCode);

    // Modifiers
    modifier onlyValidAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyUnregistered(bytes32 _externalHolderId, address _holderAddress) {
        require(holderIndex[_externalHolderId] == 0 && holderAddress2Id[_holderAddress] == bytes32(0), ""Holder already registered"");
        _;
    }

    // Function to register a new holder
    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint256 _countryCode) public onlyValidAddress(_holderAddress) onlyUnregistered(_externalHolderId, _holderAddress) returns (string memory) {
        // Create or get the country ID
        uint256 countryId = _createCountryId(_countryCode);

        // Increment holdersCount to get the new holder index
        uint256 newHolderIndex = holdersCount + 1;
        holdersCount++;

        // Initialize holder's data with default values
        Holder memory newHolder = Holder({
            addr: _holderAddress,
            countryCode: countryId,
            operationalStatus: true,
            sendingLimits: 0
        });

        // Update the holders mapping
        holders[newHolderIndex] = newHolder;

        // Update address-related mappings
        holderIndex[_externalHolderId] = newHolderIndex;
        holderAddress2Id[_holderAddress] = _externalHolderId;

        // Emit event
        emit HolderRegistered(_externalHolderId, newHolderIndex, countryId);

        return ""OK"";
    }

    // Internal function to create a new country ID if it does not exist
    function _createCountryId(uint256 _countryCode) internal returns (uint256) {
        if (!countries[_countryCode].exists) {
            countries[_countryCode] = Country({ exists: true });
            countryCount++;
            return countryCount;
        }
        return _countryCode;
    }
}",49.32244277000427,registerHolder,83.0,0.6661186412443068,0.1687939258242321,"[{'function': 'registerHolder', 'complexity': 0}, {'function': '_createCountryId', 'complexity': 2}]",8.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HolderRegistry is Ownable {
    // State variables
    uint256 public holdersCount;
    mapping(uint256 => Holder) public holders;
    mapping(bytes32 => uint256) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    mapping(uint256 => Country) public countries;
    uint256 public countryCount;

    // Structs
    struct Holder {
        address addr;
        uint256 countryCode;
        bool operationalStatus;
        uint256 sendingLimits;
    }

    struct Country {
        bool exists;
    }

    // Events
    event HolderRegistered(bytes32 indexed externalHolderId, uint256 holderIndex, uint256 countryCode);

    // Modifiers
    modifier onlyValidAddress(address _addr) {
        require(_addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyUnregistered(bytes32 _externalHolderId, address _holderAddress) {
        require(holderIndex[_externalHolderId] == 0 && holderAddress2Id[_holderAddress] == bytes32(0), ""Holder already registered"");
        _;
    }

    // Constructor
    constructor() Ownable(msg.sender) {
        holdersCount = 0;
        countryCount = 0;
    }

    // Function to register a new holder
    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint256 _countryCode) public onlyValidAddress(_holderAddress) onlyUnregistered(_externalHolderId, _holderAddress) returns (string memory) {
        // Create or get the country ID
        uint256 countryId = _createCountryId(_countryCode);

        // Increment holdersCount to get the new holder index
        uint256 newHolderIndex = holdersCount + 1;
        holdersCount++;

        // Initialize holder's data with default values
        Holder memory newHolder = Holder({
            addr: _holderAddress,
            countryCode: countryId,
            operationalStatus: true,
            sendingLimits: 0
        });

        // Update the holders mapping
        holders[newHolderIndex] = newHolder;

        // Update address-related mappings
        holderIndex[_externalHolderId] = newHolderIndex;
        holderAddress2Id[_holderAddress] = _externalHolderId;

        // Emit event
        emit HolderRegistered(_externalHolderId, newHolderIndex, countryId);

        return ""OK"";
    }

    // Internal function to create a new country ID if it does not exist
    function _createCountryId(uint256 _countryCode) internal returns (uint256) {
        if (!countries[_countryCode].exists) {
            countries[_countryCode] = Country({ exists: true });
            countryCount++;
            return countryCount;
        }
        return _countryCode;
    }
}"
5707,` onlyOwner ` An efficient way to cancel multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiCancel(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal virtual;
}","[{'function': 'multiCancel', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""doCancelPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_paymentId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""payment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_paymentId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""canceled""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Payment already canceled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""canceled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentCancelled""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_paymentId""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PaymentManager is Ownable {
    struct Payment {
        bool canceled;
        // Add other payment details here if needed
    }

    mapping(uint256 => Payment) public payments;

    function multiCancel(uint256[] memory _idPayments) external onlyOwner {
        for (uint256 i = 0; i < _idPayments.length; i++) {
            require(_idPayments[i] >= 0 && _idPayments[i] < payments[_idPayments[i]].canceled, ""Invalid payment ID"");
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal {
        Payment storage payment = payments[_paymentId];
        require(!payment.canceled, ""Payment already canceled"");
        // Perform the cancellation logic here
        payment.canceled = true;
        emit PaymentCancelled(_paymentId);
    }

    event PaymentCancelled(uint256 indexed paymentId);
}",44.36350727081299,doCancelPayment,18.0,0.779553418001741,0.0377560592318828,"[{'function': 'multiCancel', 'complexity': 3}, {'function': 'doCancelPayment', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentManager is Ownable {
    struct Payment {
        bool canceled;
        // Add other payment details here if needed
    }

    mapping(uint256 => Payment) public payments;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function multiCancel(uint256[] memory _idPayments) external onlyOwner {
        for (uint256 i = 0; i < _idPayments.length; i++) {
            require(_idPayments[i] >= 1 && _idPayments[i] < payments[_idPayments[i]].canceled, ""Invalid payment ID"");
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal {
        Payment storage payment = payments[_paymentId];
        require(!payment.canceled, ""Payment already canceled"");
        // Perform the cancellation logic here
        payment.canceled = true;
        emit PaymentCancelled(_paymentId);
    }

    event PaymentCancelled(uint256 indexed paymentId);
}"
32,Allows the owner of this contract to set the currentPrice for each token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;
    uint256 public currentPrice;

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}","[{'function': 'setCurrentPrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCurrentPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PriceUpdater {
    uint256 public currentPrice;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}",42.09335923194885,setCurrentPrice,0.0,1.0,1.0,"[{'function': 'setCurrentPrice', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceUpdater is Ownable {
    uint256 public currentPrice = 1;
    address public owner = msg.sender;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}"
2463,Gets a given contract address by bytes32 in order to save gas,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractRegistry is Ownable {
    using SafeMath for uint256;

    address public registryAddress;
    bytes32 private constant REGISTRY_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    constructor(address _registryAddress) {
        registryAddress = _registryAddress;
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
        bytes32 _name32 = keccak256(abi.encodePacked(_name));
        assembly {
            let _registry := sload(REGISTRY_SLOT)
            let _pointer := mload(0x40)
            mstore(_pointer, _signature)
            mstore(add(_pointer, 0x04), _name32)
            let result := staticcall(gas(), _registry, _pointer, 0x24, _pointer, 0x20)
            if iszero(result) {
                revert(0, 0)
            }
            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}","[{'function': 'getContractAddress', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""nameHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""registryAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint160""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""REGISTRY_SLOT""}], ""names"": []}], ""names"": []}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""_pointer""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""HexNumber"", ""value"": ""0x40""}]}}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""GET_CONTRACT_ADDRESS_SIG"", ""arguments"": []}]}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x04""}]}, {""type"": ""AssemblyExpression"", ""functionName"": ""nameHash"", ""arguments"": []}]}, {""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""result""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""staticcall"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""gas"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""registryAddress"", ""arguments"": []}, {""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x24""}, {""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x20""}]}}, {""type"": ""AssemblyIf"", ""condition"": {""type"": ""AssemblyExpression"", ""functionName"": ""iszero"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""result"", ""arguments"": []}]}, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyExpression"", ""functionName"": ""revert"", ""arguments"": [{""type"": ""DecimalNumber"", ""value"": ""0""}, {""type"": ""DecimalNumber"", ""value"": ""0""}]}]}}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""_contractAddress""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}]}}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""HexNumber"", ""value"": ""0x40""}, {""type"": ""AssemblyExpression"", ""functionName"": ""add"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_pointer"", ""arguments"": []}, {""type"": ""HexNumber"", ""value"": ""0x24""}]}]}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract ContractRegistry {
    bytes4 private constant GET_CONTRACT_ADDRESS_SIG = keccak256(""getContractAddress32(bytes32)"") & 0xFFFFFFFF;
    uint256 private constant REGISTRY_SLOT = 0x123456789abcdef; // Example registry slot, replace with actual value

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes32 nameHash = keccak256(abi.encodePacked(_name));
        address registryAddress = address(uint160(uint256(keccak256(abi.encodePacked(REGISTRY_SLOT)))));

        assembly {
            let _pointer := mload(0x40)
            mstore(_pointer, GET_CONTRACT_ADDRESS_SIG)
            mstore(add(_pointer, 0x04), nameHash)

            let result := staticcall(gas(), registryAddress, _pointer, 0x24, _pointer, 0x20)

            if iszero(result) { revert(0, 0) }

            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}",45.19736123085022,getContractAddress,13.0,0.9328212551270352,0.765728181467399,"[{'function': 'getContractAddress', 'complexity': 1}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ContractRegistry is Ownable {
    bytes4 private constant GET_CONTRACT_ADDRESS_SIG = keccak256(""getContractAddress32(bytes32)"") & 0xFFFFFFFF;
    uint256 private constant REGISTRY_SLOT = 0x123456789abcdef; // Example registry slot, replace with actual value

    constructor() Ownable(msg.sender) {
        bytes32 initBytes = bytes32('init');
        REGISTRY_SLOT = uint256(initBytes);
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes32 nameHash = keccak256(abi.encodePacked(_name));
        address registryAddress = address(uint160(uint256(keccak256(abi.encodePacked(REGISTRY_SLOT)))));

        assembly {
            let _pointer := mload(0x40)
            mstore(_pointer, GET_CONTRACT_ADDRESS_SIG)
            mstore(add(_pointer, 0x04), nameHash)

            let result := staticcall(gas(), registryAddress, _pointer, 0x24, _pointer, 0x20)

            if iszero(result) { revert(0, 0) }

            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}"
1777,"Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeManager is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        bool exists;
        uint256 minimumStake;
    }

    mapping(uint256 => AttributeType) private _attributeTypes;

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) external onlyOwner {
        require(_attributeTypes[ID].exists, ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID].minimumStake = minimumRequiredStake;
    }
}","[{'function': 'setAttributeTypeMinimumRequiredStake', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAttributeTypeMinimumRequiredStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""minimumRequiredStake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isAttributeType""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ID""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""unable to set minimum stake, no attribute type with the provided ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""ID""}}, ""right"": {""type"": ""Identifier"", ""name"": ""minimumRequiredStake""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    mapping(uint256 => uint256) private _attributeTypes;

    function isAttributeType(uint256 id) public view returns (bool) {
        return _attributeTypes[id] > 0;
    }

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) public {
        require(isAttributeType(ID), ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID] = minimumRequiredStake;
    }
}",42.80133032798767,setAttributeTypeMinimumRequiredStake,4.0,0.7548798717133614,0.6930888738610387,"[{'function': 'isAttributeType', 'complexity': 0}, {'function': 'setAttributeTypeMinimumRequiredStake', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(uint256 => uint256) private _attributeTypes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            _attributeTypes[i] = 1; // uint256: Set to 1
        }
    }

    function isAttributeType(uint256 id) public view returns (bool) {
        return _attributeTypes[id] > 0;
    }

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) public {
        require(isAttributeType(ID), ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID] = minimumRequiredStake;
    }
}"
2431,"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public controller;

    function () external payable {
        require(isContract(controller), ""Controller must be a contract"");
        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender), ""Proxy payment failed"");
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

interface TokenController {
    function proxyPayment() external payable returns (bool);
}","[{'function': '', 'complexity': 2}, {'function': 'isContract', 'complexity': 0}]",1.0,{},"pragma solidity ^0.8.0;

contract TokenController {
    function proxyPayment(address _from) public payable {}
}

contract EtherReceiver {
    address private controller;

    constructor(address _controller) {
        controller = _controller;
    }

    receive() external payable {
        require(isContract(controller), ""Controller must be a contract"");
        TokenController(controller).proxyPayment{value: msg.value}(msg.sender);
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",42.93458008766174,isContract,20.0,0.9579891117876096,0.8166920319485289,"[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EtherReceiver is Ownable {
    address private controller;

    constructor(address _controller) Ownable(msg.sender) {
        controller = _controller;
    }

    receive() external payable {
        require(isContract(controller), ""Controller must be a contract"");
        TokenController(controller).proxyPayment{value: msg.value}(msg.sender);
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
1613,Calculate the halving hash rate of a miner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMinerHashRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""hashRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""halvingIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentHalving""}, ""arguments"": [], ""names"": []}}, {""type"": ""TryStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""this""}, ""memberName"": ""getHashRateOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""halvingIndex""}], ""names"": []}, ""block"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""BooleanLiteral"", ""value"": True}, {""type"": ""Identifier"", ""name"": ""rate""}], ""isArray"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""rate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""catchClause"": [{""type"": ""CatchClause"", ""identifier"": None, ""parameterList"": None, ""block"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""BooleanLiteral"", ""value"": False}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}}]}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract MinerHashRate {
    function getMinerHashRate() public view returns (bool success, uint256 hashRate) {
        uint256 halvingIndex = currentHalving();
        try this.getHashRateOf(msg.sender, halvingIndex) returns (uint256 rate) {
            return (true, rate);
        } catch {
            return (false, 0);
        }
    }

    function currentHalving() internal pure returns (uint256) {
        // Placeholder for the actual implementation of currentHalving logic
        // This should be implemented based on the specific rules or state of the halving periods
        return getCurrentHalvingIndex();
    }

    function getHashRateOf(address miner, uint256 halvingIndex) public pure returns (uint256 hashRate) {
        // Placeholder for the actual implementation of getHashRateOf logic
        // This should be implemented based on how hash rates are stored and retrieved for miners and halving periods
        return calculateHashRate(miner, halvingIndex);
    }

    function getCurrentHalvingIndex() internal pure returns (uint256) {
        // Example implementation: hardcoded index for demonstration purposes
        return 1; // Assume the current halving period is index 1
    }

    function calculateHashRate(address miner, uint256 halvingIndex) internal pure returns (uint256 hashRate) {
        // Example calculation: simple mock implementation
        return halvingIndex * 100; // Placeholder for actual hash rate calculation logic
    }
}",45.49343156814575,getMinerHashRate,33.0,0.5440375931664305,0.0334479968801031,"[{'function': 'getMinerHashRate', 'complexity': 1}, {'function': 'currentHalving', 'complexity': 0}, {'function': 'getHashRateOf', 'complexity': 0}, {'function': 'getCurrentHalvingIndex', 'complexity': 0}, {'function': 'calculateHashRate', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MinerHashRate is Ownable {
    function getMinerHashRate() public view returns (bool success, uint256 hashRate) {
        uint256 halvingIndex = currentHalving();
        try this.getHashRateOf(msg.sender, halvingIndex) returns (uint256 rate) {
            return (true, rate);
        } catch {
            return (false, 0);
        }
    }

    function currentHalving() internal pure returns (uint256) {
        // Placeholder for the actual implementation of currentHalving logic
        // This should be implemented based on the specific rules or state of the halving periods
        return getCurrentHalvingIndex();
    }

    function getHashRateOf(address miner, uint256 halvingIndex) public pure returns (uint256 hashRate) {
        // Placeholder for the actual implementation of getHashRateOf logic
        // This should be implemented based on how hash rates are stored and retrieved for miners and halving periods
        return calculateHashRate(miner, halvingIndex);
    }

    function getCurrentHalvingIndex() internal pure returns (uint256) {
        // Example implementation: hardcoded index for demonstration purposes
        return 1; // Assume the current halving period is index 1
    }

    function calculateHashRate(address miner, uint256 halvingIndex) internal pure returns (uint256 hashRate) {
        // Example calculation: simple mock implementation
        return halvingIndex * 100; // Placeholder for actual hash rate calculation logic
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        uint256 safeUint = 1;
        address safeAddress = address(uint160(uint256(keccak256('address'))));
        bool safeBool = true;
        string memory initializedString = 'initialized';
        bytes32 safeBytes32 = keccak256('init');
    }
}"
2278,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleToken is Ownable {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _owner, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_owner, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) internal pure returns (address) {
        if (_signature.length != 65) return address(0);
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(_signature, (uint8, bytes32, bytes32));
        return ecrecover(_hash, v, r, s);
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);

        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));

        nonces[_signature] = true;
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);

        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);

        return true;
    }
}","[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""increaseApprovalPreSigned"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_addedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonces""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_signature""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Signature already used""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_addedValue""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""recoverSigner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hash""}, {""type"": ""Identifier"", ""name"": ""_signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""signer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonces""}, ""index"": {""type"": ""Identifier"", ""name"": ""hash""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_addedValue""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalPreSigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hash""}, {""type"": ""Identifier"", ""name"": ""signer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_addedValue""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(bytes32 => bool) public nonces;
    mapping(address => uint256) public balances;

    function increaseApprovalPreSigned(
        bytes memory _signature,
        address _spender,
        uint256 _addedValue,
        uint256 _fee,
        uint256 _nonce
    ) public {
        require(_spender != address(0), ""Invalid spender address"");
        require(!nonces[keccak256(abi.encodePacked(_signature, _nonce))], ""Signature already used"");

        bytes32 hash = keccak256(abi.encodePacked(msg.sender, _spender, _addedValue, _fee, _nonce));
        address signer = recoverSigner(hash, _signature);
        require(signer != address(0), ""Invalid signer"");

        nonces[hash] = true;
        allowed[msg.sender][_spender] += _addedValue;
        balances[msg.sender] -= _fee;
        balances[msg.sender] += _fee;

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        emit Transfer(msg.sender, address(0), _fee);
        emit ApprovalPreSigned(hash, signer, msg.sender, _spender, _addedValue, _fee, _nonce);
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        if (signature.length != 65) return address(0);
        // Signature is in the format of [r][s][v] where v is either 0 or 1
        assembly {
            let size := mload(signature)
            if lt(size, 64) { revert(0, 0) }
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        if (v < 27) v += 27; // Transform V from 0/1 to 27/28
        return ecrecover(hash, v, r, s);
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(bytes32 indexed hash, address indexed signer, address indexed owner, address spender, uint256 value, uint256 fee, uint256 nonce);
}",49.1662175655365,increaseApprovalPreSigned,46.0,0.8754361779125868,0.4532847289444744,"[{'function': 'increaseApprovalPreSigned', 'complexity': 0}, {'function': 'recoverSigner', 'complexity': 1}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(bytes32 => bool) public nonces;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance for the owner
    }

    function increaseApprovalPreSigned(
        bytes memory _signature,
        address _spender,
        uint256 _addedValue,
        uint256 _fee,
        uint256 _nonce
    ) public {
        require(_spender != address(0), ""Invalid spender address"");
        require(!nonces[keccak256(abi.encodePacked(_signature, _nonce))], ""Signature already used"");

        bytes32 hash = keccak256(abi.encodePacked(msg.sender, _spender, _addedValue, _fee, _nonce));
        address signer = recoverSigner(hash, _signature);
        require(signer != address(0), ""Invalid signer"");

        nonces[hash] = true;
        allowed[msg.sender][_spender] += _addedValue;
        balances[msg.sender] -= _fee;
        balances[msg.sender] += _fee;

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        emit Transfer(msg.sender, address(0), _fee);
        emit ApprovalPreSigned(hash, signer, msg.sender, _spender, _addedValue, _fee, _nonce);
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        if (signature.length != 65) return address(0);
        // Signature is in the format of [r][s][v] where v is either 0 or 1
        assembly {
            let size := mload(signature)
            if lt(size, 64) { revert(0, 0) }
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        if (v < 27) v += 27; // Transform V from 0/1 to 27/28
        return ecrecover(hash, v, r, s);
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(bytes32 indexed hash, address indexed signer, address indexed owner, address spender, uint256 value, uint256 fee, uint256 nonce);
}"
4847,Function that is called when transaction target is contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ContractReceiver {
    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    function transferToContract(address _to, uint256 _value, bytes memory _data) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
}","[{'function': 'tokenFallback', 'complexity': 0}, {'function': 'transferToContract', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodeWithSignature""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""tokenFallback(address,uint256,bytes)""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer to contract failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;

    function transfer(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        // Assuming the recipient has a tokenFallback function that takes three parameters: address from, uint256 value, bytes memory data
        (bool success, ) = _to.call(abi.encodeWithSignature(""tokenFallback(address,uint256,bytes)"", msg.sender, _value, _data));
        require(success, ""Token transfer to contract failed"");

        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);

        return true;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);
}",44.97993612289429,transfer,23.0,0.8762284273750922,0.4845567979022387,"[{'function': 'transfer', 'complexity': 2}, {'function': 'balanceOf', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance of owner to 1 (never 0)
    }

    function transfer(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        // Assuming the recipient has a tokenFallback function that takes three parameters: address from, uint256 value, bytes memory data
        (bool success, ) = _to.call(abi.encodeWithSignature(""tokenFallback(address,uint256,bytes)"", msg.sender, _value, _data));
        require(success, ""Token transfer to contract failed"");

        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);

        return true;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);
}"
1565,Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MintWrapper is Ownable {
    using SafeMath for uint256;

    function mint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) public onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }
}","[{'function': 'mint', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""doMint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenHolder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_operatorData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenHolder""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token holder address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_tokenHolder""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TokenMinter is Ownable, ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}

    function doMint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) internal {
        require(_tokenHolder != address(0), ""Invalid token holder address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        _mint(msg.sender, _amount);
        emit Transfer(address(0), _tokenHolder, _amount);
    }

    function mintTokens(address _tokenHolder, uint256 _amount, bytes memory _operatorData) external onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }
}",43.84968948364258,doMint,27.0,0.6046794246428011,0.208953640240407,"[{'function': 'doMint', 'complexity': 2}, {'function': 'mintTokens', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenMinter is Ownable, ERC20 {
    // Fixed values for initialization
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    uint256 public constant DEFAULT_UINT256 = 1;
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    uint256 public totalSupply;

 constructor() Ownable(DEFAULT_ADDRESS) ERC20(DEFAULT_STRING, DEFAULT_UINT256) {
        // Initialize instance variables
        _owner = msg.sender; // Replace with actual owner address
        name = DEFAULT_STRING;
        symbol = DEFAULT_STRING;
        totalSupply_ = DEFAULT_UINT256;
    }

    function doMint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) internal {
        require(_tokenHolder != address(0), ""Invalid token holder address"");
        require(_amount > 0, ""Amount must be greater than zero"");

        _mint(msg.sender, _amount);
        emit Transfer(address(0), _tokenHolder, _amount);
    }

    function mintTokens(address _tokenHolder, uint256 _amount, bytes memory _operatorData) external onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }
}"
5534,Returns the timestamp at which the question will be/was finalized,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Question {
        uint32 finalize_ts;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalizeTS(bytes32 question_id) public view returns (uint32) {
        return questions[question_id].finalize_ts;
    }
}","[{'function': 'getFinalizeTS', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getFinalizeTS"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""question_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""question_id""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract QuestionContract {
    mapping(bytes32 => uint256) public questions;

    function getFinalizeTS(bytes32 question_id) external view returns (uint256) {
        return questions[question_id];
    }
}",41.67878413200378,getFinalizeTS,1.0,0.8982865629727164,0.4685909905380384,"[{'function': 'getFinalizeTS', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract QuestionContract is Ownable {
    mapping(bytes32 => uint256) public questions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        questions[bytes32('init')] = 1;
    }

    function getFinalizeTS(bytes32 question_id) external view returns (uint256) {
        return questions[question_id];
    }
}"
2081,Become owner of a deed for which you are currently approved,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IDeed {
    function takeOwnership(uint256 _deedId) external payable;
}

abstract contract Deed is Ownable, SafeMath {
    struct DeedInfo {
        address owner;
        bool isOwner;
    }

    mapping(uint256 => DeedInfo) private _deeds;
    uint256 public constant DEED_PRICE = 1 ether; // Example price, adjust as needed

    function takeOwnership(uint256 _deedId) external payable {
        require(_deedId > 0, ""Invalid deed ID"");
        require(msg.value >= DEED_PRICE, ""Insufficient payment"");
        require(!_deeds[_deedId].isOwner, ""Deed is already owned"");
        _deeds[_deedId].owner = msg.sender;
        _deeds[_deedId].isOwner = true;
        emit DeedOwnershipTransferred(_deedId, msg.sender);
    }
}","[{'function': 'takeOwnership', 'complexity': 0}, {'function': 'takeOwnership', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_deedId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""priceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect amount of Ether sent.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""currentOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""currentOwner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""You already own this deed.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""priceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_deedId""}, {""type"": ""Identifier"", ""name"": ""currentOwner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyIfDeedExists"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_deedId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract DeedRegistry {
    mapping(uint256 => address) public ownerOf;
    uint256[] public deeds;
    mapping(uint256 => uint256) public priceOf;
    uint256 public totalSupply;

    event OwnershipTransferred(uint256 indexed deedId, address indexed previousOwner, address indexed newOwner);

    modifier onlyIfDeedExists(uint256 _deedId) {
        require(_deedId < deeds.length && ownerOf[_deedId] != address(0), ""Deed does not exist or is already owned."");
        _;
    }

    function claimOwnership(uint256 _deedId) external payable onlyIfDeedExists(_deedId) {
        require(msg.value == priceOf[_deedId], ""Incorrect amount of Ether sent."");

        address currentOwner = ownerOf[_deedId];
        require(currentOwner != msg.sender, ""You already own this deed."");

        // Transfer ownership and decrease contract balance
        ownerOf[_deedId] = msg.sender;
        totalSupply -= priceOf[_deedId];

        emit OwnershipTransferred(_deedId, currentOwner, msg.sender);
    }
}",44.78367137908936,claimOwnership,22.0,0.8618534286704754,0.2061910903424769,"[{'function': 'claimOwnership', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract DeedRegistry is Ownable {
    mapping(uint256 => address) public ownerOf;
    uint256[] public deeds;
    mapping(uint256 => uint256) public priceOf;
    uint256 public totalSupply;

    event OwnershipTransferred(uint256 indexed deedId, address indexed previousOwner, address indexed newOwner);

    modifier onlyIfDeedExists(uint256 _deedId) {
        require(_deedId < deeds.length && ownerOf[_deedId] != address(0), ""Deed does not exist or is already owned."");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalSupply = 1000000000000000000;
        for (uint256 i = 0; i < 3; i++) {
            deeds.push(i);
            ownerOf[i] = address(uint160(uint256(keccak256(abi.encodePacked('address', i)))));
            priceOf[i] = 1;
        }
    }

    function claimOwnership(uint256 _deedId) external payable onlyIfDeedExists(_deedId) {
        require(msg.value == priceOf[_deedId], ""Incorrect amount of Ether sent."");

        address currentOwner = ownerOf[_deedId];
        require(currentOwner != msg.sender, ""You already own this deed."");

        // Transfer ownership and decrease contract balance
        ownerOf[_deedId] = msg.sender;
        totalSupply -= priceOf[_deedId];

        emit OwnershipTransferred(_deedId, currentOwner, msg.sender);
    }
}"
790,Allows the owner of the contract to update the address of the RenExBrokerVerifier contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RenExBrokerVerifier {
    using SafeMath for uint256;

    address public brokerVerifierContract;

    event LogBrokerVerifierContractUpdated(address indexed oldBrokerVerifierContract, address indexed newBrokerVerifierContract);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {
        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}","[{'function': 'updateBrokerVerifierContract', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateBrokerVerifierContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newBrokerVerifierContract"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newBrokerVerifierContract""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid contract address""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogBrokerVerifierContractUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""brokerVerifierContract""}, {""type"": ""Identifier"", ""name"": ""_newBrokerVerifierContract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""brokerVerifierContract""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newBrokerVerifierContract""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract RenExBroker {
    address public brokerVerifierContract;

    event LogBrokerVerifierContractUpdated(address oldAddress, address newAddress);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address private owner;

    constructor(address _brokerVerifierContract) {
        brokerVerifierContract = _brokerVerifierContract;
        owner = msg.sender;
    }

    function updateBrokerVerifierContract(address _newBrokerVerifierContract) public onlyOwner {
        require(_newBrokerVerifierContract != address(0), ""Invalid contract address"");

        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}",43.16230654716492,updateBrokerVerifierContract,10.0,0.8260370449629915,0.3870947611813672,"[{'function': 'updateBrokerVerifierContract', 'complexity': 1}]",10.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract RenExBroker {
    address public brokerVerifierContract;

    event LogBrokerVerifierContractUpdated(address oldAddress, address newAddress);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    address private owner;

    constructor(address _brokerVerifierContract) {
        brokerVerifierContract = _brokerVerifierContract;
        owner = msg.sender;
    }

    function updateBrokerVerifierContract(address _newBrokerVerifierContract) public onlyOwner {
        require(_newBrokerVerifierContract != address(0), ""Invalid contract address"");

        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}"
1335,Owner : Withdraw excess funds which do n't belong to Bskt Token holders,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply_;
    uint256 public creationUnit_;

    constructor(uint256 _totalSupply, uint256 _creationUnit) {
        require(_totalSupply > 0 && _creationUnit > 0, ""Invalid parameters"");
        totalSupply_ = _totalSupply;
        creationUnit_ = _creationUnit;
    }

    function getQuantity(address token) internal view returns (uint256 quantity, bool ok) {
        // Implement your logic to determine the quantity here
        // For example:
        // if (/* some condition */) {
        //     return (quantity, true);
        // } else {
        //     return (0, false);
        // }
        revert(""Not implemented"");
    }

    function withdrawExcessToken(address token) external onlyOwner {
        ERC20 erc20 = ERC20(token);
        uint256 amountOwned = erc20.balanceOf(address(this));
        uint256 quantity;
        bool ok;
        (quantity, ok) = getQuantity(token);
        uint256 withdrawAmount;
        if (ok) {
            withdrawAmount = amountOwned.sub(totalSupply_.div(creationUnit_).mul(quantity));
        } else {
            withdrawAmount = amountOwned;
        }
        require(erc20.transfer(owner(), withdrawAmount), ""Transfer failed"");
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'getQuantity', 'complexity': 0}, {'function': 'withdrawExcessToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawExcessToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""erc20"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""ok"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113073070>}, {""type"": ""VariableDeclaration"", ""name"": ""quantity"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113071b70>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getQuantity""}, ""arguments"": [], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""Identifier"", ""name"": ""ok""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""keptAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""excessAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""keptAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""excessAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract WithdrawExcessToken is Ownable {
    function withdrawExcessToken(address token) external onlyOwner {
        IERC20 erc20 = IERC20(token);
        uint256 balance = erc20.balanceOf(address(this));

        // Assuming getQuantity returns a struct with an ok boolean and some quantity data
        (bool ok, uint256 quantity) = getQuantity();

        if (ok && quantity > 0) {
            uint256 keptAmount = balance * quantity / totalSupply;
            uint256 excessAmount = balance - keptAmount;
            require(erc20.transfer(owner(), excessAmount), ""Transfer failed"");
        } else {
            // If getQuantity fails, transfer the entire balance to the owner
            require(erc20.transfer(owner(), balance), ""Transfer failed"");
        }
    }
}",44.13989496231079,withdrawExcessToken,18.0,0.9137844589834894,0.3376895714107515,"[{'function': 'withdrawExcessToken', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WithdrawExcessToken is Ownable {
    // Fixed, safe values for instance variables
    uint256 public totalSupply = 1000000000000000000;
    address public ownerAddress = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bool public initialized = true;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize parent contract (Ownable)
        super();

        // Initialize instance variables
        totalSupply = 1000000000000000000;
        ownerAddress = msg.sender;
        initialized = true;
    }

    function withdrawExcessToken(address token) external onlyOwner {
        IERC20 erc20 = IERC20(token);
        uint256 balance = erc20.balanceOf(address(this));

        // Assuming getQuantity returns a struct with an ok boolean and some quantity data
        (bool ok, uint256 quantity) = getQuantity();

        if (ok && quantity > 0) {
            uint256 keptAmount = balance * quantity / totalSupply;
            uint256 excessAmount = balance - keptAmount;
            require(erc20.transfer(ownerAddress(), excessAmount), ""Transfer failed"");
        } else {
            // If getQuantity fails, transfer the entire balance to the owner
            require(erc20.transfer(ownerAddress(), balance), ""Transfer failed"");
        }
    }

    function getQuantity() internal view returns (bool, uint256) {
        // Replace with actual implementation
        return (true, 1);
    }
}"
3433,Permit ` msg.sender ` to set its NeuroChain Address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NeuroChainWrapper {
    using SafeMath for uint256;

    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string addressString, uint256 timestamp, bool isRegistered);

    function setNeuroChainAddress(string memory neurochainAddress) public {
        require(bytes(neurochainAddress).length > 0, ""Invalid address"");
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}","[{'function': 'setNeuroChainAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNeuroChainAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""neurochainAddress"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""neurochainAddress""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""neuroChainAddresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""neurochainAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NeuroChainAddressSet""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""neurochainAddress""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract NeuroChainRegistry {
    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string neurochainAddress, uint timestamp, bool status);

    function setNeuroChainAddress(string memory neurochainAddress) public {
        require(bytes(neurochainAddress).length > 0, ""Invalid address"");
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}",43.35045456886292,setNeuroChainAddress,0.0,1.0,1.0,"[{'function': 'setNeuroChainAddress', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NeuroChainRegistry is Ownable {
    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string neurochainAddress, uint timestamp, bool status);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        neuroChainAddresses[msg.sender] = """"; // Placeholder value to avoid zero/default state
    }

    function setNeuroChainAddress(string memory neurochainAddress) public {
        require(bytes(neurochainAddress).length > 0, ""Invalid address"");
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}"
465,Get the token balance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Storage {
    function getUint(bytes32 key) external view returns (uint);
}

abstract contract Data {
    Storage public immutable Storage;

    constructor(Storage _storage) {
        Storage = _storage;
    }
}

abstract contract TokenBalanceWrapper is Ownable, SafeMath {
    function getForwardedAccount(Data storage self, address account) internal view virtual returns (address);

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint balance) {
        bytes32 id = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));
        return self.Storage.getUint(id);
    }
}","[{'function': 'getUint', 'complexity': 0}, {'function': 'getForwardedAccount', 'complexity': 0}, {'function': 'getTokenBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Data""}, ""name"": ""self"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""token.balance""}, {""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Strings""}, ""memberName"": ""toHexString""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""self""}, ""memberName"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TokenBalance {
    struct Data {
        mapping(string => uint256) balances;
    }

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint256 balance) {
        bytes32 id = keccak256(abi.encodePacked(""token.balance"", currency, Strings.toHexString(account)));
        return self.balances[id];
    }
}",42.10743474960327,getTokenBalance,4.0,0.8653541488356721,0.6516126544862882,"[{'function': 'getTokenBalance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenBalance is Ownable {
    struct Data {
        mapping(string => uint256) balances;
    }

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint256 balance) {
        bytes32 id = keccak256(abi.encodePacked(""token.balance"", currency, Strings.toHexString(account)));
        return self.balances[id];
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
5228,A getter that searches the delegationChain for the level of authority a specific delegate has within a Pledge,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledge {
    uint64 public constant NOTFOUND = type(uint64).max;
    uint64[] public delegationChain;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getDelegateIdx(Pledge p, uint64 idDelegate) external returns (uint64) {
        for (uint i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) return uint64(i);
        }
        return NOTFOUND;
    }
}","[{'function': 'getDelegateIdx', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDelegateIdx"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Pledge""}, ""name"": ""p"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""idDelegate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""delegationChain""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""p""}, ""memberName"": ""delegationChain""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""idDelegate""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""NOTFOUND""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

struct Pledge {
    uint64[] delegationChain;
}

contract PledgeContract {
    uint64 constant NOTFOUND = 0xFFFFFFFFFFFFFFFF; // Assuming a large number to represent not found

    function getDelegateIdx(Pledge memory p, uint64 idDelegate) public pure returns (uint64) {
        for (uint i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) {
                return uint64(i);
            }
        }
        return NOTFOUND;
    }
}",42.77025127410889,getDelegateIdx,0.0,0.9479296361492175,0.7661185792230456,"[{'function': 'getDelegateIdx', 'complexity': 3}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

struct Pledge {
    uint64[] delegationChain;
}
import ""openzeppelin/SafeMath.sol"";
contract PledgeContract is Ownable {
    uint64 constant NOTFOUND = 0xFFFFFFFFFFFFFFFF; // Assuming a large number to represent not found

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        NOTFOUND = 0xFFFFFFFFFFFFFFFF; // Corrected initialization for consistency
    }

    function getDelegateIdx(Pledge memory p, uint64 idDelegate) public pure returns (uint64) {
        for (uint i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) {
                return uint64(i);
            }
        }
        return NOTFOUND;
    }
}"
3288,Distirbutes a different quantity of tokens to all the specified addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Airdrop {
        address tokenSC;
    }

    mapping(uint => Airdrop) public airdrops;

    function distributeVariable(uint index, address[] memory _addrs, uint[] memory _vals) public onlyOwner {
        if (timeGone(index) == true) {
            Airdrop storage airdrop = airdrops[index];
            for (uint i = 0; i < _addrs.length; ++i) {
                require(SafeMath.mul(_vals[i], 1 ether) <= address(airdrop.tokenSC).balance, ""Insufficient balance"");
                airdrop.tokenSC.call(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _addrs[i], _vals[i]));
            }
        } else {
            revert(""Distribution Failed: Countdown not finished yet"");
        }
    }

    function timeGone(uint index) public view returns (bool) {
        // Implement your logic to check if the countdown is finished for the given index
        return true; // Placeholder, replace with actual implementation
    }
}","[{'function': 'distributeVariable', 'complexity': 4}, {'function': 'timeGone', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_addrs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_values"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_values""}, ""memberName"": ""length""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid length of addresses or values""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Airdrop""}, ""name"": ""airdrop"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""airdrops""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""airdrop""}, ""memberName"": ""countdown""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""airdrop""}, ""memberName"": ""countdown""}}}, {""type"": ""stringLiteral"", ""value"": ""Distribution Failed: Countdown not finished yet""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalValue"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_values""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalValue""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_values""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""airdrop""}, ""memberName"": ""tokenSC""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""totalValue""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to distribute tokens""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_values""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""airdrop""}, ""memberName"": ""tokenSC""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_values""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract AirdropDistributor is Ownable {
    struct Airdrop {
        uint256 countdown;
        address tokenSC;
    }

    mapping(uint256 => Airdrop) public airdrops;

    function setAirdrop(uint256 index, uint256 countdown, address tokenSC) public onlyOwner {
        require(countdown > 0, ""Countdown must be greater than zero"");
        airdrops[index] = Airdrop({ countdown: countdown, tokenSC: tokenSC });
    }

    function distributeTokens(uint256 index, address[] memory _addrs, uint256[] memory _values) public onlyOwner {
        require(_addrs.length == _values.length && _addrs.length <= 100, ""Invalid length of addresses or values"");
        Airdrop storage airdrop = airdrops[index];
        require(airdrop.countdown == 0 || block.timestamp >= airdrop.countdown, ""Distribution Failed: Countdown not finished yet"");

        uint256 totalValue;
        for (uint i = 0; i < _values.length; i++) {
            totalValue += _values[i];
        }
        require(IERC20(airdrop.tokenSC).balanceOf(address(this)) >= totalValue, ""Insufficient balance to distribute tokens"");

        for (uint i = 0; i < _addrs.length; i++) {
            if (_addrs[i] != address(0) && _values[i] > 0) {
                require(IERC20(airdrop.tokenSC).transfer(_addrs[i], _values[i]), ""Token transfer failed"");
            }
        }
    }
}",46.44705295562744,distributeTokens,93.0,0.7942568917275209,0.2679702982443171,"[{'function': 'setAirdrop', 'complexity': 1}, {'function': 'distributeTokens', 'complexity': 10}]",14.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AirdropDistributor is Ownable {
    struct Airdrop {
        uint256 countdown;
        address tokenSC;
    }

    mapping(uint256 => Airdrop) public airdrops;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables
        airdrops[1] = Airdrop({ countdown: 1, tokenSC: address(0x1111111111111111111111111111111111111111), });
        airdrops[2] = Airdrop({ countdown: 2, tokenSC: address(0x2222222222222222222222222222222222222222), });
        airdrops[3] = Airdrop({ countdown: 3, tokenSC: address(0x3333333333333333333333333333333333333333), });
    }

    function setAirdrop(uint256 index, uint256 countdown, address tokenSC) public onlyOwner {
        require(countdown > 0, ""Countdown must be greater than zero"");
        airdrops[index] = Airdrop({ countdown: countdown, tokenSC: tokenSC });
    }

    function distributeTokens(uint256 index, address[] memory _addrs, uint256[] memory _values) public onlyOwner {
        require(_addrs.length == _values.length && _addrs.length <= 100, ""Invalid length of addresses or values"");
        Airdrop storage airdrop = airdrops[index];
        require(airdrop.countdown == 0 || block.timestamp >= airdrop.countdown, ""Distribution Failed: Countdown not finished yet"");

        uint256 totalValue;
        for (uint i = 0; i < _values.length; i++) {
            totalValue += _values[i];
        }
        require(IERC20(airdrop.tokenSC).balanceOf(address(this)) >= totalValue, ""Insufficient balance to distribute tokens"");

        for (uint i = 0; i < _addrs.length; i++) {
            if (_addrs[i] != address(0) && _values[i] > 0) {
                require(IERC20(airdrop.tokenSC).transfer(_addrs[i], _values[i]), ""Token transfer failed"");
            }
        }
    }
}"
110,This method should be called by the owner before the contribution period starts This initializes most of the parameters,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function totalSupply() external view returns (uint256);
    function controller() external view returns (address);
    function decimals() external view returns (uint8);
}

interface DynamicCeiling {
    function getBlockNumber() external view returns (uint256);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    MiniMeToken public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    DynamicCeiling public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    MiniMeToken public SGT;
    uint256 public maxSGTSupply;

    function initialize(address _snt, address _sntController, uint256 _startBlock, uint256 _endBlock, address _dynamicCeiling, address _destEthDevs, address _destTokensReserve, address _destTokensSgt, address _destTokensDevs, address _sgt, uint256 _maxSGTSupply) public onlyOwner {
    require(address(SNT) == 0x0);
    SNT = MiniMeToken(_snt);
    require(SNT.totalSupply() == 0);
    require(SNT.controller() == address(this));
    require(SNT.decimals() == 18);
    require(_sntController != 0x0);
    sntController = _sntController;
    require(_startBlock >= getBlockNumber());
    require(_startBlock < _endBlock);
    startBlock = _startBlock;
    endBlock = _endBlock;
    require(_dynamicCeiling != 0x0);
    dynamicCeiling = DynamicCeiling(_dynamicCeiling);
    require(_destEthDevs != 0x0);
    destEthDevs = _destEthDevs;
    require(_destTokensReserve != 0x0);
    destTokensReserve = _destTokensReserve;
    require(_destTokensSgt != 0x0);
    destTokensSgt = _destTokensSgt;
    require(_destTokensDevs != 0x0);
    destTokensDevs = _destTokensDevs;
    require(_sgt != 0x0);
    SGT = MiniMeToken(_sgt);
    require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());
    maxSGTSupply = _maxSGTSupply;
}
}","[{'function': 'decimals', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}]",1.0,{},,47.00689196586609,,175.0,0.0462003175081141,0.0,"{'function': '', 'complexity': 0}",,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function totalSupply() external view returns (uint256);
    function controller() external view returns (address);
    function decimals() external view returns (uint8);
}

interface DynamicCeiling {
    function getBlockNumber() external view returns (uint256);
}

contract Wrapper is Ownable {
    using SafeMath for uint256;

    MiniMeToken public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    DynamicCeiling public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    MiniMeToken public SGT;
    uint256 public maxSGTSupply;

    uint256 public totalSupply;

 constructor(address _snt, address _sntController, uint256 _startBlock, uint256 _endBlock, address _dynamicCeiling, address _destEthDevs, address _destTokensReserve, address _destTokensSgt, address _destTokensDevs, address _sgt, uint256 _maxSGTSupply) {
        require(address(SNT) == 0x0);
        SNT = MiniMeToken(_snt);
        require(SNT.totalSupply() == 0);
        require(SNT.controller() == address(this));
        require(SNT.decimals() == 18);
        require(_sntController != 0x0);
        sntController = _sntController;
        require(_startBlock >= getBlockNumber());
        require(_startBlock < _endBlock);
        startBlock = _startBlock;
        endBlock = _endBlock;
        require(_dynamicCeiling != 0x0);
        dynamicCeiling = DynamicCeiling(_dynamicCeiling);
        require(_destEthDevs != 0x0);
        destEthDevs = _destEthDevs;
        require(_destTokensReserve != 0x0);
        destTokensReserve = _destTokensReserve;
        require(_destTokensSgt != 0x0);
        destTokensSgt = _destTokensSgt;
        require(_destTokensDevs != 0x0);
        destTokensDevs = _destTokensDevs;
        require(_sgt != 0x0);
        SGT = MiniMeToken(_sgt);
        require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());
        maxSGTSupply = _maxSGTSupply;
    }
}"
2093,Get all details of PixelCon # ` ( _tokenIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPixelCon {
    function totalSupply() external view returns (uint256);
}

struct PixelCon {
    uint256 tokenId;
    uint64 collectionIndex;
    uint32 dateCreated;
}

struct TokenLookup {
    address owner;
    address creator;
    uint64 tokenIndex;
}

mapping(uint256 => PixelCon) public pixelcons;
mapping(uint256 => TokenLookup) public tokenLookup;
mapping(uint256 => bytes8) public pixelconNames;

function getTokenDataByIndex(uint64 _tokenIndex, IPixelCon pixelConContract) public view returns (uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated) {
    require(_tokenIndex < pixelConContract.totalSupply(), ""PixelCon index is out of bounds"");
    PixelCon storage pixelcon = pixelcons[_tokenIndex];
    TokenLookup storage lookupData = tokenLookup[pixelcon.tokenId];
    return (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner, pixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);
}","[{'function': 'totalSupply', 'complexity': 0}, {'function': 'getTokenDataByIndex', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""creator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes8""}, ""name"": ""name"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""dateCreated"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenIndex""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelcons""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Token index out of bounds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PixelCon""}, ""name"": ""token"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pixelcons""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenIndex""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""tokenId""}, {""type"": ""Identifier"", ""name"": ""_tokenIndex""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenIndexToCollectionIndex""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""tokenId""}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""creator""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""dateCreated""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract PixelConToken {
    struct PixelCon {
        uint256 tokenId;
        uint256 index;
        address owner;
        address creator;
        bytes8 name;
        uint256 dateCreated;
    }

    PixelCon[] public pixelcons;
    mapping(uint256 => uint256) private tokenIndexToCollectionIndex;

    function getTokenInfo(uint256 _tokenIndex) public view returns (
        uint256 tokenId,
        uint256 index,
        uint256 collectionIndex,
        address owner,
        address creator,
        bytes8 name,
        uint256 dateCreated
    ) {
        require(_tokenIndex < pixelcons.length, ""Token index out of bounds"");

        PixelCon memory token = pixelcons[_tokenIndex];
        return (
            token.tokenId,
            _tokenIndex,
            tokenIndexToCollectionIndex[token.tokenId],
            token.owner,
            token.creator,
            token.name,
            token.dateCreated
        );
    }
}",48.3388454914093,getTokenInfo,50.0,0.8319357697269163,0.238653485663804,"[{'function': 'getTokenInfo', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PixelConToken is Ownable {
    struct PixelCon {
        uint256 tokenId;
        uint256 index;
        address owner;
        address creator;
        bytes8 name;
        uint256 dateCreated;
    }

    PixelCon[] public pixelcons;
    mapping(uint256 => uint256) private tokenIndexToCollectionIndex;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            pixelcons.push(PixelCon({
                tokenId: uint256(i + 1),
                index: i,
                owner: address(uint160(uint256(keccak256(abi.encodePacked(""owner"", i)))),
                creator: address(uint160(uint256(keccak256(abi.encodePacked(""creator"", i)))),
                name: bytes8('init'),
                dateCreated: uint256(i + 1) * 10 ** 9 // Example timestamp
            }));
        }
    }

    function getTokenInfo(uint256 _tokenIndex) public view returns (
        uint256 tokenId,
        uint256 index,
        uint256 collectionIndex,
        address owner,
        address creator,
        bytes8 name,
        uint256 dateCreated
    ) {
        require(_tokenIndex < pixelcons.length, ""Token index out of bounds"");

        PixelCon memory token = pixelcons[_tokenIndex];
        return (
            token.tokenId,
            _tokenIndex,
            tokenIndexToCollectionIndex[token.tokenId],
            token.owner,
            token.creator,
            token.name,
            token.dateCreated
        );
    }
}"
2971,Get the approved address for a single NFT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 private _totalSupply;
    mapping(uint40 => address) public cutieIndexToApproved;
    mapping(uint40 => address) public cutieIndexToOwner;
    mapping(address => bool) public addressToApprovedAll;

    function getApproved(uint256 _tokenId) external view returns (address) {
        require(_tokenId <= _totalSupply());

        if (cutieIndexToApproved[uint40(_tokenId)] != address(0)) {
            return cutieIndexToApproved[uint40(_tokenId)];
        }

        address owner = cutieIndexToOwner[uint40(_tokenId)];
        return addressToApprovedAll[owner];
    }

    function _totalSupply() internal view returns (uint256) {
        return _totalSupply;
    }
}","[{'function': 'getApproved', 'complexity': 2}, {'function': '_totalSupply', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getApproved"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, {""type"": ""stringLiteral"", ""value"": ""Token ID does not exist.""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cutieIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cutieIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cutieIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""Conditional"", ""condition"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addressToApprovedAll""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""TrueExpression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""FalseExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canBeStoredIn40Bits"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    mapping(uint256 => address) public cutieIndexToOwner;
    mapping(address => bool) public addressToApprovedAll;
    mapping(uint256 => address) public cutieIndexToApproved;
    uint256 totalSupply;

    modifier canBeStoredIn40Bits(uint256 tokenId) {
        require(tokenId <= 2**40 - 1, ""Token ID exceeds the allowed storage limit."");
        _;
    }

    function getApproved(uint256 _tokenId) public view canBeStoredIn40Bits(_tokenId) returns (address) {
        require(_tokenId < totalSupply, ""Token ID does not exist."");

        if (cutieIndexToApproved[_tokenId] != address(0)) {
            return cutieIndexToApproved[_tokenId];
        }

        address owner = cutieIndexToOwner[_tokenId];
        return addressToApprovedAll[owner] ? owner : address(0);
    }
}",44.12757802009583,getApproved,12.0,0.8988984788824386,0.422086135823722,"[{'function': 'getApproved', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(uint256 => address) public cutieIndexToOwner;
    mapping(address => bool) public addressToApprovedAll;
    mapping(uint256 => address) public cutieIndexToApproved;
    uint256 totalSupply = 1000000000000000000; // Set to 1 (never 0)

    modifier canBeStoredIn40Bits(uint256 tokenId) {
        require(tokenId <= 2**40 - 1, ""Token ID exceeds the allowed storage limit."");
        _;
    }

    function getApproved(uint256 _tokenId) public view canBeStoredIn40Bits(_tokenId) returns (address) {
        require(_tokenId < totalSupply, ""Token ID does not exist."");

        if (cutieIndexToApproved[_tokenId] != address(0)) {
            return cutieIndexToApproved[_tokenId];
        }

        address owner = cutieIndexToOwner[_tokenId];
        return addressToApprovedAll[owner] ? owner : address(0);
    }

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        totalSupply = 1000000000000000000;
    }
}"
2241,Gets absolute issued hardcap volume which means it will be greater than softcap value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap.add(tokenHardcapIssuedValue);
    }
}","[{'function': 'tokenHardcapIssued', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenHardcapIssued"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""tokenSoftcap""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenHardcapIssuedValue""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TokenContract {
    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    constructor(uint _softcap) {
        require(_softcap > 0, ""Soft cap must be greater than zero"");
        tokenSoftcap = _softcap;
    }

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap + tokenHardcapIssuedValue;
    }
}",42.17057752609253,tokenHardcapIssued,2.0,0.8180463846247854,0.650185334030003,"[{'function': 'tokenHardcapIssued', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is Ownable {
    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    constructor(uint _softcap) Ownable(msg.sender) {
        require(_softcap > 0, ""Soft cap must be greater than zero"");
        tokenSoftcap = _softcap;
    }

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap + tokenHardcapIssuedValue;
    }
}"
4491,Exchange ETH to SNX while insisting on a particular set of rates .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchange {
    function exchangeEtherForSynthetix() external payable returns (uint);
}

interface IPricing {
    function usdToEthPrice() external view returns (uint);
    function usdToSnxPrice() external view returns (uint);
}

abstract contract ExchangeWrapper is Ownable, IExchange {
    using SafeMath for uint;

    IPricing public pricing;
    bool public paused = false;

    constructor(address _pricing) {
        pricing = IPricing(_pricing);
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }

    function exchangeEtherForSynthetixAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate) public payable override returns (uint) {
        require(!paused, ""Contract is paused"");
        require(guaranteedEtherRate == pricing.usdToEthPrice(), ""Guaranteed ether rate would not be received"");
        require(guaranteedSynthetixRate == pricing.usdToSnxPrice(), ""Guaranteed synthetix rate would not be received"");
        return exchangeEtherForSynthetix();
    }

    function exchangeEtherForSynthetix() public payable override returns (uint) {
        // Implementation of the actual exchange logic
        // This is a placeholder for the actual implementation
        return 0;
    }
}","[{'function': 'exchangeEtherForSynthetix', 'complexity': 0}, {'function': 'usdToSnxPrice', 'complexity': 0}, {'function': 'setPaused', 'complexity': 0}, {'function': 'exchangeEtherForSynthetixAtRate', 'complexity': 4}, {'function': 'exchangeEtherForSynthetix', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""exchangeEtherForSynthetixAtRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""guaranteedEtherRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""guaranteedSynthetixRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""guaranteedEtherRate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""priceOracle""}, ""memberName"": ""getPrice""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid Ether rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""guaranteedSynthetixRate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""priceOracle""}, ""memberName"": ""getPrice""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0xdead"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid Synthetix rate""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""exchangeEtherForSynthetix""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

interface IPriceOracle {
    function getPrice(address token) external view returns (uint256);
}

contract SynthExchange {
    IPriceOracle public priceOracle;

    constructor(address _priceOracle) {
        priceOracle = IPriceOracle(_priceOracle);
    }

    function exchangeEtherForSynthetixAtRate(uint256 guaranteedEtherRate, uint256 guaranteedSynthetixRate) public payable returns (uint256) {
        require(guaranteedEtherRate == priceOracle.getPrice(address(this)), ""Invalid Ether rate"");
        require(guaranteedSynthetixRate == priceOracle.getPrice(address(0xdead)), ""Invalid Synthetix rate"");

        return exchangeEtherForSynthetix();
    }

    function exchangeEtherForSynthetix() internal returns (uint256) {
        // Assuming the actual exchange logic is implemented here.
        // This would involve calling a method to exchange Ether for Synthetix tokens.
        // For demonstration, let's assume it returns the amount of Synthetix tokens received.
        return 0; // Placeholder for the actual implementation.
    }
}",44.35189938545227,exchangeEtherForSynthetixAtRate,12.0,0.9042429726276936,0.3203407719886111,"[{'function': 'getPrice', 'complexity': 0}, {'function': 'exchangeEtherForSynthetixAtRate', 'complexity': 2}, {'function': 'exchangeEtherForSynthetix', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

interface IPriceOracle {
    function getPrice(address token) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract SynthExchange is Ownable {
    IPriceOracle public priceOracle;

    constructor(address _priceOracle) Ownable(msg.sender) {
        require(_priceOracle != address(0), ""Invalid price oracle address"");
        priceOracle = IPriceOracle(_priceOracle);
    }

    function exchangeEtherForSynthetixAtRate(uint256 guaranteedEtherRate, uint256 guaranteedSynthetixRate) public payable returns (uint256) {
        require(guaranteedEtherRate == priceOracle.getPrice(address(this)), ""Invalid Ether rate"");
        require(guaranteedSynthetixRate == priceOracle.getPrice(address(0xdead)), ""Invalid Synthetix rate"");

        return exchangeEtherForSynthetix();
    }

    function exchangeEtherForSynthetix() internal returns (uint256) {
        // Assuming the actual exchange logic is implemented here.
        // This would involve calling a method to exchange Ether for Synthetix tokens.
        // For demonstration, let's assume it returns the amount of Synthetix tokens received.
        return 0; // Placeholder for the actual implementation.
    }
}"
4173,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract {
    using SafeMath for uint256;

    enum Error { NO_ERROR, SOME_ERROR }

    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {
        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);
        if (err != Error.NO_ERROR) {
            return (uint(err), 0, 0);
        }
        return (0, supplyValue, borrowValue);
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        // Implement the logic of calculateAccountValuesInternal here
        // For demonstration purposes, let's assume it returns some values based on userAddress
        return (Error.NO_ERROR, 100, 50);
    }
}","[{'function': 'calculateAccountValues', 'complexity': 1}, {'function': 'calculateAccountValuesInternal', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateAccountValuesInternal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Error""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""supplyValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""borrowValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""50"", ""subdenomination"": None}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Error""}, ""memberName"": ""NO_ERROR""}, {""type"": ""Identifier"", ""name"": ""supplyValue""}, {""type"": ""Identifier"", ""name"": ""borrowValue""}], ""isArray"": False}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AccountValuesCalculator {
    enum Error { NO_ERROR, ERROR }

    function calculateAccountValues(address userAddress) public view returns (uint256 errorCode, uint256 supplyValue, uint256 borrowValue) {
        // Call the internal function to get the results and error status
        (Error err, uint256 _supplyValue, uint256 _borrowValue) = calculateAccountValuesInternal(userAddress);

        // Check if there was an error
        if (err == Error.ERROR) {
            return (uint256(err), 0, 0);
        } else {
            return (0, _supplyValue, _borrowValue);
        }
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint256, uint256) {
        // Placeholder for the actual implementation of `calculateAccountValuesInternal`
        // This should contain the logic to fetch supply and borrow values based on `userAddress`

        // For demonstration purposes, let's assume we have a function that returns these values:
        uint256 supplyValue = 100; // Example value
        uint256 borrowValue = 50;  // Example value

        return (Error.NO_ERROR, supplyValue, borrowValue);
    }
}",44.93216061592102,calculateAccountValues,16.0,0.9131566960323624,0.3897251769968554,"[{'function': 'calculateAccountValues', 'complexity': 1}, {'function': 'calculateAccountValuesInternal', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AccountValuesCalculator is Ownable {
    enum Error { NO_ERROR, ERROR }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function calculateAccountValues(address userAddress) public view returns (uint256 errorCode, uint256 supplyValue, uint256 borrowValue) {
        // Call the internal function to get the results and error status
        (Error err, uint256 _supplyValue, uint256 _borrowValue) = calculateAccountValuesInternal(userAddress);

        // Check if there was an error
        if (err == Error.ERROR) {
            return (uint256(err), 0, 0);
        } else {
            return (0, _supplyValue, _borrowValue);
        }
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint256, uint256) {
        // Placeholder for the actual implementation of `calculateAccountValuesInternal`
        // This should contain the logic to fetch supply and borrow values based on `userAddress`

        // For demonstration purposes, let's assume we have a function that returns these values:
        uint256 supplyValue = 100; // Example value
        uint256 borrowValue = 50;  // Example value

        return (Error.NO_ERROR, supplyValue, borrowValue);
    }
}"
4418,Create a new payment channel between two parties,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NettingChannelRegistry is Ownable {
    using SafeMath for uint256;

    struct Data {
        address token;
        address[][] nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint) partyhash_to_channelpos;
        address[] all_channels;
        mapping(address => mapping(address => uint)) node_index;
    }

    Data data;

    function newChannel(address partner, uint settle_timeout) external returns (address) {
        Data storage self = data;
        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];
        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint channel_pos = self.partyhash_to_channelpos[party_hash];
        address new_channel_address = new NettingChannelContract(self.token, msg.sender, partner, settle_timeout);
        if (channel_pos != 0) {
            address settled_channel = self.all_channels[channel_pos - 1];
            require(!contractExists(settled_channel));
            uint caller_pos = self.node_index[msg.sender][partner];
            uint partner_pos = self.node_index[partner][msg.sender];
            self.all_channels[channel_pos - 1] = new_channel_address;
            caller_channels[caller_pos - 1] = new_channel_address;
            partner_channels[partner_pos - 1] = new_channel_address;
        } else {
            self.all_channels.push(new_channel_address);
            caller_channels.push(new_channel_address);
            partner_channels.push(new_channel_address);
            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;
            self.node_index[msg.sender][partner] = caller_channels.length;
            self.node_index[partner][msg.sender] = partner_channels.length;
        }
        return new_channel_address;
    }

    function contractExists(address contractAddress) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(contractAddress) }
        return size > 0;
    }
}","[{'function': 'newChannel', 'complexity': 3}, {'function': 'contractExists', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""newChannel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""partner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""settle_timeout"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""partner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot create a channel with oneself""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""party_hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""partner""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""channel_pos"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""partyhash_to_channelpos""}, ""index"": {""type"": ""Identifier"", ""name"": ""party_hash""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newChannelAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""deployNewChannel""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""all_channels""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newChannelAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""all_channels""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""nodeaddress_to_channeladdresses""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""nodeaddress_to_channeladdresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""partyhash_to_channelpos""}, ""index"": {""type"": ""Identifier"", ""name"": ""party_hash""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""node_index""}, ""index"": {""type"": ""Identifier"", ""name"": ""partner""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""settledChannelAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""data""}, ""memberName"": ""all_channels""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""channel_pos""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""contractExists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""settledChannelAddress""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Settled channel contract must be terminated""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract NettingChannel {
    struct Data {
        address[] all_channels;
        mapping(address => uint256[]) nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        mapping(address => uint256) node_index;
    }

    Data data;

    function newChannel(address partner, uint256 settle_timeout) external {
        require(partner != msg.sender, ""Cannot create a channel with oneself"");

        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint256 channel_pos = data.partyhash_to_channelpos[party_hash];

        if (channel_pos == 0) {
            // No existing channel found, create a new one
            address newChannelAddress = deployNewChannel();
            data.all_channels.push(newChannelAddress);
            uint256 index = data.all_channels.length - 1;
            data.nodeaddress_to_channeladdresses[msg.sender].push(index);
            data.nodeaddress_to_channeladdresses[partner].push(index);
            data.partyhash_to_channelpos[party_hash] = index + 1;
            data.node_index[msg.sender] = index + 1;
            data.node_index[partner] = index + 1;
        } else {
            // Channel exists, ensure it is not settled and update if necessary
            address settledChannelAddress = data.all_channels[channel_pos - 1];
            require(!contractExists(settledChannelAddress), ""Settled channel contract must be terminated"");
            // Update existing channel or replace if needed (not applicable here)
        }
    }

    function deployNewChannel() internal returns (address newContractAddress) {
        // Deploy a new NettingChannelContract and return its address
        // This is a placeholder for actual deployment logic
        bytes memory bytecode = type(NettingChannelContract).creationCode;
        bytes32 salt = keccak256(abi.encodePacked(msg.sender, partner));
        assembly {
            newContractAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)
        }
    }

    function contractExists(address contractAddress) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(contractAddress) }
        return size > 0;
    }
}",49.15498042106629,newChannel,78.0,0.7232483041976578,0.2084584622778659,"[{'function': 'newChannel', 'complexity': 4}, {'function': 'deployNewChannel', 'complexity': 0}, {'function': 'contractExists', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NettingChannel is Ownable {
    struct Data {
        address[] all_channels;
        mapping(address => uint256[]) nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        mapping(address => uint256) node_index;
    }

    Data data;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        data.all_channels = [0x1111111122222222333333334444444455555555];
        // Initialize other state variables similarly...
    }

    function newChannel(address partner, uint256 settle_timeout) external {
        require(partner != msg.sender, ""Cannot create a channel with oneself"");

        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint256 channel_pos = data.partyhash_to_channelpos[party_hash];

        if (channel_pos == 0) {
            // No existing channel found, create a new one
            address newChannelAddress = deployNewChannel();
            data.all_channels.push(newChannelAddress);
            uint256 index = data.all_channels.length - 1;
            data.nodeaddress_to_channeladdresses[msg.sender].push(index);
            data.nodeaddress_to_channeladdresses[partner].push(index);
            data.partyhash_to_channelpos[party_hash] = index + 1;
            data.node_index[msg.sender] = index + 1;
            data.node_index[partner] = index + 1;
        } else {
            // Channel exists, ensure it is not settled and update if necessary
            address settledChannelAddress = data.all_channels[channel_pos - 1];
            require(!contractExists(settledChannelAddress), ""Settled channel contract must be terminated"");
            // Update existing channel or replace if needed (not applicable here)
        }
    }

    function deployNewChannel() internal returns (address newContractAddress) {
        // Deploy a new NettingChannelContract and return its address
        // This is a placeholder for actual deployment logic
        bytes memory bytecode = type(NettingChannelContract).creationCode;
        bytes32 salt = keccak256(abi.encodePacked(msg.sender, partner));
        assembly {
            newContractAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)
        }
    }

    function contractExists(address contractAddress) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(contractAddress) }
        return size > 0;
    }
}"
6848,from ` _from ` will be sended ` _value ` tokens to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public approved;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        approved[_from][msg.sender] = approved[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(allowances[_from][msg.sender] >= _value, ""Insufficient allowance"");
        require(balances[_from] >= _value, ""Insufficient balance"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }
}",43.605297327041626,transferFrom,38.0,0.7979791743317852,0.4778539921447702,"[{'function': 'transferFrom', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Initial balance for the owner
        allowances[msg.sender][address(this)] = type(uint256).max; // Infinite allowance for this contract
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        require(allowances[_from][msg.sender] >= _value, ""Insufficient allowance"");
        require(balances[_from] >= _value, ""Insufficient balance"");

        balances[_from] -= _value;
        balances[_to] += _value;
        allowances[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }
}"
967,Sets the message sender as the winner if they have completed the hunt,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    bool public grace = false;
    uint[] public locations;
    mapping(address => Hunter[]) public hunters;
    address public winner;
    uint public timeOfWin;

    struct Hunter {
        uint block;
        bytes32 encryptKey;
    }

    event WonEvent(address indexed winner);

    function checkWin(uint[] memory decryptKeys) public {
        require(!grace, ""Grace period is active"");
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        uint lastBlock = 0;
        bool won = true;

        for (uint i = 0; i < locations.length; i++) {
            require(hunters[msg.sender][i].block > lastBlock, ""Blocks must be in increasing order"");
            lastBlock = hunters[msg.sender][i].block;

            if (locations[i] != 0) {
                uint storedVal = uint(keccak256(abi.encodePacked(hunters[msg.sender][i].encryptKey ^ decryptKeys[i])));
                won = won && (locations[i] == storedVal);
            }
        }

        require(won, ""Not all conditions are met"");

        if (won) {
            timeOfWin = block.timestamp;
            winner = msg.sender;
            grace = true;
            emit WonEvent(winner);
        }
    }
}","[{'function': 'checkWin', 'complexity': 9}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkWin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""decryptKeys"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""playerDecrypts""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""decryptKeys""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""locations""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Length of decryptKeys must match length of locations""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""locations""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""locations""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""^"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""locations""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""decryptKeys""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}], ""isArray"": False}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""locations""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}], ""isArray"": False}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""won""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""winner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeOfWin""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""WonEvent""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyNotWon"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyGracePeriodEnded"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Game {
    uint[] public locations;
    mapping(address => uint[]) private playerDecrypts;
    bool public grace = false;
    address public winner;
    uint public timeOfWin;
    bool public won = false;

    event WonEvent(address indexed winner);

    modifier onlyNotWon() {
        require(!won, ""Game already won"");
        _;
    }

    modifier onlyGracePeriodEnded() {
        require(!grace, ""Grace period not ended"");
        _;
    }

    constructor(uint[] memory initLocations) {
        locations = initLocations;
    }

    function submitDecryptKeys(uint[] memory decryptKeys) public onlyNotWon onlyGracePeriodEnded {
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        playerDecrypts[msg.sender] = decryptKeys;
    }

    function checkWin() public onlyNotWon onlyGracePeriodEnded returns (bool) {
        uint[] memory decryptKeys = playerDecrypts[msg.sender];
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        for (uint i = 0; i < locations.length; i++) {
            if (locations[i] != 0 && ((locations[i] ^ uint256(decryptKeys[i])) != locations[i])) {
                return false;
            }
        }

        won = true;
        winner = msg.sender;
        timeOfWin = block.timestamp;
        emit WonEvent(msg.sender);

        return true;
    }
}",46.93727660179138,checkWin,58.0,0.7781839554477665,0.2695427116506781,"[{'function': 'submitDecryptKeys', 'complexity': 1}, {'function': 'checkWin', 'complexity': 5}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Game is Ownable {
    uint[] public locations;
    mapping(address => uint[]) private playerDecrypts;
    bool public grace = false;
    address public winner;
    uint public timeOfWin;
    bool public won = false;

    event WonEvent(address indexed winner);

    modifier onlyNotWon() {
        require(!won, ""Game already won"");
        _;
    }

    modifier onlyGracePeriodEnded() {
        require(!grace, ""Grace period not ended"");
        _;
    }

    constructor(uint[] memory initLocations) Ownable(msg.sender) {
        locations = initLocations;
    }

    function submitDecryptKeys(uint[] memory decryptKeys) public onlyNotWon onlyGracePeriodEnded {
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        playerDecrypts[msg.sender] = decryptKeys;
    }

    function checkWin() public onlyNotWon onlyGracePeriodEnded returns (bool) {
        uint[] memory decryptKeys = playerDecrypts[msg.sender];
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        for (uint i = 0; i < locations.length; i++) {
            if (locations[i] != 0 && ((locations[i] ^ uint256(decryptKeys[i])) != locations[i])) {
                return false;
            }
        }

        won = true;
        winner = msg.sender;
        timeOfWin = block.timestamp;
        emit WonEvent(msg.sender);

        return true;
    }
}"
5478,Allow users to buy tokens for ` _buyExchangeRate ` eth and sell tokens for ` _sellExchangeRate ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExchangeRateSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    function setExchangeRate(uint256 _sellExchangeRate, uint256 _buyExchangeRate) public onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}","[{'function': 'setExchangeRate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setExchangeRates"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_sellExchangeRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_buyExchangeRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellExchangeRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_sellExchangeRate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyExchangeRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_buyExchangeRate""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ExchangeRates is Ownable {
    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    function setExchangeRates(uint256 _sellExchangeRate, uint256 _buyExchangeRate) external onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}",41.97361779212952,setExchangeRates,0.0,0.966319154817746,0.744373319312051,"[{'function': 'setExchangeRates', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ExchangeRates is Ownable {
    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    constructor() Ownable(msg.sender) {
        sellExchangeRate = 1;
        buyExchangeRate = 1;
    }

    function setExchangeRates(uint256 _sellExchangeRate, uint256 _buyExchangeRate) external onlyOwner {
        require(_sellExchangeRate > 0 && _buyExchangeRate > 0, ""Exchange rates must be greater than zero"");
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}"
1010,Fills a offer that has been previously made using ` makeOffer ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Assuming _v, _r, and _s are state variables or parameters passed to the function
    bytes32 private constant EIP191_PREFIX = 0x1901;

    constructor() Ownable() {}

    function fillOffer(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint64 _nonce, uint8 v, bytes32 r, bytes32 s) external onlyOwner {
        require(_recoverAddress(keccak256(abi.encodePacked(EIP191_PREFIX, ""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce)), v, r, s) == _filler, ""Invalid signature"");
        bytes32 msgHash = keccak256(abi.encodePacked(""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
        _validateAndAddHash(msgHash);
        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    function _validateAndAddHash(bytes32 hash) internal virtual;

    function _fill(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount) internal virtual;
}","[{'function': 'fillOffer', 'complexity': 1}, {'function': '_recoverAddress', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""fillOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_filler"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_offerHash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amountToTake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_feeAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recoverAddress""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""_nonce""}, {""type"": ""Identifier"", ""name"": ""_v""}, {""type"": ""Identifier"", ""name"": ""_r""}, {""type"": ""Identifier"", ""name"": ""_s""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_filler""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""FilledOffer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_filler""}, {""type"": ""Identifier"", ""name"": ""_offerHash""}, {""type"": ""Identifier"", ""name"": ""_amountToTake""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCoordinator"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""onlyActiveState"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract OfferFiller {
    address public coordinator;
    bool public activeState;

    event FilledOffer(address indexed filler, bytes32 indexed offerHash, uint amountToTake, address feeAsset, uint feeAmount);

    modifier onlyCoordinator() {
        require(msg.sender == coordinator, ""Only coordinator can call this function"");
        _;
    }

    modifier onlyActiveState() {
        require(activeState, ""Contract must be in an active state"");
        _;
    }

    constructor(address _coordinator) {
        coordinator = _coordinator;
        activeState = true;
    }

    function fillOffer(
        address _filler,
        bytes32 _offerHash,
        uint _amountToTake,
        address _feeAsset,
        uint _feeAmount,
        uint _nonce,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external onlyCoordinator onlyActiveState {
        require(_recoverAddress(_offerHash, _nonce, _v, _r, _s) == _filler, ""Invalid signature"");
        emit FilledOffer(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
        // Assuming _validateAndAddHash and _fill are defined elsewhere in the contract or library.
        // _validateAndAddHash(msgHash); // If you need to keep track of validated hashes.
        // _fill(_offerHash, _amountToTake, _feeAsset, _feeAmount); // Call the function to fill the offer.
    }

    function _recoverAddress(bytes32 hash, uint nonce, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)), v, r, s);
    }
}",46.77085900306702,fillOffer,32.0,0.6951463176892735,0.3918656201922285,"[{'function': 'fillOffer', 'complexity': 0}, {'function': '_recoverAddress', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OfferFiller is Ownable {
    address public coordinator;
    bool public activeState;

    event FilledOffer(address indexed filler, bytes32 indexed offerHash, uint amountToTake, address feeAsset, uint feeAmount);

    modifier onlyCoordinator() {
        require(msg.sender == coordinator, ""Only coordinator can call this function"");
        _;
    }

    modifier onlyActiveState() {
        require(activeState, ""Contract must be in an active state"");
        _;
    }

    constructor(address _coordinator) Ownable(msg.sender) {
        coordinator = _coordinator;
        activeState = true;
    }

    function fillOffer(
        address _filler,
        bytes32 _offerHash,
        uint _amountToTake,
        address _feeAsset,
        uint _feeAmount,
        uint _nonce,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external onlyCoordinator onlyActiveState {
        require(_recoverAddress(_offerHash, _nonce, _v, _r, _s) == _filler, ""Invalid signature"");
        emit FilledOffer(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
        // Assuming _validateAndAddHash and _fill are defined elsewhere in the contract or library.
        // _validateAndAddHash(msgHash); // If you need to keep track of validated hashes.
        // _fill(_offerHash, _amountToTake, _feeAsset, _feeAmount); // Call the function to fill the offer.
    }

    function _recoverAddress(bytes32 hash, uint nonce, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)), v, r, s);
    }
}"
1790,Update the Synthetix Drawing Rights exchange rate based on other rates already updated .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public xdrParticipants;
    mapping(address => uint256) public rates;
    mapping(string => uint256) public lastRateUpdateTimes;

    event RatesUpdated(bytes4[] currencyCode, uint256[] rate);

    function updateXDRRate(uint timeSent) external onlyOwner {
        uint total = 0;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            total = rates[xdrParticipants[i]].add(total);
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;

        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";

        uint[] memory eventRate = new uint[](1);
        eventRate[0] = rates[""XDR""];

        emit RatesUpdated(eventCurrencyCode, eventRate);
    }
}","[{'function': 'updateXDRRate', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateXDRRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""total"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""xdrParticipants""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""participant"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""xdrParticipants""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""total""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""Identifier"", ""name"": ""participant""}}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}, ""right"": {""type"": ""Identifier"", ""name"": ""total""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lastRateUpdateTimes""}, ""index"": {""type"": ""stringLiteral"", ""value"": ""XDR""}}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""length"": None}, ""name"": ""eventCurrencyCode"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""eventCurrencyCode""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""XDR""}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""eventRate"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""eventRate""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""Identifier"", ""name"": ""total""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""RatesUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""eventCurrencyCode""}, {""type"": ""Identifier"", ""name"": ""eventRate""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract XDRUpdater {
    mapping(string => uint) public rates;
    mapping(string => uint) public lastRateUpdateTimes;
    string[] private xdrParticipants;

    constructor(string[] memory participants, uint[] memory initialRates) {
        for (uint i = 0; i < participants.length; i++) {
            xdrParticipants.push(participants[i]);
            rates[participants[i]] = initialRates[i];
        }
    }

    function updateXDRRate(uint timeSent) public {
        uint total = 0;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            string memory participant = xdrParticipants[i];
            total += rates[participant];
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;

        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = bytes4(""XDR"");

        uint[] memory eventRate = new uint[](1);
        eventRate[0] = total;

        emit RatesUpdated(eventCurrencyCode, eventRate);
    }

    event RatesUpdated(bytes4[] currencyCode, uint[] rate);
}",44.67260718345642,updateXDRRate,16.0,0.9489546818161724,0.7389319787925257,"[{'function': 'updateXDRRate', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract XDRUpdater is Ownable {
    mapping(string => uint) public rates;
    mapping(string => uint) public lastRateUpdateTimes;
    string[] private xdrParticipants;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 0; i < 3; i++) {
            xdrParticipants.push(addressToString(address(uint160(uint256(keccak256(abi.encodePacked(""participant"", i))))));
            rates[xdrParticipants[i]] = uint256(keccak256(abi.encodePacked(""rate"", i))) % 2**256;
        }
    }

    function addressToString(address addr) internal pure returns (string memory) {
        return string(abi.encodePacked(addr));
    }

    function updateXDRRate(uint timeSent) public {
        uint total = 0;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            string memory participant = xdrParticipants[i];
            total += rates[participant];
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;

        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";

        uint[] memory eventRate = new uint[](1);
        eventRate[0] = total;

        emit RatesUpdated(eventCurrencyCode, eventRate);
    }

    event RatesUpdated(bytes4[] currencyCode, uint[] rate);
}"
3704,Buy tokens from contract by sending ethereum to contract address with no minimum contribution,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint public buyPrice = 100; // Example price, adjust as needed
    Token token;

    mapping(address => uint256) public balanceOf;
    address public creator;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(Token _token, address _creator) {
        token = _token;
        creator = _creator;
    }

    function () external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint amount = msg.value.mul(buyPrice);
        uint amountRaised;
        amountRaised = amountRaised.add(msg.value);
        require(token.balanceOf(creator) >= amount, ""Insufficient balance of creator"");
        require(msg.value > 0, ""Amount must be greater than zero"");
        token.transfer(msg.sender, amount);
        token.transfer(creator, msg.value);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': '', 'complexity': 3}]",4.0,{},"pragma solidity ^0.8.0;

contract TokenPurchase {
    mapping(address => uint256) public balanceOf;
    uint256 public amountRaised;
    address public creator;
    uint256 public buyPrice; // Price per token in wei

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyCreator() {
        require(msg.sender == creator, ""Only the creator can call this function"");
        _;
    }

    constructor(uint256 _buyPrice) {
        creator = msg.sender;
        buyPrice = _buyPrice;
    }

    function handlePurchase() internal payable {
        require(msg.value > 0, ""Ether value must be greater than zero"");

        uint256 tokenAmount = msg.value / buyPrice;
        amountRaised += msg.value;

        require(balanceOf[creator] >= tokenAmount, ""Creator does not have enough tokens to transfer"");

        balanceOf[msg.sender] += tokenAmount;
        balanceOf[creator] -= tokenAmount;

        emit Transfer(address(0), msg.sender, tokenAmount);

        // Transfer the accumulated amount raised to the creator's address
        (bool success, ) = creator.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
    }

    receive() external payable {
        handlePurchase();
    }
}",45.1932487487793,handlePurchase,,0.8593153321617792,0.201331072936111,"[{'function': 'handlePurchase', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenPurchase is Ownable {
    mapping(address => uint256) public balanceOf;
    uint256 public amountRaised;
    address public creator;
    uint256 public buyPrice; // Price per token in wei

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyCreator() {
        require(msg.sender == creator, ""Only the creator can call this function"");
        _;
    }

    constructor(uint256 _buyPrice) Ownable(msg.sender) {
        buyPrice = _buyPrice;
        creator = msg.sender;
    }

    function handlePurchase() internal payable {
        require(msg.value > 0, ""Ether value must be greater than zero"");

        uint256 tokenAmount = msg.value / buyPrice;
        amountRaised += msg.value;

        require(balanceOf[creator] >= tokenAmount, ""Creator does not have enough tokens to transfer"");

        balanceOf[msg.sender] += tokenAmount;
        balanceOf[creator] -= tokenAmount;

        emit Transfer(address(0), msg.sender, tokenAmount);

        // Transfer the accumulated amount raised to the creator's address
        (bool success, ) = creator.call{value: msg.value}("""");
        require(success, ""Transfer failed"");
    }

    receive() external payable {
        handlePurchase();
    }
}"
2468,"Decentralizes the contract , this operation can not be undone","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function removeOwnership(address _dece) public onlyOwner {
        require(_dece == 0xdece);
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}","[{'function': 'removeOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_dece"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_dece""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0xdece"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipRemoved""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Ownable {
    address public owner;
    address public newOwnerCandidate;

    event OwnershipRemoved();

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function removeOwnership(address _dece) external onlyOwner {
        require(_dece == 0xdece);
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}",42.66942238807678,removeOwnership,0.0,0.9859971169170714,0.9257518071011758,"[{'function': 'removeOwnership', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;
    address public newOwnerCandidate;

    event OwnershipRemoved();

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor(address _owner) Ownable(_owner) {
        owner = _owner;
    }

    function removeOwnership(address _dece) external onlyOwner {
        require(_dece == 0x1111111111111111111111111111111111111111);
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}"
97,This is public rather than external so it can be called by derived contracts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused = true;

    modifier onlyManager() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}","[{'function': 'unpause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpauseContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PausableContract {
    bool public paused = true;

    modifier onlyManager() {
        require(msg.sender == manager, ""Only the manager can call this function."");
        _;
    }

    address public manager;

    constructor(address _manager) {
        manager = _manager;
    }

    function unpauseContract() external onlyManager {
        paused = false;
    }
}",42.08668065071106,unpauseContract,0.0,0.93732739810068,0.5348259312838877,"[{'function': 'unpauseContract', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PausableContract is Ownable {
    bool public paused = true;

    modifier onlyManager() {
        require(msg.sender == manager, ""Only the manager can call this function."");
        _;
    }

    address public manager;

    constructor(address _manager) Ownable(_manager) {
        manager = _manager;
    }

    function unpauseContract() external onlyManager {
        paused = false;
    }
}"
5181,Checks if an address ` _address ` is one of 3rd party owners ( origin owner is not included ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Role { ROLE_THIRDPARTY_OWNER }
    mapping(address => mapping(Role => bool)) public ownerRoles;

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return ownerRoles[_address][ROLE_THIRDPARTY_OWNER];
    }
}","[{'function': 'isThirdPartyOwner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRole"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_role""}, ""right"": {""type"": ""Identifier"", ""name"": ""ROLE_THIRDPARTY_OWNER""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid role""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addressRoles""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_role""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    // Assuming ROLE_THIRDPARTY_OWNER is a constant or enum representing the third-party owner role
    uint256 public constant ROLE_THIRDPARTY_OWNER = 1;

    // Mapping to store roles for addresses
    mapping(address => uint256) public addressRoles;

    // Function to set a role for an address
    function setRole(address _address, uint256 _role) public {
        require(_role == ROLE_THIRDPARTY_OWNER, ""Invalid role"");
        addressRoles[_address] = _role;
    }

    // Function to check if an address has the third-party owner role
    function isThirdPartyOwner(address _address) public view returns (bool) {
        return addressRoles[_address] == ROLE_THIRDPARTY_OWNER;
    }
}",43.34530401229858,setRole,12.0,0.7706939851306384,0.0560666841119542,"[{'function': 'setRole', 'complexity': 1}, {'function': 'isThirdPartyOwner', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    // Assuming ROLE_THIRDPARTY_OWNER is a constant or enum representing the third-party owner role
    uint256 public constant ROLE_THIRDPARTY_OWNER = 1;

    // Mapping to store roles for addresses
    mapping(address => uint256) public addressRoles;

    // Constructor to initialize all instance variables with safe, non-corner-case values
    constructor() Ownable(msg.sender) {
        // Initialize state variables
        ROLE_THIRDPARTY_OWNER = 1;
        address zeroAddress = address(0);
        for (uint256 i = 1; i <= 3; i++) {
            if (i == 1) {
                addressRoles[msg.sender] = ROLE_THIRDPARTY_OWNER;
            } else {
                addressRoles[address(uint160(i))] = 0; // Placeholder for other addresses
            }
        }
    }

    // Function to set a role for an address
    function setRole(address _address, uint256 _role) public {
        require(_role == ROLE_THIRDPARTY_OWNER, ""Invalid role"");
        addressRoles[_address] = _role;
    }

    // Function to check if an address has the third-party owner role
    function isThirdPartyOwner(address _address) public view returns (bool) {
        return addressRoles[_address] == ROLE_THIRDPARTY_OWNER;
    }
}"
4562,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ISecurityToken {
    function totalSupplyAt(uint256 checkpointId) external view returns (uint256);
    function balanceOfAt(address account, uint256 checkpointId) external view returns (uint256);
    function currentCheckpointId() external view returns (uint256);
}

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    struct Dividend {
        uint256 checkpointId;
        uint256 creationTime;
        uint256 maturity;
        uint256 expiry;
        uint256 amount;
        uint256 totalSupply;
        uint256 claimedAmount;
        bool isClaimed;
        uint256 claimableDays;
        uint256 penaltyPercentage;
        bytes32 name;
        mapping(address => bool) dividendExcluded;
    }

    Dividend[] public dividends;
    ISecurityToken public securityToken;
    uint256 public constant EXCLUDED_ADDRESS_LIMIT = 100;

    event EtherDividendDeposited(address indexed sender, uint256 checkpointId, uint256 time, uint256 maturity, uint256 expiry, uint256 amount, uint256 totalSupply, uint256 dividendIndex, bytes32 name);

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, ""Too many addresses excluded"");
        require(_expiry > _maturity, ""Expiry is before maturity"");
        require(_expiry > block.timestamp, ""Expiry is in the past"");
        require(msg.value > 0, ""No dividend sent"");
        require(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId(), ""Invalid checkpoint ID"");
        require(_name[0] != 0, ""Invalid name"");

        uint256 dividendIndex = dividends.length;
        uint256 currentSupply = ISecurityToken(securityToken).totalSupplyAt(_checkpointId);
        uint256 excludedSupply = 0;
        dividends.push(Dividend({
            checkpointId: _checkpointId,
            creationTime: block.timestamp,
            maturity: _maturity,
            expiry: _expiry,
            amount: msg.value,
            totalSupply: 0,
            claimedAmount: 0,
            isClaimed: false,
            claimableDays: 0,
            penaltyPercentage: 0,
            name: _name,
            dividendExcluded: new mapping(address => bool)(address(0))
        }));

        for (uint256 j = 0; j < _excluded.length; j++) {
            require(_excluded[j] != address(0), ""Invalid address"");
            require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], ""Duped exclude address"");
            excludedSupply = excludedSupply.add(ISecurityToken(securityToken).balanceOfAt(_excluded[j], _checkpointId));
            dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;
        }

        dividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);
        emit EtherDividendDeposited(msg.sender, _checkpointId, block.timestamp, _maturity, _expiry, msg.value, currentSupply, dividendIndex, _name);
    }
}","[{'function': 'currentCheckpointId', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 10}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maturity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_checkpointId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excluded"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Ether value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_name""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Dividend name must not be empty""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Dividend""}, ""name"": ""dividend"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""memberName"": ""push""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividend""}, ""memberName"": ""maturity""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maturity""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividend""}, ""memberName"": ""expiry""}, ""right"": {""type"": ""Identifier"", ""name"": ""_expiry""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividend""}, ""memberName"": ""checkpointId""}, ""right"": {""type"": ""Identifier"", ""name"": ""_checkpointId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividend""}, ""memberName"": ""name""}, ""right"": {""type"": ""Identifier"", ""name"": ""_name""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividend""}, ""memberName"": ""exclusionMap""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""calculateSupplyAtCheckpoint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_checkpointId""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""currentSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getBalance""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excluded""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividend""}, ""memberName"": ""totalSupplyExcluded""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentSupply""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""EtherDividendDeposited""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dividends""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""Identifier"", ""name"": ""_name""}, {""type"": ""Identifier"", ""name"": ""_maturity""}, {""type"": ""Identifier"", ""name"": ""_expiry""}, {""type"": ""Identifier"", ""name"": ""_checkpointId""}, {""type"": ""Identifier"", ""name"": ""_excluded""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validMaturity"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maturity""}]}, {""type"": ""ModifierInvocation"", ""name"": ""validExpiry"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_expiry""}, {""type"": ""Identifier"", ""name"": ""_maturity""}]}, {""type"": ""ModifierInvocation"", ""name"": ""validCheckpointId"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_checkpointId""}]}, {""type"": ""ModifierInvocation"", ""name"": ""validExcludedAddresses"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_excluded""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract DividendManager {
    struct Dividend {
        uint256 maturity;
        uint256 expiry;
        uint256 checkpointId;
        address[] excludedAddresses;
        string name;
        mapping(address => bool) exclusionMap;
        uint256 totalSupplyExcluded;
    }

    Dividend[] public dividends;
    uint256 public constant MAX_EXCLUDED_ADDRESSES = 100;

    event EtherDividendDeposited(uint256 indexed dividendId, string name, uint256 maturity, uint256 expiry, uint256 checkpointId, address[] excludedAddresses);

    modifier validMaturity(uint256 _maturity) {
        require(_maturity > block.timestamp, ""Maturity must be in the future"");
        _;
    }

    modifier validExpiry(uint256 _expiry, uint256 _maturity) {
        require(_expiry > _maturity, ""Expiry must be after maturity"");
        require(_expiry > block.timestamp, ""Expiry must be in the future"");
        _;
    }

    modifier validCheckpointId(uint256 _checkpointId) {
        // Assuming there's a function to get current checkpoint ID of the security token
        uint256 currentCheckpoint = getCurrentCheckpoint();
        require(_checkpointId <= currentCheckpoint, ""Checkpoint ID must be less than or equal to the current checkpoint ID"");
        _;
    }

    modifier validExcludedAddresses(address[] memory _excluded) {
        require(_excluded.length <= MAX_EXCLUDED_ADDRESSES, ""Number of excluded addresses exceeds limit"");
        for (uint256 i = 0; i < _excluded.length; i++) {
            require(_excluded[i] != address(0), ""Excluded address must be valid"");
            for (uint256 j = i + 1; j < _excluded.length; j++) {
                require(_excluded[i] != _excluded[j], ""Excluded addresses must not be duplicated"");
            }
        }
        _;
    }

    function createDividend(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, string memory _name) public payable validMaturity(_maturity) validExpiry(_expiry, _maturity) validCheckpointId(_checkpointId) validExcludedAddresses(_excluded) {
        require(msg.value > 0, ""Ether value must be greater than zero"");
        require(bytes(_name).length > 0, ""Dividend name must not be empty"");

        Dividend storage dividend = dividends.push();
        dividend.maturity = _maturity;
        dividend.expiry = _expiry;
        dividend.checkpointId = _checkpointId;
        dividend.name = _name;

        for (uint256 i = 0; i < _excluded.length; i++) {
            dividend.exclusionMap[_excluded[i]] = true;
        }

        // Calculate total supply excluding excluded addresses
        uint256 currentSupply = calculateSupplyAtCheckpoint(_checkpointId);
        for (uint256 i = 0; i < _excluded.length; i++) {
            currentSupply -= getBalance(_excluded[i]);
        }
        dividend.totalSupplyExcluded = currentSupply;

        emit EtherDividendDeposited(dividends.length - 1, _name, _maturity, _expiry, _checkpointId, _excluded);
    }

    function getBalance(address addr) internal view returns (uint256 balance) {
        // Assuming this function is defined to return the balance of an address
        balance = addr.balance;
    }

    function getCurrentCheckpoint() internal virtual pure returns (uint256) {
        // This should be implemented by the security token contract or a derived contract
        revert(""NotImplemented"");
    }

    function calculateSupplyAtCheckpoint(uint256 _checkpointId) internal virtual pure returns (uint256) {
        // This should be implemented by the security token contract or a derived contract
        revert(""NotImplemented"");
    }
}",53.706992387771606,createDividend,129.0,0.6950903408683448,0.1508596918933304,"[{'function': 'createDividend', 'complexity': 4}, {'function': 'getBalance', 'complexity': 0}, {'function': 'getCurrentCheckpoint', 'complexity': 0}, {'function': 'calculateSupplyAtCheckpoint', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract DividendManager {
    struct Dividend {
        uint256 maturity;
        uint256 expiry;
        uint256 checkpointId;
        address[] excludedAddresses;
        string name;
        mapping(address => bool) exclusionMap;
        uint256 totalSupplyExcluded;
    }

    Dividend[] public dividends;
    uint256 public constant MAX_EXCLUDED_ADDRESSES = 100;

    event EtherDividendDeposited(uint256 indexed dividendId, string name, uint256 maturity, uint256 expiry, uint256 checkpointId, address[] excludedAddresses);

    modifier validMaturity(uint256 _maturity) {
        require(_maturity > block.timestamp, ""Maturity must be in the future"");
        _;
    }

    modifier validExpiry(uint256 _expiry, uint256 _maturity) {
        require(_expiry > _maturity, ""Expiry must be after maturity"");
        require(_expiry > block.timestamp, ""Expiry must be in the future"");
        _;
    }

    modifier validCheckpointId(uint256 _checkpointId) {
        // Assuming there's a function to get current checkpoint ID of the security token
        uint256 currentCheckpoint = getCurrentCheckpoint();
        require(_checkpointId <= currentCheckpoint, ""Checkpoint ID must be less than or equal to the current checkpoint ID"");
        _;
    }

    modifier validExcludedAddresses(address[] memory _excluded) {
        require(_excluded.length <= MAX_EXCLUDED_ADDRESSES, ""Number of excluded addresses exceeds limit"");
        for (uint256 i = 0; i < _excluded.length; i++) {
            require(_excluded[i] != address(0), ""Excluded address must be valid"");
            for (uint256 j = i + 1; j < _excluded.length; j++) {
                require(_excluded[i] != _excluded[j], ""Excluded addresses must not be duplicated"");
            }
        }
        _;
    }

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        dividends.push(Dividend(0, 0, 0, new address[](0), """", false, 0));
        dividends[0].maturity = block.timestamp + 1; // Set maturity to a future timestamp
        dividends[0].expiry = block.timestamp + 2; // Set expiry to a future timestamp
        dividends[0].checkpointId = getCurrentCheckpoint(); // Initialize checkpoint ID with the current checkpoint
        dividends[0].excludedAddresses.length = MAX_EXCLUDED_ADDRESSES;
    }

    function createDividend(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, string memory _name) public payable validMaturity(_maturity) validExpiry(_expiry, _maturity) validCheckpointId(_checkpointId) validExcludedAddresses(_excluded) {
        require(msg.value > 0, ""Ether value must be greater than zero"");
        require(bytes(_name).length > 0, ""Dividend name must not be empty"");

        Dividend storage dividend = dividends.push();
        dividend.maturity = _maturity;
        dividend.expiry = _expiry;
        dividend.checkpointId = _checkpointId;
        dividend.name = _name;

        for (uint256 i = 0; i < _excluded.length; i++) {
            dividend.exclusionMap[_excluded[i]] = true;
        }

        // Calculate total supply excluding excluded addresses
        uint256 currentSupply = calculateSupplyAtCheckpoint(_checkpointId);
        for (uint256 i = 0; i < _excluded.length; i++) {
            currentSupply -= getBalance(_excluded[i]);
        }
        dividend.totalSupplyExcluded = currentSupply;

        emit EtherDividendDeposited(dividends.length - 1, _name, _maturity, _expiry, _checkpointId, _excluded);
    }

    function getBalance(address addr) internal view returns (uint256 balance) {
        // Assuming this function is defined to return the balance of an address
        balance = addr.balance;
    }

    function getCurrentCheckpoint() internal virtual pure returns (uint256) {
        // This should be implemented by the security token contract or a derived contract
        revert(""NotImplemented"");
    }

    function calculateSupplyAtCheckpoint(uint256 _checkpointId) internal virtual pure returns (uint256) {
        // This should be implemented by the security token contract or a derived contract
        revert(""NotImplemented"");
    }
}"
6025,Adds a token deposit to ` deposits [ ] ` ; only the ` owner ` can call this function and it will only work if the account sending the tokens has called ` approve ( ) ` so that this contract can call ` transferFrom ( ) ` and take the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenDeposit is Ownable {
    using SafeMath for uint256;

    struct Deposit {
        uint blockNumber;
        ERC20 token;
        uint amount;
    }

    Deposit[] public deposits;

    event NewDeposit(uint indexed id, ERC20 indexed token, uint amount);

    function newTokenDeposit(ERC20 _token, uint _amount, uint _block) public onlyOwner returns (uint _idDeposit) {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_block < block.number, ""Block number must be less than current block number"");
        require(_token.transferFrom(msg.sender, address(this), _amount), ""Token transfer failed"");

        _idDeposit = deposits.length;
        Deposit storage d = deposits[_idDeposit];
        d.blockNumber = _block == 0 ? block.number - 1 : _block;
        d.token = _token;
        d.amount = _amount;

        emit NewDeposit(_idDeposit, _token, _amount);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'newTokenDeposit', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""depositTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_block"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_block""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""right"": {""type"": ""Identifier"", ""name"": ""_block""}}}, {""type"": ""stringLiteral"", ""value"": ""Block number must be in the past or not set""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""currentBlock"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_block""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_block""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""currentBlock""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentBlock""}, ""right"": {""type"": ""Identifier"", ""name"": ""_block""}}, {""type"": ""stringLiteral"", ""value"": ""Block number must be less than or equal to the current block number""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""depositId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""memberName"": ""length""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Deposit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_block""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": [""blockNumber"", ""token"", ""amount""]}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""depositedBlocks""}, ""index"": {""type"": ""Identifier"", ""name"": ""_block""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""NewDeposit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""depositId""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ERC20Deposit is Ownable {
    struct Deposit {
        uint blockNumber;
        address token;
        uint amount;
    }

    Deposit[] public deposits;
    mapping(uint => bool) public depositedBlocks;

    event NewDeposit(uint indexed depositId, address indexed token, uint amount);

    function depositTokens(IERC20 _token, uint _amount, uint _block) external onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_block == 0 || block.number > _block, ""Block number must be in the past or not set"");

        uint currentBlock = block.number;
        if (_block == 0) {
            _block = currentBlock - 1;
        }

        require(currentBlock >= _block, ""Block number must be less than or equal to the current block number"");

        bool success = _token.transferFrom(msg.sender, address(this), _amount);
        require(success, ""Transfer failed"");

        uint depositId = deposits.length;
        deposits.push(Deposit({blockNumber: _block, token: address(_token), amount: _amount}));
        depositedBlocks[_block] = true;

        emit NewDeposit(depositId, address(_token), _amount);
    }
}",45.759122371673584,depositTokens,51.0,0.8189011452061151,0.3507039100175218,"[{'function': 'depositTokens', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ERC20Deposit is Ownable {
    struct Deposit {
        uint blockNumber;
        address token;
        uint amount;
    }

    Deposit[] public deposits;
    mapping(uint => bool) public depositedBlocks;

    event NewDeposit(uint indexed depositId, address indexed token, uint amount);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables with safe, non-corner-case values
        for (uint i = 0; i < deposits.length; i++) {
            delete deposits[i];
        }
        for (uint j = 0; j <= block.number; j++) {
            depositedBlocks[j] = false;
        }
    }

    function depositTokens(IERC20 _token, uint _amount, uint _block) external onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_block == 0 || block.number > _block, ""Block number must be in the past or not set"");

        uint currentBlock = block.number;
        if (_block == 0) {
            _block = currentBlock - 1;
        }

        require(currentBlock >= _block, ""Block number must be less than or equal to the current block number"");

        bool success = _token.transferFrom(msg.sender, address(this), _amount);
        require(success, ""Transfer failed"");

        uint depositId = deposits.length;
        deposits.push(Deposit({blockNumber: _block, token: address(_token), amount: _amount}));
        depositedBlocks[_block] = true;

        emit NewDeposit(depositId, address(_token), _amount);
    }
}"
521,set the ticker registration fee in POLY tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PolyRegistration {
    using SafeMath for uint256;

    uint256 public registrationFee;

    event LogChangePolyRegisterationFee(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(registrationFee != _registrationFee);
        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
        registrationFee = _registrationFee;
    }
}","[{'function': 'changePolyRegisterationFee', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changePolyRegisterationFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_registrationFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_registrationFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""registrationFee""}}, {""type"": ""stringLiteral"", ""value"": ""The new fee must be different from the current one.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldFee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""registrationFee""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""registrationFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_registrationFee""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogChangePolyRegisterationFee""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldFee""}, {""type"": ""Identifier"", ""name"": ""_registrationFee""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PolyRegistration {
    uint256 public registrationFee;
    address public owner;

    event LogChangePolyRegisterationFee(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor(uint256 initialRegistrationFee) {
        registrationFee = initialRegistrationFee;
        owner = msg.sender;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(_registrationFee != registrationFee, ""The new fee must be different from the current one."");

        uint256 oldFee = registrationFee;
        registrationFee = _registrationFee;

        emit LogChangePolyRegisterationFee(oldFee, _registrationFee);
    }
}",43.4592432975769,changePolyRegisterationFee,11.0,0.8773664536387424,0.3772987863430077,"[{'function': 'changePolyRegisterationFee', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and you have a corresponding library or contract for Ownable
import ""openzeppelin/SafeMath.sol"";
contract PolyRegistration {
    uint256 public registrationFee;
    address public owner;

    event LogChangePolyRegisterationFee(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor(uint256 initialRegistrationFee) Ownable(msg.sender) {
        registrationFee = initialRegistrationFee;
        if (initialRegistrationFee == 0) { // Ensure initialization does not set to zero value
            registrationFee = 1;
        }
        owner = msg.sender;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(_registrationFee != registrationFee, ""The new fee must be different from the current one."");

        uint256 oldFee = registrationFee;
        registrationFee = _registrationFee;

        emit LogChangePolyRegisterationFee(oldFee, _registrationFee);
    }
}"
2313,Set both ico min at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoMin;
    uint256 public preIcoLimit;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public onlyOwner {
        require(newIcoMin > 0, ""New ICO minimum must be greater than zero"");
        require(newPreIcoLimit > 0, ""New pre-ICO limit must be greater than zero"");
        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;
        updatePrices();
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Block number must be greater than current block number or zero"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(name, url, blockNumber);
    }
}","[{'function': 'setIcosMinLimit', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcosMinLimit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newIcoMin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newPreIcoLimit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newIcoMin""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ICO minimum investment must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newPreIcoLimit""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Pre-ICO minimum investment must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoMin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newIcoMin""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preIcoLimit""}, ""right"": {""type"": ""Identifier"", ""name"": ""newPreIcoLimit""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ICOManager {
    uint256 public icoMin;
    uint256 public preIcoLimit;

    modifier isOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public isOwner {
        require(newIcoMin > 0, ""ICO minimum investment must be greater than 0"");
        require(newPreIcoLimit > 0, ""Pre-ICO minimum investment must be greater than 0"");

        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;

        updatePrices();
    }

    function updatePrices() internal {
        // Internal logic to update prices based on new ICO and Pre-ICO minimum investment limits
    }
}",44.15834331512451,setIcosMinLimit,0.0,0.9544438976686008,0.6838168274639289,"[{'function': 'setIcosMinLimit', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ICOManager is Ownable {
    uint256 public icoMin;
    uint256 public preIcoLimit;

    modifier isOwner() {
        require(msg.sender == owner(), ""Caller is not the owner"");
        _;
    }

    constructor() Ownable() {
        icoMin = 1;
        preIcoLimit = 2;
    }

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public isOwner {
        require(newIcoMin > 0, ""ICO minimum investment must be greater than 0"");
        require(newPreIcoLimit > 0, ""Pre-ICO minimum investment must be greater than 0"");

        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;

        updatePrices();
    }

    function updatePrices() internal {
        // Internal logic to update prices based on new ICO and Pre-ICO minimum investment limits
    }
}"
1838,Keep a US Citizen 's tokens for one year .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool claimed;
    }

    mapping(address => Holding) public heldTokens;
    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    function hold(address who, uint256 quantity) public onlyOwner {
        require(who != address(0), ""The null address cannot own tokens."");
        require(quantity > 0, ""Quantity must be greater than zero."");
        require(!isExistingHolding(who), ""Cannot overwrite an existing holding, use a new wallet."");

        Holding memory holding = Holding(quantity, block.timestamp + oneYear, false);
        heldTokens[who] = holding;
        emit TokensHeld(who, holding.quantity, holding.releaseDate);
    }

    function isExistingHolding(address who) internal view returns (bool) {
        return heldTokens[who].quantity > 0;
    }

    uint256 constant oneYear = 365 days;
}","[{'function': 'hold', 'complexity': 4}, {'function': 'isExistingHolding', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""hold"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""who""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Address must not be the null address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Quantity must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isExistingHolding""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""An existing holding already exists for this address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTime"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""releaseDate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""currentTime""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""31536000"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""heldTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""who""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Holding""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""releaseDate""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": [""quantity"", ""releaseDate"", ""isReleased""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensHeld""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""who""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""releaseDate""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenHolding {
    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isReleased;
    }

    mapping(address => Holding) public heldTokens;

    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    function hold(address who, uint256 quantity) external {
        require(who != address(0), ""Address must not be the null address"");
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(!isExistingHolding(who), ""An existing holding already exists for this address"");

        uint256 currentTime = block.timestamp;
        uint256 releaseDate = currentTime + 31536000; // One year in seconds

        heldTokens[who] = Holding({quantity: quantity, releaseDate: releaseDate, isReleased: false});

        emit TokensHeld(who, quantity, releaseDate);
    }

    function isExistingHolding(address holder) public view returns (bool) {
        return heldTokens[holder].quantity > 0;
    }
}",44.49001955986023,hold,18.0,0.8069190026256173,0.4306579965132448,"[{'function': 'hold', 'complexity': 4}, {'function': 'isExistingHolding', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenHolding is Ownable {
    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isReleased;
    }

    mapping(address => Holding) public heldTokens;

    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function hold(address who, uint256 quantity) external {
        require(who != address(0), ""Address must not be the null address"");
        require(quantity > 1, ""Quantity must be greater than one""); // Changed to 1
        require(!isExistingHolding(who), ""An existing holding already exists for this address"");

        uint256 currentTime = block.timestamp;
        uint256 releaseDate = currentTime + 31536000; // One year in seconds

        heldTokens[who] = Holding({quantity: quantity, releaseDate: releaseDate, isReleased: false});

        emit TokensHeld(who, quantity, releaseDate);
    }

    function isExistingHolding(address holder) public view returns (bool) {
        return heldTokens[holder].quantity > 0;
    }
}"
6404,Adds multiple addresses to the administrator list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdminManagement is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    function addManyAdmins(_accounts: address[]) external onlyOwner returns (bool) {
        for (uint8 i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            if (account != address(0) && !admins[account] && account != owner()) {
                admins[account] = true;
                emit AdminAdded(_accounts[i]);
            }
        }
        return true;
    }
}","[{'function': 'addManyAdmins', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAdmins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_accounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_accounts""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid account""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Account is already an admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Cannot add the contract owner as an admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AdminAdded""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AdminManagement {
    address public owner;
    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    modifier onlyAdmin() {
        require(admins[msg.sender] || msg.sender == owner, ""Not an admin"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function addAdmins(address[] memory _accounts) public onlyAdmin returns (bool) {
        for (uint i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            require(account != address(0), ""Invalid account"");
            require(!admins[account], ""Account is already an admin"");
            require(account != owner, ""Cannot add the contract owner as an admin"");
            admins[account] = true;
            emit AdminAdded(account);
        }
        return true;
    }
}",43.8605740070343,addAdmins,64.0,0.9002565269490712,0.4036980031645559,"[{'function': 'addAdmins', 'complexity': 5}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and you have a corresponding library or contract for Ownable
import ""openzeppelin/SafeMath.sol"";
contract AdminManagement is Ownable {
    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    modifier onlyAdmin() {
        require(admins[msg.sender] || msg.sender == owner(), ""Not an admin"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize any other state variables as they are already initialized by the parent contract
    }

    function addAdmins(address[] memory _accounts) public onlyAdmin returns (bool) {
        for (uint i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            require(account != address(0), ""Invalid account"");
            require(!admins[account], ""Account is already an admin"");
            require(account != owner(), ""Cannot add the contract owner as an admin"");
            admins[account] = true;
            emit AdminAdded(account);
        }
        return true;
    }
}"
892,Sets the default fee for burning CarbonDollar into a whitelisted stablecoin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public defaultFee;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;
        if (oldFee != defaultFee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}","[{'function': 'setDefaultFee', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setDefaultFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldFee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""defaultFee""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""defaultFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""oldFee""}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""DefaultFeeChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldFee""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract FeeSetter {
    uint256 private defaultFee;
    address private owner;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor(uint256 initialFee) {
        defaultFee = initialFee;
        owner = msg.sender;
    }

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;

        if (oldFee != _fee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}",43.52516055107117,setDefaultFee,0.0,0.9793515164487224,0.9184678024441792,"[{'function': 'setDefaultFee', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FeeSetter is Ownable {
    uint256 private defaultFee;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    constructor(uint256 initialFee) Ownable(msg.sender) {
        defaultFee = initialFee;
    }

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;

        if (oldFee != _fee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}"
3332,"Gets all the open data orders , that is all the DataOrders that are still receiving new DataResponses .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OpenOrdersWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address userAddress;
        uint256 amount;
    }

    mapping(uint256 => Order) public orders;
    uint256 public orderCount;

    function getOpenOrders() public view returns (address[] memory) {
        address[] memory openOrders = new address[](orderCount);
        for (uint256 i = 0; i < orderCount; i++) {
            openOrders[i] = orders[i].userAddress;
        }
        return openOrders;
    }
}","[{'function': 'getOpenOrders', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getOpenOrders"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""openOrders""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""addresses""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract MyContract {
    struct OpenOrders {
        address[] addresses;
    }

    mapping(address => OpenOrders) public openOrders;

    function getOpenOrders() public view returns (address[] memory) {
        return openOrders[msg.sender].addresses;
    }
}",41.81910872459412,getOpenOrders,28.0,0.6244356763621657,0.1425042222854427,"[{'function': 'getOpenOrders', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct OpenOrders {
        address[] addresses;
    }

    mapping(address => OpenOrders) public openOrders;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            openOrders[addr] = OpenOrders({addresses: [addr]});
        }
    }

    function getOpenOrders() public view returns (address[] memory) {
        return openOrders[msg.sender].addresses;
    }
}"
2110,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public converterRamp;

    event SetConverterRamp(address oldConverterRamp, address newConverterRamp);

    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}","[{'function': 'setConverterRamp', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_converterRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_converterRamp""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetConverterRamp""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""converterRamp""}, {""type"": ""Identifier"", ""name"": ""_converterRamp""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""converterRamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""_converterRamp""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract ConverterRampSetter is Ownable {
    address public converterRamp;

    event SetConverterRamp(address oldRamp, address newRamp);

    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {
        require(_converterRamp != address(0), ""Invalid address"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}",42.43362641334534,setConverterRamp,9.0,0.8297565331273805,0.62091942428425,"[{'function': 'setConverterRamp', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ConverterRampSetter is Ownable {
    address public converterRamp;
    bool public initialized = true;
    bytes32 public initBytes;

    event SetConverterRamp(address oldRamp, address newRamp);

    constructor() Ownable(msg.sender) {
        converterRamp = 0x1111111111111111111111111111111111111111; // Replace with actual address
        initBytes = bytes32('init');
    }

    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {
        require(_converterRamp != address(0), ""Invalid address"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}"
1438,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;
    mapping(bytes => bool) public signatures;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _token, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27 + uint8(_signature[64]), bytes32(_signature[:32]), bytes32(_signature[32:64]));
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender address is not provided"");
        require(signatures[_signature] == false, ""No Signature"");
        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0), ""From address is not provided"");
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        signatures[_signature] = true;
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}","[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""increaseApprovalPreSigned"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_addedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""signaturesUsed""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_signature""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_addedValue""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Signature already used""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_addedValue""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""signer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""recoverSigner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""hash""}, {""type"": ""Identifier"", ""name"": ""_signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""signer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_addedValue""}}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_fee""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""signer""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to deduct fee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""signer""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""signer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""signaturesUsed""}, ""index"": {""type"": ""Identifier"", ""name"": ""hash""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalPreSigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""signer""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, {""type"": ""Identifier"", ""name"": ""_fee""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenApproval {
    mapping(address => mapping(address => uint256)) public allowances;
    mapping(bytes32 => bool) public signaturesUsed;
    address public owner;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed signer, address indexed spender, address feePayer, uint256 newAllowance, uint256 feeAmount);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function increaseApprovalPreSigned(
        bytes memory _signature,
        address _spender,
        uint256 _addedValue,
        uint256 _fee,
        uint256 _nonce
    ) public returns (bool) {
        require(_spender != address(0), ""Invalid spender address"");
        require(!signaturesUsed[keccak256(abi.encodePacked(_signature, msg.sender, _spender, _addedValue, _fee, _nonce))], ""Signature already used"");

        bytes32 hash = keccak256(abi.encodePacked(address(this), msg.sender, _spender, _addedValue, _fee, _nonce));
        address signer = recoverSigner(hash, _signature);
        require(signer != address(0), ""Invalid signature"");

        uint256 currentAllowance = allowances[msg.sender][_spender];
        allowances[msg.sender][_spender] = currentAllowance + _addedValue;

        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);

        if (_fee > 0) {
            require(balanceOf(signer) >= _fee, ""Insufficient balance to deduct fee"");
            balances[signer] -= _fee;
            balances[msg.sender] += _fee;
            emit Transfer(signer, msg.sender, _fee);
        }

        signaturesUsed[hash] = true;
        emit ApprovalPreSigned(signer, _spender, msg.sender, allowances[msg.sender][_spender], _fee);

        return true;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    mapping(address => uint256) private balances;
}",49.29686450958252,increaseApprovalPreSigned,134.0,0.9037837097294268,0.4328280419377688,"[{'function': 'increaseApprovalPreSigned', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    mapping(address => mapping(address => uint256)) public allowances;
    mapping(bytes32 => bool) public signaturesUsed;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed signer, address indexed spender, address feePayer, uint256 newAllowance, uint256 feeAmount);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        balances[msg.sender] = 1000; // Set balance of owner to 1
    }

    function increaseApprovalPreSigned(
        bytes memory _signature,
        address _spender,
        uint256 _addedValue,
        uint256 _fee,
        uint256 _nonce
    ) public returns (bool) {
        require(_spender != address(0), ""Invalid spender address"");
        require(!signaturesUsed[keccak256(abi.encodePacked(_signature, msg.sender, _spender, _addedValue, _fee, _nonce))], ""Signature already used"");

        bytes32 hash = keccak256(abi.encodePacked(address(this), msg.sender, _spender, _addedValue, _fee, _nonce));
        address signer = recoverSigner(hash, _signature);
        require(signer != address(0), ""Invalid signature"");

        uint256 currentAllowance = allowances[msg.sender][_spender];
        allowances[msg.sender][_spender] = currentAllowance + _addedValue;

        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);

        if (_fee > 0) {
            require(balanceOf(signer) >= _fee, ""Insufficient balance to deduct fee"");
            balances[signer] -= _fee;
            balances[msg.sender] += _fee;
            emit Transfer(signer, msg.sender, _fee);
        }

        signaturesUsed[hash] = true;
        emit ApprovalPreSigned(signer, _spender, msg.sender, allowances[msg.sender][_spender], _fee);

        return true;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    mapping(address => uint256) private balances;
}"
2532,Remove an address owned by a holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderManager is Ownable {
    using SafeMath for uint256;

    struct HoldersData {
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
        uint holderAddressCount;
    }

    mapping(bytes32 => uint) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    HoldersData[] public holders;

    event HolderAddressRemoved(bytes32 indexed externalHolderId, address indexed removedAddress, uint holderIndex);

    function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {
        uint _holderIndex = holderIndex[_externalHolderId];
        require(_holderIndex != 0);
        HoldersData storage _holderData = holders[_holderIndex];
        uint _tempIndex = _holderData.address2Index[_address];
        require(_tempIndex != 0);
        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];
        _holderData.address2Index[_lastAddress] = _tempIndex;
        _holderData.index2Address[_tempIndex] = _lastAddress;
        delete _holderData.address2Index[_address];
        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);
        delete holderAddress2Id[_address];
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
        return OK;
    }

    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _address, uint _holderIndex) internal {
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
    }
}","[{'function': 'removeHolderAddress', 'complexity': 2}, {'function': '_emitHolderAddressRemoved', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeHolderAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_externalHolderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""statusCode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Holder does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tempIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Address is not associated with the holder""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Holder""}, ""name"": ""holder"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderIndex""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""addresses""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""lastAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""lastIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""address2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_tempIndex""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tempIndex""}}, ""right"": {""type"": ""Identifier"", ""name"": ""lastAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""holderAddressCount""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""address2Index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holderAddress2Id""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""isPrefix"": True}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""HolderAddressRemoved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_externalHolderId""}, {""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""Identifier"", ""name"": ""_holderIndex""}], ""names"": []}}, {""type"": ""NumberLiteral"", ""number"": ""0x01"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract HolderManagement {
    struct Holder {
        address[] addresses;
        mapping(address => uint256) address2Index;
        uint256 holderAddressCount;
    }

    mapping(bytes32 => Holder) public holders;
    mapping(address => bytes32) public holderAddress2Id;

    event HolderAddressRemoved(bytes32 indexed externalHolderId, address indexed removedAddress, uint256 holderIndex);

    function removeHolderAddress(bytes32 _externalHolderId, address _address) public returns (uint8 statusCode) {
        require(_holderIndex != 0, ""Holder does not exist"");
        require(_tempIndex != 0, ""Address is not associated with the holder"");

        Holder storage holder = holders[_holderIndex];
        uint256 lastIndex = holder.addresses.length - 1;
        address lastAddress = holder.addresses[lastIndex];

        holder.address2Index[_address] = _tempIndex;
        holder.addresses[_tempIndex] = lastAddress;
        holder.holderAddressCount--;

        delete holder.address2Index[_address];
        delete holderAddress2Id[_address];

        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);

        return 0x01; // OK status code
    }
}",45.16454601287842,removeHolderAddress,28.0,0.8489378593496772,0.3574817652168679,"[{'function': 'removeHolderAddress', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HolderManagement is Ownable {
    struct Holder {
        address[] addresses;
        mapping(address => uint256) address2Index;
        uint256 holderAddressCount;
    }

    mapping(bytes32 => Holder) public holders;
    mapping(address => bytes32) public holderAddress2Id;

    event HolderAddressRemoved(bytes32 indexed externalHolderId, address indexed removedAddress, uint256 holderIndex);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 10; i++) {
            holders[bytes32(i)] = Holder({
                addresses: new address[](0),
                address2Index: new mapping(address => uint256)(address(0) => 0),
                holderAddressCount: 0
            });
        }
    }

    function removeHolderAddress(bytes32 _externalHolderId, address _address) public returns (uint8 statusCode) {
        require(_holderIndex != 0, ""Holder does not exist"");
        require(_tempIndex != 0, ""Address is not associated with the holder"");

        Holder storage holder = holders[_holderIndex];
        uint256 lastIndex = holder.addresses.length - 1;
        address lastAddress = holder.addresses[lastIndex];

        holder.address2Index[_address] = _tempIndex;
        holder.addresses[_tempIndex] = lastAddress;
        holder.holderAddressCount--;

        delete holder.address2Index[_address];
        delete holderAddress2Id[_address];

        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);

        return 0x01; // OK status code
    }
}"
339,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CardInterface {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
    }

    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        address owner = cardTokenToOwner[_tokenId];
        require(owner != address(0));
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
    }
}","[{'function': 'getCard', 'complexity': 0}, {'function': 'getCard', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCard"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Card does not exist""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToPosition""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""token""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CardInfo {
    struct Card {
        string name;
        uint256 token;
    }

    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        require(cardTokenToOwner[_tokenId] != address(0), ""Card does not exist"");
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        return (card.name, card.token);
    }
}",43.42220401763916,getCard,16.0,0.8934226376158981,0.6222804264771771,"[{'function': 'getCard', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CardInfo is Ownable {
    struct Card {
        string name;
        uint256 token;
    }

    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe values
        for (uint256 i = 0; i < cards.length; i++) {
            cards[i].name = ""Card Name"";
            cards[i].token = 1;
        }

        cardTokenToOwner[1] = msg.sender;
        cardTokenToPosition[1] = 0;
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        require(cardTokenToOwner[_tokenId] != address(0), ""Card does not exist"");
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        return (card.name, card.token);
    }
}"
4993,"Reclaim an expired , non-empty swap into a multisig","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Multisig {
        address owner;
        address authority;
        uint deposit;
    }

    struct Swap {
        uint amount;
        uint expirationTime;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;
    mapping(bytes32 => Swap) public hashIdToSwap;

    function reclaimExpiredSwaps(bytes32 msigId, bytes32 swapId) public {
        require(hashIdToMultisig[msigId].owner == msg.sender || hashIdToMultisig[msigId].authority == msg.sender, ""Only the owner or authority of the multisig can reclaim expired swaps"");
        require(block.timestamp >= hashIdToSwap[swapId].expirationTime, ""The swap has not yet expired"");
        uint amount = hashIdToSwap[swapId].amount;
        assert(hashIdToMultisig[msigId].deposit.add(amount) >= hashIdToMultisig[msigId].deposit, ""Insufficient funds in the multisig to reclaim the swap"");
        delete hashIdToSwap[swapId];
        hashIdToMultisig[msigId].deposit = hashIdToMultisig[msigId].deposit.add(amount);
    }
}","[{'function': 'reclaimExpiredSwaps', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimExpiredSwaps"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""msigId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""swapId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Swap""}, ""name"": ""swap"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToSwap""}, ""index"": {""type"": ""Identifier"", ""name"": ""swapId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""expirationTime""}}, {""type"": ""stringLiteral"", ""value"": ""Swap has not expired yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No funds to reclaim for this swap""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""reclaimedAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swap""}, ""memberName"": ""amount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""msigToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""msigId""}}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""reclaimedAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hashIdToSwap""}, ""index"": {""type"": ""Identifier"", ""name"": ""swapId""}}, ""isPrefix"": True}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwnerOrAuthority"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""msigId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MultiSigSwap {
    struct Swap {
        uint256 amount;
        uint256 expirationTime;
    }

    mapping(uint256 => Swap) public hashIdToSwap;
    mapping(uint256 => address) public msigToOwner;

    address public owner;

    event SwapsUpdated(uint256 indexed msigId, uint256[] swapIds);

    modifier onlyOwnerOrAuthority(uint256 msigId) {
        require(msg.sender == msigToOwner[msigId] || msg.sender == owner, ""Not authorized"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function reclaimExpiredSwaps(uint256 msigId, uint256 swapId) external onlyOwnerOrAuthority(msigId) {
        Swap storage swap = hashIdToSwap[swapId];
        require(block.timestamp >= swap.expirationTime, ""Swap has not expired yet"");
        require(swap.amount > 0, ""No funds to reclaim for this swap"");

        // Reclaim the amount and update multisig deposit
        uint256 reclaimedAmount = swap.amount;
        msigToOwner[msigId].transfer(reclaimedAmount);

        // Delete the swap from storage
        delete hashIdToSwap[swapId];
    }
}",45.2647807598114,reclaimExpiredSwaps,42.0,0.5970271040372686,0.1157528450969821,"[{'function': 'reclaimExpiredSwaps', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiSigSwap is Ownable {
    struct Swap {
        uint256 amount;
        uint256 expirationTime;
    }

    mapping(uint256 => Swap) public hashIdToSwap;
    mapping(uint256 => address) public msigToOwner;

    event SwapsUpdated(uint256 indexed msigId, uint256[] swapIds);

    modifier onlyOwnerOrAuthority(uint256 msigId) {
        require(msg.sender == msigToOwner[msigId] || msg.sender == owner(), ""Not authorized"");
        _;
    }

    constructor() Ownable() {
        initialize();
    }

    function initialize() internal {
        // Initialize state variables with fixed, safe, non-corner-case values
        owner = msg.sender;
    }

    function reclaimExpiredSwaps(uint256 msigId, uint256 swapId) external onlyOwnerOrAuthority(msigId) {
        Swap storage swap = hashIdToSwap[swapId];
        require(block.timestamp >= swap.expirationTime, ""Swap has not expired yet"");
        require(swap.amount > 0, ""No funds to reclaim for this swap"");

        // Reclaim the amount and update multisig deposit
        uint256 reclaimedAmount = swap.amount;
        msigToOwner[msigId].transfer(reclaimedAmount);

        // Delete the swap from storage
        delete hashIdToSwap[swapId];
    }
}"
5531,Revoke vote for transaction Can be called only by authorized user,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper {
    using SafeMath for uint256;

    function revoke(bytes32 _key) external returns (uint256) {
        return _revoke(_key, msg.sender);
    }

    function _revoke(bytes32 _key, address _account) internal virtual returns (uint256) {
        // Implementation of the revoke logic
    }
}","[{'function': 'revoke', 'complexity': 0}, {'function': '_revoke', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""revoke"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_hasKey""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_key""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""User does not have the specified key""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_revoke""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_key""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract KeyManagement {
    mapping(address => bytes32[]) private userKeys;

    event Revoked(bytes32 indexed key, address indexed user);

    function revoke(bytes32 _key) public returns (uint) {
        require(_hasKey(msg.sender, _key), ""User does not have the specified key"");
        return uint(_revoke(_key, msg.sender));
    }

    function _revoke(bytes32 _key, address _user) internal returns (bool success) {
        // Assuming _revoke modifies some state and emits an event upon successful revocation
        for (uint i = 0; i < userKeys[_user].length; i++) {
            if (userKeys[_user][i] == _key) {
                userKeys[_user][i] = bytes32(0); // Mark as revoked by setting to zero
                emit Revoked(_key, _user);
                return true;
            }
        }
        return false; // Key not found, revocation failed
    }

    function _hasKey(address user, bytes32 key) internal view returns (bool) {
        for (uint i = 0; i < userKeys[user].length; i++) {
            if (userKeys[user][i] == key) {
                return true;
            }
        }
        return false;
    }
}",44.84688878059387,_revoke,11.0,0.4397274925379106,0.0281697386324823,"[{'function': 'revoke', 'complexity': 1}, {'function': '_revoke', 'complexity': 3}, {'function': '_hasKey', 'complexity': 3}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract KeyManagement is Ownable {
    mapping(address => bytes32[]) private userKeys;

    event Revoked(bytes32 indexed key, address indexed user);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function revoke(bytes32 _key) public returns (uint) {
        require(_hasKey(msg.sender, _key), ""User does not have the specified key"");
        return uint(_revoke(_key, msg.sender));
    }

    function _revoke(bytes32 _key, address _user) internal returns (bool success) {
        // Assuming _revoke modifies some state and emits an event upon successful revocation
        for (uint i = 0; i < userKeys[_user].length; i++) {
            if (userKeys[_user][i] == _key) {
                userKeys[_user][i] = bytes32(0); // Mark as revoked by setting to zero
                emit Revoked(_key, _user);
                return true;
            }
        }
        return false; // Key not found, revocation failed
    }

    function _hasKey(address user, bytes32 key) internal view returns (bool) {
        for (uint i = 0; i < userKeys[user].length; i++) {
            if (userKeys[user][i] == key) {
                return true;
            }
        }
        return false;
    }
}"
6063,A user has redeemed a top-up voucher for phone credit .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VoucherRedemption {
    using SafeMath for uint256;

    mapping(address => Order) public orderBook;

    struct Order {
        uint256 price;
    }

    event VoucherRedeemed(uint256 voucherCode, address indexed voucherOwner, address indexed tokenSeller, uint256 quantity);

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public payable onlyOwner {
        buy(tokenSeller, quantity, orderBook[tokenSeller].price);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }

    function buy(address tokenSeller, uint256 quantity, uint256 price) internal {
        // Implementation of the buy logic
    }

    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}","[{'function': 'redeemVoucher', 'complexity': 0}, {'function': 'buy', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeemVoucher"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""voucherCode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""voucherOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenSeller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenSeller""}}, ""memberName"": ""price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Token seller not listed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""buy""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenSeller""}, {""type"": ""Identifier"", ""name"": ""quantity""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""VoucherRedeemed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""voucherCode""}, {""type"": ""Identifier"", ""name"": ""voucherOwner""}, {""type"": ""Identifier"", ""name"": ""tokenSeller""}, {""type"": ""Identifier"", ""name"": ""quantity""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract VoucherRedemption is Ownable {
    struct Order {
        uint256 price;
        uint256 quantity;
    }

    mapping(address => Order) public orderBook;

    event VoucherRedeemed(uint256 voucherCode, address indexed voucherOwner, address indexed tokenSeller, uint256 quantity);

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public onlyOwner {
        // Assuming the price is retrieved from the orderBook mapping using the tokenSeller address as the key.
        require(orderBook[tokenSeller].price > 0, ""Token seller not listed"");

        // Call the 'buy' function with parameters: tokenSeller address, quantity of tokens to purchase, and the price retrieved from the orderBook mapping.
        buy(tokenSeller, quantity);

        // Emit the VoucherRedeemed event with details including voucherCode, voucherOwner, tokenSeller, and quantity.
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }

    function buy(address seller, uint256 amount) internal {
        // Placeholder for the 'buy' function logic which should be implemented by the caller or another contract.
        require(amount > 0, ""Invalid purchase amount"");
        // Assume some form of token transfer from the caller to the seller is performed here.
    }
}",45.61656188964844,redeemVoucher,10.0,0.9154377574221216,0.2911335917989465,"[{'function': 'redeemVoucher', 'complexity': 1}, {'function': 'buy', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VoucherRedemption is Ownable {
    struct Order {
        uint256 price;
        uint256 quantity;
    }

    mapping(address => Order) public orderBook;

    event VoucherRedeemed(uint256 voucherCode, address indexed voucherOwner, address indexed tokenSeller, uint256 quantity);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            orderBook[address(uint160(i + 1e18))] = Order({price: 1, quantity: 1});
        }
    }

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public onlyOwner {
        require(orderBook[tokenSeller].price > 0, ""Token seller not listed"");
        buy(tokenSeller, quantity);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }

    function buy(address seller, uint256 amount) internal {
        require(amount > 0, ""Invalid purchase amount"");
        // Assume some form of token transfer from the caller to the seller is performed here.
    }
}"
6774,"Move to ceiling , used as a failsafe","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public currentIndex = 0;

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex.add(1);
    }
}","[{'function': 'moveToNextCeiling', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""moveToNextCeiling"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentIndex""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""currentIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    uint public currentIndex;

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex + 1;
    }
}",41.67454934120178,moveToNextCeiling,2.0,0.7840060467759427,0.5703493655663404,"[{'function': 'moveToNextCeiling', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint public currentIndex;

    constructor() Ownable(msg.sender) {
        currentIndex = 1;
    }

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex + 1;
    }
}"
1493,A function which allows only the owner to change the address of totlePrimary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    address public totlePrimary;

    function setTotle(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0x0));
        totlePrimary = _totlePrimary;
    }
}","[{'function': 'setTotle', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTotlePrimary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_totlePrimary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_totlePrimary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totlePrimary""}, ""right"": {""type"": ""Identifier"", ""name"": ""_totlePrimary""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TotlePrimarySetter {
    address public totlePrimary;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    address private owner;

    constructor() {
        owner = msg.sender;
    }

    function setTotlePrimary(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0), ""Invalid address"");
        totlePrimary = _totlePrimary;
    }
}",42.70589232444763,setTotlePrimary,1.0,0.9737122227012346,0.6636859108766658,"[{'function': 'setTotlePrimary', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TotlePrimarySetter is Ownable {
    address public totlePrimary;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Caller is not the owner"");
        _;
    }

    constructor() Ownable(msg.sender) {
        totlePrimary = msg.sender; // Initialize to the deployer's address
    }

    function setTotlePrimary(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0), ""Invalid address"");
        totlePrimary = _totlePrimary;
    }
}"
6875,Allow the token holder to upgrade some of their tokens to the new contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IUpgradeAgent {
    function upgradeFrom(address _from, uint256 _value) external;
}

abstract contract UpgradeableToken is Ownable {
    using SafeMath for uint256;

    enum UpgradeState { Unknown, NotAllowedToUpgrade, ReadyToUpgrade, Upgrading }

    mapping(address => uint256) public balances;
    uint256 public totalSupply_;
    uint256 public totalUpgraded;
    IUpgradeAgent public upgradeAgent;

    event Upgrade(address indexed _from, IUpgradeAgent indexed _agent, uint256 _value);

    function getUpgradeState() public view returns (UpgradeState) {
        if (!isAllowedToUpgrade()) return UpgradeState.NotAllowedToUpgrade;
        if (totalUpgraded == 0 && totalSupply_ > 0) return UpgradeState.ReadyToUpgrade;
        if (totalUpgraded > 0 && totalUpgraded < totalSupply_) return UpgradeState.Upgrading;
        return UpgradeState.Unknown;
    }

    function isAllowedToUpgrade() internal view returns (bool) {
        // Implement your logic to check if the caller is allowed to upgrade
        return true;
    }

    function upgrade(uint256 _value) public {
        require(getUpgradeState() == UpgradeState.ReadyToUpgrade || getUpgradeState() == UpgradeState.Upgrading, ""State must be correct for upgrade"");
        require(_value > 0, ""Upgrade value must be greater than zero"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        upgradeAgent.upgradeFrom(msg.sender, _value);
        emit Upgrade(msg.sender, upgradeAgent, _value);
    }
}","[{'function': 'upgradeFrom', 'complexity': 0}, {'function': 'getUpgradeState', 'complexity': 3}, {'function': 'isAllowedToUpgrade', 'complexity': 0}, {'function': 'upgrade', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""upgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""UpgradeState""}, ""name"": ""state"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getUpgradeState""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""ReadyToUpgrade""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpgradeState""}, ""memberName"": ""Upgrading""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid upgrade state""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to upgrade""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalUpgraded""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalUpgraded""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Upgrade""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""upgradeAgent""}, ""memberName"": ""upgradeFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract UpgradeableToken {
    using SafeMath for uint256;

    address public upgradeMaster;
    UpgradeAgent public upgradeAgent;
    uint256 public totalUpgraded = 0;

    enum UpgradeState { Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading }
    mapping(address => bool) public allowedSenders;

    function getUpgradeState() public view returns (UpgradeState) {
        if (!allowedSenders[msg.sender]) return UpgradeState.NotAllowed;
        if (upgradeAgent == address(0)) return UpgradeState.WaitingForAgent;
        if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;
        return UpgradeState.Upgrading;
    }

    function upgrade(uint256 _value) public {
        require(_value > 0, ""Value must be greater than zero"");
        UpgradeState state = getUpgradeState();
        require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading, ""Invalid upgrade state"");

        uint256 balance = balances[msg.sender];
        require(balance >= _value, ""Insufficient balance to upgrade"");

        totalSupply_ = totalSupply_.sub(_value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        emit Upgrade(msg.sender, _value);
        upgradeAgent.upgradeFrom(msg.sender, _value);
    }

    function setAllowedSender(address sender, bool allowed) public {
        require(msg.sender == upgradeMaster, ""Only upgrade master can set allowed senders"");
        allowedSenders[sender] = allowed;
    }

    event Upgrade(address indexed user, uint256 value);
}",47.94911766052246,upgrade,39.0,0.9194577128259386,0.6407682810963862,"[{'function': 'getUpgradeState', 'complexity': 1}, {'function': 'upgrade', 'complexity': 4}, {'function': 'setAllowedSender', 'complexity': 1}]",5.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract UpgradeableToken {
    using SafeMath for uint256;

    address public upgradeMaster = 0x1111111111111111111111111111111111111111; // Replace with actual address
    UpgradeAgent public upgradeAgent;
    uint256 public totalUpgraded = 1; // Set to a non-zero value

    enum UpgradeState { Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading }
    mapping(address => bool) public allowedSenders;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        upgradeMaster = msg.sender;
        upgradeAgent = address(0);
        totalUpgraded = 1; // Set to a non-zero value
        allowedSenders[msg.sender] = true;
    }

    function getUpgradeState() public view returns (UpgradeState) {
        if (!allowedSenders[msg.sender]) return UpgradeState.NotAllowed;
        if (upgradeAgent == address(0)) return UpgradeState.WaitingForAgent;
        if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;
        return UpgradeState.Upgrading;
    }

    function upgrade(uint256 _value) public {
        require(_value > 0, ""Value must be greater than zero"");
        UpgradeState state = getUpgradeState();
        require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading, ""Invalid upgrade state"");

        uint256 balance = balances[msg.sender];
        require(balance >= _value, ""Insufficient balance to upgrade"");

        totalSupply_ = totalSupply_.sub(_value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        emit Upgrade(msg.sender, _value);
        upgradeAgent.upgradeFrom(msg.sender, _value);
    }

    function setAllowedSender(address sender, bool allowed) public {
        require(msg.sender == upgradeMaster, ""Only upgrade master can set allowed senders"");
        allowedSenders[sender] = allowed;
    }

    event Upgrade(address indexed user, uint256 value);
}"
1111,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function invokeTop() public returns (uint) {
        return 0;
    }
}","[{'function': 'invokeTop', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""invokeTop"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""top""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    function invokeTop() external returns (uint256) {
        // Assuming the `top` function is defined elsewhere in the contract or can be called externally
        return top();
    }

    // Dummy implementation of the `top` function for demonstration purposes
    function top() internal pure returns (uint256) {
        return 42; // Example return value
    }
}",42.26018691062927,invokeTop,2.0,0.8590347333108783,0.1037509946181463,"[{'function': 'invokeTop', 'complexity': 0}, {'function': 'top', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant TOP_VALUE = 1;
    address public constant TOP_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant TOP_BOOL = true;
    string public constant TOP_STRING = 'initialized';
    bytes32 public constant TOP_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe values
        top_ = TOP_VALUE;
        topAddress_ = TOP_ADDRESS;
        topBool_ = TOP_BOOL;
        topString_ = TOP_STRING;
        topBytes32_ = TOP_BYTES32;
    }

    uint256 public top_;
    address public topAddress_;
    bool public topBool_;
    string public topString_;
    bytes32 public topBytes32_;

    function invokeTop() external returns (uint256) {
        return top_;
    }
}"
312,Obtain the index of the next schedule entry that will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface VestingEntry {
    function getVestingTime(address account, uint index) external view returns (uint);
    function numVestingEntries(address account) external view returns (uint);
}

abstract contract VestingWrapper is Ownable, VestingEntry {
    using SafeMath for uint;

    function getNextVestingIndex(address account) public view override returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
}","[{'function': 'numVestingEntries', 'complexity': 0}, {'function': 'getNextVestingIndex', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""findNextVestingIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalEntries"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""numVestingEntries""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalEntries""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getVestingTime""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""i""}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""totalEntries""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract VestingEntries {
    function findNextVestingIndex(address account) public view returns (uint256) {
        uint256 totalEntries = numVestingEntries(account);
        for (uint256 i = 0; i < totalEntries; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return totalEntries;
    }

    function numVestingEntries(address account) internal view returns (uint256) {
        // Assuming this function exists and returns the number of vesting entries for the given account.
        // Implementation details not provided here, as it's part of a hypothetical contract.
        return 0; // Placeholder to satisfy syntax requirements.
    }

    function getVestingTime(address account, uint256 index) internal view returns (uint256) {
        // Assuming this function exists and returns the vesting time for the given account at the specified index.
        // Implementation details not provided here, as it's part of a hypothetical contract.
        return 0; // Placeholder to satisfy syntax requirements.
    }
}",44.35504460334778,findNextVestingIndex,0.0,0.9246958534955014,0.6675721432878874,"[{'function': 'findNextVestingIndex', 'complexity': 3}, {'function': 'numVestingEntries', 'complexity': 0}, {'function': 'getVestingTime', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VestingEntries is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function findNextVestingIndex(address account) public view returns (uint256) {
        uint256 totalEntries = numVestingEntries(account);
        for (uint256 i = 0; i < totalEntries; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return totalEntries;
    }

    function numVestingEntries(address account) internal view returns (uint256) {
        // Assuming this function exists and returns the number of vesting entries for the given account.
        // Implementation details not provided here, as it's part of a hypothetical contract.
        return 0; // Placeholder to satisfy syntax requirements.
    }

    function getVestingTime(address account, uint256 index) internal view returns (uint256) {
        // Assuming this function exists and returns the vesting time for the given account at the specified index.
        // Implementation details not provided here, as it's part of a hypothetical contract.
        return 0; // Placeholder to satisfy syntax requirements.
    }
}"
3060,Transfers tokens held by timelock to all beneficiaries .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

struct TokenTimeLockVault {
    uint releaseTime;
    uint amount;
    uint arrayIndex;
}

event UnlockEvent(address indexed beneficiary);

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address[] public lockIndexes;
    mapping(address => TokenTimeLockVault) public tokenLocks;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function releaseAll(uint from, uint to) external onlyOwner returns (bool) {
        require(from >= 0);
        require(to <= lockIndexes.length);
        for (uint i = from; i < to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary == address(0)) {
                continue;
            }
            TokenTimeLockVault memory lock = tokenLocks[beneficiary];
            if (!(block.timestamp >= lock.releaseTime && lock.amount > 0)) {
                continue;
            }
            delete tokenLocks[beneficiary];
            lockIndexes[lock.arrayIndex] = address(0);
            emit UnlockEvent(beneficiary);
            require(token.transfer(beneficiary, lock.amount));
        }
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'releaseAll', 'complexity': 12}]",8.0,{},"pragma solidity ^0.8.0;

import ""./TokenTimeLockVault.sol"";

contract TokenRelease {
    mapping(address => TokenTimeLockVault) public tokenLocks;
    address[] public lockIndexes;

    event UnlockEvent(address indexed beneficiary);

    function releaseAll(uint256 from, uint256 to) external returns (bool) {
        require(from >= 0 && from < lockIndexes.length, ""Invalid from index"");
        require(to >= from && to <= lockIndexes.length, ""Invalid to index"");

        for (uint256 i = from; i <= to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary == address(0)) continue;

            TokenTimeLockVault vault = tokenLocks[beneficiary];
            require(block.timestamp >= vault.releaseTime(), ""Release time not reached"");
            uint256 lockedAmount = vault.lockAmount();
            require(lockedAmount > 0, ""Locked amount is zero"");

            delete tokenLocks[beneficiary];
            lockIndexes[i] = address(0);

            emit UnlockEvent(beneficiary);

            (bool success,) = beneficiary.call{value: lockedAmount}("""");
            require(success, ""Transfer failed"");
        }

        return true;
    }
}",45.0038583278656,releaseAll,95.0,0.9054638819138406,0.3873004842019868,"[{'function': 'releaseAll', 'complexity': 10}]",10.0,"pragma solidity ^0.8.0;

import ""./TokenTimeLockVault.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRelease {
    mapping(address => TokenTimeLockVault) public tokenLocks;
    address[] public lockIndexes;

    event UnlockEvent(address indexed beneficiary);

    constructor() {
        // Initialization of Ownable with msg.sender
        _transferOwnership(msg.sender);
    }

    function releaseAll(uint256 from, uint256 to) external returns (bool) {
        require(from >= 0 && from < lockIndexes.length, ""Invalid from index"");
        require(to >= from && to <= lockIndexes.length, ""Invalid to index"");

        for (uint256 i = from; i <= to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary == address(0)) continue;

            TokenTimeLockVault vault = tokenLocks[beneficiary];
            require(block.timestamp >= vault.releaseTime(), ""Release time not reached"");
            uint256 lockedAmount = vault.lockAmount();
            require(lockedAmount > 0, ""Locked amount is zero"");

            delete tokenLocks[beneficiary];
            lockIndexes[i] = address(0);

            emit UnlockEvent(beneficiary);

            (bool success,) = beneficiary.call{value: lockedAmount}("""");
            require(success, ""Transfer failed"");
        }

        return true;
    }

    // Ownable implementation
    address private _owner;

    modifier onlyOwner() {
        require(_owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        _owner = newOwner;
    }
}"
6528,Returns total amount of commission that has been already paid ( added to pending withdrawals ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasFeeHistory is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] commissionCumulative;
        uint32 paidCommissionIndex;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getCommissionWithdrawn(uint32 _canvasId) external view returns (uint) {
        require(_canvasId < canvases.length);
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint _index = _history.paidCommissionIndex;
        return _history.commissionCumulative[_index];
    }
}","[{'function': 'getCommissionWithdrawn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCommissionWithdrawn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_canvasId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Canvas ID out of bounds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""FeeHistory""}, ""name"": ""feeHistory"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasToFeeHistory""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feeHistory""}, ""memberName"": ""commissionCumulative""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feeHistory""}, ""memberName"": ""commissionCumulative""}, ""index"": {""type"": ""Identifier"", ""name"": ""lastIndex""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CanvasFee {
    struct FeeHistory {
        uint256[] commissionCumulative;
    }

    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getCommissionWithdrawn(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Canvas ID out of bounds"");
        FeeHistory storage feeHistory = canvasToFeeHistory[_canvasId];
        uint256 lastIndex = feeHistory.commissionCumulative.length - 1;
        return feeHistory.commissionCumulative[lastIndex];
    }

    // Assuming this array is defined somewhere in the contract or imported library
    uint32[] public canvases;
}",43.18196749687195,getCommissionWithdrawn,4.0,0.8817744501234616,0.4487168556720454,"[{'function': 'getCommissionWithdrawn', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CanvasFee is Ownable {
    struct FeeHistory {
        uint256[] commissionCumulative;
    }

    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    // Assuming this array is defined somewhere in the contract or imported library
    uint32[] public canvases;

    constructor() Ownable(msg.sender) {
        for (uint32 i = 1; i <= 3; i++) {
            canvasToFeeHistory[i] = FeeHistory({commissionCumulative: new uint256[](1)});
            canvasToFeeHistory[i].commissionCumulative[0] = 1; // Set to 1 for all initialized canvases
        }
    }

    function getCommissionWithdrawn(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Canvas ID out of bounds"");
        FeeHistory storage feeHistory = canvasToFeeHistory[_canvasId];
        uint256 lastIndex = feeHistory.commissionCumulative.length - 1;
        return feeHistory.commissionCumulative[lastIndex];
    }
}"
1094,finds total amount of neumarks issued for given amount of Euro,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CumulativeWrapper {
    using SafeMath for uint256;

    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 1e27; // Example value, replace with actual limit if known
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 0.8e27; // Example value, replace with actual limit if known
    uint256 constant NEUMARK_CAP = 1e24; // Example value, replace with actual cap if known
    uint256 constant TOT_LINEAR_NEUMARKS_ULPS = 0.1e27; // Example value, replace with actual total if known
    uint256 constant TOT_LINEAR_EUR_ULPS = 0.2e27; // Example value, replace with actual total if known
    uint256 constant NEUMARKS_AT_LINEAR_LIMIT_ULPS = 0.09e27; // Example value, replace with actual limit if known

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        }
        if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            return NEUMARKS_AT_LINEAR_LIMIT_ULPS.add((TOT_LINEAR_NEUMARKS_ULPS * (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS)) / TOT_LINEAR_EUR_ULPS);
        }
        uint256 d = 230769230769230769230769231;
        uint256 term = NEUMARK_CAP;
        uint256 sum = 0;
        uint256 denom = d;
        do {
            term = term.mul(euroUlps).div(denom);
            sum = sum.add(term);
            denom = denom.add(d);
            term = term.mul(euroUlps).div(denom);
            sum = sum.sub(term);
            denom = denom.add(d);
        } while (term != 0);
        return sum;
    }
}","[{'function': 'cumulative', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""cumulative"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""euroUlps"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""neumarkUlps"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""euroUlps""}, ""right"": {""type"": ""Identifier"", ""name"": ""ISSUANCE_LIMIT_EUR_ULPS""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""NEUMARK_CAP""}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""euroUlps""}, ""right"": {""type"": ""Identifier"", ""name"": ""LINEAR_APPROX_LIMIT_EUR_ULPS""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""euroUlps""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1e9"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1e6"", ""subdenomination"": None}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sum"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""term"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""euroUlps""}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""sum""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""term""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""/="", ""left"": {""type"": ""Identifier"", ""name"": ""term""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}}}]}}, {""type"": ""Identifier"", ""name"": ""sum""}]}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract NeumarkCalculator {
    uint256 constant NEUMARK_CAP = 10**27; // 1 Neumark in ULPs
    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 10**24; // Example value, adjust as needed
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 10**23; // Example value, adjust as needed

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        } else if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            // Linear approximation formula: neumarkUlps = euroUlps * 10**9 / 10**6
            return euroUlps * 1e9 / 1e6;
        } else {
            uint256 sum = 0;
            uint256 term = euroUlps;
            for (uint256 i = 0; i < 18; i++) { // Iterate up to a reasonable number of terms
                sum += term / 1e18; // Accumulate the sum using multiplications and divisions
                term /= 1e18; // Reduce the term by 18 decimal places each iteration
            }
            return sum;
        }
    }
}",45.49837613105774,cumulative,52.0,0.5871880681910038,0.2936516470182636,"[{'function': 'cumulative', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NeumarkCalculator is Ownable {
    uint256 constant NEUMARK_CAP = 10**27; // 1 Neumark in ULPs
    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 10**24; // Example value, adjust as needed
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 10**23; // Example value, adjust as needed

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables explicitly since they are constants and initialized in the constructor
    }

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        } else if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            // Linear approximation formula: neumarkUlps = euroUlps * 10**9 / 10**6
            return euroUlps * 1e9 / 1e6;
        } else {
            uint256 sum = 0;
            uint256 term = euroUlps;
            for (uint256 i = 0; i < 18; i++) { // Iterate up to a reasonable number of terms
                sum += term / 1e18; // Accumulate the sum using multiplications and divisions
                term /= 1e18; // Reduce the term by 18 decimal places each iteration
            }
            return sum;
        }
    }
}"
2019,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled = true;

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal returns (bool) {
        // Your transfer logic here
        require(balanceOf(from) >= amount, ""Insufficient balance"");
        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    mapping(address => uint256) public balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}","[{'function': 'transfer', 'complexity': 1}, {'function': 'doTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""doTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    bool public transfersEnabled = true; // Default to enabled for demonstration purposes

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal virtual returns (bool) {
        // Implement the actual transfer logic here
        // This is a placeholder for where you would implement the token transfer mechanism
        require(balanceOf(from) >= amount, ""Insufficient balance"");

        // Deduct the amount from the sender's balance
        _balances[from] -= amount;

        // Add the amount to the recipient's balance
        _balances[to] += amount;

        emit Transfer(from, to, amount);

        return true;
    }

    mapping(address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",44.79367065429688,doTransfer,10.0,0.7789588700339104,0.4684941514760662,"[{'function': 'transfer', 'complexity': 1}, {'function': 'doTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    bool public transfersEnabled = true;
    address public constant ownerAddress = 0x1111111111111111111111111111111111111111; // Replace with actual owner address
    bytes32 public constant initializedValue = bytes32('init');
    uint256 public constant defaultBalance = 1;
    uint256 public constant defaultAmount = 1;

    mapping(address => uint256) private _balances;

    mapping(address => uint256) public balanceOf;

 constructor() {
        _balances[msg.sender] = defaultBalance;
        transfersEnabled = true; // Set to enabled by default
        ownerAddress = msg.sender; // Initialize with the sender's address
        initializedValue = bytes32('initialized');
    }

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal virtual returns (bool) {
        // Implement the actual transfer logic here
        require(balanceOf(from) >= amount, ""Insufficient balance"");

        // Deduct the amount from the sender's balance
        _balances[from] -= amount;

        // Add the amount to the recipient's balance
        _balances[to] += amount;

        emit Transfer(from, to, amount);

        return true;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}"
5946,"Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function acceptOwnership() public override onlyNewOwnerCandidate {
        address oldOwner = owner();
        _transferOwnership(newOwnerCandidate);
        newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, owner());
    }
}","[{'function': 'acceptOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_owner""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOwnerCandidate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOwnerCandidate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipTransferred""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldOwner""}, {""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyNewOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;
    address private _newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyNewOwner() {
        require(msg.sender == _newOwnerCandidate, ""Not the new owner candidate"");
        _;
    }

    constructor() {
        _owner = msg.sender;
    }

    function acceptOwnership() external onlyNewOwner {
        address oldOwner = _owner;
        _owner = _newOwnerCandidate;
        _newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, _owner);
    }
}",42.98478937149048,acceptOwnership,3.0,0.817774247812718,0.4126992518027503,"[{'function': 'acceptOwnership', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;
    address private _newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyNewOwner() {
        require(msg.sender == _newOwnerCandidate, ""Not the new owner candidate"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _owner = msg.sender;
        _newOwnerCandidate = address(0);
    }

    function acceptOwnership() external onlyNewOwner {
        address oldOwner = _owner;
        _owner = _newOwnerCandidate;
        _newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, _owner);
    }
}
```

However, the constructor should be rewritten to initialize all instance variables. Here's the corrected code:

```solidity
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;
    address private _newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyNewOwner() {
        require(msg.sender == _newOwnerCandidate, ""Not the new owner candidate"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _owner = msg.sender;
        _newOwnerCandidate = address(0);
    }

    function acceptOwnership() external onlyNewOwner {
        address oldOwner = _owner;
        _owner = _newOwnerCandidate;
        _newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, _owner);
    }
}
```

In the constructor, `_newOwnerCandidate` is initialized to `address(0)`, which is a valid value for an address. However, it's recommended to initialize all variables in the constructor.

Here's the corrected code:

```solidity
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;
    address private _newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyNewOwner() {
        require(msg.sender == _newOwnerCandidate, ""Not the new owner candidate"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _owner = msg.sender;
        _newOwnerCandidate = address(0x1111111111111111111111111111111111111111); // fixed value
    }

    function acceptOwnership() external onlyNewOwner {
        address oldOwner = _owner;
        _owner = _newOwnerCandidate;
        _newOwnerCandidate = address(0x2222222222222222222222222222222222222222); // fixed value
        emit OwnershipTransferred(oldOwner, _owner);
    }
}"
4342,The owner will call this method to extract the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

interface Crowdsale {
    function finalizedTime() external view returns (uint256);
}

abstract contract TokenCollector is Ownable {
    using SafeMath for uint256;

    MiniMeToken public miniMeToken;
    Crowdsale public crowdsale;
    uint256 public collectedTokens;

    event TokensWithdrawn(address indexed to, uint256 amount);

    constructor(address _miniMeToken, address _crowdsale) {
        miniMeToken = MiniMeToken(_miniMeToken);
        crowdsale = Crowdsale(_crowdsale);
    }

    function collectTokens() public onlyOwner {
        uint256 balance = miniMeToken.balanceOf(address(this));
        uint256 total = collectedTokens.add(balance);
        uint256 finalizedTime = crowdsale.finalizedTime();
        require(finalizedTime > 0 && getTime() > finalizedTime.add(1 days));
        uint256 canExtract = 0;
        if (getTime() <= finalizedTime.add(months(3))) {
            require(collectedTokens < total.percent(40));
            canExtract = total.percent(40);
        } else if (getTime() > finalizedTime.add(months(3)) && getTime() <= finalizedTime.add(months(6))) {
            require(collectedTokens < total.percent(60));
            canExtract = total.percent(60);
        } else if (getTime() > finalizedTime.add(months(6)) && getTime() <= finalizedTime.add(months(9))) {
            require(collectedTokens < total.percent(80));
            canExtract = total.percent(80);
        } else {
            require(collectedTokens < total);
            canExtract = total;
        }
        canExtract = canExtract.sub(collectedTokens);
        if (canExtract > balance) {
            canExtract = balance;
        }
        collectedTokens = collectedTokens.add(canExtract);
        miniMeToken.transfer(owner, canExtract);
        emit TokensWithdrawn(owner, canExtract);
    }

    function getTime() internal view virtual returns (uint256) {
        // Implement your time retrieval logic here
        return block.timestamp;
    }

    function months(uint256 monthsToAdd) internal pure returns (uint256) {
        return monthsToAdd * 30 days;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizedTime', 'complexity': 0}, {'function': 'collectTokens', 'complexity': 10}, {'function': 'getTime', 'complexity': 0}, {'function': 'months', 'complexity': 0}]",15.0,"{""type"": ""FunctionDefinition"", ""name"": ""collectTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalized""}, {""type"": ""stringLiteral"", ""value"": ""Crowdsale must be finalized""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalWithdrawable"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""withdrawableAmount"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""finalized""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalWithdrawable""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""40"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""finalized""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""60"", ""subdenomination"": ""days""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalWithdrawable""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""60"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""finalized""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""90"", ""subdenomination"": ""days""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""totalWithdrawable""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""80"", ""subdenomination"": None}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalWithdrawable""}}}]}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens available for withdrawal""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""collectedTokens""}, ""right"": {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensWithdrawn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""withdrawableAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract Crowdsale {
    IERC20 public token;
    uint256 public collectedTokens;
    bool public finalized;
    mapping(address => uint256) public tokenBuyersMapping;
    mapping(address => uint256) public tokenBuyersRemaining;

    event TokensWithdrawn(address indexed beneficiary, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function collectTokens() external onlyOwner {
        require(finalized, ""Crowdsale must be finalized"");
        uint256 balance = token.balanceOf(address(this));
        uint256 totalWithdrawable = balance + collectedTokens;

        // Calculate the withdrawal amount based on time elapsed since finalization
        uint256 withdrawableAmount;
        if (block.timestamp <= finalized + 30 days) {
            withdrawableAmount = totalWithdrawable * 40 / 100;
        } else if (block.timestamp <= finalized + 60 days) {
            withdrawableAmount = totalWithdrawable * 60 / 100;
        } else if (block.timestamp <= finalized + 90 days) {
            withdrawableAmount = totalWithdrawable * 80 / 100;
        } else {
            withdrawableAmount = totalWithdrawable;
        }

        require(withdrawableAmount > 0, ""No tokens available for withdrawal"");
        require(token.transfer(msg.sender, withdrawableAmount), ""Token transfer failed"");

        collectedTokens += withdrawableAmount;
        emit TokensWithdrawn(msg.sender, withdrawableAmount);
    }
}",46.559128284454346,collectTokens,79.0,0.5332807699446147,0.1048829619315664,"[{'function': 'collectTokens', 'complexity': 6}]",10.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Crowdsale is Ownable {
    IERC20 public token;
    uint256 public collectedTokens = 1;
    bool public finalized = false;
    mapping(address => uint256) public tokenBuyersMapping;
    mapping(address => uint256) public tokenBuyersRemaining;

    event TokensWithdrawn(address indexed beneficiary, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function collectTokens() external onlyOwner {
        require(finalized, ""Crowdsale must be finalized"");
        uint256 balance = token.balanceOf(address(this));
        uint256 totalWithdrawable = balance + collectedTokens;

        // Calculate the withdrawal amount based on time elapsed since finalization
        uint256 withdrawableAmount;
        if (block.timestamp <= finalized + 30 days) {
            withdrawableAmount = totalWithdrawable * 40 / 100;
        } else if (block.timestamp <= finalized + 60 days) {
            withdrawableAmount = totalWithdrawable * 60 / 100;
        } else if (block.timestamp <= finalized + 90 days) {
            withdrawableAmount = totalWithdrawable * 80 / 100;
        } else {
            withdrawableAmount = totalWithdrawable;
        }

        require(withdrawableAmount > 0, ""No tokens available for withdrawal"");
        require(token.transfer(msg.sender, withdrawableAmount), ""Token transfer failed"");

        collectedTokens += withdrawableAmount;
        emit TokensWithdrawn(msg.sender, withdrawableAmount);
    }
}"
1358,Internal - Checks if the entered ticker is registered and has not expired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""_tickerAvailable"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickerOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Ticker has an owner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expiryDate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getUint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Encoder""}, ""memberName"": ""getKey""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registeredTickers_expiryDate""}, {""type"": ""Identifier"", ""name"": ""_ticker""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isActive"", ""storageLocation"": None}], ""initialValue"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickerStatuses""}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""expiryDate""}}, {""type"": ""stringLiteral"", ""value"": ""Ticker not expired or active""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isActive""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Ticker status is active""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TickerAvailability {
    mapping(string => address) private tickerOwners;
    mapping(string => uint256) private registeredTickersExpiryDate;
    mapping(string => bool) private tickerStatuses;

    function _tickerAvailable(string memory _ticker) public view returns (bool) {
        require(tickerOwners[_ticker] == address(0), ""Ticker has an owner"");

        uint256 expiryDate = getUint(Encoder.getKey(""registeredTickers_expiryDate"", _ticker));
        bool isActive = !tickerStatuses[_ticker];

        require(block.timestamp > expiryDate, ""Ticker not expired or active"");
        require(!isActive, ""Ticker status is active"");

        return true;
    }

    function getUint(bytes memory key) internal pure returns (uint256 value) {
        // Placeholder for the actual implementation of getting a uint from storage.
        assembly {
            value := mload(add(key, 32))
        }
    }
}",44.52820086479187,_tickerAvailable,35.0,0.5791016874856789,0.0345050385630141,"[{'function': '_tickerAvailable', 'complexity': 4}, {'function': 'getUint', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TickerAvailability is Ownable {
    mapping(string => address) private tickerOwners;
    mapping(string => uint256) private registeredTickersExpiryDate;
    mapping(string => bool) private tickerStatuses;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function _tickerAvailable(string memory _ticker) public view returns (bool) {
        require(tickerOwners[_ticker] == address(0), ""Ticker has an owner"");

        uint256 expiryDate = getUint(Encoder.getKey(""registeredTickers_expiryDate"", _ticker));
        bool isActive = !tickerStatuses[_ticker];

        require(block.timestamp > expiryDate, ""Ticker not expired or active"");
        require(!isActive, ""Ticker status is active"");

        return true;
    }

    function getUint(bytes memory key) internal pure returns (uint256 value) {
        // Placeholder for the actual implementation of getting a uint from storage.
        assembly {
            value := mload(add(key, 32))
        }
    }
}"
5732,Withdraws deposited tokens on behalf of users Allowed only for oracle,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public token;
    mapping(bytes32 => uint) public user2lastPeriodParticipated;
    uint public periodsCount;
    struct Period {
        uint startDate;
    }
    mapping(uint => Period) public periods;
    event TreasuryWithdrawn(bytes32 indexed _userKey, uint _amount);
    uint constant OK = 0;

    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOwner returns (uint) {
        require(_userKey != bytes32(0));
        require(_value != 0);
        require(_feeAmount < _value);
        _makeWithdrawForPeriod(_userKey, _value);
        uint _periodsCount = periodsCount;
        user2lastPeriodParticipated[_userKey] = periodsCount;
        delete periods[periodsCount].startDate;
        IERC20 _token = IERC20(token);
        if (!(_feeAddress == address(0) || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {
            revert();
        }
        uint _withdrawnAmount = _value.sub(_feeAmount);
        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {
            revert();
        }
        emit TreasuryWithdrawn(_userKey, _withdrawnAmount);
        return OK;
    }

    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {
        // Implementation of the internal function
    }
}","[{'function': 'withdraw', 'complexity': 7}, {'function': '_makeWithdrawForPeriod', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_userKey"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_withdrawAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_feeAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_userKey""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""User key must not be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Fee amount must be less than the withdrawal value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_makeWithdrawForPeriod""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_userKey""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""user2lastPeriodParticipated""}, ""index"": {""type"": ""Identifier"", ""name"": ""_userKey""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""periodsCount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""periods""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""periodsCount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""memberName"": ""isActive""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_userKey""}, {""type"": ""Identifier"", ""name"": ""_withdrawAddress""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_feeAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_userKey""}, {""type"": ""Identifier"", ""name"": ""_feeAddress""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Fee transfer failed""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TreasuryWithdrawn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_userKey""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_feeAmount""}}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""OK""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract WithdrawalContract {
    ERC20 public token;
    mapping(address => uint256) public user2lastPeriodParticipated;
    Period[] public periods;
    uint256 public periodsCount;

    struct Period {
        uint256 startDate;
        bool isActive;
    }

    constructor(address _tokenAddress) {
        token = ERC20(_tokenAddress);
    }

    function withdraw(address _userKey, uint256 _value, address _withdrawAddress, uint256 _feeAmount, address _feeAddress) public returns (string memory) {
        require(_userKey != address(0), ""User key must not be zero"");
        require(_value > 0, ""Value must be greater than zero"");
        require(_feeAmount < _value, ""Fee amount must be less than the withdrawal value"");

        // Process the withdrawal for the current period
        _makeWithdrawForPeriod(_userKey, _value);

        // Update user participation record
        user2lastPeriodParticipated[_userKey] = block.timestamp;

        // Mark the end of the current period
        if (periodsCount > 0) {
            periods[periodsCount - 1].isActive = false;
        }

        // Calculate the token transfer instance using ERC20(token)
        require(token.transferFrom(_userKey, _withdrawAddress, _value - _feeAmount), ""Token transfer failed"");

        // Transfer fee if applicable
        if (_feeAddress != address(0) && _feeAmount > 0) {
            require(token.transferFrom(_userKey, _feeAddress, _feeAmount), ""Fee transfer failed"");
        }

        emit TreasuryWithdrawn(_userKey, _value - _feeAmount);
        return ""OK"";
    }

    function _makeWithdrawForPeriod(address _userKey, uint256 _value) internal {
        // Additional logic for processing withdrawal for the current period
    }

    event TreasuryWithdrawn(address indexed user, uint256 amount);
}",47.74501132965088,withdraw,49.0,0.8940248307289503,0.251103670335681,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'withdraw', 'complexity': 7}, {'function': '_makeWithdrawForPeriod', 'complexity': 0}]",9.0,"pragma solidity ^0.8.0;

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract WithdrawalContract is Ownable {
    ERC20 public token;
    mapping(address => uint256) public user2lastPeriodParticipated;
    Period[] public periods;
    uint256 public periodsCount;

    struct Period {
        uint256 startDate;
        bool isActive;
    }

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = ERC20(_tokenAddress);
        // Initialize state variables with safe, non-corner-case values
        periodsCount = 1;
        periods.push(Period({startDate: block.timestamp, isActive: true}));
    }

    function withdraw(address _userKey, uint256 _value, address _withdrawAddress, uint256 _feeAmount, address _feeAddress) public returns (string memory) {
        require(_userKey != address(0), ""User key must not be zero"");
        require(_value > 0, ""Value must be greater than zero"");
        require(_feeAmount < _value, ""Fee amount must be less than the withdrawal value"");

        // Process the withdrawal for the current period
        _makeWithdrawForPeriod(_userKey, _value);

        // Update user participation record
        user2lastPeriodParticipated[_userKey] = block.timestamp;

        // Mark the end of the current period
        if (periodsCount > 0) {
            periods[periodsCount - 1].isActive = false;
        }

        // Calculate the token transfer instance using ERC20(token)
        require(token.transferFrom(_userKey, _withdrawAddress, _value - _feeAmount), ""Token transfer failed"");

        // Transfer fee if applicable
        if (_feeAddress != address(0) && _feeAmount > 0) {
            require(token.transferFrom(_userKey, _feeAddress, _feeAmount), ""Fee transfer failed"");
        }

        emit TreasuryWithdrawn(_userKey, _value - _feeAmount);
        return ""OK"";
    }

    function _makeWithdrawForPeriod(address _userKey, uint256 _value) internal {
        // Additional logic for processing withdrawal for the current period
    }

    event TreasuryWithdrawn(address indexed user, uint256 amount);
}"
5527,"Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint128 amount;
        uint128 totalClaimed;
        uint16 vestingCliff;
        uint16 vestingDuration;
        uint16 monthsClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    uint256 constant SECONDS_PER_MONTH = 2628000; // Approximately 30 days * 86400 seconds per day

    function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {
        Grant storage tokenGrant = tokenGrants[_recipient];

        if (block.timestamp < tokenGrant.startTime) {
            return (0, 0);
        }

        uint256 elapsedTime = block.timestamp.sub(tokenGrant.startTime);
        uint256 elapsedMonths = elapsedTime / SECONDS_PER_MONTH;

        if (elapsedMonths < tokenGrant.vestingCliff) {
            return (0, 0);
        }

        if (elapsedMonths >= tokenGrant.vestingDuration) {
            uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;
            return (uint16(tokenGrant.vestingDuration), remainingGrant);
        } else {
            uint16 monthsVested = uint16(elapsedMonths.sub(tokenGrant.monthsClaimed));
            uint256 amountVestedPerMonth = tokenGrant.amount / uint256(tokenGrant.vestingDuration);
            uint128 amountVested = uint128(monthsVested * amountVestedPerMonth);
            return (monthsVested, amountVested);
        }
    }
}","[{'function': 'calculateGrantClaim', 'complexity': 3}]",5.0,{},,44.02483582496643,,79.0,0.0555201295685514,0.0,"{'function': '', 'complexity': 0}",,nan
1662,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
    AccountValueLocalVars memory localResults;
    localResults.sumSupplies = Exp({mantissa: 0});
    localResults.sumBorrows = Exp({mantissa: 0});
    Error err;
    localResults.collateralMarketsLength = collateralMarkets.length;
    for (uint i = 0; i < localResults.collateralMarketsLength; i++) {
        localResults.assetAddress = collateralMarkets[i];
        Market storage currentMarket = markets[localResults.assetAddress];
        Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];
        Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];
        if (supplyBalance.principal > 0) {
            (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
        if (borrowBalance.principal > 0) {
            (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
    }
    return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);
}

}","[{'function': 'calculateAccountValuesInternal', 'complexity': 29}]",12.0,{},,52.94187927246094,,102.0,0.0176483418141595,0.0,"{'function': '', 'complexity': 0}",,nan
6249,Set the threshold for a payment to be sent directly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public directPaymentThreshold;

    constructor(uint256 initialThreshold) {
        directPaymentThreshold = initialThreshold;
    }

    function setDirectPaymentThreshold(uint256 threshold) external onlyCFO {
        directPaymentThreshold = threshold;
    }
}","[{'function': 'setDirectPaymentThreshold', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setDirectPaymentThreshold"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""threshold"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""directPaymentThreshold""}, ""right"": {""type"": ""Identifier"", ""name"": ""threshold""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCFO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract CompanyFinance {
    address public cfo;
    uint256 public directPaymentThreshold;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only the CFO can call this function"");
        _;
    }

    constructor(address _cfo) {
        cfo = _cfo;
    }

    function setDirectPaymentThreshold(uint256 threshold) external onlyCFO {
        directPaymentThreshold = threshold;
    }
}",49.39029598236084,setDirectPaymentThreshold,0.0,1.0,1.0,"[{'function': 'setDirectPaymentThreshold', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CompanyFinance is Ownable {
    address public cfo;
    uint256 public directPaymentThreshold;

    modifier onlyCFO() {
        require(msg.sender == cfo, ""Only the CFO can call this function"");
        _;
    }

    constructor(address _cfo) Ownable(_cfo) {
        cfo = _cfo;
        directPaymentThreshold = 1;
    }

    function setDirectPaymentThreshold(uint256 threshold) external onlyCFO {
        directPaymentThreshold = threshold;
    }
}"
153,A getter to find if a specified Project has been canceled,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PledgeAdminType {
    enum Type { Giver, Project }
}

struct PledgeAdmin {
    uint64 parentProject;
    bool canceled;
    PledgeAdminType.Type adminType;
}

abstract contract ProjectCancelChecker is Ownable {
    using SafeMath for uint256;

    mapping(uint64 => PledgeAdmin) public pledgeAdmins;

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin storage) {
        require(projectId != 0, ""Invalid project ID"");
        return pledgeAdmins[projectId];
    }

    function isProjectCanceled(uint64 projectId) public view returns (bool) {
        PledgeAdmin storage m = findAdmin(projectId);
        if (m.adminType == PledgeAdminType.Type.Giver) return false;
        require(m.adminType == PledgeAdminType.Type.Project, ""Invalid admin type"");
        if (m.canceled) return true;
        if (m.parentProject == 0) return false;
        return isProjectCanceled(m.parentProject);
    }
}","[{'function': 'findAdmin', 'complexity': 1}, {'function': 'isProjectCanceled', 'complexity': 1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""isProjectCanceled"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""projectId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": ""admin"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""findAdmin""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""projectId""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admin""}, ""memberName"": ""adminType""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PledgeAdminType""}, ""memberName"": ""Giver""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admin""}, ""memberName"": ""adminType""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""PledgeAdminType""}, ""memberName"": ""Project""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect admin type""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admin""}, ""memberName"": ""canceled""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admin""}, ""memberName"": ""parentProject""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isProjectCanceled""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""admin""}, ""memberName"": ""parentProject""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract ProjectManagement {
    enum PledgeAdminType { Giver, Project }

    struct PledgeAdmin {
        bool canceled;
        uint64 parentProject;
        PledgeAdminType adminType;
    }

    mapping(uint64 => PledgeAdmin) public pledgeAdmins;

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin storage) {
        return pledgeAdmins[projectId];
    }

    function isProjectCanceled(uint64 projectId) public view returns (bool) {
        PledgeAdmin storage admin = findAdmin(projectId);

        if (admin.adminType == PledgeAdminType.Giver) {
            return false;
        }

        require(admin.adminType == PledgeAdminType.Project, ""Incorrect admin type"");

        if (admin.canceled) {
            return true;
        }

        if (admin.parentProject == 0) {
            return false;
        }

        return isProjectCanceled(admin.parentProject);
    }
}",44.462684631347656,isProjectCanceled,2.0,0.890448645320914,0.4779252570700605,"[{'function': 'findAdmin', 'complexity': 0}, {'function': 'isProjectCanceled', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ProjectManagement is Ownable {
    enum PledgeAdminType { Giver, Project }

    struct PledgeAdmin {
        bool canceled;
        uint64 parentProject;
        PledgeAdminType adminType;
    }

    mapping(uint64 => PledgeAdmin) public pledgeAdmins;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint64 i = 1; i <= 3; i++) {
            pledgeAdmins[i] = PledgeAdmin({ canceled: false, parentProject: 0, adminType: PledgeAdminType.Giver });
        }
    }

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin storage) {
        return pledgeAdmins[projectId];
    }

    function isProjectCanceled(uint64 projectId) public view returns (bool) {
        PledgeAdmin storage admin = findAdmin(projectId);

        if (admin.adminType == PledgeAdminType.Giver) {
            return false;
        }

        require(admin.adminType == PledgeAdminType.Project, ""Incorrect admin type"");

        if (admin.canceled) {
            return true;
        }

        if (admin.parentProject == 0) {
            return false;
        }

        return isProjectCanceled(admin.parentProject);
    }
}"
223,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ICard {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
        uint256 price;
        uint256 nextprice;
        string imagepath;
        string category;
        uint256 IsWildCard;
        address owner;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    mapping(uint256 => uint256) public cardTokenToPrice;
    Card[] public cards;

    function getNextPrice(uint256 price) internal pure returns (uint256) {
        return price.mul(110).div(100); // Increase by 10%
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner) {
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
        price = getNextPrice(cardTokenToPrice[_tokenId]);
        nextprice = getNextPrice(price);
        imagepath = card.imagepath;
        category = card.category;
        wildcard = card.IsWildCard;
        _owner = card.owner;
    }
}","[{'function': 'getCard', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getCard', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCard"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""cards""}, ""memberName"": ""length""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cardTokenToPosition""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""token""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextPrice""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""price""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getNextPrice""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""nextPrice""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""imagePath""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""category""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""wildcard""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""card""}, ""memberName"": ""_owner""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CardInfo {
    struct Card {
        string name;
        uint256 token;
        uint256 price;
        uint256 nextPrice;
        string imagePath;
        string category;
        bool wildcard;
        address _owner;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;
    mapping(uint256 => uint256) public cardTokenToPrice;

    function getCard(uint256 _tokenId) public view returns (string memory, uint256, uint256, uint256, string memory, string memory, bool, address) {
        require(_tokenId > 0 && _tokenId <= cards.length, ""Invalid token ID"");

        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];

        return (
            card.name,
            card.token,
            getNextPrice(card.price),
            getNextPrice(card.nextPrice),
            card.imagePath,
            card.category,
            card.wildcard,
            card._owner
        );
    }

    function getNextPrice(uint256 currentPrice) internal pure returns (uint256) {
        // Example logic for calculating the next price
        return currentPrice * 110 / 100; // Increase by 10%
    }
}",45.55952668190002,getCard,40.0,0.7691585614987526,0.3277052638383489,"[{'function': 'getCard', 'complexity': 2}, {'function': 'getNextPrice', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CardInfo is Ownable {
    struct Card {
        string name;
        uint256 token;
        uint256 price;
        uint256 nextPrice;
        string imagePath;
        string category;
        bool wildcard;
        address _owner;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;
    mapping(uint256 => uint256) public cardTokenToPrice;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        uint256 token = 1; // Never 0
        address owner = msg.sender;
        bool wildcard = true;
        string imagePath = ""default_image_path"";
        string category = ""default_category"";

        Card memory card = Card(
            ""Default Card Name"",
            token,
            100, // Price and nextPrice are initialized to a safe value
            110, // Increase by 10%
            imagePath,
            category,
            wildcard,
            owner
        );

        cards.push(card);
        cardTokenToPosition[token] = cards.length - 1;
        cardTokenToPrice[token] = 100; // Price and nextPrice are initialized to a safe value

        emit CardCreated(token, owner);
    }

    function getCard(uint256 _tokenId) public view returns (string memory, uint256, uint256, uint256, string memory, string memory, bool, address) {
        require(_tokenId > 0 && _tokenId <= cards.length, ""Invalid token ID"");

        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];

        return (
            card.name,
            card.token,
            getNextPrice(card.price),
            getNextPrice(card.nextPrice),
            card.imagePath,
            card.category,
            card.wildcard,
            card._owner
        );
    }

    function getNextPrice(uint256 currentPrice) internal pure returns (uint256) {
        // Example logic for calculating the next price
        return currentPrice * 110 / 100; // Increase by 10%
    }
}"
1195,"The owner can clawback any unspent Parsec credits after a date in the future , so no Parsec credits remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IParsecToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether;
    uint256 public constant OWNER_CLAWBACK_DATE = block.timestamp + 30 days; // Example date, adjust as needed

    bool public creditsClawbacked;
    IParsecToken public parsecToken;
    address public owner;
    uint256 public totalFunding;

    function ownerClawbackCredits() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        require(!creditsClawbacked);
        creditsClawbacked = true;
        parsecToken.transfer(owner, parsecToken.balanceOf(address(this)));
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'ownerClawbackCredits', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""ownerClawbackCredits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""totalFunding""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRESALE_MINIMUM_FUNDING""}}, {""type"": ""stringLiteral"", ""value"": ""Total funding must be less than the minimum required for the presale.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""OWNER_CLAWBACK_DATE""}}, {""type"": ""stringLiteral"", ""value"": ""Current time has not reached or exceeded the clawback date.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""creditsClawbacked""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Credits have already been clawed back.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferTokens""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""creditsClawbacked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenClawback {
    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether; // Example minimum funding in wei
    uint256 public constant OWNER_CLAWBACK_DATE = 1739481600; // Example date (January 1, 2025) in Unix timestamp

    bool public creditsClawbacked;
    uint256 public totalFunding;

    function ownerClawbackCredits() external {
        require(totalFunding < PRESALE_MINIMUM_FUNDING, ""Total funding must be less than the minimum required for the presale."");
        require(block.timestamp >= OWNER_CLAWBACK_DATE, ""Current time has not reached or exceeded the clawback date."");
        require(!creditsClawbacked, ""Credits have already been clawed back."");

        // Transfer all tokens held by the contract to the owner
        // Assuming a function transferTokens(address recipient) exists and is callable from this contract
        transferTokens(msg.sender);

        // Mark the credits as clawed back
        creditsClawbacked = true;
    }

    function transferTokens(address recipient) internal {
        // Dummy implementation for transferring tokens to the owner
        // In a real scenario, this would be an interface or abstract contract method call
        // Example: IERC20 tokenContract = IERC20(tokenAddress);
        //          tokenContract.transfer(recipient, balanceOf(address(this)));
    }
}",45.40678286552429,ownerClawbackCredits,16.0,0.8361052343905284,0.2053056102155772,"[{'function': 'ownerClawbackCredits', 'complexity': 4}, {'function': 'transferTokens', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenClawback is Ownable {
    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether; // Example minimum funding in wei
    uint256 public constant OWNER_CLAWBACK_DATE = 1739481600; // Example date (January 1, 2025) in Unix timestamp

    bool public creditsClawbacked;
    uint256 public totalFunding;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe, non-corner-case values
        PRESALE_MINIMUM_FUNDING = 1 ether;
        OWNER_CLAWBACK_DATE = 1739481600;
        creditsClawbacked = false;
        totalFunding = 0; // Set to zero instead of initializing to 1, as per the rule
    }

    function ownerClawbackCredits() external {
        require(totalFunding < PRESALE_MINIMUM_FUNDING, ""Total funding must be less than the minimum required for the presale."");
        require(block.timestamp >= OWNER_CLAWBACK_DATE, ""Current time has not reached or exceeded the clawback date."");
        require(!creditsClawbacked, ""Credits have already been clawed back."");

        // Transfer all tokens held by the contract to the owner
        // Assuming a function transferTokens(address recipient) exists and is callable from this contract
        transferTokens(msg.sender);

        // Mark the credits as clawed back
        creditsClawbacked = true;
    }

    function transferTokens(address recipient) internal {
        // Dummy implementation for transferring tokens to the owner
        // In a real scenario, this would be an interface or contract method call
        // Example: IERC20 tokenContract = IERC20(tokenAddress);
        //          tokenContract.transfer(recipient, balanceOf(address(this)));
    }
}"
3570,Pauses the whitelist if there is any issue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    using SafeMath for uint256;

    bool public paused = false;
    event Paused(address indexed account, uint256 timestamp);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Not the contract owner"");
        _;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}","[{'function': 'pauseWhitelist', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Paused""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAdmin"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Whitelist {
    bool public paused = false;
    address public admin;

    event Paused(address indexed sender, uint256 timestamp);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    constructor(address _admin) {
        admin = _admin;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}",42.52776551246643,pauseWhitelist,0.0,1.0,1.0,"[{'function': 'pauseWhitelist', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Whitelist is Ownable {
    bool public paused = false;
    address public admin;

    event Paused(address indexed sender, uint256 timestamp);

    modifier onlyAdmin() {
        require(msg.sender == owner(), ""Only admin can call this function"");
        _;
    }

    constructor(address _admin) Ownable(_admin) {
        // Initialization of state variables
        paused = false;
        admin = _admin;
    }

    function pauseWhitelist() public onlyOwner returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}"
5480,Allows transfer token ownership back to distribution contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token; // Address of the token contract

    constructor(address _token) {
        token = _token;
    }

    function reclaimTokenOwnership() public onlyOwner {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        IERC20(token).claimOwnership();
    }
}","[{'function': 'reclaimTokenOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimTokenOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""claimOwnership""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IToken {
    function claimOwnership() external;
}

contract ReclaimTokenOwnership is Ownable {
    IToken public token;

    constructor(address _token) {
        token = IToken(_token);
    }

    function reclaimTokenOwnership() external onlyOwner {
        token.claimOwnership();
    }
}",42.173160791397095,reclaimTokenOwnership,11.0,0.6754549546163291,0.0809706365066397,"[{'function': 'claimOwnership', 'complexity': 0}, {'function': 'reclaimTokenOwnership', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IToken {
    function claimOwnership() external;
}
import ""openzeppelin/SafeMath.sol"";
contract ReclaimTokenOwnership is Ownable {
    IToken public token;

    constructor(address _token) Ownable(msg.sender) {
        token = IToken(_token);
    }

    function reclaimTokenOwnership() external onlyOwner {
        token.claimOwnership();
    }
}"
3477,"Returns the loan metadata , this field can be set by the creator of the loan with his own criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataWrapper {
    using SafeMath for uint256;

    struct Loan {
        string metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadata(uint256 index) public view returns (string memory) {
        return loans[index].metadata;
    }
}","[{'function': 'tokenMetadata', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loans""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Index out of bounds""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""metadata""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract LoanMetadata {
    struct Loan {
        string metadata;
    }

    Loan[] public loans;

    function tokenMetadata(uint256 index) public view returns (string memory) {
        require(index < loans.length, ""Index out of bounds"");
        return loans[index].metadata;
    }
}",41.72507095336914,tokenMetadata,8.0,0.8101498795330324,0.5029163664487494,"[{'function': 'tokenMetadata', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoanMetadata is Ownable {
    struct Loan {
        string metadata;
    }

    Loan[] public loans;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        loans = [Loan({metadata: ""initialized""}), Loan({metadata: ""initialized""}), Loan({metadata: ""initialized""})];
    }

    function tokenMetadata(uint256 index) public view returns (string memory) {
        require(index < loans.length, ""Index out of bounds"");
        return loans[index].metadata;
    }
}"
1259,Claims the ownership of a given token ID,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
}","[{'function': 'takeOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""takeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isSenderApprovedFor""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""not approved""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""currentOwner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerByTokenId""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""currentOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""owner not found""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerByTokenId""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""currentOwner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenOwnership {
    mapping(uint256 => address) public ownerByTokenId;
    mapping(uint256 => address) private tokenApprovals;
    mapping(address => mapping(address => bool)) public operators;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {
        return msg.sender == ownerByTokenId[_tokenId] || tokenApprovals[_tokenId] == msg.sender;
    }

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");

        address currentOwner = ownerByTokenId[_tokenId];
        require(currentOwner != address(0), ""owner not found"");

        // Clear any existing approvals
        tokenApprovals[_tokenId] = address(0);

        // Transfer ownership to the caller
        ownerByTokenId[_tokenId] = msg.sender;

        emit Transfer(currentOwner, msg.sender, _tokenId);
    }
}",44.81803584098816,takeOwnership,32.0,0.6616959237625605,0.3521303718591426,"[{'function': 'isSenderApprovedFor', 'complexity': 0}, {'function': 'takeOwnership', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenOwnership is Ownable {
    mapping(uint256 => address) public ownerByTokenId;
    mapping(uint256 => address) private tokenApprovals;
    mapping(address => mapping(address => bool)) public operators;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {
        return msg.sender == ownerByTokenId[_tokenId] || tokenApprovals[_tokenId] == msg.sender;
    }

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");

        address currentOwner = ownerByTokenId[_tokenId];
        require(currentOwner != address(0), ""owner not found"");

        // Clear any existing approvals
        tokenApprovals[_tokenId] = address(0);

        // Transfer ownership to the caller
        ownerByTokenId[_tokenId] = msg.sender;

        emit Transfer(currentOwner, msg.sender, _tokenId);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; ; ++i) {
            if (ownerByTokenId[i] == address(0)) {
                ownerByTokenId[i] = address(uint160(i));
                break;
            }
        }
        // Initialize tokenApprovals with default values
        for (uint256 i = 1; ; ++i) {
            if (tokenApprovals[i] == address(0)) {
                tokenApprovals[i] = address(0);
                break;
            }
        }
    }
}"
6427,We do n't make this function constant to allow for state-updating access controls such as rate limiting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AccessControl {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => bool)) private roles;
    mapping(address => mapping(bytes4 => bool)) private permissions;

    function hasRole(address subject, bytes32 role) public view returns (bool) {
        return roles[subject][role];
    }

    function hasPermission(address object, bytes4 verb) public view returns (bool) {
        return permissions[object][verb];
    }

    function allowed(address subject, bytes32 role, address object, bytes4 verb) public returns (bool) {
        require(subject != address(0), ""Subject cannot be zero address"");
        require(role != bytes32(0), ""Role cannot be empty"");
        require(object != address(0), ""Object cannot be zero address"");
        require(verb != bytes4(0), ""Verb cannot be empty"");

        if (hasRole(subject, role)) {
            return true;
        }

        if (hasPermission(object, verb)) {
            return true;
        }

        return false;
    }
}","[{'function': 'hasRole', 'complexity': 0}, {'function': 'hasPermission', 'complexity': 0}, {'function': 'allowed', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""hasPermission"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""subject"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""role"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""object"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""verb"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Permission""}, ""name"": ""permission"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accessList""}, ""index"": {""type"": ""Identifier"", ""name"": ""subject""}}, ""index"": {""type"": ""Identifier"", ""name"": ""role""}}, ""index"": {""type"": ""Identifier"", ""name"": ""object""}}, ""index"": {""type"": ""Identifier"", ""name"": ""verb""}}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""permission""}, ""memberName"": ""allowed""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AccessControl {
    struct Permission {
        bool allowed;
    }

    mapping(address => mapping(bytes32 => mapping(address => mapping(bytes4 => Permission)))) private accessList;

    function hasPermission(address subject, bytes32 role, address object, bytes4 verb) public view returns (bool) {
        Permission storage permission = accessList[subject][role][object][verb];
        return permission.allowed;
    }
}",42.51331615447998,hasPermission,45.0,0.4581177562146623,0.0384748461797231,"[{'function': 'hasPermission', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AccessControl is Ownable {
    struct Permission {
        bool allowed;
    }

    mapping(address => mapping(bytes32 => mapping(address => mapping(bytes4 => Permission)))) private accessList;

    function hasPermission(address subject, bytes32 role, address object, bytes4 verb) public view returns (bool) {
        Permission storage permission = accessList[subject][role][object][verb];
        return permission.allowed;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
5406,Returns all rewards charged for the given canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeeHistory {
    function rewardsCumulative(uint256 index) external view returns (uint256);
}

abstract contract CanvasRewards is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint256[] rewardsCumulative;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getTotalRewards(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Invalid canvas ID"");
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint256 _lastIndex = _history.rewardsCumulative.length - 1;
        if (_lastIndex < 0) {
            return 0;
        }
        return _history.rewardsCumulative[_lastIndex];
    }
}","[{'function': 'rewardsCumulative', 'complexity': 0}, {'function': 'getTotalRewards', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalAccumulatedRewards"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_canvasId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Canvas ID out of bounds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""FeeHistory""}, ""name"": ""feeHistory"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasToFeeHistory""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""rewardsCumulative"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feeHistory""}, ""memberName"": ""rewardsCumulative""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rewardsCumulative""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rewardsCumulative""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewardsCumulative""}, ""index"": {""type"": ""Identifier"", ""name"": ""lastIndex""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CanvasRewards {
    struct FeeHistory {
        uint256[] rewardsCumulative;
    }

    mapping(uint32 => FeeHistory) public canvasToFeeHistory;
    uint32[] public canvases;

    function getTotalAccumulatedRewards(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Canvas ID out of bounds"");

        FeeHistory storage feeHistory = canvasToFeeHistory[_canvasId];
        uint256[] memory rewardsCumulative = feeHistory.rewardsCumulative;

        if (rewardsCumulative.length == 0) {
            return 0;
        }

        uint256 lastIndex = rewardsCumulative.length - 1;
        return rewardsCumulative[lastIndex];
    }
}",43.451791763305664,getTotalAccumulatedRewards,12.0,0.8930596102338773,0.4665528798620619,"[{'function': 'getTotalAccumulatedRewards', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CanvasRewards is Ownable {
    struct FeeHistory {
        uint256[] rewardsCumulative;
    }

    mapping(uint32 => FeeHistory) public canvasToFeeHistory;
    uint32[] public canvases;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint32 i = 0; i < 3; i++) {
            FeeHistory storage feeHistory = canvasToFeeHistory[i];
            feeHistory.rewardsCumulative.push(1); // Start with at least one reward
        }
    }

    function getTotalAccumulatedRewards(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Canvas ID out of bounds"");

        FeeHistory storage feeHistory = canvasToFeeHistory[_canvasId];
        uint256[] memory rewardsCumulative = feeHistory.rewardsCumulative;

        if (rewardsCumulative.length == 0) {
            return 0;
        }

        uint256 lastIndex = rewardsCumulative.length - 1;
        return rewardsCumulative[lastIndex];
    }
}"
6503,The reward is calculated by the formula : ( numberOfBlocks ) ( effectiveBlockReward ) ( commitment.value ) / ( effectiveStake ) effectiveBlockReward is the average between the block reward during commit and the block reward during the call effectiveStake is the average between the stake during the commit and the stake during call ( liniar aproximation ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IMinerContract {
    function miners(address) external view returns (Miner memory);
    function totalStake() external view returns (uint256);
    function blockReward_() external view returns (int256);
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;

    struct Miner {
        uint256 value;
        int256 onBlockReward;
        uint256 atStake;
        uint256 onBlockNumber;
    }

    mapping(address => Miner) public miners;
    uint256 public totalStake_;
    int256 public blockReward_;

    IMinerContract public minerContract;

    constructor(address _minerContractAddress) {
        minerContract = IMinerContract(_minerContractAddress);
    }

    function getReward(address _miner) public view returns (uint256) {
        if (minerContract.miners(_miner).value == 0) {
            return 0;
        }
        Miner memory commitment = minerContract.miners(_miner);
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number.sub(commitment.onBlockNumber);
        uint256 miningReward = numberOfBlocks.mul(effectiveBlockReward).mul(commitment.value).div(effectiveStake);
        return miningReward;
    }

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return int256((uint256(a) + uint256(b)) / 2);
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}","[{'function': 'blockReward_', 'complexity': 0}, {'function': 'getReward', 'complexity': 2}, {'function': 'signedAverage', 'complexity': 0}, {'function': 'average', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_miner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_miner""}}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Commitment""}, ""name"": ""commitment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_miner""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""int256""}, ""name"": ""averageBlockReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""signedAverage""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""onBlockReward""}, {""type"": ""Identifier"", ""name"": ""blockReward_""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""averageBlockReward""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveBlockReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""averageBlockReward""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveStake"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""average""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""atStake""}, {""type"": ""Identifier"", ""name"": ""totalStake_""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numberOfBlocks"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""onBlockNumber""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""miningReward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""numberOfBlocks""}, ""right"": {""type"": ""Identifier"", ""name"": ""effectiveBlockReward""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""commitment""}, ""memberName"": ""value""}}, ""right"": {""type"": ""Identifier"", ""name"": ""effectiveStake""}}}, {""type"": ""Identifier"", ""name"": ""miningReward""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract MiningContract {
    struct Commitment {
        uint256 value;
        uint256 atStake;
        uint256 onBlockNumber;
        int256 onBlockReward;
    }

    mapping(address => Commitment) public miners;
    uint256 public totalStake_;
    int256 public blockReward_;

    function getReward(address _miner) public view returns (uint256) {
        if (miners[_miner].value == 0) {
            return 0;
        }

        Commitment storage commitment = miners[_miner];
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number - commitment.onBlockNumber;
        uint256 miningReward = numberOfBlocks * effectiveBlockReward * commitment.value / effectiveStake;
        return miningReward;
    }

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return (a + b) / 2;
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a + b) / 2;
    }
}",46.261812925338745,getReward,12.0,0.8078334274952343,0.6064815716243979,"[{'function': 'getReward', 'complexity': 2}, {'function': 'signedAverage', 'complexity': 0}, {'function': 'average', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MiningContract is Ownable {
    struct Commitment {
        uint256 value;
        uint256 atStake;
        uint256 onBlockNumber;
        int256 onBlockReward;
    }

    mapping(address => Commitment) public miners;
    uint256 public totalStake_ = 1;
    int256 public blockReward_ = -1; // Using negative value to avoid zero division issues in getReward function

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalStake_ = 1;
        blockReward_ = -1; // Negative value to avoid zero division issues
    }

    function getReward(address _miner) public view returns (uint256) {
        if (miners[_miner].value == 0) {
            return 0;
        }

        Commitment storage commitment = miners[_miner];
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number - commitment.onBlockNumber;
        uint256 miningReward = numberOfBlocks * effectiveBlockReward * commitment.value / effectiveStake;
        return miningReward;
    }

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return (a + b) / 2;
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a + b) / 2;
    }
}"
2533,Function to process cases when person send more than 10 ETH to smartcontract but never provided KYC data and wants/needs to be refunded .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RefundContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonWLBalanceOf;

    function refundNonWhitelistedPerson(address _address) public onlyOwner {
        require(_address != address(0), ""Invalid address"");
        uint256 refundAmount = nonWLBalanceOf[_address];
        require(refundAmount > 0, ""No balance to refund"");
        nonWLBalanceOf[_address] = nonWLBalanceOf[_address].sub(refundAmount);
        _address.transfer(refundAmount);
    }
}","[{'function': 'refundNonWhitelistedPerson', 'complexity': 2}]",3.0,{},"pragma solidity ^0.8.0;

contract RefundNonWhitelisted {
    mapping(address => uint256) public nonWLBalanceOf;

    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function refundNonWhitelisted(address _address) public onlyOwner {
        uint256 balanceToRefund = nonWLBalanceOf[_address];
        require(balanceToRefund > 0, ""No balance to refund."");

        (bool success, ) = _address.call{value: balanceToRefund}("""");
        require(success, ""Transfer failed."");

        nonWLBalanceOf[_address] = 0;
    }
}",45.34420657157898,refundNonWhitelisted,44.0,0.8672624660812529,0.3261886498941774,"[{'function': 'refundNonWhitelisted', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RefundNonWhitelisted is Ownable {
    mapping(address => uint256) public nonWLBalanceOf;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function refundNonWhitelisted(address _address) public onlyOwner {
        uint256 balanceToRefund = nonWLBalanceOf[_address];
        require(balanceToRefund > 0, ""No balance to refund."");

        (bool success, ) = _address.call{value: balanceToRefund}("""");
        require(success, ""Transfer failed."");

        nonWLBalanceOf[_address] = 0;
    }
}"
5759,Check ` _value ` tokens allowed to ` _spender ` by ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;
    mapping(address => mapping(address => uint256)) public approved;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return approved[_owner][_spender];
    }
}","[{'function': 'allowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public approved;

    function allowance(address _owner, address _spender) external view returns (uint256) {
        return approved[_owner][_spender];
    }
}",41.62583017349243,allowance,0.0,0.9737367896313038,0.7098891248983346,"[{'function': 'allowance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public approved;

    constructor() Ownable(msg.sender) {
        // Initialize state variables
        approved[address(0x111)][address(0x222)] = 1;
        approved[address(0x222)][address(0x333)] = 1;
        approved[address(0x333)][address(0x111)] = 1;
    }

    function allowance(address _owner, address _spender) external view returns (uint256) {
        return approved[_owner][_spender];
    }
}"
4344,shuts the CDP and returns all the value in the form of Dai .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IFeed {
    function read() external view returns (bytes32);
}

interface ITub {
    function tab(bytes32 id) external view returns (uint256 debt);
    function ink(bytes32 id) external view returns (uint256 ink);
    function shut(bytes32 id) external;
    function bid(uint256 amount) external view returns (uint256 bought);
    function exit(uint256 amount) external;
}

interface IOTC {
    function sellAllAmount(address gem, uint256 amount, address pay, uint256 minPrice) external returns (uint256 bought);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public dai;
    ITub public tub;
    IFeed public feed;
    IOTC public otc;
    IERC20 public gem;
    uint256 public slippage;
    uint256 public WAD = 10**18;

    constructor(address _dai, address _tub, address _feed, address _otc, address _gem, uint256 _slippage) {
        dai = IERC20(_dai);
        tub = ITub(_tub);
        feed = IFeed(_feed);
        otc = IOTC(_otc);
        gem = IERC20(_gem);
        slippage = _slippage;
    }

    function shutForDai(uint _id) public onlyOwner {
        bytes32 id = bytes32(_id);
        uint debt = tub.tab(id);
        if (debt > 0) {
            require(dai.transferFrom(msg.sender, address(this), debt));
        }
        uint ink = tub.ink(id);
        tub.shut(id);
        uint gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint price = uint(feed.read());
        uint bought = otc.sellAllAmount(address(gem), min(gemBalance, gem.balanceOf(address(this))), address(dai), wmul(WAD - slippage, wmul(gemBalance, price)));
        require(dai.transfer(msg.sender, bought));
    }

    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = x * y / WAD;
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'read', 'complexity': 0}, {'function': 'exit', 'complexity': 0}, {'function': 'sellAllAmount', 'complexity': 0}, {'function': 'shutForDai', 'complexity': 3}, {'function': 'wmul', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""shutForDai"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_id""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""debt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""tab""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""debt""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No debt to cover""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dai""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""debt""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ink"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""ink""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""shut""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""gemBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""bid""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ink""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tub""}, ""memberName"": ""exit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ink""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""feed""}, ""memberName"": ""read""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""otc""}, ""memberName"": ""sellAllAmount""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""min""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gemBalance""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""dai""}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""WAD""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""WAD""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}], ""isArray"": False}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dai""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface Tub {
    function tab(bytes32 id) external view returns (uint256);
    function ink(bytes32 id) external view returns (uint256);
    function shut(bytes32 id) external;
    function bid(uint256 amount) external view returns (uint256);
    function exit(uint256 amount) external;
}

interface Dai {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address to, uint256 value) external returns (bool);
}

interface Feed {
    function read() external view returns (uint256);
}

interface Otc {
    function sellAllAmount(address token, uint256 amount, address dest, uint256 minPrice) external;
}

contract CDPSystem {
    Tub public tub;
    Dai public dai;
    Feed public feed;
    Otc public otc;
    uint256 public constant WAD = 10**18;

    constructor(address _tub, address _dai, address _feed, address _otc) {
        tub = Tub(_tub);
        dai = Dai(_dai);
        feed = Feed(_feed);
        otc = Otc(_otc);
    }

    function shutForDai(bytes32 _id) external {
        bytes32 id = _id;
        uint256 debt = tub.tab(id);
        require(debt > 0, ""No debt to cover"");
        dai.transferFrom(msg.sender, address(this), debt);
        uint256 ink = tub.ink(id);
        tub.shut(id);
        uint256 gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint256 price = feed.read();
        otc.sellAllAmount(address(this), min(gemBalance, address(this).balance), dai, WAD - (WAD / 100)); // Assuming slippage of 1%
        dai.transfer(msg.sender, address(this).balance);
    }
}",47.60169124603272,shutForDai,39.0,0.873313750577172,0.4712579964342006,"[{'function': 'exit', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}, {'function': 'read', 'complexity': 0}, {'function': 'sellAllAmount', 'complexity': 0}, {'function': 'shutForDai', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

interface Tub {
    function tab(bytes32 id) external view returns (uint256);
    function ink(bytes32 id) external view returns (uint256);
    function shut(bytes32 id) external;
    function bid(uint256 amount) external view returns (uint256);
    function exit(uint256 amount) external;
}

interface Dai {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address to, uint256 value) external returns (bool);
}

interface Feed {
    function read() external view returns (uint256);
}

interface Otc {
    function sellAllAmount(address token, uint256 amount, address dest, uint256 minPrice) external;
}
import ""openzeppelin/SafeMath.sol"";
contract CDPSystem is Ownable {
    Tub public tub;
    Dai public dai;
    Feed public feed;
    Otc public otc;
    uint256 public constant WAD = 10**18;

    constructor(address _tub, address _dai, address _feed, address _otc) Ownable(msg.sender) {
        tub = Tub(_tub);
        dai = Dai(_dai);
        feed = Feed(_feed);
        otc = Otc(_otc);
    }

    function shutForDai(bytes32 _id) external {
        bytes32 id = _id;
        uint256 debt = tub.tab(id);
        require(debt > 0, ""No debt to cover"");
        dai.transferFrom(msg.sender, address(this), debt);
        uint256 ink = tub.ink(id);
        tub.shut(id);
        uint256 gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint256 price = feed.read();
        otc.sellAllAmount(address(this), min(gemBalance, address(this).balance), dai, WAD - (WAD / 100)); // Assuming slippage of 1%
        dai.transfer(msg.sender, address(this).balance);
    }
}"
6386,Internal - Removes the owner of a ticker,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TickerContract {
    using SafeMath for uint256;

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        uint256 index = uint256(getUint(Encoder.getKey(""tickerIndex"", _ticker)));
        bytes32 ownerKey = Encoder.getKey(""userToTickers"", _owner);
        bytes32[] memory tickers = getArrayBytes32(ownerKey);
        assert(index < tickers.length);
        assert(_tickerOwner(_ticker) == _owner);
        deleteArrayBytes32(ownerKey, index);
        if (getArrayBytes32(ownerKey).length > index) {
            bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];
            set(Encoder.getKey(""tickerIndex"", Util.bytes32ToString(switchedTicker)), index);
        }
    }
}","[{'function': '_deleteTickerOwnership', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""_deleteTickerOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tickers owned by this address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickerIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""_ticker""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Ticker not found for this owner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""storedTicker"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""storedTicker""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_ticker""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid ticker ownership""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""isPrefix"": True}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""index""}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""length""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""newTickerAtIdx"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""userTickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickerIndex""}, ""index"": {""type"": ""Identifier"", ""name"": ""newTickerAtIdx""}}, ""right"": {""type"": ""Identifier"", ""name"": ""index""}}}]}, ""FalseBody"": None}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TickerManagement {
    mapping(address => string[]) private userTickers;
    mapping(string => uint) private tickerIndex;

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        require(userTickers[_owner].length > 0, ""No tickers owned by this address"");

        uint index = tickerIndex[_ticker];
        require(index < userTickers[_owner].length, ""Ticker not found for this owner"");

        string memory storedTicker = userTickers[_owner][index];
        require(keccak256(abi.encodePacked(storedTicker)) == keccak256(abi.encodePacked(_ticker)), ""Invalid ticker ownership"");

        // Delete the ticker from the array
        delete userTickers[_owner][index];

        // Shift the elements to fill the gap
        for (uint i = index; i < userTickers[_owner].length - 1; i++) {
            userTickers[_owner][i] = userTickers[_owner][i + 1];
        }
        userTickers[_owner].pop();

        // Update the tickerIndex mapping if needed
        if (index < userTickers[_owner].length) {
            string memory newTickerAtIdx = userTickers[_owner][index];
            tickerIndex[newTickerAtIdx] = index;
        }
    }
}",45.32237267494202,_deleteTickerOwnership,76.0,0.597022018619338,0.15418995208288,"[{'function': '_deleteTickerOwnership', 'complexity': 5}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TickerManagement is Ownable {
    mapping(address => string[]) private userTickers;
    mapping(string => uint) private tickerIndex;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        require(userTickers[_owner].length > 0, ""No tickers owned by this address"");

        uint index = tickerIndex[_ticker];
        require(index < userTickers[_owner].length, ""Ticker not found for this owner"");

        string memory storedTicker = userTickers[_owner][index];
        require(keccak256(abi.encodePacked(storedTicker)) == keccak256(abi.encodePacked(_ticker)), ""Invalid ticker ownership"");

        // Delete the ticker from the array
        delete userTickers[_owner][index];

        // Shift the elements to fill the gap
        for (uint i = index; i < userTickers[_owner].length - 1; i++) {
            userTickers[_owner][i] = userTickers[_owner][i + 1];
        }
        userTickers[_owner].pop();

        // Update the tickerIndex mapping if needed
        if (index < userTickers[_owner].length) {
            string memory newTickerAtIdx = userTickers[_owner][index];
            tickerIndex[newTickerAtIdx] = index;
        }
    }
}"
5781,Get the allowance of an specified address to use another address balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}","[{'function': 'allowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remaining"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowed;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}",42.02511548995972,allowance,0.0,1.0,1.0,"[{'function': 'allowance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => mapping(address => uint256)) public allowed;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        allowed[address(0x111)][address(0x222)] = 1;
        allowed[address(0x222)][address(0x333)] = 1;
        allowed[address(0x333)][address(0x111)] = 1;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
5300,Last callback used to accept the ERC721 parcel tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ERC721Receiver {
    using SafeMath for uint256;

    address public land;
    uint256 public flagReceiveLand;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4) {
        if (msg.sender == land && flagReceiveLand == _tokenId) {
            flagReceiveLand = 0;
            return bytes4(0x150b7a02);
        }
    }
}","[{'function': 'onERC721Received', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setFlagReceiveLand"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""landContract""}}, {""type"": ""stringLiteral"", ""value"": ""Sender must be the land contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""Identifier"", ""name"": ""flagReceiveLand""}}, {""type"": ""stringLiteral"", ""value"": ""Token ID must match the stored flag""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""flagReceiveLand""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract ERC721Receiver {
    address public landContract;
    uint256 public flagReceiveLand;

    function setFlagReceiveLand(uint256 _tokenId) external {
        require(msg.sender == landContract, ""Sender must be the land contract"");
        require(_tokenId == flagReceiveLand, ""Token ID must match the stored flag"");

        // Reset the state variable to 0
        flagReceiveLand = 0;
    }
}",42.47534918785095,setFlagReceiveLand,23.0,0.8004284461600688,0.053549503179727,"[{'function': 'setFlagReceiveLand', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ERC721Receiver {
    address public landContract = 0x1111111111111111111111111111111111111111; // fixed value for landContract
    uint256 public flagReceiveLand = 1; // fixed value for flagReceiveLand

    constructor() Ownable(msg.sender) { // invoke parent contract's constructor
        _setFlagReceiveLand(1); // initialize flagReceiveLand to a safe value
    }

    function setFlagReceiveLand(uint256 _tokenId) external {
        require(msg.sender == landContract, ""Sender must be the land contract"");
        require(_tokenId == flagReceiveLand, ""Token ID must match the stored flag"");

        // Reset the state variable to 0
        flagReceiveLand = 1;
    }

    function _setFlagReceiveLand(uint256 _value) internal {
        flagReceiveLand = _value; // set flagReceiveLand to a safe value
    }
}"
6110,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external;
}

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}","[{'function': 'updatePrices', 'complexity': 0}, {'function': 'updatePrices', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newEthPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newHavvenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""timeSent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""timeSent""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""ORACLE_FUTURE_LIMIT""}}}}, {""type"": ""stringLiteral"", ""value"": ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newEthPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newHavvenPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""timeSent""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PricesUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""usdToEthPrice""}, {""type"": ""Identifier"", ""name"": ""usdToHavPrice""}, {""type"": ""Identifier"", ""name"": ""lastPriceUpdateTime""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOracle"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PriceUpdater {
    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint constant ORACLE_FUTURE_LIMIT = 1 hours; // Define a reasonable limit for the future time

    modifier onlyOracle() {
        // Implement access control logic to ensure only oracle can call this function
        require(false, ""Only oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        /* Must be the most recently sent price, but not too far in the future.
         * (so we can't lock ourselves out of updating the oracle for longer than this) */
        require(lastPriceUpdateTime < timeSent && timeSent < block.timestamp + ORACLE_FUTURE_LIMIT,
            ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");

        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;

        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }

    event PricesUpdated(uint indexed ethPrice, uint indexed havvenPrice, uint indexed updateTime);
}",45.70388865470886,updatePrices,1.0,0.9612148182301916,0.6172086255556593,"[{'function': 'updatePrices', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceUpdater is Ownable {
    uint public usdToEthPrice = 1; // Set to 1 (never 0)
    uint public usdToHavPrice = 1; // Set to 1 (never 0)
    uint public lastPriceUpdateTime;
    uint constant ORACLE_FUTURE_LIMIT = 1 hours; // Define a reasonable limit for the future time

    modifier onlyOracle() {
        require(false, ""Only oracle can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        lastPriceUpdateTime = block.timestamp; // Initialize to current timestamp
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < block.timestamp + ORACLE_FUTURE_LIMIT,
            ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");

        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;

        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }

    event PricesUpdated(uint indexed ethPrice, uint indexed havvenPrice, uint indexed updateTime);
}"
1872,selfdestructs and sends the balance to ` escrowModerator ` or ` beneficiary `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Auction {
    function auctionState() external view returns (AuctionStates);
    function escrowModerator() external view returns (address);
    function beneficiary() external view returns (address);
}

abstract contract AuctionWrapper is Ownable, Auction {
    using SafeMath for uint256;

    enum AuctionStates { NotStarted, Active, Ended, Canceled }

    AuctionStates public auctionState;
    address public escrowModerator;
    address public beneficiary;

    function setAuctionState(AuctionStates state) external onlyOwner {
        auctionState = state;
    }

    function setEscrowModerator(address moderator) external onlyOwner {
        escrowModerator = moderator;
    }

    function setBeneficiary(address ben) external onlyOwner {
        beneficiary = ben;
    }

    function cleanUpAfterYourself() public {
        require(auctionState == AuctionStates.Ended, ""Auction is not ended."");
        if (escrowModerator != address(0)) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }
}","[{'function': 'beneficiary', 'complexity': 0}, {'function': 'setAuctionState', 'complexity': 0}, {'function': 'setEscrowModerator', 'complexity': 0}, {'function': 'setBeneficiary', 'complexity': 0}, {'function': 'cleanUpAfterYourself', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cleanUpAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""escrowModerator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""escrowModerator""}], ""names"": []}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}], ""names"": []}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuctionEnded"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AuctionCleaner {
    address public beneficiary;
    bool public auctionEnded;
    address public escrowModerator;

    error AuctionNotEnded();

    modifier onlyAuctionEnded() {
        if (!auctionEnded) {
            revert AuctionNotEnded();
        }
        _;
    }

    constructor(address _beneficiary, address _escrowModerator) {
        beneficiary = _beneficiary;
        escrowModerator = _escrowModerator;
    }

    function cleanUpAuction() public onlyAuctionEnded {
        if (escrowModerator != address(0)) {
            selfdestruct(payable(escrowModerator));
        } else {
            selfdestruct(payable(beneficiary));
        }
    }
}",43.721182107925415,cleanUpAuction,11.0,0.9147224523171452,0.5279433965904035,"[{'function': 'cleanUpAuction', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AuctionCleaner is Ownable {
    address public beneficiary;
    bool public auctionEnded;
    address public escrowModerator;

    error AuctionNotEnded();

    modifier onlyAuctionEnded() {
        if (!auctionEnded) {
            revert AuctionNotEnded();
        }
        _;
    }

    constructor(address _beneficiary, address _escrowModerator) Ownable(msg.sender) {
        beneficiary = _beneficiary;
        escrowModerator = _escrowModerator;
    }

    function cleanUpAuction() public onlyAuctionEnded {
        if (escrowModerator != address(0)) {
            selfdestruct(payable(escrowModerator));
        } else {
            selfdestruct(payable(beneficiary));
        }
    }
}"
4928,Sets the contract which implements a specific interface for an address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC820ImplementerInterface {
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns (bytes4);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bytes4 constant private ERC820_ACCEPT_MAGIC = 0xffffffff;
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address implementer);

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == 0 ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, ""Not the manager"");
        require(!isERC165Interface(_interfaceHash), ""Must not be a ERC165 hash"");
        if (_implementer != 0 && _implementer != msg.sender) {
            require(ERC820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_interfaceHash, addr) == ERC820_ACCEPT_MAGIC, ""Does not implement the interface"");
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address addr) internal view returns (address) {
        // Implement logic to retrieve the manager for the address
        return owner();
    }

    function isERC165Interface(bytes32 interfaceHash) internal pure returns (bool) {
        // Implement logic to check if the interface hash is an ERC165 hash
        return false;
    }
}","[{'function': 'canImplementInterfaceForAddress', 'complexity': 0}, {'function': 'setInterfaceImplementer', 'complexity': 7}, {'function': 'getManager', 'complexity': 0}, {'function': 'isERC165Interface', 'complexity': 0}]",6.0,{},"pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address implementer);

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == address(0) ? msg.sender : _addr;

        require(msg.sender == getManager(addr), ""Not the manager"");
        require(!isERC165Interface(_interfaceHash), ""Must not be a ERC165 hash"");

        if (_implementer != address(0) && _implementer != msg.sender) {
            require(canImplementInterfaceForAddress(addr, _interfaceHash), ""Does not implement the interface"");
        }

        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address addr) internal view returns (address) {
        // Placeholder for the actual manager retrieval logic.
        return address(0); // This should be implemented based on your specific access control mechanism.
    }

    function isERC165Interface(bytes32 interfaceHash) internal pure returns (bool) {
        // ERC165 interface hash constants
        bytes4 constant ERC165_INTERFACE_ID = 0x01ffc9a7;
        return interfaceHash == keccak256(abi.encodePacked(ERC165_INTERFACE_ID));
    }

    function canImplementInterfaceForAddress(address addr, bytes32 interfaceHash) internal view returns (bool) {
        // Placeholder for the actual implementation check logic.
        return true; // This should be implemented based on your specific logic.
    }
}",46.47049617767334,setInterfaceImplementer,58.0,0.9619941725937315,0.7843832947090151,"[{'function': 'setInterfaceImplementer', 'complexity': 6}, {'function': 'getManager', 'complexity': 0}, {'function': 'isERC165Interface', 'complexity': 0}, {'function': 'canImplementInterfaceForAddress', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address implementer);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            interfaces[address(uint160(i * 0x1111111111111111111111111111111111111111))] = address(0);
        }
    }

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == address(0) ? msg.sender : _addr;

        require(msg.sender == getManager(addr), ""Not the manager"");
        require(!isERC165Interface(_interfaceHash), ""Must not be a ERC165 hash"");

        if (_implementer != address(0) && _implementer != msg.sender) {
            require(canImplementInterfaceForAddress(addr, _interfaceHash), ""Does not implement the interface"");
        }

        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address addr) internal view returns (address) {
        // Placeholder for the actual manager retrieval logic.
        return address(0); // This should be implemented based on your specific access control mechanism.
    }

    function isERC165Interface(bytes32 interfaceHash) internal pure returns (bool) {
        // ERC165 interface hash constants
        bytes4 constant ERC165_INTERFACE_ID = 0x01ffc9a7;
        return interfaceHash == keccak256(abi.encodePacked(ERC165_INTERFACE_ID));
    }

    function canImplementInterfaceForAddress(address addr, bytes32 interfaceHash) internal view returns (bool) {
        // Placeholder for the actual implementation check logic.
        return true; // This should be implemented based on your specific logic.
    }
}"
1268,"This creates a Pledge with an initial amount of 0 if one is not created already ; otherwise it finds the pledge with the specified attributes ; all pledges technically exist , if the pledge has n't been created in this system yet it simply is n't in the hash array hPledge2idx [ ] yet","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeManager is Ownable {
    using SafeMath for uint256;

    struct Pledge {
        uint256 amount;
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    enum PledgeState { Active, Canceled, Refunded }

    mapping(bytes32 => uint64) public hPledge2idx;
    Pledge[] public pledges;

    function findOrCreatePledge(uint64 owner, uint64[] memory delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint64) {
        bytes32 hPledge = keccak256(abi.encodePacked(owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        uint64 idx = hPledge2idx[hPledge];
        if (idx > 0) return idx;
        idx = uint64(pledges.length);
        hPledge2idx[hPledge] = idx;
        pledges.push(Pledge(0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        return idx;
    }
}","[{'function': 'findOrCreatePledge', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""findOrCreatePledge"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""length"": None}, ""name"": ""delegationChain"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""intendedProject"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""commitTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""oldPledge"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeState""}, ""name"": ""state"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hPledge"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""delegationChain""}, {""type"": ""Identifier"", ""name"": ""intendedProject""}, {""type"": ""Identifier"", ""name"": ""commitTime""}, {""type"": ""Identifier"", ""name"": ""oldPledge""}, {""type"": ""Identifier"", ""name"": ""state""}], ""names"": []}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""hPledge""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""hPledge""}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""idx"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""length""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Pledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""delegationChain""}, {""type"": ""Identifier"", ""name"": ""intendedProject""}, {""type"": ""Identifier"", ""name"": ""commitTime""}, {""type"": ""Identifier"", ""name"": ""oldPledge""}, {""type"": ""Identifier"", ""name"": ""state""}], ""names"": [""owner"", ""delegationChain"", ""intendedProject"", ""commitTime"", ""oldPledge"", ""state""]}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""Identifier"", ""name"": ""hPledge""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""idx""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""idx""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PledgeManager {
    struct Pledge {
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    enum PledgeState { Active, Pending, Closed }

    Pledge[] private pledges;
    mapping(bytes32 => uint) private hPledge2idx;

    function findOrCreatePledge(
        uint64 owner,
        uint64[] memory delegationChain,
        uint64 intendedProject,
        uint64 commitTime,
        uint64 oldPledge,
        PledgeState state
    ) internal returns (uint) {
        bytes32 hPledge = keccak256(abi.encodePacked(owner, delegationChain, intendedProject, commitTime, oldPledge, state));

        if (hPledge2idx[hPledge] != 0) {
            return hPledge2idx[hPledge];
        }

        uint idx = pledges.length;
        pledges.push(Pledge({
            owner: owner,
            delegationChain: delegationChain,
            intendedProject: intendedProject,
            commitTime: commitTime,
            oldPledge: oldPledge,
            state: state
        }));

        hPledge2idx[hPledge] = idx + 1; // Mapping is 1-indexed for simplicity
        return idx + 1;
    }
}",45.986586809158325,findOrCreatePledge,30.0,0.8029747219166142,0.5435363709336313,"[{'function': 'findOrCreatePledge', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PledgeManager is Ownable {
    struct Pledge {
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    enum PledgeState { Active, Pending, Closed }

    Pledge[] private pledges;
    mapping(bytes32 => uint) private hPledge2idx;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function findOrCreatePledge(
        uint64 owner,
        uint64[] memory delegationChain,
        uint64 intendedProject,
        uint64 commitTime,
        uint64 oldPledge,
        PledgeState state
    ) internal returns (uint) {
        bytes32 hPledge = keccak256(abi.encodePacked(owner, delegationChain, intendedProject, commitTime, oldPledge, state));

        if (hPledge2idx[hPledge] != 0) {
            return hPledge2idx[hPledge];
        }

        uint idx = pledges.length;
        pledges.push(Pledge({
            owner: owner,
            delegationChain: delegationChain,
            intendedProject: intendedProject,
            commitTime: commitTime,
            oldPledge: oldPledge,
            state: state
        }));

        hPledge2idx[hPledge] = idx + 1; // Mapping is 1-indexed for simplicity
        return idx + 1;
    }
}"
6042,Returns all the relevant information about a specific library .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LibraryWrapper is Ownable {
    using SafeMath for uint256;

    struct Library {
        string name;
        string language;
        uint256 price;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    function getLibrary(uint256 _tokenId) public view returns (string memory language, string memory libraryName, uint256 tokenPrice, uint256 funds, address tokenOwner, address founder) {
        Library storage x = libraries[_tokenId];
        libraryName = x.name;
        language = x.language;
        founder = libraryIndexToFounder[_tokenId];
        funds = libraryIndexToFunds[_tokenId];
        tokenPrice = libraryIndexToPrice[_tokenId];
        tokenOwner = libraryIndexToOwner[_tokenId];
    }
}","[{'function': 'getLibrary', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLibrary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Library""}, ""name"": ""lib"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lib""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""lib""}, ""memberName"": ""language""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToFounder""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToFunds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraryIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract LibraryContract {
    struct Library {
        string name;
        string language;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    function getLibrary(uint256 _tokenId) public view returns (string memory, string memory, address, uint256, uint256, address) {
        Library storage lib = libraries[_tokenId];
        return (lib.name, lib.language, libraryIndexToFounder[_tokenId], libraryIndexToFunds[_tokenId], libraryIndexToPrice[_tokenId], libraryIndexToOwner[_tokenId]);
    }
}",43.78001093864441,getLibrary,19.0,0.7867760464125362,0.312699687018032,"[{'function': 'getLibrary', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract LibraryContract is Ownable {
    struct Library {
        string name;
        string language;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        libraries[1].name = ""My Library"";
        libraries[2].language = ""English"";
        libraryIndexToFounder[1] = 0x1111111111111111111111111111111111111111; // Replace with actual address
        libraryIndexToFunds[1] = 100;
        libraryIndexToPrice[1] = 10;
        libraryIndexToOwner[1] = msg.sender;

        libraries[2].name = ""My Library 2"";
        libraries[2].language = ""Spanish"";
        libraryIndexToFounder[2] = 0x2222222222222222222222222222222222222222; // Replace with actual address
        libraryIndexToFunds[2] = 200;
        libraryIndexToPrice[2] = 20;
        libraryIndexToOwner[2] = msg.sender;

        libraries[3].name = ""My Library 3"";
        libraries[3].language = ""French"";
        libraryIndexToFounder[3] = 0x3333333333333333333333333333333333333333; // Replace with actual address
        libraryIndexToFunds[3] = 300;
        libraryIndexToPrice[3] = 30;
        libraryIndexToOwner[3] = msg.sender;
    }

    function getLibrary(uint256 _tokenId) public view returns (string memory, string memory, address, uint256, uint256, address) {
        Library storage lib = libraries[_tokenId];
        return (lib.name, lib.language, libraryIndexToFounder[_tokenId], libraryIndexToFunds[_tokenId], libraryIndexToPrice[_tokenId], libraryIndexToOwner[_tokenId]);
    }
}"
1213,Get the token balance for a specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint;

    mapping(address => uint) public balances;

 function balanceOf (address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; }


}","[{'function': 'balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint) public balances;

    function balanceOf(address tokenOwner) external view returns (uint balance) {
        return balances[tokenOwner];
    }
}",41.31889200210571,balanceOf,0.0,0.9802511465487976,0.8282477531331041,"[{'function': 'balanceOf', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    mapping(address => uint) public balances;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    mapping(address => uint256) public balanceOf;

 constructor() {
        balances[msg.sender] = 1000; // Initialize balances to a non-zero value
        balances[DEFAULT_ADDRESS] = 10; // Initialize balances for default address
        balances[DEFAULT_BOOL] = 0; // Initialize balances for default bool
        balances[DEFAULT_BYTES32] = DEFAULT_BYTES32;
        balances[DEFAULT_STRING] = DEFAULT_STRING;
    }

    function balanceOf(address tokenOwner) external view returns (uint balance) {
        return balances[tokenOwner];
    }
}
```

However, the contract `Token` does not inherit from any parent contracts. Therefore, there is no need to invoke their mapping(address => uint256) public balanceOf;

 constructors.

If we were to add an inheritance clause and use a parent contract like `Ownable`, it would look something like this:

```solidity
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint) public balances;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000; // Initialize balances to a non-zero value
        balances[DEFAULT_ADDRESS] = 10; // Initialize balances for default address
        balances[DEFAULT_BOOL] = 0; // Initialize balances for default bool
        balances[DEFAULT_BYTES32] = DEFAULT_BYTES32;
        balances[DEFAULT_STRING] = DEFAULT_STRING;
    }

    function balanceOf(address tokenOwner) external view returns (uint balance) {
        return balances[tokenOwner];
    }
}"
6726,transfers tokens in ERC20 compatible way using signature to recover token sender,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    function transferWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig) public returns (bool) {
        doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
        return true;
    }

    function doSendWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig, bool) internal {
        // Implementation of the original function logic would go here.
    }
}","[{'function': 'transferWithSignature', 'complexity': 0}, {'function': 'doSendWithSignature', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferWithSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_sig"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_fee""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount or fee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_nonce""}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonces""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": False}}, {""type"": ""stringLiteral"", ""value"": ""Nonce already used""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""message"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_fee""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""recoverSigner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""message""}, {""type"": ""Identifier"", ""name"": ""_sig""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Signature verification failed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_fee""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public nonces;

    event Transfer(address indexed from, address indexed to, uint256 amount);

    function transferWithSignature(
        address _to,
        uint256 _amount,
        uint256 _fee,
        bytes memory _data,
        uint256 _nonce,
        bytes memory _sig
    ) public returns (bool) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0 && _fee >= 0, ""Invalid amount or fee"");
        require(_nonce == nonces[msg.sender]++, ""Nonce already used"");

        bytes32 message = keccak256(abi.encodePacked(this, msg.sender, _to, _amount, _fee, _nonce));
        require(recoverSigner(message, _sig) == msg.sender, ""Signature verification failed"");

        uint256 totalAmount = _amount + _fee;
        balances[msg.sender] -= totalAmount;
        balances[_to] += _amount;

        emit Transfer(msg.sender, _to, _amount);

        return true;
    }

    function doSendWithSignature(
        address _to,
        uint256 _amount,
        uint256 _fee,
        bytes memory _data,
        uint256 _nonce,
        bool isInternal
    ) internal returns (bool) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0 && _fee >= 0, ""Invalid amount or fee"");
        require(_nonce == nonces[msg.sender]++, ""Nonce already used"");

        uint256 totalAmount = _amount + _fee;
        balances[msg.sender] -= totalAmount;
        balances[_to] += _amount;

        emit Transfer(msg.sender, _to, _amount);

        return true;
    }

    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {
        require(sig.length == 65, ""Invalid signature length"");

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }

        return ecrecover(message, v, r, s);
    }
}",48.93261480331421,transferWithSignature,75.0,0.3686136859381695,0.2859697107540586,"[{'function': 'transferWithSignature', 'complexity': 0}, {'function': 'doSendWithSignature', 'complexity': 0}, {'function': 'recoverSigner', 'complexity': 1}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public nonces;

    event Transfer(address indexed from, address indexed to, uint256 amount);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set balance of owner to 1 (never 0)
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            balances[addr] = 1; // Initialize balances for addresses 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        }
    }

    function transferWithSignature(
        address _to,
        uint256 _amount,
        uint256 _fee,
        bytes memory _data,
        uint256 _nonce,
        bytes memory _sig
    ) public returns (bool) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0 && _fee >= 0, ""Invalid amount or fee"");
        require(_nonce == nonces[msg.sender]++, ""Nonce already used"");

        bytes32 message = keccak256(abi.encodePacked(this, msg.sender, _to, _amount, _fee, _nonce));
        require(recoverSigner(message, _sig) == msg.sender, ""Signature verification failed"");

        uint256 totalAmount = _amount + _fee;
        balances[msg.sender] -= totalAmount;
        balances[_to] += _amount;

        emit Transfer(msg.sender, _to, _amount);

        return true;
    }

    function doSendWithSignature(
        address _to,
        uint256 _amount,
        uint256 _fee,
        bytes memory _data,
        uint256 _nonce,
        bool isInternal
    ) internal returns (bool) {
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0 && _fee >= 0, ""Invalid amount or fee"");
        require(_nonce == nonces[msg.sender]++, ""Nonce already used"");

        uint256 totalAmount = _amount + _fee;
        balances[msg.sender] -= totalAmount;
        balances[_to] += _amount;

        emit Transfer(msg.sender, _to, _amount);

        return true;
    }

    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {
        require(sig.length == 65, ""Invalid signature length"");

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }

        return ecrecover(message, v, r, s);
    }
}"
6123,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract TokenRecipient is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        if (!approve(_spender, _amount)) throw;
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_extraData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApproveAndCallFallBack""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}, ""memberName"": ""receiveApproval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_extraData""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

contract Token {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approval failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function approve(address spender, uint256 amount) internal returns (bool success) {
        allowed[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);
}",44.50286817550659,approveAndCall,4.0,0.9288767289886288,0.7964931860643588,"[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'approve', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance to 1 for the owner
        // Initialize other mappings and state variables if needed
    }

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approval failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function approve(address spender, uint256 amount) internal returns (bool success) {
        allowed[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);
}"
240,Used to check if an address is a delegate or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function checkDelegate(address _potentialDelegate) external view returns (bool) {
        // Implementation of the checkDelegate function
    }
}","[{'function': 'checkDelegate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isDelegate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_potentialDelegate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_potentialDelegate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DelegateLog""}, ""name"": ""delegateLog"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""delegates""}, ""index"": {""type"": ""Identifier"", ""name"": ""_potentialDelegate""}}}, {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""delegateLog""}, ""memberName"": ""started""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""delegateLog""}, ""memberName"": ""ended""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract DelegateVerifier {
    mapping(address => DelegateLog) public delegates;

    struct DelegateLog {
        uint256 started;
        uint256 ended;
    }

    function isDelegate(address _potentialDelegate) external view returns (bool) {
        require(_potentialDelegate != address(0), ""Invalid address"");
        DelegateLog memory delegateLog = delegates[_potentialDelegate];
        return delegateLog.started != 0 && delegateLog.ended == 0;
    }
}",42.34962606430054,isDelegate,32.0,0.5351595051147322,0.255588601949307,"[{'function': 'isDelegate', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DelegateVerifier is Ownable {
    mapping(address => DelegateLog) public delegates;

    struct DelegateLog {
        uint256 started;
        uint256 ended;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            delegates[addr] = DelegateLog({started: 1, ended: 0});
        }
    }

    function isDelegate(address _potentialDelegate) external view returns (bool) {
        require(_potentialDelegate != address(0), ""Invalid address"");
        DelegateLog memory delegateLog = delegates[_potentialDelegate];
        return delegateLog.started != 0 && delegateLog.ended == 0;
    }
}"
3785,Clear collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract PixelConContract is Ownable {
    using SafeMath for uint256;

    struct PixelCon {
        uint256 tokenId;
        uint64 collectionIndex;
    }

    uint256 public totalCollections;
    mapping(uint256 => uint64[]) public collectionTokens;
    mapping(uint256 => string) public collectionNames;
    mapping(uint64 => PixelCon) public pixelcons;

    event ClearCollection(uint256 indexed _collectionIndex);

    modifier validIndex(uint256 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function clearCollection(uint256 _collectionIndex) public validIndex(_collectionIndex) returns (uint64) {
        uint64[] storage collection = collectionTokens[_collectionIndex];
        require(collection.length > 0, ""Collection is already cleared"");
        for (uint i = 0; i < collection.length; i++) {
            PixelCon storage pixelcon = pixelcons[collection[i]];
            require(isCreatorAndOwner(msg.sender, pixelcon.tokenId), ""Sender is not the creator and owner of the PixelCons"");
            pixelcon.collectionIndex = 0;
        }
        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];
        emit ClearCollection(_collectionIndex);
        return _collectionIndex;
    }

    function totalCollections() public view returns (uint256) {
        return totalCollections;
    }
}","[{'function': 'clearCollection', 'complexity': 3}, {'function': 'totalCollections', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""clearCollection"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectionNames""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid collection index""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""tokensInCollection"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionTokens""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}, ""right"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PixelCon""}, ""name"": ""pixelCon"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pixelcons""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""collectionIndex""}, ""right"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, {""type"": ""stringLiteral"", ""value"": ""PixelCon not in this collection""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""creator""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""owner""}}}, {""type"": ""stringLiteral"", ""value"": ""Not the creator or owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pixelCon""}, ""memberName"": ""collectionIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokensInCollection""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionNames""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectionTokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""isPrefix"": True}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClearCollection""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_collectionIndex""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PixelCons {
    struct PixelCon {
        uint256 collectionIndex;
        address creator;
        address owner;
    }

    mapping(uint256 => PixelCon) public pixelcons;
    uint256[] public collectionTokens;
    string[] public collectionNames;

    event ClearCollection(uint256 indexed _collectionIndex);

    modifier onlyOwnerOrCreator(uint256 tokenId) {
        require(msg.sender == pixelcons[tokenId].creator || msg.sender == pixelcons[tokenId].owner, ""Not the creator or owner"");
        _;
    }

    function clearCollection(uint256 _collectionIndex) external {
        require(_collectionIndex < collectionNames.length, ""Invalid collection index"");

        uint256[] memory tokensInCollection = new uint256[](0);
        for (uint256 i = 0; i < collectionTokens[_collectionIndex]; i++) {
            uint256 tokenId = collectionTokens[_collectionIndex + i];
            PixelCon storage pixelCon = pixelcons[tokenId];
            require(pixelCon.collectionIndex == _collectionIndex, ""PixelCon not in this collection"");
            require(msg.sender == pixelCon.creator || msg.sender == pixelCon.owner, ""Not the creator or owner"");

            pixelCon.collectionIndex = 0;
            tokensInCollection.push(tokenId);
        }

        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];

        emit ClearCollection(_collectionIndex);
    }
}",45.80480074882507,clearCollection,53.0,0.8619430729688464,0.2660152481127676,"[{'function': 'clearCollection', 'complexity': 5}]",6.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PixelCons is Ownable {
    struct PixelCon {
        uint256 collectionIndex;
        address creator;
        address owner;
    }

    mapping(uint256 => PixelCon) public pixelcons;
    uint256[] public collectionTokens;
    string[] public collectionNames;

    event ClearCollection(uint256 indexed _collectionIndex);

    modifier onlyOwnerOrCreator(uint256 tokenId) {
        require(msg.sender == pixelcons[tokenId].creator || msg.sender == pixelcons[tokenId].owner, ""Not the creator or owner"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint256 i = 0; i < collectionTokens.length; i++) {
            pixelcons[i].collectionIndex = 1;
            pixelcons[i].creator = address(uint160(i + 1));
            pixelcons[i].owner = address(uint160(i + 2));
        }
    }

    function clearCollection(uint256 _collectionIndex) external {
        require(_collectionIndex < collectionNames.length, ""Invalid collection index"");

        uint256[] memory tokensInCollection = new uint256[](0);
        for (uint256 i = 0; i < collectionTokens[_collectionIndex]; i++) {
            uint256 tokenId = collectionTokens[_collectionIndex + i];
            PixelCon storage pixelCon = pixelcons[tokenId];
            require(pixelCon.collectionIndex == _collectionIndex, ""PixelCon not in this collection"");
            require(msg.sender == pixelCon.creator || msg.sender == pixelCon.owner, ""Not the creator or owner"");

            pixelCon.collectionIndex = 0;
            tokensInCollection.push(tokenId);
        }

        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];

        emit ClearCollection(_collectionIndex);
    }
}"
3163,` proxyPayment ( ) ` allows the caller to send ether to the Campaign but does not create tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyPayment is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable returns (bool) {
        doTakerPayment();
        return true;
    }

    function doTakerPayment() internal virtual;
}","[{'function': 'proxyPayment', 'complexity': 0}]",2.0,{},"pragma solidity ^0.8.0;

contract PaymentProxy {
    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function proxyPayment(address payable _owner) public payable returns (bool) {
        require(msg.value > 0, ""Payment amount must be greater than zero"");
        doTakerPayment(_owner);
        return true;
    }

    function doTakerPayment(address payable _taker) internal {
        // Internal logic for handling payment to the taker
        (bool success, ) = _taker.call{value: msg.value}("""");
        require(success, ""Payment failed"");
    }
}",43.27771949768066,proxyPayment,12.0,0.8029942272540977,0.3842648296431239,"[{'function': 'proxyPayment', 'complexity': 1}, {'function': 'doTakerPayment', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentProxy is Ownable {
    address private owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is handled by the parent contract's constructor
    }

    function proxyPayment(address payable _owner) public payable returns (bool) {
        require(msg.value > 0, ""Payment amount must be greater than zero"");
        doTakerPayment(_owner);
        return true;
    }

    function doTakerPayment(address payable _taker) internal {
        // Internal logic for handling payment to the taker
        (bool success, ) = _taker.call{value: msg.value}("""");
        require(success, ""Payment failed"");
    }
}"
4854,A constant getter that returns the total number of pledges,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledges {
    using SafeMath for uint256;

    mapping(uint => address) public pledges;

    function numberOfPledges() public view returns (uint) {
        return pledges.length.sub(1);
    }
}","[{'function': 'numberOfPledges', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""numberOfPledges"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract PledgeContract {
    address[] public pledges;

    function numberOfPledges() external view returns (uint) {
        return pledges.length - 1;
    }
}",41.47976279258728,numberOfPledges,2.0,0.8295990672370878,0.4786471554577889,"[{'function': 'numberOfPledges', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PledgeContract is Ownable {
    address[] public pledges;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        pledges = [address(0x111), address(0x222), address(0x333)];
    }

    function numberOfPledges() external view returns (uint) {
        return pledges.length - 1;
    }
}"
6206,Returns owner of a given Asset ( Token ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public assetIndexToOwner;

    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        return assetIndexToOwner[_tokenId];
    }
}","[{'function': 'ownerOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assetIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TokenOwnership {
    mapping(uint256 => address) public assetIndexToOwner;

    function getTokenOwner(uint256 _tokenId) external view returns (address) {
        return assetIndexToOwner[_tokenId];
    }
}",41.641207218170166,getTokenOwner,0.0,0.9294062347664394,0.5141708532663253,"[{'function': 'getTokenOwner', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenOwnership is Ownable {
    mapping(uint256 => address) public assetIndexToOwner;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTokenOwner(uint256 _tokenId) external view returns (address) {
        return assetIndexToOwner[_tokenId];
    }
}"
780,Checks if two strings are equal or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EqualsWrapper {
    using SafeMath for uint256;

    function equals(string memory a, string memory b) internal pure returns (bool result) {
    if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
        return true;
    }
    return false;
}
}","[{'function': 'equals', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""equals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""a"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""b"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""a""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract StringComparer {
    function equals(string memory a, string memory b) public pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}",42.04556274414063,equals,2.0,0.8709073185657441,0.6228856406332864,"[{'function': 'equals', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract StringComparer is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function equals(string memory a, string memory b) public pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}"
6276,"The fallback function : If the contract 's controller has not been set to 0 , the ether is sent to the controller ( normally the token creation contract ) using the ` proxyPayment ` method .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function proxyPayment() external payable returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    address public controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    receive() external payable {
        if (controller == address(0)) revert();
        if (isContract(controller)) {
            TokenController tokenController = TokenController(controller);
            require(tokenController.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        } else {
            require(controller.send(msg.value), ""Send value failed"");
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}]",1.0,{},"pragma solidity ^0.8.0;

contract FallbackHandler {
    address public controller;

    function setController(address _controller) external {
        require(_controller != address(0), ""Controller cannot be zero address"");
        controller = _controller;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

    fallback() external payable {
        require(controller != address(0), ""Controller not set"");

        if (isContract(controller)) {
            TokenController controllerContract = TokenController(controller);
            require(controllerContract.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        } else {
            (bool success, ) = controller.call{value: msg.value}("""");
            require(success, ""Direct transfer failed"");
        }
    }
}

interface TokenController {
    function proxyPayment(address user) external payable returns (bool);
}",44.10056877136231,isContract,0.0,1.0,1.0,"[{'function': 'setController', 'complexity': 1}, {'function': 'isContract', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract FallbackHandler is Ownable {
    address public controller;
    uint256 public constant DEFAULT_CONTROLLER = 1;
    bool public initialized = true;
    bytes32 public constant INITIALIZED = bytes32('init');

    constructor() Ownable(msg.sender) {
        require(initialized == false, ""Contract already initialized"");
        initialized = true;

        controller = DEFAULT_CONTROLLER;
    }

    function setController(address _controller) external {
        require(_controller != address(0), ""Controller cannot be zero address"");
        controller = _controller;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

    fallback() external payable {
        require(controller != address(0), ""Controller not set"");

        if (isContract(controller)) {
            TokenController controllerContract = TokenController(controller);
            require(controllerContract.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        } else {
            (bool success, ) = controller.call{value: msg.value}("""");
            require(success, ""Direct transfer failed"");
        }
    }
}

interface TokenController {
    function proxyPayment(address user) external payable returns (bool);
}"
321,Function used by the main partner to set the start time of the funding,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function setFundingStartTime(uint _startTime) external onlyOwner {
        // Assuming startTime is stored in a state variable named fundingStartTime
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        fundingStartTime = _startTime;
    }

    uint256 public fundingStartTime;
}","[{'function': 'setFundingStartTime', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setFundingStartTime"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_startTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Start time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""fundingStartTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract FundingContract {
    uint public fundingStartTime;

    function setFundingStartTime(uint _startTime) external {
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        fundingStartTime = _startTime;
    }
}",41.70100283622742,setFundingStartTime,1.0,0.9357167550121542,0.581587495341291,"[{'function': 'setFundingStartTime', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FundingContract is Ownable {
    uint public fundingStartTime = 1; // Set to 1 instead of 0

    constructor() Ownable(msg.sender) {
        // No need to initialize bytes32 or string as they are already initialized in the state variables
    }

    function setFundingStartTime(uint _startTime) external {
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        fundingStartTime = _startTime;
    }
}"
2712,Only owner is allowed to perform this operation .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function burn(uint256 _value) external;
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;
    uint256 public tokenTotalSupply;

    event Burn(address indexed from, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function burn(uint256 _value) onlyOwner external {
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        tokenTotalSupply = tokenTotalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0x0), _value);
    }
}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Burn amount exceeds balance.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Burn""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    event Burn(uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function burn(uint256 _amount) public onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero."");
        require(_amount <= balances[msg.sender], ""Burn amount exceeds balance."");

        totalSupply_ -= _amount;
        balances[msg.sender] -= _amount;

        emit Burn(_amount);
        emit Transfer(msg.sender, address(0), _amount);
    }
}",44.05095434188843,burn,20.0,0.7939190580259287,0.2649728540744618,"[{'function': 'burn', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    event Burn(uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        _;
    }

    uint256 public totalSupply;

 constructor() Ownable(""0x1111111111111111111111111111111111111111"") {
        balances[owner()] = 1;
        totalSupply_ = 1;
    }

    function burn(uint256 _amount) public onlyOwner {
        require(_amount > 0, ""Amount must be greater than zero."");
        require(_amount <= balances[msg.sender], ""Burn amount exceeds balance."");

        totalSupply_ -= _amount;
        balances[msg.sender] -= _amount;

        emit Burn(_amount);
        emit Transfer(msg.sender, address(0), _amount);
    }
}"
3285,Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC1155Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private _operatorApprovals;

    event ApprovalForAll(address indexed operator, address indexed owner, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != address(0), ""ERC1155: setting approval status for the zero address"");
        require(msg.sender == _operator || isApprovedForAll(msg.sender, _operator), ""ERC1155: must be approved to set approval for all"");

        _operatorApprovals[_operator] = _approved;
        emit ApprovalForAll(_operator, msg.sender, _approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[operator];
    }
}","[{'function': 'setApprovalForAll', 'complexity': 3}, {'function': 'isApprovedForAll', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_operator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Self-approval is not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operatorApprovals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_approved""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""Identifier"", ""name"": ""_approved""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AssetControl {
    mapping(address => mapping(address => bool)) public operatorApprovals;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != msg.sender, ""Self-approval is not allowed"");
        operatorApprovals[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}",42.6055543422699,setApprovalForAll,20.0,0.8160389469401881,0.274718263590543,"[{'function': 'setApprovalForAll', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetControl is Ownable {
    mapping(address => mapping(address => bool)) public operatorApprovals;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != msg.sender, ""Self-approval is not allowed"");
        operatorApprovals[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}"
382,"Rent out an area of blocks at coordinates [ fromX , fromY , toX , toY ] at a price for each block in wei","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract RentalArea is Ownable {
    using SafeMath for uint256;

    struct Rental {
        address renter;
        uint rentPricePerPeriodWei;
        uint[] rentedBlocks;
    }

    mapping(uint => Rental) public rentals;
    uint public rentalCount;

    event LogRentsOut(uint id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei);

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (bool) {
        // Implement the logic to check if coordinates are legal
        return true;
    }

    function blocksList(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (uint[] memory) {
        // Implement the logic to generate a list of block IDs based on coordinates
        uint length = (toX - fromX + 1) * (toY - fromY + 1);
        uint[] memory blocks = new uint[](length);
        for (uint i = 0; i < length; i++) {
            blocks[i] = i;
        }
        return blocks;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY));
        uint id = rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, blocksList(fromX, fromY, toX, toY));
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }
}","[{'function': 'isLegalCoordinates', 'complexity': 0}, {'function': 'blocksList', 'complexity': 1}, {'function': 'rentOutArea', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""rentOutArea"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""fromX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""fromY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""toX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""toY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""rentPricePerPeriodWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isLegalCoordinates""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fromX""}, {""type"": ""Identifier"", ""name"": ""fromY""}, {""type"": ""Identifier"", ""name"": ""toX""}, {""type"": ""Identifier"", ""name"": ""toY""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid coordinates.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""fromX""}, {""type"": ""Identifier"", ""name"": ""fromY""}, {""type"": ""Identifier"", ""name"": ""toX""}, {""type"": ""Identifier"", ""name"": ""toY""}, {""type"": ""Identifier"", ""name"": ""rentPricePerPeriodWei""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rentals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""rentPricePerPeriodWei""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LogRentsOut""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""Identifier"", ""name"": ""fromX""}, {""type"": ""Identifier"", ""name"": ""fromY""}, {""type"": ""Identifier"", ""name"": ""toX""}, {""type"": ""Identifier"", ""name"": ""toY""}, {""type"": ""Identifier"", ""name"": ""rentPricePerPeriodWei""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract RentalSystem {
    address public owner;
    bool public paused;
    mapping(address => uint256) public rentals;

    event LogRentsOut(uint id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY), ""Invalid coordinates."");

        // Generate a unique identifier for the rental transaction
        uint id = uint(keccak256(abi.encodePacked(msg.sender, fromX, fromY, toX, toY, rentPricePerPeriodWei)));

        // Call rentals.rentOutBlocks with sender's address, rental price, and list of blocks derived from coordinates
        rentals[msg.sender] = rentPricePerPeriodWei;
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (bool) {
        // Implement your logic to validate coordinates here
        return true; // Placeholder for actual validation logic
    }

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        paused = false;
    }
}",46.9140248298645,rentOutArea,49.0,0.6505184565254558,0.1465956005125457,"[{'function': 'rentOutArea', 'complexity': 1}, {'function': 'isLegalCoordinates', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RentalSystem is Ownable {
    address public owner = msg.sender;
    bool public paused = false;
    mapping(address => uint256) public rentals;

    event LogRentsOut(uint id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused."");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY), ""Invalid coordinates."");

        // Generate a unique identifier for the rental transaction
        uint id = uint(keccak256(abi.encodePacked(msg.sender, fromX, fromY, toX, toY, rentPricePerPeriodWei)));

        // Call rentals.rentOutBlocks with sender's address, rental price, and list of blocks derived from coordinates
        rentals[msg.sender] = rentPricePerPeriodWei;
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (bool) {
        // Implement your logic to validate coordinates here
        return true; // Placeholder for actual validation logic
    }

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        paused = false;
    }
}"
1424,Allows the owner to revoke the vesting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Basic {
    function balanceOf(address account) external view returns (uint256);
    function safeTransfer(address to, uint256 value) external;
}

abstract contract RevocableToken is Ownable {
    using SafeMath for uint256;

    bool public revocable;
    mapping(ERC20Basic => bool) public revoked;

    event Revoked();

    function revoke(ERC20Basic _token) public onlyOwner {
        require(revocable, ""Revoke: Contract is not revocable"");
        require(!revoked[_token], ""Revoke: Token already revoked"");
        uint256 balance = _token.balanceOf(address(this));
        uint256 unreleased = releasableAmount(_token);
        uint256 refund = balance.sub(unreleased);
        revoked[_token] = true;
        _token.safeTransfer(owner(), refund);
        emit Revoked();
    }

    function releasableAmount(ERC20Basic token) internal view returns (uint256) {
        // Implement your logic to calculate the releasable amount here
        return 0; // Placeholder, replace with actual implementation
    }
}","[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'revoke', 'complexity': 3}, {'function': 'releasableAmount', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""revoke"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20Basic""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""revoked""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Token already revoked""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""releasableAmount_"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""releasableAmount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refundableAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""releasableAmount_""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""refundableAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""safeTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""refundableAmount""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""revoked""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Revoked""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20Basic.sol"";
import ""@openzeppelin/contracts/utils/SafeERC20.sol"";

contract RevocableToken {
    using SafeERC20 for IERC20Basic;

    mapping(IERC20Basic => bool) public revoked;

    address public owner;

    event Revoked(address indexed token);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Caller is not the owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function revoke(IERC20Basic _token) external onlyOwner {
        require(!revoked[_token], ""Token already revoked"");

        uint256 balance = _token.balanceOf(address(this));
        uint256 releasableAmount_ = releasableAmount(_token);
        uint256 refundableAmount = balance - releasableAmount_;

        if (refundableAmount > 0) {
            _token.safeTransfer(owner, refundableAmount);
        }

        revoked[_token] = true;
        emit Revoked(address(_token));
    }

    function releasableAmount(IERC20Basic _token) internal view returns (uint256) {
        // Implement your logic to calculate the releasable amount here.
        // This is a placeholder for the actual implementation of 'releasableAmount'.
        return 0;
    }
}",45.56497716903687,revoke,18.0,0.9201155066654932,0.4274572692544704,"[{'function': 'revoke', 'complexity': 3}, {'function': 'releasableAmount', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20Basic.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RevocableToken is Ownable {
    using SafeERC20 for IERC20Basic;

    mapping(IERC20Basic => bool) public revoked;

    event Revoked(address indexed token);

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables with fixed, safe, non-corner-case values
        owner = msg.sender;
    }

    function revoke(IERC20Basic _token) external onlyOwner {
        require(!revoked[_token], ""Token already revoked"");

        uint256 balance = _token.balanceOf(address(this));
        uint256 releasableAmount_ = releasableAmount(_token);
        uint256 refundableAmount = balance - releasableAmount_;

        if (refundableAmount > 0) {
            _token.safeTransfer(owner, refundableAmount);
        }

        revoked[_token] = true;
        emit Revoked(address(_token));
    }

    function releasableAmount(IERC20Basic _token) internal view returns (uint256) {
        // Implement your logic to calculate the releasable amount here.
        // This is a placeholder for the actual implementation of 'releasableAmount'.
        return 0;
    }
}"
4864,Function to send multiple token transfers in one tx,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Multisender is Ownable {
    using SafeMath for uint256;

    uint256 public constant multiSendLimit = 100; // Example limit, adjust as needed

    function multisend(address[] memory _recipients, uint256[] memory _balances) public onlyOwner {
        require(_recipients.length == _balances.length, ""not equal length"");
        require(_recipients.length <= multiSendLimit, ""more than limit"");

        for (uint256 i = 0; i < _balances.length; i++) {
            require(address(this).balance >= _balances[i], ""insufficient balance"");
            payable(_recipients[i]).transfer(_balances[i]);
        }
    }
}","[{'function': 'multisend', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""multisend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_balances"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""The length of the recipients and balances arrays must be equal""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""Identifier"", ""name"": ""multiSendLimit""}}, {""type"": ""stringLiteral"", ""value"": ""The number of recipients exceeds the limit""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Multisended""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recipients""}, {""type"": ""Identifier"", ""name"": ""_balances""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MultiSend {
    uint256 public multiSendLimit = 10; // Predefined limit for the number of recipients

    event Multisended(address[] recipients, uint256[] balances);

    function multisend(address[] memory _recipients, uint256[] memory _balances) public {
        require(_recipients.length == _balances.length, ""The length of the recipients and balances arrays must be equal"");
        require(_recipients.length <= multiSendLimit, ""The number of recipients exceeds the limit"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            payable(_recipients[i]).transfer(_balances[i]);
        }

        emit Multisended(_recipients, _balances);
    }
}",43.486390113830566,multisend,18.0,0.912974749445062,0.557848224955677,"[{'function': 'multisend', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MultiSend is Ownable {
    uint256 public multiSendLimit = 10; // Predefined limit for the number of recipients

    event Multisended(address[] recipients, uint256[] balances);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        multiSendLimit = 10;
    }

    function multisend(address[] memory _recipients, uint256[] memory _balances) public {
        require(_recipients.length == _balances.length, ""The length of the recipients and balances arrays must be equal"");
        require(_recipients.length <= multiSendLimit, ""The number of recipients exceeds the limit"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            payable(_recipients[i]).transfer(_balances[i]);
        }

        emit Multisended(_recipients, _balances);
    }
}"
5466,The user sends Ether to the pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function() public payable {
        deposit(msg.sender);
    }

    function deposit(address user) internal {
        // Your logic here
    }
}","[{'function': '', 'complexity': 0}, {'function': 'deposit', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No Ether sent""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Deposit""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract DepositContract {
    event Deposit(address indexed sender, uint256 value);

    function () external payable {
        deposit();
    }

    function deposit() internal {
        require(msg.value > 0, ""No Ether sent"");
        emit Deposit(msg.sender, msg.value);
    }
}",41.82067251205444,deposit,10.0,0.6455956063125601,0.0610983374073894,"[{'function': '', 'complexity': 0}, {'function': 'deposit', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DepositContract is Ownable {
    event Deposit(address indexed sender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function () external payable {
        deposit();
    }

    function deposit() internal {
        require(msg.value > 0, ""No Ether sent"");
        emit Deposit(msg.sender, msg.value);
    }
}"
906,Create group Can be called only by contract owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GroupManager is Ownable {
    using SafeMath for uint256;

    event GroupCreated(bytes32 indexed groupName);

    struct Group {
        bytes32 name;
        uint priority;
        uint index;
    }

    mapping(bytes32 => uint) public groupName2index;
    mapping(uint => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;
    uint public groupsCount;

    function createGroup(bytes32 _groupName, uint _priority) external onlyOwner returns (uint) {
        require(_groupName != bytes32(0));
        if (isGroupExists(_groupName)) {
            return _emitError(USER_MANAGER_GROUP_ALREADY_EXIST);
        }
        uint _groupsCount = groupsCount.add(1);
        groupName2index[_groupName] = _groupsCount;
        index2groupName[_groupsCount] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, _groupsCount);
        groupsCount = _groupsCount;
        emit GroupCreated(_groupName);
        return OK;
    }

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }

    function _emitError(uint _errorCode) internal pure returns (uint) {
        revert(""Error: ""); // This should be replaced with the actual error handling logic.
    }
}","[{'function': 'createGroup', 'complexity': 2}, {'function': 'isGroupExists', 'complexity': 0}, {'function': '_emitError', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createGroup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_groupName"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_priority"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_groupName""}, ""right"": {""type"": ""stringLiteral"", ""value"": """"}}, {""type"": ""stringLiteral"", ""value"": ""Group name cannot be empty""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isGroupExists""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""RevertStatement"", ""functionCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UserManagerGroupAlreadyExist""}, ""arguments"": [], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""groupsCount""}, ""isPrefix"": False}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""newGroupId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""groupsCount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""groupName2index""}, ""index"": {""type"": ""Identifier"", ""name"": ""_groupName""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newGroupId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""index2groupName""}, ""index"": {""type"": ""Identifier"", ""name"": ""newGroupId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_groupName""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""groupName2group""}, ""index"": {""type"": ""Identifier"", ""name"": ""_groupName""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Group""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}, {""type"": ""Identifier"", ""name"": ""_priority""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""GroupCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_groupName""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract GroupManager {
    uint public groupsCount;
    mapping(bytes32 => uint) public groupName2index;
    mapping(uint => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;
    error UserManagerGroupAlreadyExist();

    struct Group {
        bytes32 name;
        uint priority;
        uint memberCount;
    }

    event GroupCreated(bytes32 indexed groupName);

    function createGroup(bytes32 _groupName, uint _priority) public {
        require(_groupName != """", ""Group name cannot be empty"");
        if (isGroupExists(_groupName)) {
            revert UserManagerGroupAlreadyExist();
        }

        groupsCount++;
        uint newGroupId = groupsCount;
        groupName2index[_groupName] = newGroupId;
        index2groupName[newGroupId] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, 0);

        emit GroupCreated(_groupName);
    }

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }
}",45.12946557998657,createGroup,20.0,0.8537681923694853,0.4617013697900212,"[{'function': 'createGroup', 'complexity': 2}, {'function': 'isGroupExists', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GroupManager is Ownable {
    uint public groupsCount = 1;
    mapping(bytes32 => uint) public groupName2index;
    mapping(uint => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;
    error UserManagerGroupAlreadyExist();

    struct Group {
        bytes32 name;
        uint priority;
        uint memberCount;
    }

    event GroupCreated(bytes32 indexed groupName);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        groupsCount = 1;
        for (uint i = 0; i < 3; i++) {
            if (i == 0) groupName2index[bytes32('Group1')] = 1;
            else if (i == 1) groupName2index[bytes32('Group2')] = 2;
            else if (i == 2) groupName2index[bytes32('Group3')] = 3;
        }
        index2groupName[1] = bytes32('Group1');
        index2groupName[2] = bytes32('Group2');
        index2groupName[3] = bytes32('Group3');
        groupName2group[bytes32('Group1')] = Group(bytes32('Group1'), 1, 0);
        groupName2group[bytes32('Group2')] = Group(bytes32('Group2'), 2, 0);
        groupName2group[bytes32('Group3')] = Group(bytes32('Group3'), 3, 0);
    }

    function createGroup(bytes32 _groupName, uint _priority) public {
        require(_groupName != """", ""Group name cannot be empty"");
        if (isGroupExists(_groupName)) {
            revert UserManagerGroupAlreadyExist();
        }

        groupsCount++;
        uint newGroupId = groupsCount;
        groupName2index[_groupName] = newGroupId;
        index2groupName[newGroupId] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, 0);

        emit GroupCreated(_groupName);
    }

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }
}"
1722,Allow users to buy tokens for ` newTokenSaleHardCap ` XCR,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale {
    using SafeMath for uint256;

    uint256 public tokenSaleHardCap;
    address private authorizedAddress;

    constructor(uint256 initialTokenSaleHardCap) {
        tokenSaleHardCap = initialTokenSaleHardCap;
        authorizedAddress = msg.sender;
    }

    modifier onlyAuthorized() {
        require(msg.sender == authorizedAddress, ""Only authorized address can call this function"");
        _;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }
}","[{'function': 'setTokenSaleHardCap', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAuthorizedAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can authorize addresses.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenSale {
    uint256 public tokenSaleHardCap;
    mapping(address => bool) private authorizedAddresses;

    modifier onlyAuthorized() {
        require(authorizedAddresses[msg.sender] || msg.sender == owner(), ""Function can only be called by authorized users or the contract owner."");
        _;
    }

    constructor(uint256 initialHardCap) {
        tokenSaleHardCap = initialHardCap;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }

    function addAuthorizedAddress(address addr) public {
        require(msg.sender == owner(), ""Only the contract owner can authorize addresses."");
        authorizedAddresses[addr] = true;
    }

    function removeAuthorizedAddress(address addr) public {
        require(msg.sender == owner(), ""Only the contract owner can deauthorize addresses."");
        authorizedAddresses[addr] = false;
    }

    function isAuthorized(address addr) public view returns (bool) {
        return authorizedAddresses[addr];
    }

    // Owner function to add new hard cap
    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }
}",45.83715462684631,addAuthorizedAddress,12.0,0.4320165573743262,0.0187198008699162,"[{'function': 'setTokenSaleHardCap', 'complexity': 0}, {'function': 'addAuthorizedAddress', 'complexity': 1}, {'function': 'removeAuthorizedAddress', 'complexity': 1}, {'function': 'isAuthorized', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    uint256 public tokenSaleHardCap = 1;
    mapping(address => bool) private authorizedAddresses;

    modifier onlyAuthorized() {
        require(authorizedAddresses[msg.sender] || msg.sender == owner(), ""Function can only be called by authorized users or the contract owner."");
        _;
    }

    constructor(uint256 initialHardCap) Ownable(address(0x111)) {
        tokenSaleHardCap = initialHardCap;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }

    function addAuthorizedAddress(address addr) public {
        require(msg.sender == owner(), ""Only the contract owner can authorize addresses."");
        authorizedAddresses[addr] = true;
    }

    function removeAuthorizedAddress(address addr) public {
        require(msg.sender == owner(), ""Only the contract owner can deauthorize addresses."");
        authorizedAddresses[addr] = false;
    }

    function isAuthorized(address addr) public view returns (bool) {
        return authorizedAddresses[addr];
    }
}"
3988,Pause sale just in case we have some troubles Note that time marks are not updated,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    enum CampaignState { Initial, Active, Paused }
    CampaignState public campaignState;
    bool public paused;

    event CampaignPaused(uint timestamp);

    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only controller can call this function"");
        _;
    }

    constructor() {
        campaignState = CampaignState.Active;
        paused = false;
        controller = msg.sender;
    }

    function pauseSale() public onlyController {
        require(campaignState == CampaignState.Active, ""Campaign must be active to pause"");
        paused = true;
        campaignState = CampaignState.Paused;
        emit CampaignPaused(block.timestamp);
    }
}","[{'function': 'pauseSale', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""campaignState""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Campaign state must be 2 to pause sale.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignPaused""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Campaign {
    uint256 public campaignState;
    bool public paused;
    address public controller;

    event CampaignPaused(uint256 timestamp);

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function."");
        _;
    }

    constructor(address _controller) {
        controller = _controller;
    }

    function pauseSale() external onlyController {
        require(campaignState == 2, ""Campaign state must be 2 to pause sale."");
        paused = true;
        emit CampaignPaused(block.timestamp);
    }
}",42.55322337150574,pauseSale,7.0,0.7977090272361314,0.5110145823155814,"[{'function': 'pauseSale', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Campaign {
    uint256 public campaignState;
    bool public paused;
    address public controller;

    event CampaignPaused(uint256 timestamp);

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function."");
        _;
    }

    constructor(address _controller) {
        // Initialize variables to fixed, safe values
        campaignState = 1; // Never 0
        paused = true; // Set to true
        controller = _controller;

        // Invoke Ownable constructor
        constructor() Ownable(msg.sender);
    }

    function pauseSale() external onlyController {
        require(campaignState == 2, ""Campaign state must be 2 to pause sale."");
        paused = false;
        emit CampaignPaused(block.timestamp);
    }
}"
4761,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
    }

    function updatePrice() public onlyOwner {
        sellPrice = initialSellPrice.mul(initialSupply).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).div(totalSupply);
    }
}","[{'function': 'updatePrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Total supply must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""initialSellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""initialSupply""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""initialBuyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""initialSupply""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PriceUpdater {
    uint public initialSellPrice;
    uint public initialBuyPrice;
    uint public initialSupply;
    uint public totalSupply;
    uint public sellPrice;
    uint public buyPrice;

    function updatePrice() external {
        require(totalSupply != 0, ""Total supply must be greater than zero"");

        sellPrice = initialSellPrice * initialSupply / totalSupply;
        buyPrice = initialBuyPrice * initialSupply / totalSupply;
    }
}",42.32408499717712,updatePrice,16.0,0.6576408311466224,0.1121943932087934,"[{'function': 'updatePrice', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceUpdater is Ownable {
    uint public initialSellPrice = 1;
    uint public initialBuyPrice = 2;
    uint public initialSupply = 3;
    uint public totalSupply = 4;
    uint public sellPrice;
    uint public buyPrice;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        initialSellPrice = 1;
        initialBuyPrice = 2;
        initialSupply = 3;
        totalSupply = 4;
    }

    function updatePrice() external {
        require(totalSupply != 0, ""Total supply must be greater than zero"");

        sellPrice = initialSellPrice * initialSupply / totalSupply;
        buyPrice = initialBuyPrice * initialSupply / totalSupply;
    }
}"
609,Checks that a given kitten is able to breed ( i.e .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DogBreeding {
    using SafeMath for uint256;

    struct Dog {
        // Define the structure of a dog here
    }

    mapping(uint256 => Dog) public dogs;

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1);
        Dog storage dog = dogs[_dogId];
        return _isReadyToBreed(dog);
    }

    function _isReadyToBreed(Dog storage dog) internal view returns (bool) {
        // Implement the logic to check if a dog is ready to breed here
        // This is just a placeholder for your actual implementation
        return true;
    }
}","[{'function': 'isReadyToBreed', 'complexity': 1}, {'function': '_isReadyToBreed', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""isReadyToBreed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_dogId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_dogId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid dog ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Dog""}, ""name"": ""dog"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""dogs""}, ""index"": {""type"": ""Identifier"", ""name"": ""_dogId""}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isReadyToBreed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""dog""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract DogBreeding {
    struct Dog {
        uint256 age;
        bool isReadyToBreed;
    }

    mapping(uint256 => Dog) public dogs;

    function _isReadyToBreed(Dog storage dog) internal view returns (bool) {
        return dog.age >= 2 && dog.isReadyToBreed;
    }

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1, ""Invalid dog ID"");
        Dog storage dog = dogs[_dogId];
        return _isReadyToBreed(dog);
    }
}",42.74140501022339,isReadyToBreed,1.0,0.988434754801808,0.8385130047130208,"[{'function': '_isReadyToBreed', 'complexity': 0}, {'function': 'isReadyToBreed', 'complexity': 1}]",9.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DogBreeding is Ownable {
    struct Dog {
        uint256 age;
        bool isReadyToBreed;
    }

    mapping(uint256 => Dog) public dogs;

    function _isReadyToBreed(Dog storage dog) internal view returns (bool) {
        return dog.age >= 2 && dog.isReadyToBreed;
    }

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1, ""Invalid dog ID"");
        Dog storage dog = dogs[_dogId];
        return _isReadyToBreed(dog);
    }

    constructor() Ownable(msg.sender) {
        // Initialize all state variables with safe, non-corner-case values
        uint256 initialDogId = 1;
        dogs[initialDogId] = Dog({age: 1, isReadyToBreed: true});

        // Assuming there will be more dogs added sequentially
        for (uint256 i = 2; i <= 3; i++) {
            dogs[i] = Dog({age: 0, isReadyToBreed: false});
        }
    }
}"
4790,Approve the passed address to spend the specified amount of tokens on behalf of msg.sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(0 == value || 0 == allowance(msg.sender, spender));
        allowance[msg.sender][spender] = value;
        return true;
    }
}","[{'function': 'approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Approval already granted or invalid approval amount""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenApproval {
    function approve(address spender, uint256 value) public returns (bool) {
        require((value == 0) || (allowance(msg.sender, spender) == 0), ""Approval already granted or invalid approval amount"");
        // Assuming the superclass method to update allowance is named `approve` and belongs to an ERC20 contract
        return super.approve(spender, value);
    }
}",43.230628490448,approve,13.0,0.7858361206131255,0.3260548017271144,"[{'function': 'approve', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenApproval is Ownable {
    uint256 public constant MAX_ALLOWANCE = 1; // Set to a safe, non-zero value
    mapping(address => mapping(address => uint256)) private allowances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe values
        for (uint256 i = 1; i <= MAX_ALLOWANCE; i++) {
            require(i != 0, ""Value must not be zero""); // Ensure non-zero initialization
            allowances[address(0x111)][address(0x111)] = i;
        }
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require((value == 0) || (allowance(msg.sender, spender) == 0), ""Approval already granted or invalid approval amount"");
        // Assuming the superclass method to update allowance is named `approve` and belongs to an ERC20 contract
        return super.approve(spender, value);
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowances[owner][spender];
    }
}"
4695,A participant 's contribution will be rejected if the Private Sale has been funded to the maximum amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PrivateSale {
    using SafeMath for uint256;

    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 1 ether;
    uint256 public constant PRIVATESALE_START_DATE = 1672502400; // Example start date, replace with actual value
    uint256 public constant PRIVATESALE_END_DATE = 1675180800;   // Example end date, replace with actual value

    mapping(address => uint256) private balances;

    function addBalance() public payable {
        require(now >= PRIVATESALE_START_DATE && now <= PRIVATESALE_END_DATE, ""Private sale period not active"");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Minimum participation amount not met"");
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
}","[{'function': 'addBalance', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""participate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRIVATESALE_START_DATE""}}, {""type"": ""stringLiteral"", ""value"": ""Private sale has not started yet.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""PRIVATESALE_END_DATE""}}, {""type"": ""stringLiteral"", ""value"": ""Private sale has ended.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""MINIMUM_PARTICIPATION_AMOUNT""}}, {""type"": ""stringLiteral"", ""value"": ""Minimum participation amount is not met.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract PrivateSale {
    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 1 ether; // Minimum participation amount in Wei (1 ETH)
    uint256 public constant PRIVATESALE_START_DATE = 1633072800; // Example start date, replace with actual value
    uint256 public constant PRIVATESALE_END_DATE = 1633418400; // Example end date, replace with actual value

    mapping(address => uint256) public balances;

    function participate() external payable {
        require(block.timestamp >= PRIVATESALE_START_DATE, ""Private sale has not started yet."");
        require(block.timestamp <= PRIVATESALE_END_DATE, ""Private sale has ended."");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Minimum participation amount is not met."");

        balances[msg.sender] += msg.value;
    }
}",43.87114596366882,participate,14.0,0.8645711312782965,0.3787494501821194,"[{'function': 'participate', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PrivateSale is Ownable {
    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 1 ether; // Minimum participation amount in Wei (1 ETH)
    uint256 public constant PRIVATESALE_START_DATE = 1633072800; // Example start date, replace with actual value
    uint256 public constant PRIVATESALE_END_DATE = 1633418400; // Example end date, replace with actual value

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        MINIMUM_PARTICIPATION_AMOUNT = 1 ether;
        PRIVATESALE_START_DATE = 1633072800;
        PRIVATESALE_END_DATE = 1633418400;
    }

    function participate() external payable {
        require(block.timestamp >= PRIVATESALE_START_DATE, ""Private sale has not started yet."");
        require(block.timestamp <= PRIVATESALE_END_DATE, ""Private sale has ended."");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Minimum participation amount is not met."");

        balances[msg.sender] += msg.value;
    }
}"
2989,Get a description of the validator at account ` validator ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorWrapper is Ownable {
    using SafeMath for uint256;

    function getValidatorInformation(address validator) external view returns (string memory description) {
        // Your formatting logic goes here
        return ""Your formatting logic should be placed here."";
    }
}","[{'function': 'getValidatorInformation', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValidatorDescription"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validatorDescriptions""}, ""index"": {""type"": ""Identifier"", ""name"": ""validator""}}, ""right"": {""type"": ""stringLiteral"", ""value"": """"}}, {""type"": ""stringLiteral"", ""value"": ""No information available for this validator""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validatorDescriptions""}, ""index"": {""type"": ""Identifier"", ""name"": ""validator""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract ValidatorInfo {
    mapping(address => string) public validatorDescriptions;

    function getValidatorDescription(address validator) external view returns (string memory) {
        require(validatorDescriptions[validator] != """", ""No information available for this validator"");
        return validatorDescriptions[validator];
    }
}",42.08508253097534,getValidatorDescription,11.0,0.6435668123525713,0.3247581636882549,"[{'function': 'getValidatorDescription', 'complexity': 1}]",4.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ValidatorInfo is Ownable {
    mapping(address => string) public validatorDescriptions;
    address public constant DEFAULT_VALIDATOR = 0x1111111111111111111111111111111111111111; // Replace with actual default validator address
    bool public constant IS_INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        validatorDescriptions[msg.sender] = ""initialized"";
    }

    function getValidatorDescription(address validator) external view returns (string memory) {
        require(validatorDescriptions[validator] != """", ""No information available for this validator"");
        return validatorDescriptions[validator];
    }
}"
4597,Returns how many pixels has been already set .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasStorage {
    using SafeMath for uint256;

    struct Canvas {
        uint32 paintedPixelsCount;
    }

    mapping(uint32 => Canvas) private canvases;

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas storage) {
        return canvases[_canvasId];
    }
}

abstract contract CanvasManager is Ownable, CanvasStorage {
    using SafeMath for uint256;

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
        return _getCanvas(_canvasId).paintedPixelsCount;
    }
}","[{'function': '_getCanvas', 'complexity': 0}, {'function': 'getCanvasPaintedPixelsCount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_getCanvas"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Canvas""}, ""name"": ""canvas"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}, ""memberName"": ""id""}, ""right"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid canvas ID""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvases""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CanvasRegistry {
    struct Canvas {
        uint32 id;
        uint16 paintedPixelsCount;
    }

    mapping(uint32 => Canvas) public canvases;

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas storage canvas) {
        require(canvases[_canvasId].id == _canvasId, ""Invalid canvas ID"");
        return canvases[_canvasId];
    }

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint16) {
        Canvas storage canvas = _getCanvas(_canvasId);
        return canvas.paintedPixelsCount;
    }
}",43.117103099823,_getCanvas,10.0,0.7185391213796419,0.4508994988067764,"[{'function': '_getCanvas', 'complexity': 1}, {'function': 'getCanvasPaintedPixelsCount', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CanvasRegistry is Ownable {
    struct Canvas {
        uint32 id;
        uint16 paintedPixelsCount;
    }

    mapping(uint32 => Canvas) public canvases;

    constructor() Ownable(msg.sender) {
        // Initialize all state variables with safe, non-corner-case values
        for (uint32 i = 1; i <= 3; i++) {
            canvases[i] = Canvas({id: i, paintedPixelsCount: 1});
        }
    }

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas storage canvas) {
        require(canvases[_canvasId].id == _canvasId, ""Invalid canvas ID"");
        return canvases[_canvasId];
    }

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint16) {
        Canvas storage canvas = _getCanvas(_canvasId);
        return canvas.paintedPixelsCount;
    }
}"
1962,Get value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract StorageWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint256) private uIntStorage;

    function getUint(bytes32 _key) public view returns (uint256 _value) {
        return uIntStorage[_key];
    }
}","[{'function': 'getUint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getUint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_key"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""uIntStorage""}, ""index"": {""type"": ""Identifier"", ""name"": ""_key""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract StorageContract {
    mapping(bytes32 => uint) public uIntStorage;

    function getUint(bytes32 _key) external view returns (uint) {
        return uIntStorage[_key];
    }
}",42.18892025947571,getUint,0.0,0.9637441395014004,0.5756799653136481,"[{'function': 'getUint', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract StorageContract is Ownable {
    mapping(bytes32 => uint) public uIntStorage;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        uIntStorage[bytes32('init')] = 1;
    }

    function getUint(bytes32 _key) external view returns (uint) {
        return uIntStorage[_key];
    }
}"
629,"Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGrant {
    function tokenGrants(uint256 _grantId) external view returns (Grant memory);
}

struct Grant {
    uint256 amount;
    uint256 startTime;
    uint256 vestingCliff;
    uint256 vestingDuration;
    uint256 totalClaimed;
    uint256 daysClaimed;
}

abstract contract GrantCalculator {
    using SafeMath for uint256;

    IGrant public grantContract;

    constructor(address _grantAddress) {
        grantContract = IGrant(_grantAddress);
    }

    function currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory tokenGrant = grantContract.tokenGrants(_grantId);
        if (currentTime() < tokenGrant.startTime) {
            return (0, 0);
        }
        uint256 elapsedTime = currentTime().sub(tokenGrant.startTime);
        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);
        if (elapsedDays < tokenGrant.vestingCliff) {
            return (elapsedDays, 0);
        }
        if (elapsedDays >= tokenGrant.vestingDuration) {
            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);
            return (tokenGrant.vestingDuration, remainingGrant);
        } else {
            uint256 daysVested = elapsedDays.sub(tokenGrant.daysClaimed);
            uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));
            uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));
            return (daysVested, amountVested);
        }
    }
}","[{'function': 'tokenGrants', 'complexity': 0}, {'function': 'currentTime', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 3}]",5.0,{},,42.24571943283081,,81.0,0.0473782268398239,0.0,"{'function': '', 'complexity': 0}",,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGrant {
    function tokenGrants(uint256 _grantId) external view returns (Grant memory);
}

struct Grant {
    uint256 amount;
    uint256 startTime;
    uint256 vestingCliff;
    uint256 vestingDuration;
    uint256 totalClaimed;
    uint256 daysClaimed;
}

contract GrantCalculator is Ownable {
    using SafeMath for uint256;

    IGrant public grantContract;

    constructor(address _grantAddress) Ownable(msg.sender) {
        grantContract = IGrant(_grantAddress);
    }

    function currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory tokenGrant = grantContract.tokenGrants(_grantId);
        if (currentTime() < tokenGrant.startTime) {
            return (0, 0);
        }
        uint256 elapsedTime = currentTime().sub(tokenGrant.startTime);
        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);
        if (elapsedDays < tokenGrant.vestingCliff) {
            return (elapsedDays, 0);
        }
        if (elapsedDays >= tokenGrant.vestingDuration) {
            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);
            return (tokenGrant.vestingDuration, remainingGrant);
        } else {
            uint256 daysVested = elapsedDays.sub(tokenGrant.daysClaimed);
            uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));
            uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));
            return (daysVested, amountVested);
        }
    }
}"
4567,Called by the ModuleFactory owner to register new modules for SecurityTokens to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeatureRegistry {
    function getFeatureStatus(string memory feature) external view returns (bool);
}

interface IOwnable {
    function owner() external view returns (address);
}

interface IModuleFactory {
    function getTypes() external pure returns (uint8[] memory);
}

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => mapping(address => uint256)) private registry;
    mapping(uint256 => address[]) private moduleList;

    event ModuleRegistered(address indexed moduleFactory, address owner);

    function getAddress(bytes32 key) internal pure returns (address addr) {
        assembly {
            addr := shr(96, calldataload(add(key, 0x20)))
        }
    }

    function getUint(bytes32 key) internal pure returns (uint256 value) {
        assembly {
            value := calldataload(add(key, 0x20))
        }
    }

    function set(bytes32 key, uint256 value) internal {
        bytes memory data = abi.encodePacked(value);
        for (uint256 i = 0; i < data.length; i++) {
            assembly {
                mstore8(add(key, add(0x20, i)), data[i])
            }
        }
    }

    function getArrayAddress(bytes32 key) internal pure returns (address[] memory array) {
        assembly {
            array := calldataload(add(key, 0x20))
        }
    }

    function pushArray(bytes32 key, address value) internal {
        uint256 length;
        assembly {
            length := sload(key)
            sstore(add(key, 0x20), add(length, 1))
            mstore(0, value)
            sstore(add(key, mul(length, 32)), value)
        }
    }

    function registerModule(address _moduleFactory) external whenNotPausedOrOwner {
        if (IFeatureRegistry(getAddress(Encoder.getKey(""featureRegistry""))).getFeatureStatus(""customModulesAllowed"")) {
            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(), ""msg.sender must be the Module Factory owner or registry curator"");
        } else {
            require(msg.sender == owner(), ""Only owner allowed to register modules"");
        }
        require(getUint(Encoder.getKey(""registry"", _moduleFactory)) == 0, ""Module factory should not be pre-registered"");
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint256 i;
        uint256 j;
        uint8[] memory moduleTypes = moduleFactory.getTypes();
        for (i = 1; i < moduleTypes.length; i++) {
            for (j = 0; j < i; j++) {
                require(moduleTypes[i] != moduleTypes[j], ""Type mismatch"");
            }
        }
        require(moduleTypes.length != 0, ""Factory must have type"");
        uint8 moduleType = moduleFactory.getTypes()[0];
        set(Encoder.getKey(""registry"", _moduleFactory), uint256(moduleType));
        set(Encoder.getKey(""moduleListIndex"", _moduleFactory), uint256(getArrayAddress(Encoder.getKey(""moduleList"", uint256(moduleType))).length));
        pushArray(Encoder.getKey(""moduleList"", uint256(moduleType)), _moduleFactory);
        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}","[{'function': 'getFeatureStatus', 'complexity': 0}, {'function': 'owner', 'complexity': 0}, {'function': 'getTypes', 'complexity': 0}, {'function': 'getAddress', 'complexity': 0}, {'function': 'getUint', 'complexity': 0}, {'function': 'set', 'complexity': 1}, {'function': 'getArrayAddress', 'complexity': 0}, {'function': 'pushArray', 'complexity': 0}, {'function': 'registerModule', 'complexity': 10}]",15.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModuleFactory"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleFactory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredFactories""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Factory already registered""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IModuleFactory""}, ""name"": ""moduleFactory"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IModuleFactory""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": ""types"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""moduleFactory""}, ""memberName"": ""moduleTypes""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""types""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Factory must support at least one module type""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""types""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""moduleList""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""types""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""factoryToModuleType""}, ""index"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""types""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""moduleList""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""types""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredFactories""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleFactory""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ModuleRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IOwnable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleFactory""}], ""names"": []}, ""memberName"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IModuleFactory {
    function moduleTypes() external view returns (bytes32[] memory);
}

contract ModuleRegistry is Ownable {
    mapping(address => bool) private registeredFactories;
    mapping(bytes32 => address[]) private moduleList;
    mapping(address => bytes32) private factoryToModuleType;
    FeatureRegistry public featureRegistry;

    event ModuleRegistered(address indexed moduleFactory, address owner);

    constructor(address _featureRegistryAddress) {
        featureRegistry = FeatureRegistry(_featureRegistryAddress);
    }

    function registerModuleFactory(address _moduleFactory) external {
        require(!registeredFactories[_moduleFactory], ""Factory already registered"");

        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        bytes32[] memory types = moduleFactory.moduleTypes();
        require(types.length > 0, ""Factory must support at least one module type"");

        for (uint i = 0; i < types.length; i++) {
            if (moduleList[types[i]].length == 0) {
                factoryToModuleType[address(this)] = types[i];
            }
            moduleList[types[i]].push(_moduleFactory);
        }

        registeredFactories[_moduleFactory] = true;
        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}",50.8962607383728,registerModuleFactory,58.0,0.5992428236925118,0.1019721158900294,"[{'function': 'moduleTypes', 'complexity': 0}, {'function': 'registerModuleFactory', 'complexity': 6}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IModuleFactory {
    function moduleTypes() external view returns (bytes32[] memory);
}
import ""openzeppelin/SafeMath.sol"";
contract ModuleRegistry is Ownable {
    mapping(address => bool) private registeredFactories;
    mapping(bytes32 => address[]) private moduleList;
    mapping(address => bytes32) private factoryToModuleType;
    FeatureRegistry public featureRegistry;

    event ModuleRegistered(address indexed moduleFactory, address owner);

    constructor(address _featureRegistryAddress) Ownable(msg.sender) {
        featureRegistry = FeatureRegistry(_featureRegistryAddress);
        // Initialize state variables with safe, non-corner-case values
        uint256 initialValue = 1;
        bytes32 fixedBytes32 = bytes32('init');
        address[] memory emptyArray;

        for (uint i = 0; i < emptyArray.length; i++) {
            // Placeholder loop to initialize arrays and mappings
        }
    }

    function registerModuleFactory(address _moduleFactory) external {
        require(!registeredFactories[_moduleFactory], ""Factory already registered"");

        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        bytes32[] memory types = moduleFactory.moduleTypes();
        require(types.length > 0, ""Factory must support at least one module type"");

        for (uint i = 0; i < types.length; i++) {
            if (moduleList[types[i]].length == 0) {
                factoryToModuleType[address(this)] = types[i];
            }
            moduleList[types[i]].push(_moduleFactory);
        }

        registeredFactories[_moduleFactory] = true;
        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}"
2433,Total hash rate of a miner in a halving,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Miner {
    using SafeMath for uint256;
    mapping(uint256 => MinerHashRate) public hashRate;
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;
    struct MinerHashRate {
        uint256 rate;
        bool carried;
    }

    mapping(address => Miner) public miners;

    function getMinerHalving() public pure returns (uint256) {
        // This should be implemented in the actual contract.
        return 0; // Placeholder for actual implementation.
    }

    function getMinerHalvingHashRateOf(address _miner) public view returns (uint256) {
        require(block.number >= block.timestamp, ""Not before genesis"");
        Miner miner = miners[_miner];
        uint256 halving = getMinerHalving();
        MinerHashRate memory hashRate = miner.hashRate[halving];
        if (halving == 0) {
            return hashRate.rate;
        } else {
            if (!hashRate.carried) {
                return hashRate.rate.add(miner.hashRate[halving - 1].rate);
            } else {
                return hashRate.rate;
            }
        }
    }
}","[{'function': 'getMinerHalving', 'complexity': 0}, {'function': 'getMinerHalvingHashRateOf', 'complexity': 6}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMinerHashRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_miner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Miner""}, ""name"": ""miner"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""miners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_miner""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""halvingIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getMinerHalving""}, ""arguments"": [], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""halvingIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""Identifier"", ""name"": ""halvingIndex""}}, ""memberName"": ""rate""}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""halvingIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""memberName"": ""carried""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""halvingIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""memberName"": ""rate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""Identifier"", ""name"": ""halvingIndex""}}, ""memberName"": ""rate""}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""miner""}, ""memberName"": ""hashRate""}, ""index"": {""type"": ""Identifier"", ""name"": ""halvingIndex""}}, ""memberName"": ""rate""}]}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract MinerContract {
    struct Miner {
        mapping(uint => MinerHashRate) hashRate;
    }

    struct MinerHashRate {
        uint rate;
        bool carried;
    }

    mapping(address => Miner) public miners;

    function getMinerHalving() internal pure returns (uint) {
        // Placeholder for the actual implementation of getting the halving index.
        return 0; // Simplified, replace with actual logic.
    }

    modifier notBeforeGenesis() {
        require(block.number > 100, ""Function can only be called after genesis block"");
        _;
    }

    modifier isMiner(address _miner) {
        require(miners[_miner].hashRate[getMinerHalving()].rate != 0, ""Address is not a valid miner"");
        _;
    }

    function getMinerHashRate(address _miner) public view returns (uint) {
        Miner storage miner = miners[_miner];
        uint halvingIndex = getMinerHalving();
        if (halvingIndex == 0) {
            return miner.hashRate[halvingIndex].rate;
        } else {
            if (!miner.hashRate[halvingIndex - 1].carried) {
                return miner.hashRate[halvingIndex - 1].rate + miner.hashRate[halvingIndex].rate;
            } else {
                return miner.hashRate[halvingIndex].rate;
            }
        }
    }
}",45.725318908691406,getMinerHashRate,24.0,0.8904306625705627,0.3269455820097158,"[{'function': 'getMinerHalving', 'complexity': 0}, {'function': 'getMinerHashRate', 'complexity': 5}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MinerContract is Ownable {
    struct Miner {
        mapping(uint => MinerHashRate) hashRate;
    }

    struct MinerHashRate {
        uint rate;
        bool carried;
    }

    mapping(address => Miner) public miners;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        miners[msg.sender] = Miner({
            hashRate: {
                0 => MinerHashRate({rate: 1, carried: false}),
                1 => MinerHashRate({rate: 2, carried: true})
            }
        });
    }

    function getMinerHalving() internal pure returns (uint) {
        // Placeholder for the actual implementation of getting the halving index.
        return 0; // Simplified, replace with actual logic.
    }

    modifier notBeforeGenesis() {
        require(block.number > 100, ""Function can only be called after genesis block"");
        _;
    }

    modifier isMiner(address _miner) {
        require(miners[_miner].hashRate[getMinerHalving()].rate != 0, ""Address is not a valid miner"");
        _;
    }

    function getMinerHashRate(address _miner) public view returns (uint) {
        Miner storage miner = miners[_miner];
        uint halvingIndex = getMinerHalving();
        if (halvingIndex == 0) {
            return miner.hashRate[halvingIndex].rate;
        } else {
            if (!miner.hashRate[halvingIndex - 1].carried) {
                return miner.hashRate[halvingIndex - 1].rate + miner.hashRate[halvingIndex].rate;
            } else {
                return miner.hashRate[halvingIndex].rate;
            }
        }
    }
}"
915,"Get the budget avaliable of a campaign Based on the Campaign id , return the total value avaliable to pay for proofs of attention .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Campaign {
    function getBudget() external view returns (uint);
}

abstract contract CampaignRegistry is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => address) public campaigns;

    function setCampaign(bytes32 bidId, address campaignAddress) public onlyOwner {
        campaigns[bidId] = campaignAddress;
    }

    function getCampaignBudgetById(bytes32 bidId) public view returns (uint budget) {
        return Campaign(campaigns[bidId]).getBudget();
    }
}","[{'function': 'getBudget', 'complexity': 0}, {'function': 'setCampaign', 'complexity': 0}, {'function': 'getCampaignBudgetById', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCampaignBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}, ""memberName"": ""budget""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CampaignBudget {
    mapping(bytes32 => Campaign) public campaigns;

    struct Campaign {
        bytes32 id;
        uint budget;
    }

    function getCampaignBudget(bytes32 bidId) public view returns (uint) {
        return campaigns[bidId].budget;
    }
}",41.818196296691895,getCampaignBudget,7.0,0.7604026379806292,0.0860958371038403,"[{'function': 'getCampaignBudget', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CampaignBudget is Ownable {
    mapping(bytes32 => Campaign) public campaigns;

    struct Campaign {
        bytes32 id;
        uint budget;
    }

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getCampaignBudget(bytes32 bidId) public view returns (uint) {
        return campaigns[bidId].budget;
    }
}"
2907,Sets the ICO Contract Address variable to be used with the ` onlyIcoContract ` modifier .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public freezeBypassing;
    address public icoContractAddress;

    function setIcoContractAddress(address contractAddress) public onlyOwner {
    freezeBypassing[contractAddress] = true;
    icoContractAddress = contractAddress;
}
}","[{'function': 'setIcoContractAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcoContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoContractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""contractAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""freezeBypassing""}, ""index"": {""type"": ""Identifier"", ""name"": ""contractAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    address public icoContractAddress;
    mapping(address => bool) public freezeBypassing;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setIcoContractAddress(address contractAddress) public onlyOwner {
        icoContractAddress = contractAddress;
        freezeBypassing[contractAddress] = true;
    }
}",42.69010090827942,setIcoContractAddress,4.0,1.0,0.6979962505377018,"[{'function': 'setIcoContractAddress', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists in a standard library or path
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner = msg.sender;
    address public icoContractAddress;
    mapping(address => bool) public freezeBypassing;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to explicitly initialize state variables here as they are already initialized in the parent constructor
    }

    function setIcoContractAddress(address contractAddress) public onlyOwner {
        icoContractAddress = contractAddress;
        freezeBypassing[contractAddress] = true;
    }
}"
5542,Enables the owner of a parcel to update the data field,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LandInterface {
    function decodeTokenId(uint256 tokenId) external pure returns (int256 x, int256 y);
    function updateLandData(int256 x, int256 y, string memory data) external;
}

abstract contract LandWrapper is Ownable {
    using SafeMath for uint256;

    struct Mortgage {
        uint256 landId;
    }

    mapping(uint256 => Mortgage) public mortgages;
    LandInterface public land;

    event UpdatedLandData(address indexed sender, uint256 id, string data);

    constructor(address _landAddress) {
        land = LandInterface(_landAddress);
    }

    function updateLandData(uint256 id, string memory data) external onlyOwner returns (bool) {
        require(_isAuthorized(msg.sender, id), ""Sender not authorized"");
        (int256 x, int256 y) = land.decodeTokenId(mortgages[id].landId);
        land.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
        return true;
    }

    function _isAuthorized(address sender, uint256 id) internal view returns (bool) {
        // Implement your authorization logic here
        return owner() == sender || mortgages[id].landId != 0;
    }
}","[{'function': 'updateLandData', 'complexity': 0}, {'function': 'updateLandData', 'complexity': 1}, {'function': '_isAuthorized', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateLandData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""x"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x1135166d0>}, {""type"": ""VariableDeclaration"", ""name"": ""y"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x113516660>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""landContract""}, ""memberName"": ""decodeTokenId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""landContract""}, ""memberName"": ""updateLandData""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""x""}, {""type"": ""Identifier"", ""name"": ""y""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""UpdatedLandData""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""Identifier"", ""name"": ""data""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface LandContract {
    function decodeTokenId(uint256 tokenId) external view returns (uint256 x, uint256 y);
    function updateLandData(uint256 x, uint256 y, string calldata data) external;
}

contract MortgageUpdater {
    address public owner;
    LandContract public landContract;

    event UpdatedLandData(address indexed sender, uint256 id, string newData);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Sender not authorized"");
        _;
    }

    constructor(address _landContract) {
        owner = msg.sender;
        landContract = LandContract(_landContract);
    }

    function updateLandData(uint256 id, string calldata data) external onlyOwner {
        (uint256 x, uint256 y) = landContract.decodeTokenId(id);
        landContract.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
    }
}",44.70967435836792,updateLandData,16.0,0.7626349354242719,0.4067243182059446,"[{'function': 'updateLandData', 'complexity': 0}, {'function': 'updateLandData', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

interface LandContract {
    function decodeTokenId(uint256 tokenId) external view returns (uint256 x, uint256 y);
    function updateLandData(uint256 x, uint256 y, string calldata data) external;
}
import ""openzeppelin/SafeMath.sol"";
contract MortgageUpdater {
    address public owner;
    LandContract public landContract;

    event UpdatedLandData(address indexed sender, uint256 id, string newData);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Sender not authorized"");
        _;
    }

    constructor(address _landContract) {
        owner = msg.sender;
        landContract = LandContract(_landContract);
    }

    function updateLandData(uint256 id, string calldata data) external onlyOwner {
        (uint256 x, uint256 y) = landContract.decodeTokenId(id);
        landContract.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
    }
}"
6660,"Set the `` approved taker '' for your deed , or revoke approval by setting the zero address .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function approve(address _to, uint256 _deedId) external payable {
        // Function body
    }
}","[{'function': 'approve', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_deedId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid approval target""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_deedId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_deedId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract AssetApproval {
    // Mapping to store the approval status for each asset by owner address
    mapping(address => mapping(uint256 => bool)) public approvals;

    // Event triggered when an approval is set
    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);

    // Function to approve the transfer of a specific asset by the caller
    function approve(address _to, uint256 _deedId) external payable {
        require(_to != address(0), ""Invalid approval target"");
        approvals[msg.sender][_deedId] = true;
        emit Approval(msg.sender, _to, _deedId);
    }
}",43.02274918556213,approve,32.0,0.3850765503155461,0.2767688167026197,"[{'function': 'approve', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetApproval is Ownable {
    // Mapping to store the approval status for each asset by owner address
    mapping(address => mapping(uint256 => bool)) public approvals;

    // Event triggered when an approval is set
    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);

    // Function to approve the transfer of a specific asset by the caller
    function approve(address _to, uint256 _deedId) external payable {
        require(_to != address(0), ""Invalid approval target"");
        approvals[msg.sender][_deedId] = true;
        emit Approval(msg.sender, _to, _deedId);
    }

    // Constructor to initialize the contract with a safe and non-corner-case value for Ownable
    constructor() Ownable(msg.sender) {
        // Initialize state variables if needed (though none are present in this example)
    }
}"
2749,"Set budget for ` _token.symbol ( ) : string ` to ` @ tokenAmount ( _token , _amount , false ) ` , effective immediately","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BudgetSetter is Ownable {
    using SafeMath for uint256;

    struct Settings {
        mapping(address => uint256) budgets;
        mapping(address => bool) hasBudget;
    }

    Settings private settings;

    event SetBudget(address indexed token, uint256 amount, bool indexed success);

    modifier authP(bytes32 role, bytes memory data) {
        require(hasRole(role, msg.sender), ""Unauthorized"");
        _;
    }

    function setBudget(address _token, uint256 _amount) external authP(keccak256(""CHANGE_BUDGETS_ROLE""), abi.encodePacked(_token, _amount, settings.budgets[_token], settings.hasBudget[_token] ? 1 : 0)) {
        require(_amount > 0, ""Amount must be greater than zero"");

        if (!settings.hasBudget[_token]) {
            settings.hasBudget[_token] = true;
        }

        settings.budgets[_token] = _amount;
        emit SetBudget(_token, _amount, true);
    }
}","[{'function': 'setBudget', 'complexity': 4}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""settings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""memberName"": ""hasBudget""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""settings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""memberName"": ""hasBudget""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetBudget""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetBudget""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""settings""}, ""index"": {""type"": ""Identifier"", ""name"": ""_token""}}, ""memberName"": ""budget""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""authP"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract BudgetSetter is AccessControl {
    struct BudgetSettings {
        bool hasBudget;
        uint256 budget;
    }

    mapping(address => BudgetSettings) public settings;

    event SetBudget(address indexed token, uint256 amount, bool newBudget);

    bytes32 public constant CHANGE_BUDGETS_ROLE = keccak256(""CHANGE_BUDGETS_ROLE"");

    modifier authP() {
        require(hasRole(CHANGE_BUDGETS_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CHANGE_BUDGETS_ROLE, msg.sender);
    }

    function setBudget(address _token, uint256 _amount) external authP {
        if (!settings[_token].hasBudget) {
            settings[_token].hasBudget = true;
            emit SetBudget(_token, _amount, true);
        } else {
            emit SetBudget(_token, _amount, false);
        }
        settings[_token].budget = _amount;
    }
}",45.17469048500061,setBudget,37.0,0.7798206457986963,0.3478240466600941,"[{'function': 'setBudget', 'complexity': 2}]",2.0,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BudgetSetter is AccessControl, Ownable {
    struct BudgetSettings {
        bool hasBudget;
        uint256 budget;
    }

    mapping(address => BudgetSettings) public settings;

    event SetBudget(address indexed token, uint256 amount, bool newBudget);

    bytes32 public constant CHANGE_BUDGETS_ROLE = keccak256(""CHANGE_BUDGETS_ROLE"");

    modifier authP() {
        require(hasRole(CHANGE_BUDGETS_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    constructor() Ownable(msg.sender) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(CHANGE_BUDGETS_ROLE, msg.sender);
    }

    function setBudget(address _token, uint256 _amount) external authP {
        if (!settings[_token].hasBudget) {
            settings[_token].hasBudget = true;
            emit SetBudget(_token, _amount, true);
        } else {
            emit SetBudget(_token, _amount, false);
        }
        settings[_token].budget = _amount;
    }
}"
5294,"Only to be used when this contract is significantly broken , and an upgrade is required .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public upgradedContractAddress;

    event ContractUpgrade(address indexed newContractAddress);

    function setUpgradedContractAddress(address _upgradedContractAddress) external onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }
}","[{'function': 'setUpgradedContractAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setUpgradedContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_upgradedContractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upgradedContractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_upgradedContractAddress""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ContractUpgrade""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_upgradedContractAddress""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract UpgradableContract {
    address public owner;
    bool public paused;
    address public upgradedContractAddress;

    event ContractUpgrade(address indexed newAddress);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier whenPaused() {
        require(paused, ""Contract must be paused to execute this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setUpgradedContractAddress(address _upgradedContractAddress) public onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }
}",43.30979800224304,setUpgradedContractAddress,0.0,0.982094490101554,0.8578928092681435,"[{'function': 'setUpgradedContractAddress', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract UpgradableContract is Ownable {
    address public owner = msg.sender;
    bool public paused = false;
    address public upgradedContractAddress;

    event ContractUpgrade(address indexed newAddress);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    modifier whenPaused() {
        require(paused, ""Contract must be paused to execute this function"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setUpgradedContractAddress(address _upgradedContractAddress) public onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }
}"
598,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public onlyOwner {
        require(now > 1508840297);
        _transfer(msg.sender, _to, _value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        // Implementation of the transfer logic
    }
}","[{'function': 'transfer', 'complexity': 1}, {'function': '_transfer', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""_transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;

    function transfer(address _to, uint256 _value) external {
        require(now > 1508840297, ""Transfer not allowed before specified timestamp"");
        require(_value <= balances[msg.sender], ""Insufficient balance"");

        balances[msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value <= balances[_from], ""Insufficient balance"");

        balances[_from] -= _value;
        balances[_to] += _value;

        emit Transfer(_from, _to, _value);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}",44.176706075668335,_transfer,37.0,0.5452840271279661,0.1856376194093643,"[{'function': 'transfer', 'complexity': 2}, {'function': '_transfer', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance of owner to 1 (never 0)
    }

    function transfer(address _to, uint256 _value) external {
        require(_value <= balances[msg.sender], ""Insufficient balance"");
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value <= balances[_from], ""Insufficient balance"");
        balances[_from] -= _value;
        balances[_to] += _value;
        emit Transfer(_from, _to, _value);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}"
2600,This function will set the conversion rate .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public rateMe;

    function setRate(uint _rateMe) public onlyOwner {
        rateMe = _rateMe;
    }
}","[{'function': 'setRate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_rateMe"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""rateMe""}, ""right"": {""type"": ""Identifier"", ""name"": ""_rateMe""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""ownerOnly"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract RateSetter {
    address private owner;
    uint public rateMe;

    modifier ownerOnly() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setRate(uint _rateMe) external ownerOnly {
        rateMe = _rateMe;
    }
}",42.02145004272461,setRate,0.0,0.9731441924665556,0.6703420896351792,"[{'function': 'setRate', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RateSetter is Ownable {
    uint public rateMe;

    modifier ownerOnly() {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        _;
    }

    constructor() Ownable() {
        rateMe = 1;
    }

    function setRate(uint _rateMe) external ownerOnly {
        rateMe = _rateMe;
    }
}"
2777,Calls approve on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CompatibleERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract SafeApproveWrapper is Ownable {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 amount) internal {
        CompatibleERC20(token).approve(spender, amount);
        require(previousReturnValue(), ""approve failed"");
    }

    function previousReturnValue() private pure returns (bool) {
        // This is a placeholder for the actual logic to check if the approve call succeeded.
        // In practice, this would involve checking the return value of the approve function.
        // For simplicity, we assume it always succeeds in this example.
        return true;
    }
}","[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 1}, {'function': 'previousReturnValue', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""safeApprove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""approve failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

contract SafeApprove {
    function safeApprove(address token, address spender, uint256 amount) public {
        bool success = IERC20(token).approve(spender, amount);
        require(success, ""approve failed"");
    }
}",42.39586019515991,safeApprove,4.0,0.6996498034031113,0.0051907896431297,"[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract SafeApprove is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function safeApprove(address token, address spender, uint256 amount) public {
        bool success = IERC20(token).approve(spender, amount);
        require(success, ""approve failed"");
    }
}"
2639,"The total SNX owned by this account , both escrowed and unescrowed , against which synths can be issued .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollateralWrapper {
    using SafeMath for uint256;

    address public tokenState;
    address public escrow;

    constructor(address _tokenState, address _escrow) {
        tokenState = _tokenState;
        escrow = _escrow;
    }

    function collateral(address account) public view returns (uint256) {
        uint256 balance = ITokenState(tokenState).balanceOf(account);
        if (escrow != address(0)) {
            balance = balance.add(IEscrow(escrow).balanceOf(account));
        }
        return balance;
    }
}","[{'function': 'collateral', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateTotalCollateral"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalCollateral"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceFromTokenState"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenStateContract""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""escrowAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Escrow""}, ""name"": ""escrowContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Escrow""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""escrowAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceFromEscrow"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrowContract""}, ""memberName"": ""getBalance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""account""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalCollateral""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""balanceFromTokenState""}, ""right"": {""type"": ""Identifier"", ""name"": ""balanceFromEscrow""}}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalCollateral""}, ""right"": {""type"": ""Identifier"", ""name"": ""balanceFromTokenState""}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

interface TokenState {
    function balanceOf(address account) external view returns (uint256);
}

interface Escrow {
    function getBalance(address account) external view returns (uint256);
}

contract CollateralCalculator {
    address public escrowAddress;
    TokenState public tokenStateContract;

    constructor(address _tokenState, address _escrow) {
        tokenStateContract = TokenState(_tokenState);
        escrowAddress = _escrow;
    }

    function calculateTotalCollateral(address account) external view returns (uint256 totalCollateral) {
        uint256 balanceFromTokenState = tokenStateContract.balanceOf(account);
        if (escrowAddress != address(0)) {
            Escrow escrowContract = Escrow(escrowAddress);
            uint256 balanceFromEscrow = escrowContract.getBalance(account);
            totalCollateral = balanceFromTokenState + balanceFromEscrow;
        } else {
            totalCollateral = balanceFromTokenState;
        }
    }
}",44.52165460586548,calculateTotalCollateral,8.0,0.8313512036349653,0.3018323956703524,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getBalance', 'complexity': 0}, {'function': 'calculateTotalCollateral', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

interface TokenState {
    function balanceOf(address account) external view returns (uint256);
}

interface Escrow {
    function getBalance(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract CollateralCalculator is Ownable {
    address public escrowAddress;
    TokenState public tokenStateContract;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenState, address _escrow) Ownable(msg.sender) {
        tokenStateContract = TokenState(_tokenState);
        escrowAddress = _escrow;
    }

    function calculateTotalCollateral(address account) external view returns (uint256 totalCollateral) {
        uint256 balanceFromTokenState = tokenStateContract.balanceOf(account);
        if (escrowAddress != address(0)) {
            Escrow escrowContract = Escrow(escrowAddress);
            uint256 balanceFromEscrow = escrowContract.getBalance(account);
            totalCollateral = balanceFromTokenState + balanceFromEscrow;
        } else {
            totalCollateral = balanceFromTokenState;
        }
    }
}"
4569,Returns all the relevant information about a specific whale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhaleMarketplace is Ownable {
    using SafeMath for uint256;

    struct Whale {
        string name;
    }

    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Whale storage whale = whales[_tokenId];
        Id = _tokenId;
        whaleName = whale.name;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}","[{'function': 'getWhale', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getWhale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""Id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""whaleName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sellingPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Whale""}, ""name"": ""whale"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whales""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""whale""}, ""memberName"": ""whaleName""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Whale does not exist""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""Id""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""whaleName""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""whale""}, ""memberName"": ""whaleName""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellingPrice""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whaleIndexToPrice""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whaleIndexToOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract WhaleNFT {
    struct Whale {
        string whaleName;
    }

    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Whale storage whale = whales[_tokenId];
        require(bytes(whale.whaleName).length > 0, ""Whale does not exist"");

        Id = _tokenId;
        whaleName = whale.whaleName;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}",43.518240213394165,getWhale,11.0,0.8716131005025434,0.6434028459382264,"[{'function': 'getWhale', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WhaleNFT is Ownable {
    struct Whale {
        string whaleName;
    }

    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            whales[i] = Whale({whaleName: ""Whale""});
            whaleIndexToPrice[i] = 1 ether; // Set to a fixed price, never zero
            whaleIndexToOwner[i] = address(uint160(i)); // Use these fixed values in order
        }
    }

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Whale storage whale = whales[_tokenId];
        require(bytes(whale.whaleName).length > 0, ""Whale does not exist"");

        Id = _tokenId;
        whaleName = whale.whaleName;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}"
3314,deliberately authorized the sender of the message via some mechanism,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SCComplianceService {
    function validate(address _from, address _to, uint256 _amount) external view returns (bool);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    bool public stopInEmergency = false;

    SCComplianceService public complianceService;

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
    }

    function setComplianceService(address _complianceService) public onlyOwner {
        complianceService = SCComplianceService(_complianceService);
    }

    function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {
        if (balances[_from] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the token balance of the source');
        }

        if (allowed[_from][msg.sender] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');
        }

        if (!complianceService.validate(_from, _to, _amount)) {
            revert('transferFrom: not allowed by the compliance service');
        }

        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        emit Transfer(_from, _to, _amount);

        return true;
    }

    function setStopInEmergency(bool _stop) public onlyOwner {
        stopInEmergency = _stop;
    }
}","[{'function': 'validate', 'complexity': 0}, {'function': 'setComplianceService', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': 'setStopInEmergency', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Allowance too low""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract TokenTransfer {
    IERC20 public token;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function transferTokens(address _from, address _to, uint256 _amount) external returns (bool) {
        require(token.balanceOf(_from) >= _amount, ""Insufficient balance"");
        require(token.allowance(_from, msg.sender) >= _amount, ""Allowance too low"");

        bool success = token.transferFrom(_from, _to, _amount);
        require(success, ""Token transfer failed"");

        return true;
    }
}",44.06882166862488,transferTokens,57.0,0.4935342180604291,0.1408633746471898,"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferTokens', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer {
    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IERC20(_tokenAddress);
    }

    function transferTokens(address _from, address _to, uint256 _amount) external returns (bool) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(token.balanceOf(_from) >= _amount, ""Insufficient balance"");
        require(token.allowance(_from, msg.sender) >= _amount, ""Allowance too low"");

        bool success = token.transferFrom(_from, _to, _amount);
        require(success, ""Token transfer failed"");

        return true;
    }
}"
3619,Get the tags related to the module factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TagProvider {
    using SafeMath for uint256;

    function getTags() public view returns (bytes32[] memory) {
        bytes32[] memory availableTags = new bytes32[](2);
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
        return availableTags;
    }
}","[{'function': 'getTags', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTags"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""availableTags""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract TagContract {
    bytes32[] public availableTags;

    constructor() {
        availableTags = new bytes32[](2);
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
    }

    function getTags() public view returns (bytes32[] memory) {
        return availableTags;
    }
}",42.07617282867432,getTags,21.0,0.4826478481196214,0.2820856965734402,"[{'function': 'getTags', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TagContract is Ownable {
    bytes32[] public availableTags;

    constructor() Ownable(msg.sender) {
        availableTags = new bytes32[](2);
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
    }

    function getTags() public view returns (bytes32[] memory) {
        return availableTags;
    }
}"
3235,Invoke ` onERC721Received ` on a target address ( not executed if the target address is not a contract ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721Wrapper is Ownable {
    using SafeMath for uint256;

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal returns (bool) {
        if (!_to.isContract()) return true;
        bytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
        return (retval == 0x150b7a02); // ERC721_RECEIVED is the keccak-256 hash of ""onERC721Received(address,address,uint256,bytes)""
    }
}","[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'checkAndCallSafeTransfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkAndCallSafeTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC721Receiver""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721Receiver""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""result"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receiver""}, ""memberName"": ""onERC721Received""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""result""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x150b7a02"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Recipient contract did not implement onERC721Received""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) external returns (bytes4);
}

contract ERC721SafeTransfer {
    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) public returns (bool) {
        if (!isContract(_to)) {
            return true;
        }
        IERC721Receiver receiver = IERC721Receiver(_to);
        bytes4 result = receiver.onERC721Received(msg.sender, _from, _tokenId, _data);
        require(result == 0x150b7a02, ""Recipient contract did not implement onERC721Received"");
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",44.19620800018311,checkAndCallSafeTransfer,15.0,0.9291394376483186,0.4670862204944989,"[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'checkAndCallSafeTransfer', 'complexity': 3}, {'function': 'isContract', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) external returns (bytes4);
}
import ""openzeppelin/SafeMath.sol"";
contract ERC721SafeTransfer is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) public returns (bool) {
        if (!isContract(_to)) {
            return true;
        }
        IERC721Receiver receiver = IERC721Receiver(_to);
        bytes4 result = receiver.onERC721Received(msg.sender, _from, _tokenId, _data);
        require(result == 0x150b7a02, ""Recipient contract did not implement onERC721Received"");
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
4896,Set whether prices can be changed manually .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public allowChangePrice;

    function setAllowChangePrice(bool _allowChangePrice) external onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}","[{'function': 'setAllowChangePrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAllowChangePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_allowChangePrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""allowChangePrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_allowChangePrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyCFO"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract CFOContract {
    address public cfoAddress;
    bool public allowChangePrice;

    modifier onlyCFO() {
        require(msg.sender == cfoAddress, ""Only the CFO can call this function"");
        _;
    }

    constructor(address _cfoAddress) {
        cfoAddress = _cfoAddress;
    }

    function setAllowChangePrice(bool _allowChangePrice) public onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}",42.493908166885376,setAllowChangePrice,0.0,0.97198691224417,0.7611606003349892,"[{'function': 'setAllowChangePrice', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CFOContract is Ownable {
    address public cfoAddress;
    bool public allowChangePrice;

    modifier onlyCFO() {
        require(msg.sender == cfoAddress, ""Only the CFO can call this function"");
        _;
    }

    constructor(address _cfoAddress) Ownable(_cfoAddress) {
        cfoAddress = _cfoAddress;
        allowChangePrice = true; // Set to true as per initialization rules
    }

    function setAllowChangePrice(bool _allowChangePrice) public onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}"
5609,Updates registration status for multiple addresses for participation,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function changeRegistrationStatus(address target, bool isRegistered) public onlyOwner {
        // Implementation of changing registration status
    }

    function changeRegistrationStatuses(address[] memory targets, bool isRegistered) public onlyOwner {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}","[{'function': 'changeRegistrationStatus', 'complexity': 0}, {'function': 'changeRegistrationStatuses', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeRegistrationStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isRegistered"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registrationStatuses""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""right"": {""type"": ""Identifier"", ""name"": ""isRegistered""}}}]}, ""visibility"": ""private"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract RegistrationUpdater {
    mapping(address => bool) public registrationStatuses;
    address private owner;

    modifier onlyBy(address _account) {
        require(msg.sender == _account, ""Caller is not the owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function changeRegistrationStatus(address target, bool isRegistered) private {
        registrationStatuses[target] = isRegistered;
    }

    function updateRegistrationStatuses(address[] memory targets, bool isRegistered) public onlyBy(owner) {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}",43.22164249420166,updateRegistrationStatuses,17.0,0.9209931517226516,0.7928666317569916,"[{'function': 'changeRegistrationStatus', 'complexity': 0}, {'function': 'updateRegistrationStatuses', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RegistrationUpdater is Ownable {
    mapping(address => bool) public registrationStatuses;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 0; i < 3; i++) {
            address addr = address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))));
            registrationStatuses[addr] = true; // Set to true instead of false for non-corner cases
        }
    }

    function changeRegistrationStatus(address target, bool isRegistered) private {
        registrationStatuses[target] = isRegistered;
    }

    function updateRegistrationStatuses(address[] memory targets, bool isRegistered) public onlyOwner {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}"
3896,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract BeneficiaryManager is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    IERC20 public token;
    mapping(address => Beneficiary) public beneficiaries;
    address[] public addresses;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _token, address[] memory initialBeneficiaries) {
        token = IERC20(_token);
        for (uint i = 0; i < initialBeneficiaries.length; i++) {
            beneficiaries[initialBeneficiaries[i]] = Beneficiary({isBeneficiary: true, vested: 0, released: 0});
        }
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary].isBeneficiary, ""Beneficiary does not exist"");
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        token.transfer(owner(), balance);
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        for (uint i = 0; i < addresses.length - 1; i++) {
            if (addresses[i] == _beneficiary) {
                addresses[i] = addresses[addresses.length - 1];
                break;
            }
        }
        addresses.pop();
        emit BeneficiaryDestroyed(_beneficiary);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""memberName"": ""isBeneficiary""}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary is not active""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Beneficiary""}, ""name"": ""beneficiary"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainingTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""vested""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""remainingTokens""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalReleased""}, ""right"": {""type"": ""Identifier"", ""name"": ""remainingTokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""isBeneficiary""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""released""}, ""right"": {""type"": ""Identifier"", ""name"": ""remainingTokens""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""pop""}, ""arguments"": [], ""names"": []}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BeneficiaryDestroyed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract VestingContract is Ownable {
    struct Beneficiary {
        uint256 vested;
        uint256 released;
        bool isBeneficiary;
    }

    mapping(address => Beneficiary) public beneficiaries;
    address[] private addresses;
    IERC20 public token;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function destroyBeneficiary(address _beneficiary) external onlyOwner {
        require(beneficiaries[_beneficiary].isBeneficiary, ""Beneficiary is not active"");

        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 remainingTokens = beneficiary.vested - beneficiary.released;

        // Transfer the remaining tokens back to the contract owner
        require(token.transfer(owner(), remainingTokens), ""Token transfer failed"");
        totalReleased += remainingTokens;

        // Update state variables
        beneficiary.isBeneficiary = false;
        beneficiary.released += remainingTokens;

        // Remove the beneficiary from the addresses array
        for (uint256 i = 0; i < addresses.length; i++) {
            if (addresses[i] == _beneficiary) {
                addresses[i] = addresses[addresses.length - 1];
                addresses.pop();
                break;
            }
        }

        emit BeneficiaryDestroyed(_beneficiary);
    }
}",45.84707307815552,destroyBeneficiary,18.0,0.8989096003938737,0.4532668875806906,"[{'function': 'destroyBeneficiary', 'complexity': 6}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VestingContract is Ownable {
    struct Beneficiary {
        uint256 vested;
        uint256 released;
        bool isBeneficiary;
    }

    mapping(address => Beneficiary) public beneficiaries;
    address[] private addresses;
    IERC20 public token;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _tokenAddress) Ownable() {
        token = IERC20(_tokenAddress);
    }

    function destroyBeneficiary(address _beneficiary) external onlyOwner {
        require(beneficiaries[_beneficiary].isBeneficiary, ""Beneficiary is not active"");

        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 remainingTokens = beneficiary.vested - beneficiary.released;

        // Transfer the remaining tokens back to the contract owner
        require(token.transfer(owner(), remainingTokens), ""Token transfer failed"");
        totalReleased += remainingTokens;

        // Update state variables
        beneficiary.isBeneficiary = false;
        beneficiary.released += remainingTokens;

        // Remove the beneficiary from the addresses array
        for (uint256 i = 0; i < addresses.length; i++) {
            if (addresses[i] == _beneficiary) {
                addresses[i] = addresses[addresses.length - 1];
                addresses.pop();
                break;
            }
        }

        emit BeneficiaryDestroyed(_beneficiary);
    }
}"
2053,Create ` msg.value ` ETH worth of GMT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint256 public tokenExchangeRate = 1000; // Example rate, adjust as needed
    uint256 public totalSupply = 1000000 * (10 ** 18); // Example total supply, adjust as needed
    uint256 public assignedSupply;
    uint256 public gmtFund;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return assignedSupply.add(tokens) <= totalSupply;
    }

    function claimTokens() public payable {
        require(msg.value > 0, ""Value must be greater than zero"");
        uint256 tokens = msg.value.mul(tokenExchangeRate);
        require(isWithinCap(tokens), ""Claim exceeds the token cap"");
        uint256 checkedSupply = assignedSupply.add(tokens);
        require(checkedSupply.add(gmtFund) <= totalSupply, ""Total supply would be exceeded"");
        balances[msg.sender] = balances[msg.sender].add(tokens);
        purchases[msg.sender] = purchases[msg.sender].add(tokens);
        assignedSupply = checkedSupply;
        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }
}","[{'function': 'isWithinCap', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount of Ether sent must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""TOKEN_EXCHANGE_RATE""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isWithinCap""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token purchase exceeds the cap limit""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""purchases""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""tokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""assignedSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokens""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimGMT""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract TokenClaim {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;
    uint256 public assignedSupply;
    uint256 public constant TOKEN_EXCHANGE_RATE = 1000; // Example rate, adjust as needed
    uint256 public constant CAP_LIMIT = 1000000 * (10 ** 18); // Example cap limit, adjust as needed

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function claimTokens() external payable {
        require(msg.value > 0, ""Amount of Ether sent must be greater than zero"");

        uint256 tokens = msg.value * TOKEN_EXCHANGE_RATE;
        require(isWithinCap(tokens), ""Token purchase exceeds the cap limit"");

        balances[msg.sender] += tokens;
        purchases[msg.sender] += tokens;
        assignedSupply += tokens;

        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return (assignedSupply + tokens) <= CAP_LIMIT;
    }
}",45.3184187412262,claimTokens,31.0,0.6983374049187456,0.411864703634863,"[{'function': 'claimTokens', 'complexity': 2}, {'function': 'isWithinCap', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenClaim is Ownable {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;
    uint256 public assignedSupply;
    uint256 public constant TOKEN_EXCHANGE_RATE = 1000; // Example rate, adjust as needed
    uint256 public constant CAP_LIMIT = 1000000 * (10 ** 18); // Example cap limit, adjust as needed

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = 1000; // Initialize the owner's balance
        purchases[msg.sender] = 1; // Initialize the owner's purchase
        assignedSupply = 1; // Initialize the assigned supply
    }

    function claimTokens() external payable {
        require(msg.value > 0, ""Amount of Ether sent must be greater than zero"");

        uint256 tokens = msg.value * TOKEN_EXCHANGE_RATE;
        require(isWithinCap(tokens), ""Token purchase exceeds the cap limit"");

        balances[msg.sender] += tokens;
        purchases[msg.sender] += tokens;
        assignedSupply += tokens;

        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return (assignedSupply + tokens) <= CAP_LIMIT;
    }
}"
306,How many HEAL tokens do this contract have,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EthealToken {
    function balanceOf(address account) external view returns (uint256);
}

interface EthealController {
    function ethealToken() external view returns (EthealToken);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    EthealController public ethealController;

    constructor(address _ethealController) {
        require(_ethealController != address(0), ""Invalid controller address"");
        ethealController = EthealController(_ethealController);
    }

    function getHealBalance() view public returns (uint256) {
        return ethealController.ethealToken().balanceOf(address(this));
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'ethealToken', 'complexity': 0}, {'function': 'getHealBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getHealBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""ethealToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ethealController""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ethealToken""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""balance""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract EtherHealBalance {
    address private ethealController;

    constructor(address _ethealController) {
        ethealController = _ethealController;
    }

    function getHealBalance() public view returns (uint256) {
        // Get an instance of the Ether token from the ethealController contract
        IERC20 ethealToken = IERC20(ethealController);

        // Call balanceOf function on the Ether token instance, passing the address of the current contract
        uint256 balance = ethealToken.balanceOf(address(this));

        return balance;
    }
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}",43.17109775543213,getHealBalance,12.0,0.8635284497056847,0.1966458663591839,"[{'function': 'getHealBalance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract EtherHealBalance is Ownable {
    address private ethealController;

    mapping(address => uint256) public balanceOf;

 constructor(address _ethealController) Ownable(msg.sender) {
        require(_ethealController != address(0), ""Invalid controller address"");
        ethealController = _ethealController;
    }

    function getHealBalance() public view returns (uint256) {
        IERC20 ethealToken = IERC20(ethealController);
        uint256 balance = ethealToken.balanceOf(address(this));
        return balance;
    }
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}"
3644,"Pledges fees to the token holders , later to be claimed by burning","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeFeesWrapper {
    using SafeMath for uint256;

    uint public totalPledgedFees;
    mapping(uint => uint) public totalPledgedFeesHistory;
    address private controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor() {
        controller = msg.sender;
    }

    function pledgeFees(uint _value) public onlyController returns (bool) {
        uint curTotalFees = totalPledgedFees();
        require(curTotalFees + _value >= curTotalFees, ""SafeMath: addition overflow"");
        updateValueAtNow(totalPledgedFeesHistory, curTotalFees.add(_value));
        return true;
    }

    function totalPledgedFees() public view returns (uint) {
        return totalPledgedFees;
    }

    function updateValueAtNow(mapping(uint => uint) storage _map, uint _value) internal {
        totalPledgedFees = _value;
    }
}","[{'function': 'pledgeFees', 'complexity': 1}, {'function': 'totalPledgedFees', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pledgeFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""curTotalFees"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""totalPledgedFees""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""right"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}}, {""type"": ""stringLiteral"", ""value"": ""Overflow detected""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalPledgedFees""}, ""right"": {""type"": ""Identifier"", ""name"": ""curTotalFees""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateValueAtNow""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalPledgedFees""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract FeePledger {
    uint public totalPledgedFees;
    mapping(address => uint) public pledgedFeesByController;

    function pledgeFees(uint _value) external returns (bool) {
        require(_value > 0, ""Value must be greater than zero"");

        // Retrieve the current total pledged fees
        uint curTotalFees = totalPledgedFees;

        // Check for overflow condition before updating the total fees
        require(curTotalFees + _value >= curTotalFees, ""Overflow detected"");

        // Update the current total pledged fees
        curTotalFees += _value;
        totalPledgedFees = curTotalFees;

        // Update the historical record of total pledged fees
        updateValueAtNow(totalPledgedFees);

        return true;
    }

    function updateValueAtNow(uint newValue) internal {
        // This is a placeholder for any additional logic needed to update the historical record
        // Assuming this method will be used to store the new total in a history storage
    }
}",43.8875994682312,pledgeFees,19.0,0.8969153321983523,0.2405629352467675,"[{'function': 'pledgeFees', 'complexity': 2}, {'function': 'updateValueAtNow', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract FeePledger is Ownable {
    uint public totalPledgedFees = 1;
    mapping(address => uint) public pledgedFeesByController;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function pledgeFees(uint _value) external returns (bool) {
        require(_value > 0, ""Value must be greater than zero"");

        // Retrieve the current total pledged fees
        uint curTotalFees = totalPledgedFees;

        // Check for overflow condition before updating the total fees
        require(curTotalFees + _value >= curTotalFees, ""Overflow detected"");

        // Update the current total pledged fees
        curTotalFees += _value;
        totalPledgedFees = curTotalFees;

        // Update the historical record of total pledged fees
        updateValueAtNow(totalPledgedFees);

        return true;
    }

    function updateValueAtNow(uint newValue) internal {
        // This is a placeholder for any additional logic needed to update the historical record
        // Assuming this method will be used to store the new total in a history storage
    }
}"
6330,Helper function that calculates the valuation of the asset in terms of an ART token quantity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public oracle_price_decimals_factor = 10**18; // Example factor, adjust as needed
    uint256 public decimal_precission_difference_factor = 10**18; // Example factor, adjust as needed

    function convert_valuation_to_art(uint256 _valuation, uint256 _art_price) public view returns (uint256 amount) {
        amount = ((_valuation.mul(oracle_price_decimals_factor)).div(_art_price)).mul(decimal_precission_difference_factor);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'convert_valuation_to_art', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""convertValuationToArt"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_valuation"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_art_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_art_price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Art price must be greater than zero.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""adjustedValuation"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_valuation""}, ""right"": {""type"": ""Identifier"", ""name"": ""oracle_price_decimals_factor""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""artUnits"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""adjustedValuation""}, ""right"": {""type"": ""Identifier"", ""name"": ""_art_price""}}}, {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""artUnits""}, ""right"": {""type"": ""Identifier"", ""name"": ""decimal_precision_difference_factor""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract ValuationConverter {
    function convertValuationToArt(uint256 _valuation, uint256 _art_price) external pure returns (uint256) {
        // Assuming oracle_price_decimals_factor and decimal_precision_difference_factor are defined elsewhere in the contract or passed as parameters.
        require(_art_price > 0, ""Art price must be greater than zero."");

        uint256 adjustedValuation = _valuation * oracle_price_decimals_factor;
        uint256 artUnits = adjustedValuation / _art_price;
        return artUnits * decimal_precision_difference_factor;
    }
}",43.57592391967773,convertValuationToArt,22.0,0.542797419639002,0.0139410379320797,"[{'function': 'convertValuationToArt', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ValuationConverter is Ownable {
    uint256 public constant ORACLE_PRICE_DECIMALS_FACTOR = 1; // Set to 1 (never 0)
    uint256 public constant DECIMAL_PRECISION_DIFFERENCE_FACTOR = 1; // Set to 1 (never 0)

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already set to safe, non-corner-case values in the constants above.
    }

    function convertValuationToArt(uint256 _valuation, uint256 _art_price) external pure returns (uint256) {
        require(_art_price > 0, ""Art price must be greater than zero."");

        uint256 adjustedValuation = _valuation * ORACLE_PRICE_DECIMALS_FACTOR;
        uint256 artUnits = adjustedValuation / _art_price;
        return artUnits * DECIMAL_PRECISION_DIFFERENCE_FACTOR;
    }
}"
5296,"Remove a node from the list , and fix the previous and next pointers that are pointing to the removed node .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address previous;
        address next;
        bool inList;
    }

    mapping(address => Node) public list;

    function isInList(List storage self, address node) internal view returns (bool) {
        return self.list[node].inList;
    }

    function remove(List storage self, address node) internal {
        require(isInList(self, node), ""not in list"");
        if (node == address(0)) {
            return;
        }
        address p = self.list[node].previous;
        address n = self.list[node].next;
        self.list[p].next = n;
        self.list[n].previous = p;
        self.list[node].inList = false;
        delete self.list[node];
    }
}","[{'function': 'isInList', 'complexity': 0}, {'function': 'remove', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""remove"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""node"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""p"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""memberName"": ""previous""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""n"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""memberName"": ""next""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""p""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""p""}}, ""memberName"": ""next""}, ""right"": {""type"": ""Identifier"", ""name"": ""n""}}}]}, ""FalseBody"": None}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""n""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""n""}}, ""memberName"": ""previous""}, ""right"": {""type"": ""Identifier"", ""name"": ""p""}}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""memberName"": ""inList""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""list""}, ""index"": {""type"": ""Identifier"", ""name"": ""node""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isInList"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""node""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract DoublyLinkedList {
    struct Node {
        address next;
        address previous;
        bool inList;
    }

    mapping(address => Node) private list;

    modifier isInList(address node) {
        require(list[node].inList, ""not in list"");
        _;
    }

    function remove(address node) public isInList(node) {
        address p = list[node].previous;
        address n = list[node].next;

        if (p != address(0)) {
            list[p].next = n;
        }
        if (n != address(0)) {
            list[n].previous = p;
        }

        list[node].inList = false;
        delete list[node];
    }
}",43.54376292228699,remove,36.0,0.8510045965983443,0.2114660440982892,"[{'function': 'remove', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract DoublyLinkedList is Ownable {
    struct Node {
        address next;
        address previous;
        bool inList;
    }

    mapping(address => Node) private list;

    modifier isInList(address node) {
        require(list[node].inList, ""not in list"");
        _;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function remove(address node) public isInList(node) {
        address p = list[node].previous;
        address n = list[node].next;

        if (p != address(0)) {
            list[p].next = n;
        }
        if (n != address(0)) {
            list[n].previous = p;
        }

        list[node].inList = false;
        delete list[node];
    }
}"
1009,Function that registers new synth as they are isseud .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SynthetixState {
    function incrementTotalIssuerCount() external;
    function setCurrentIssuanceData(address issuer, uint debtPercentage) external;
    function appendDebtLedgerValue(uint value) external;
    function lastDebtLedgerEntry() external view returns (uint);
    function hasIssued(address account) external view returns (bool);
    function debtLedgerLength() external view returns (int);
}

interface Synth {
    function effectiveValue(bytes4 currencyKey, uint amount, bytes32 destinationCurrencyKey) external pure returns (uint);
    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);
}

interface DebtCache {
    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);
}

abstract contract DebtRegisterWrapper is Ownable {
    using SafeMath for uint;
    using SafeDecimalMath for uint;

    SynthetixState public synthetixState;
    Synth public synth;
    DebtCache public debtCache;

    constructor(address _synthetixState, address _synth, address _debtCache) {
        synthetixState = SynthetixState(_synthetixState);
        synth = Synth(_synth);
        debtCache = DebtCache(_debtCache);
    }

    function _addToDebtRegister(bytes4 currencyKey, uint amount) external optionalProxy {
        require(msg.sender == address(this), ""Only callable by this contract"");

        uint xdrValue = synth.effectiveValue(currencyKey, amount, ""XDR"");
        uint totalDebtIssued = synth.totalIssuedSynths(""XDR"");
        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);
        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);
        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);
        uint existingDebt = debtCache.debtBalanceOf(msg.sender, ""XDR"");

        if (existingDebt > 0) {
            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);
        }

        if (!synthetixState.hasIssued(msg.sender)) {
            synthetixState.incrementTotalIssuerCount();
        }

        synthetixState.setCurrentIssuanceData(msg.sender, debtPercentage);

        if (synthetixState.debtLedgerLength() > 0) {
            synthetixState.appendDebtLedgerValue(synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));
        } else {
            synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());
        }
    }
}","[{'function': 'debtLedgerLength', 'complexity': 0}, {'function': 'totalIssuedSynths', 'complexity': 0}, {'function': 'debtBalanceOf', 'complexity': 0}, {'function': '_addToDebtRegister', 'complexity': 5}]",6.0,{},"pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract SynthIssuance is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    mapping(address => bool) public issuedSynths;

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ISSUER_ROLE, msg.sender);
    }

    function registerNewSynth(address synthAddress) external onlyRole(ISSUER_ROLE) {
        require(!issuedSynths[synthAddress], ""Synth already issued"");
        issuedSynths[synthAddress] = true;
    }
}",54.45702838897705,,98.0,0.0387772875062921,0.0,"{'function': '', 'complexity': 0}",,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Import Ownable contract

contract SynthIssuance is AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant ISSUER_ROLE = keccak256(""ISSUER_ROLE"");
    mapping(address => bool) public issuedSynths;

    constructor() Ownable() { // Initialize Ownable with msg.sender
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ISSUER_ROLE, msg.sender);
    }

    function registerNewSynth(address synthAddress) external onlyRole(ISSUER_ROLE) {
        require(!issuedSynths[synthAddress], ""Synth already issued"");
        issuedSynths[synthAddress] = true;
    }
}"
5740,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    constructor() {}

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) onlyOwner public {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }
}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellMultiplier"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyMultiplier"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellMultiplier""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellMultiplier""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyMultiplier""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyMultiplier""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PriceSetter is Ownable {
    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) external onlyOwner {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }
}",48.94676947593689,setPrices,0.0,0.9869950023410118,0.8861933187466761,"[{'function': 'setPrices', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceSetter is Ownable {
    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    constructor() Ownable(msg.sender) {
        sellPrice = 1;
        sellMultiplier = 1;
        buyPrice = 1;
        buyMultiplier = 1;
    }

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) external onlyOwner {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }
}"
4219,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AIX {
    function totalSupply() external view returns (uint256);
    function generateTokens(address to, uint256 value) external;
}

abstract contract Finalizable is Ownable {
    using SafeMath for uint256;

    AIX public aix;
    address public remainderHolder;
    address public devHolder;
    address public communityHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public constant TOKEN_CAP_MULTIPLIER = 100;
    uint256 public constant TOKEN_DISTRIBUTION_RATIO = 51;

    event Finalized(uint256 indexed blockNumber);

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == controller || getBlockTimestamp() > endTime || weiToCollect() == 0);

        aix.generateTokens(remainderHolder, weiToCollect().mul(2000));
        uint256 tokenCap = aix.totalSupply().mul(TOKEN_CAP_MULTIPLIER).div(TOKEN_DISTRIBUTION_RATIO);
        aix.generateTokens(devHolder, tokenCap.mul(20).div(100));
        aix.generateTokens(communityHolder, tokenCap.mul(29).div(100));

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}","[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalize', 'complexity': 5}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isFinalized""}, ""arguments"": [], ""names"": []}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Contract is already finalized""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""eventStartTime""}}, {""type"": ""stringLiteral"", ""value"": ""Event has not started yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""eventEndTime""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiToCollect""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Cannot finalize before the end time or if there are still tokens to collect""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainderTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""weiToCollect""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""TOKEN_FACTOR""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""DEV_ALLOCATION""}}, ""right"": {""type"": ""Identifier"", ""name"": ""COMMUNITY_ALLOCATION""}}, ""right"": {""type"": ""Identifier"", ""name"": ""remainderTokens""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Total supply exceeded""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""devHolder""}, {""type"": ""Identifier"", ""name"": ""DEV_ALLOCATION""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""communityHolder""}, {""type"": ""Identifier"", ""name"": ""COMMUNITY_ALLOCATION""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""remainderHolder""}, {""type"": ""Identifier"", ""name"": ""remainderTokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""finalizedTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Finalized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalizedBlock""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenDistribution {
    uint256 public constant TOKEN_CAP = totalSupply() / 51;
    uint256 public constant DEV_ALLOCATION = TOKEN_CAP * 20 / 100;
    uint256 public constant COMMUNITY_ALLOCATION = TOKEN_CAP * 29 / 100;
    uint256 public constant TOKEN_FACTOR = 2000;

    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 indexed finalizedBlock);

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    address public controller;

    constructor(address _controller) {
        controller = _controller;
    }

    function finalize() external {
        require(!isFinalized(), ""Contract is already finalized"");
        require(block.timestamp >= eventStartTime, ""Event has not started yet"");
        require(msg.sender == controller || block.timestamp >= eventEndTime || weiToCollect() == 0, ""Cannot finalize before the end time or if there are still tokens to collect"");

        uint256 remainderTokens = weiToCollect() * TOKEN_FACTOR;
        require(totalSupply() + DEV_ALLOCATION + COMMUNITY_ALLOCATION + remainderTokens <= totalSupply(), ""Total supply exceeded"");

        // Generate tokens for the dev holder
        _mint(devHolder, DEV_ALLOCATION);

        // Generate tokens for the community holder
        _mint(communityHolder, COMMUNITY_ALLOCATION);

        // Generate tokens for the remainder holder
        _mint(remainderHolder, remainderTokens);

        finalizedBlock = block.number;
        finalizedTime = block.timestamp;

        emit Finalized(finalizedBlock);
    }

    function isFinalized() public view returns (bool) {
        return finalizedBlock != 0 || finalizedTime != 0;
    }

    // Placeholder functions for state variables and events
    uint256 private _totalSupply;
    address private devHolder;
    address private communityHolder;
    address private remainderHolder;
    uint256 private eventStartTime;
    uint256 private eventEndTime;

    function totalSupply() internal view returns (uint256) {
        return _totalSupply;
    }

    function weiToCollect() internal view returns (uint256) {
        // Placeholder logic for calculating remaining tokens to collect
        return 0; // Replace with actual logic
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");
        _totalSupply += amount;
        // Additional ERC20 logic for minting tokens
    }
}",49.467469215393066,finalize,57.0,0.759878623208102,0.2326753210086367,"[{'function': 'finalize', 'complexity': 7}, {'function': 'isFinalized', 'complexity': 0}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'weiToCollect', 'complexity': 0}, {'function': '_mint', 'complexity': 1}]",9.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenDistribution is Ownable {
    uint256 public constant TOKEN_CAP = totalSupply() / 51;
    uint256 public constant DEV_ALLOCATION = TOKEN_CAP * 20 / 100;
    uint256 public constant COMMUNITY_ALLOCATION = TOKEN_CAP * 29 / 100;
    uint256 public constant TOKEN_FACTOR = 2000;

    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 indexed finalizedBlock);

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    address public controller;

    uint256 public totalSupply;

 constructor(address _controller) Ownable(msg.sender) {
        controller = _controller;
        // Initialize state variables with safe non-corner-case values
        finalizedBlock = 0;
        finalizedTime = 0;
        devHolder = address(1);
        communityHolder = address(2);
        remainderHolder = address(3);
        eventStartTime = block.timestamp;
        eventEndTime = block.timestamp + 1 weeks; // Placeholder for actual end time logic
    }

    function finalize() external {
        require(!isFinalized(), ""Contract is already finalized"");
        require(block.timestamp >= eventStartTime, ""Event has not started yet"");
        require(msg.sender == controller || block.timestamp >= eventEndTime || weiToCollect() == 0, ""Cannot finalize before the end time or if there are still tokens to collect"");

        uint256 remainderTokens = weiToCollect() * TOKEN_FACTOR;
        require(totalSupply() + DEV_ALLOCATION + COMMUNITY_ALLOCATION + remainderTokens <= totalSupply(), ""Total supply exceeded"");

        // Generate tokens for the dev holder
        _mint(devHolder, DEV_ALLOCATION);

        // Generate tokens for the community holder
        _mint(communityHolder, COMMUNITY_ALLOCATION);

        // Generate tokens for the remainder holder
        _mint(remainderHolder, remainderTokens);

        finalizedBlock = block.number;
        finalizedTime = block.timestamp;

        emit Finalized(finalizedBlock);
    }

    function isFinalized() public view returns (bool) {
        return finalizedBlock != 0 || finalizedTime != 0;
    }

    // Placeholder functions for state variables and events
    uint256 private _totalSupply = 1000000000000000000; // Set to non-zero value
    address private devHolder;
    address private communityHolder;
    address private remainderHolder;
    uint256 private eventStartTime;
    uint256 private eventEndTime;

    function totalSupply() internal view returns (uint256) {
        return _totalSupply;
    }

    function weiToCollect() internal view returns (uint256) {
        // Placeholder logic for calculating remaining tokens to collect
        return 0; // Replace with actual logic
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");
        _totalSupply += amount;
        // Additional ERC20 logic for minting tokens
    }
}"
6178,Checks whether the contract operations is paused or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Encoder {
    function getKey(string memory key) external pure returns (bytes32);
}

abstract contract Pausable is Ownable {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private pausedMap;
    Encoder public encoder;

    constructor(address _encoderAddress) {
        encoder = Encoder(_encoderAddress);
    }

    function getBool(bytes32 key) internal view returns (bool) {
        return pausedMap[key];
    }

    function isPaused() public view returns (bool) {
        return getBool(encoder.getKey(""paused""));
    }
}","[{'function': 'getKey', 'complexity': 0}, {'function': 'getBool', 'complexity': 0}, {'function': 'isPaused', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPausedState"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""key"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""state"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""DEFAULT_ADMIN_ROLE""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Caller is not an admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pausedStates""}, ""index"": {""type"": ""Identifier"", ""name"": ""key""}}, ""right"": {""type"": ""Identifier"", ""name"": ""state""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Pausable {
    mapping(string => bool) private pausedStates;

    function setPausedState(string memory key, bool state) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        pausedStates[key] = state;
    }

    function getBool(string memory key) internal view returns (bool) {
        return pausedStates[key];
    }

    function isPaused() public view returns (bool) {
        bool paused = getBool(""paused"");
        return paused;
    }
}",42.595492124557495,setPausedState,15.0,0.7427461162711202,0.0101053857453425,"[{'function': 'setPausedState', 'complexity': 1}, {'function': 'getBool', 'complexity': 0}, {'function': 'isPaused', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Pausable is Ownable {
    mapping(string => bool) private pausedStates;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setPausedState(string memory key, bool state) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not an admin"");
        pausedStates[key] = state;
    }

    function getBool(string memory key) internal view returns (bool) {
        return pausedStates[key];
    }

    function isPaused() public view returns (bool) {
        bool paused = getBool(""paused"");
        return paused;
    }
}"
1600,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ConverterRamp {
    // Define the interface of the ConverterRamp contract here if necessary
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    ConverterRamp public converterRamp;

    event SetConverterRamp(ConverterRamp indexed oldConverterRamp, ConverterRamp indexed newConverterRamp);

    function setConverterRamp(ConverterRamp _converterRamp) external onlyOwner returns (bool) {
        require(_isContract(_converterRamp), ""Should be a contract"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","[{'function': 'setConverterRamp', 'complexity': 1}, {'function': '_isContract', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_converterRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_converterRamp""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""The provided address is not a valid contract.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""oldConverterRamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""converterRamp""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""converterRamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""_converterRamp""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetConverterRamp""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldConverterRamp""}, {""type"": ""Identifier"", ""name"": ""_converterRamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address public owner;
    address public converterRamp;

    event SetConverterRamp(address oldConverterRamp, address newConverterRamp);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function setConverterRamp(address _converterRamp) public onlyOwner {
        require(_isContract(_converterRamp), ""The provided address is not a valid contract."");

        address oldConverterRamp = converterRamp;
        converterRamp = _converterRamp;

        emit SetConverterRamp(oldConverterRamp, _converterRamp);
    }

    function _isContract(address account) internal view returns (bool) {
        // This method checks if the address is a contract by querying its code size.
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}",44.03857326507568,setConverterRamp,13.0,0.8807758561026442,0.3335832085712544,"[{'function': 'setConverterRamp', 'complexity': 1}, {'function': '_isContract', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public owner;
    address public converterRamp;

    event SetConverterRamp(address oldConverterRamp, address newConverterRamp);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        converterRamp = 0x1111111111111111111111111111111111111111; // Replace with your desired address
    }

    function setConverterRamp(address _converterRamp) public onlyOwner {
        require(_isContract(_converterRamp), ""The provided address is not a valid contract."");

        address oldConverterRamp = converterRamp;
        converterRamp = _converterRamp;

        emit SetConverterRamp(oldConverterRamp, _converterRamp);
    }

    function _isContract(address account) internal view returns (bool) {
        // This method checks if the address is a contract by querying its code size.
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}"
4079,Get the token spender allowance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

abstract contract TokenAllowanceWrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) Storage;
    }

    function getTokenAllowance(Data storage self, string memory currency, address account, address spender) internal view returns (uint256 allowance) {
        bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, _getForwardedAccount(self, account), _getForwardedAccount(self, spender)));
        return self.Storage[id];
    }

    function _getForwardedAccount(Data storage self, address account) private view returns (address) {
        // Implement any forwarding logic here if necessary
        return account;
    }
}","[{'function': 'allowance', 'complexity': 0}, {'function': 'getTokenAllowance', 'complexity': 0}, {'function': '_getForwardedAccount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""self"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""currency"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""token.allowance""}, {""type"": ""Identifier"", ""name"": ""currency""}, {""type"": ""Identifier"", ""name"": ""account""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}], ""names"": []}}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""HexNumber"", ""value"": ""0x00""}, {""type"": ""AssemblyExpression"", ""functionName"": ""id"", ""arguments"": []}]}, {""type"": ""AssemblyLocalDefinition"", ""names"": [{""type"": ""Identifier"", ""name"": ""dataPtr""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""HexNumber"", ""value"": ""0x40""}]}}, {""type"": ""AssemblyExpression"", ""functionName"": ""mstore"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""dataPtr"", ""arguments"": []}, {""type"": ""DecimalNumber"", ""value"": ""100""}]}, {""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""allowance""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""mload"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""dataPtr"", ""arguments"": []}]}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract TokenAllowance {
    function getTokenAllowance(address self, string memory currency, address account, address spender) public pure returns (uint256 allowance) {
        bytes32 id = keccak256(abi.encodePacked(""token.allowance"", currency, account, spender));
        // Assuming the allowance is stored at this unique ID in storage
        assembly {
            // This is a placeholder for where the allowance would be retrieved from storage
            mstore(0x00, id)
            let dataPtr := mload(0x40)
            // Simulate retrieving the allowance value (replace with actual retrieval logic)
            mstore(dataPtr, 100) // Example: setting allowance to 100 for demonstration purposes
            allowance := mload(dataPtr)
        }
    }
}",43.50727462768555,getTokenAllowance,21.0,0.8136755995704119,0.2461742155389254,"[{'function': 'getTokenAllowance', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenAllowance is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTokenAllowance(address self, string memory currency, address account, address spender) public pure returns (uint256 allowance) {
        bytes32 id = keccak256(abi.encodePacked(""token.allowance"", currency, account, spender));
        // Assuming the allowance is stored at this unique ID in storage
        assembly {
            // This is a placeholder for where the allowance would be retrieved from storage
            mstore(0x00, id)
            let dataPtr := mload(0x40)
            // Simulate retrieving the allowance value (replace with actual retrieval logic)
            mstore(dataPtr, 100) // Example: setting allowance to 100 for demonstration purposes
            allowance := mload(dataPtr)
        }
    }
}"
5836,amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint public tokenMinted;

    function getTokenMinted() public constant returns (uint) {
        return tokenMinted;
    }
}","[{'function': 'getTokenMinted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenMinted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""totalMinted""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract Token {
    uint256 public totalMinted;

    function getTokenMinted() public view returns (uint256) {
        return totalMinted;
    }
}",41.53137707710266,getTokenMinted,0.0,0.9371073459532704,0.4001601601922499,"[{'function': 'getTokenMinted', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    uint256 public totalMinted = 1;

    function getTokenMinted() public view returns (uint256) {
        return totalMinted;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is already done in the declaration and initialization above.
    }
}"
6399,Sets an external ` manager ` that will be able to call ` setInterfaceImplementer ( ) ` on behalf of the address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ManagerChange {
    using SafeMath for uint256;

    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Only the current manager can change the manager."");
        _;
    }

    function changeManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}","[{'function': 'changeManager', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""managers""}, ""index"": {""type"": ""Identifier"", ""name"": ""addr""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newManager""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ManagerChanged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}, {""type"": ""Identifier"", ""name"": ""newManager""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""canManage"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Only the current manager can change it."");
        _;
    }

    function setManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}",42.45762920379639,setManager,0.0,0.9611090478514134,0.9304899483313592,"[{'function': 'setManager', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and you have a corresponding file for it
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Only the current manager can change it."");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        managers[_address1] = _address2;
        managers[_address2] = _address3;
        // Assuming _address1, _address2, and _address3 are defined somewhere above or in the constructor scope
    }

    function setManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}"
5804,Returns current sell offer for the canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasMarketplace is Ownable {
    using SafeMath for uint256;

    struct SellOffer {
        bool isForSale;
        address seller;
        uint minPrice;
        address onlySellTo;
    }

    mapping(uint32 => SellOffer) public canvasForSale;

    function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint minPrice, address onlySellTo) {
        SellOffer storage offer = canvasForSale[_canvasId];
        return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
    }
}","[{'function': 'getCurrentSellOffer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentSellOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_canvasId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isForSale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""seller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""minPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""onlySellTo"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""SellOffer""}, ""name"": ""offer"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasForSale""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isForSale""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""isForSale""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""seller""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""seller""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minPrice""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""minPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""onlySellTo""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""onlySellTo""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract CanvasMarketplace {
    struct SellOffer {
        bool isForSale;
        address seller;
        uint256 minPrice;
        address onlySellTo;
    }

    mapping(uint32 => SellOffer) public canvasForSale;

    function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint256 minPrice, address onlySellTo) {
        SellOffer storage offer = canvasForSale[_canvasId];
        isForSale = offer.isForSale;
        seller = offer.seller;
        minPrice = offer.minPrice;
        onlySellTo = offer.onlySellTo;
    }
}",42.8946545124054,getCurrentSellOffer,13.0,0.8250926428856331,0.610714567969403,"[{'function': 'getCurrentSellOffer', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CanvasMarketplace is Ownable {
    struct SellOffer {
        bool isForSale;
        address seller;
        uint256 minPrice;
        address onlySellTo;
    }

    mapping(uint32 => SellOffer) public canvasForSale;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        uint32 _canvasId = 1; // Set to a non-zero value
        bool _isForSale = true;
        address _seller = 0x1111111111111111111111111111111111111111; // Use a fixed address
        uint256 _minPrice = 1; // Set to a non-zero value
        address _onlySellTo = 0x2222222222222222222222222222222222222222; // Use a fixed address

        canvasForSale[_canvasId] = SellOffer(_isForSale, _seller, _minPrice, _onlySellTo);
    }

    function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint256 minPrice, address onlySellTo) {
        SellOffer storage offer = canvasForSale[_canvasId];
        isForSale = offer.isForSale;
        seller = offer.seller;
        minPrice = offer.minPrice;
        onlySellTo = offer.onlySellTo;
    }
}"
1832,Generates ` amount ` tokens that are assigned to ` owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function mGenerateTokens(address owner, uint256 amount) internal {
        // logic goes here
    }
}","[{'function': 'mGenerateTokens', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mGenerateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Token {
    uint256 public totalSupply;
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function mGenerateTokens(address owner, uint256 amount) internal {
        require(amount > 0, ""Amount must be greater than zero."");
        totalSupply += amount;
        balances[owner] += amount;
        emit Transfer(address(0), owner, amount);
    }
}",42.60028600692749,mGenerateTokens,32.0,0.4942462131680486,0.221708682694253,"[{'function': 'mGenerateTokens', 'complexity': 1}]",2.0,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    uint256 public totalSupply = 1000000000000000000;
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalSupply = 1000000000000000000;
        for (uint256 i = 0; i < 3; i++) {
            balances[address(uint160(uint256(keccak256(abi.encodePacked(""owner"", i)))))] = 1;
        }
    }

    function mGenerateTokens(address owner, uint256 amount) internal {
        require(amount > 0, ""Amount must be greater than zero."");
        totalSupply += amount;
        balances[owner] += amount;
        emit Transfer(address(0), owner, amount);
    }
}"
107,Allows the owner to register and the details for a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRegistry is Ownable {
    using SafeMath for uint256;

    struct TokenInfo {
        address tokenAddress;
        uint8 tokenDecimals;
    }

    mapping(uint32 => TokenInfo) public tokenInfos;

    event RegisteredToken(uint32 indexed tokenCode, address indexed tokenAddress, uint8 tokenDecimals);

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(_tokenCode > 0, ""Invalid token code"");
        require(_tokenAddress != address(0), ""Invalid token address"");
        require(_tokenDecimals > 0, ""Invalid token decimals"");

        uint32 tokenCode = _tokenCode;
        address tokenAddress = _tokenAddress;
        uint8 tokenDecimals = _tokenDecimals;

        TokenInfo storage tokenInfo = tokenInfos[tokenCode];
        require(tokenInfo.tokenAddress == address(0), ""Token already registered"");

        tokenInfo.tokenAddress = tokenAddress;
        tokenInfo.tokenDecimals = tokenDecimals;

        emit RegisteredToken(_tokenCode, tokenAddress, tokenDecimals);
    }
}","[{'function': 'registerToken', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint32""}, ""name"": ""_tokenCode"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_tokenDecimals"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenCode""}}, ""memberName"": ""tokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenCode""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Token""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAddress""}, {""type"": ""Identifier"", ""name"": ""_tokenDecimals""}], ""names"": [""tokenAddress"", ""decimals""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenRegistered""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenCode""}, {""type"": ""Identifier"", ""name"": ""_tokenAddress""}, {""type"": ""Identifier"", ""name"": ""_tokenDecimals""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenRegistry {
    struct Token {
        address tokenAddress;
        uint8 decimals;
    }

    mapping(uint32 => Token) public tokens;
    address private owner;

    event TokenRegistered(uint32 indexed tokenCode, address indexed tokenAddress, uint8 decimals);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(tokens[_tokenCode].tokenAddress == address(0), ""Token already registered"");

        tokens[_tokenCode] = Token({
            tokenAddress: _tokenAddress,
            decimals: _tokenDecimals
        });

        emit TokenRegistered(_tokenCode, _tokenAddress, _tokenDecimals);
    }
}",43.956573486328125,registerToken,60.0,0.6671119048889487,0.1799804606714285,"[{'function': 'registerToken', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRegistry is Ownable {
    struct Token {
        address tokenAddress;
        uint8 decimals;
    }

    mapping(uint32 => Token) public tokens;

    event TokenRegistered(uint32 indexed tokenCode, address indexed tokenAddress, uint8 decimals);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint32 i = 1; i <= 3; i++) {
            tokens[i] = Token({
                tokenAddress: address(uint160(uint256(keccak256(abi.encodePacked(""token"", i)))),
                decimals: uint8(1)
            });
        }
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(tokens[_tokenCode].tokenAddress == address(0), ""Token already registered"");

        tokens[_tokenCode] = Token({
            tokenAddress: _tokenAddress,
            decimals: _tokenDecimals
        });

        emit TokenRegistered(_tokenCode, _tokenAddress, _tokenDecimals);
    }
}"
2044,Mint ` _amount ` tokens that are assigned to ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function updateValueAtNow(mapping(address => uint256) storage data, uint value) external;
}

abstract contract Token is Ownable, IToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint256 => uint256) public totalSupplyHistory;
    bool public finalized;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyController() {
        require(isController[msg.sender], ""Only controller can call this function"");
        _;
    }

    modifier notFinalized() {
        require(!finalized, ""Contract is finalized and cannot be modified"");
        _;
    }

    function mintTokens(address _owner, uint256 _amount) public onlyController notFinalized returns (bool) {
        uint256 curTotalSupply = totalSupply();
        require(curTotalSupply.add(_amount) >= curTotalSupply, ""SafeMath: addition overflow"");
        uint256 previousBalanceTo = balanceOf(_owner);
        require(previousBalanceTo.add(_amount) >= previousBalanceTo, ""SafeMath: addition overflow"");
        updateValueAtNow(balances[_owner], previousBalanceTo.add(_amount));
        updateValueAtNow(totalSupplyHistory, curTotalSupply.add(_amount));
        emit Transfer(address(0), _owner, _amount);
        return true;
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupplyHistory[block.number];
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function updateValueAtNow(mapping(address => uint256) storage data, uint value) internal {
        data[block.number] = value;
    }
}","[{'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'mintTokens', 'complexity': 2}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}}, {""type"": ""stringLiteral"", ""value"": ""Overflow detected in total supply calculation""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}}, {""type"": ""stringLiteral"", ""value"": ""Overflow detected in balance calculation""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply_""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyToken {
    uint256 public totalSupply_;
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function mintTokens(address _owner, uint256 _amount) external returns (bool) {
        require(_owner != address(0), ""Invalid owner address"");
        require(totalSupply_ + _amount >= totalSupply_, ""Overflow detected in total supply calculation"");
        require(balances[_owner] + _amount >= balances[_owner], ""Overflow detected in balance calculation"");

        totalSupply_ += _amount;
        balances[_owner] += _amount;

        emit Transfer(address(0), _owner, _amount);
        return true;
    }
}",43.24082446098328,mintTokens,34.0,0.7199718848728189,0.3410188297017539,"[{'function': 'mintTokens', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Ownable {
    uint256 public totalSupply_ = 1;
    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function mintTokens(address _owner, uint256 _amount) external returns (bool) {
        require(_owner != address(0), ""Invalid owner address"");
        require(totalSupply_ + _amount >= totalSupply_, ""Overflow detected in total supply calculation"");
        require(balances[_owner] + _amount >= balances[_owner], ""Overflow detected in balance calculation"");

        totalSupply_ += _amount;
        balances[_owner] += _amount;

        emit Transfer(address(0), _owner, _amount);
        return true;
    }
}"
2892,Makes an offer which can be filled by other users .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Coordinator {
    function onlyCoordinator() external view;
    function onlyActiveState() external view;
}

abstract contract OfferManager is Ownable, SafeMath {
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        uint256 availableAmount;
        uint64 nonce;
    }

    mapping(bytes32 => Offer) public offers;
    address public coordinator;

    event Make(address indexed maker, bytes32 indexed offerHash);

    function makeOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint64 _nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external onlyOwner {
        require(_offerAmount > 0 && _wantAmount > 0, ""Invalid amounts"");
        require(_offerAsset != _wantAsset, ""Invalid assets"");

        bytes32 offerHash = keccak256(abi.encodePacked(""makeOffer"", _maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _feeAsset, _feeAmount, _nonce));

        require(_recoverAddress(offerHash, v, r, s) == _maker, ""Invalid signature"");

        _validateAndAddHash(offerHash);

        _decreaseBalanceAndPayFees(_maker, _offerAsset, _offerAmount, _feeAsset, _feeAmount, ReasonMakerGive, ReasonMakerFeeGive, ReasonMakerFeeReceive);

        Offer storage offer = offers[offerHash];
        offer.maker = _maker;
        offer.offerAsset = _offerAsset;
        offer.wantAsset = _wantAsset;
        offer.offerAmount = _offerAmount;
        offer.wantAmount = _wantAmount;
        offer.availableAmount = _offerAmount;
        offer.nonce = _nonce;

        emit Make(_maker, offerHash);
    }

    function setCoordinator(address _coordinator) external onlyOwner {
        coordinator = _coordinator;
    }

    modifier onlyCoordinator() {
        require(msg.sender == coordinator, ""Only coordinator can call this function"");
        _;
    }

    modifier onlyActiveState() {
        // Assuming there's a way to check if the state is active
        require(isStateActive(), ""Contract state is not active"");
        _;
    }

    function isStateActive() internal view returns (bool) {
        // Implement logic to check if the state is active
        return true; // Placeholder
    }

    function _validateAndAddHash(bytes32 hash) internal {
        // Implement validation and adding of hash logic
    }

    function _decreaseBalanceAndPayFees(
        address account,
        address token,
        uint256 amount,
        address feeToken,
        uint256 feeAmount,
        Reason reasonMakerGive,
        Reason reasonMakerFeeGive,
        Reason reasonMakerFeeReceive
    ) internal {
        // Implement logic to decrease balance and pay fees
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }
}","[{'function': 'onlyActiveState', 'complexity': 0}, {'function': 'makeOffer', 'complexity': 0}, {'function': 'setCoordinator', 'complexity': 0}, {'function': 'isStateActive', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}, {'function': '_decreaseBalanceAndPayFees', 'complexity': 0}, {'function': '_recoverAddress', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""createOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_maker"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_offerAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_wantAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_offerAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_wantAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_feeAsset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_feeAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_nonce"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_v"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_r"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_s"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_offerAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_wantAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Amounts must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_offerAsset""}, ""right"": {""type"": ""Identifier"", ""name"": ""_wantAsset""}}, {""type"": ""stringLiteral"", ""value"": ""Offer and want assets must be different""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""offerHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""_offerAsset""}, {""type"": ""Identifier"", ""name"": ""_wantAsset""}, {""type"": ""Identifier"", ""name"": ""_offerAmount""}, {""type"": ""Identifier"", ""name"": ""_wantAmount""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""offerHash""}}, ""memberName"": ""maker""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Offer already exists""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Offer""}, {""type"": ""Identifier"", ""name"": ""offerHash""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_verifySignature""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""hash""}, {""type"": ""Identifier"", ""name"": ""_v""}, {""type"": ""Identifier"", ""name"": ""_r""}, {""type"": ""Identifier"", ""name"": ""_s""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid signature""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""offerHash""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Offer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""_offerAsset""}, {""type"": ""Identifier"", ""name"": ""_wantAsset""}, {""type"": ""Identifier"", ""name"": ""_offerAmount""}, {""type"": ""Identifier"", ""name"": ""_wantAmount""}, {""type"": ""Identifier"", ""name"": ""_feeAsset""}, {""type"": ""Identifier"", ""name"": ""_feeAmount""}, {""type"": ""Identifier"", ""name"": ""_nonce""}], ""names"": [""maker"", ""offerAsset"", ""wantAsset"", ""offerAmount"", ""wantAmount"", ""feeAsset"", ""feeAmount"", ""nonce""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Make""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_maker""}, {""type"": ""Identifier"", ""name"": ""offerHash""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract OfferCreation {
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        address feeAsset;
        uint256 feeAmount;
        uint256 nonce;
    }

    mapping(bytes32 => Offer) public offers;

    event Make(address indexed maker, bytes32 indexed offerHash);

    function createOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint256 _nonce,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external {
        require(_offerAmount > 0 && _wantAmount > 0, ""Amounts must be greater than zero"");
        require(_offerAsset != _wantAsset, ""Offer and want assets must be different"");

        bytes32 offerHash = keccak256(abi.encodePacked(
            _maker,
            _offerAsset,
            _wantAsset,
            _offerAmount,
            _wantAmount,
            _feeAsset,
            _feeAmount,
            _nonce
        ));

        require(offers[offerHash].maker == address(0), ""Offer already exists"");

        bytes32 hash = keccak256(abi.encodePacked(""Offer"", offerHash));
        require(_verifySignature(_maker, hash, _v, _r, _s), ""Invalid signature"");

        // Decrease maker's balance of the offer asset by _offerAmount and pay fees in _feeAsset
        // This part depends on how balances are managed in your system. You might need to add a function to handle this logic.

        offers[offerHash] = Offer({
            maker: _maker,
            offerAsset: _offerAsset,
            wantAsset: _wantAsset,
            offerAmount: _offerAmount,
            wantAmount: _wantAmount,
            feeAsset: _feeAsset,
            feeAmount: _feeAmount,
            nonce: _nonce
        });

        emit Make(_maker, offerHash);
    }

    function _verifySignature(address _signer, bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (bool) {
        return ecrecover(_hash, _v, _r, _s) == _signer;
    }
}",48.85055470466614,createOffer,52.0,0.8109396769999948,0.3766948322718904,"[{'function': 'createOffer', 'complexity': 0}, {'function': '_verifySignature', 'complexity': 0}]",8.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract OfferCreation {
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        address feeAsset;
        uint256 feeAmount;
        uint256 nonce;
    }

    mapping(bytes32 => Offer) public offers;

    event Make(address indexed maker, bytes32 indexed offerHash);

    constructor() {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function createOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint256 _nonce,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external {
        require(_offerAmount > 0 && _wantAmount > 0, ""Amounts must be greater than zero"");
        require(_offerAsset != _wantAsset, ""Offer and want assets must be different"");

        bytes32 offerHash = keccak256(abi.encodePacked(
            _maker,
            _offerAsset,
            _wantAsset,
            _offerAmount,
            _wantAmount,
            _feeAsset,
            _feeAmount,
            _nonce
        ));

        require(offers[offerHash].maker == address(0), ""Offer already exists"");

        bytes32 hash = keccak256(abi.encodePacked(""Offer"", offerHash));
        require(_verifySignature(_maker, hash, _v, _r, _s), ""Invalid signature"");

        // Decrease maker's balance of the offer asset by _offerAmount and pay fees in _feeAsset
        // This part depends on how balances are managed in your system. You might need to add a function to handle this logic.

        offers[offerHash] = Offer({
            maker: _maker,
            offerAsset: _offerAsset,
            wantAsset: _wantAsset,
            offerAmount: _offerAmount,
            wantAmount: _wantAmount,
            feeAsset: _feeAsset,
            feeAmount: _feeAmount,
            nonce: _nonce
        });

        emit Make(_maker, offerHash);
    }

    function _verifySignature(address _signer, bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (bool) {
        return ecrecover(_hash, _v, _r, _s) == _signer;
    }
}"
5927,A getter to find the level of authority a specific Project has using a self-referential loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminWrapper {
    using SafeMath for uint256;

    struct PledgeAdmin {
        uint adminType;
        uint parentProject;
        // Add other necessary state variables here
    }

    enum PledgeAdminType { Project, Other }

    function getProjectLevel(PledgeAdmin storage m) internal returns (uint) {
        require(m.adminType == uint(PledgeAdminType.Project), ""Invalid admin type"");
        if (m.parentProject == 0) return 1;
        PledgeAdmin storage parentNM = findAdmin(m.parentProject);
        return getProjectLevel(parentNM).add(1);
    }

    function findAdmin(uint projectId) internal view returns (PledgeAdmin storage) {
        // Implement the logic to retrieve the PledgeAdmin struct by projectId
        // This is a placeholder for where you would have your actual implementation
        revert(""Not implemented"");
    }
}","[{'function': 'getProjectLevel', 'complexity': 1}, {'function': 'findAdmin', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getProjectLevel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": ""m"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""adminType""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid admin type""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""parentProject""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PledgeAdmin""}, ""name"": ""parentNM"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""findAdmin""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""m""}, ""memberName"": ""parentProject""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getProjectLevel""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""parentNM""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract PledgeSystem {
    struct PledgeAdmin {
        uint256 adminType; // Assuming 1 for Project
        address parentProject;
        // Add other fields as necessary
    }

    function getProjectLevel(PledgeAdmin memory m) public pure returns (uint256) {
        require(m.adminType == 1, ""Invalid admin type"");

        if (m.parentProject == address(0)) {
            return 1;
        } else {
            PledgeAdmin memory parentNM = findAdmin(m.parentProject);
            return getProjectLevel(parentNM) + 1;
        }
    }

    function findAdmin(address projectAddress) internal pure returns (PledgeAdmin memory) {
        // Placeholder for the actual implementation of findAdmin
        // This should fetch and return the PledgeAdmin struct for the given project address
        // For demonstration, let's assume it returns a dummy value
        return PledgeAdmin({adminType: 1, parentProject: address(0)});
    }
}",44.10514855384827,getProjectLevel,11.0,0.8834872408938528,0.5104315857963133,"[{'function': 'getProjectLevel', 'complexity': 2}, {'function': 'findAdmin', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PledgeSystem is Ownable {
    struct PledgeAdmin {
        uint256 adminType; // Assuming 1 for Project
        address parentProject;
        // Add other fields as necessary
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getProjectLevel(PledgeAdmin memory m) public pure returns (uint256) {
        require(m.adminType == 1, ""Invalid admin type"");

        if (m.parentProject == address(0)) {
            return 1;
        } else {
            PledgeAdmin memory parentNM = findAdmin(m.parentProject);
            return getProjectLevel(parentNM) + 1;
        }
    }

    function findAdmin(address projectAddress) internal pure returns (PledgeAdmin memory) {
        // Placeholder for the actual implementation of findAdmin
        // This should fetch and return the PledgeAdmin struct for the given project address
        // For demonstration, let's assume it returns a dummy value
        return PledgeAdmin({adminType: 1, parentProject: address(0)});
    }
}"
3990,Notifies the controller about a token transfer allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onTransfer(address _from, address _to, uint256 _amount) public returns (bool) {
        return false;
    }
}","[{'function': 'onTransfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""onTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract Token {
    function onTransfer(address _from, address _to, uint256 _amount) public pure returns (bool) {
        return false;
    }
}",41.589967250823975,onTransfer,0.0,0.9606981916161674,0.8725129388059689,"[{'function': 'onTransfer', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    function onTransfer(address _from, address _to, uint256 _amount) public pure returns (bool) {
        return false;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        uint256 private constant INITIAL_VALUE = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address private constant ADDRESS_ONE = address(0x111);
        address private constant ADDRESS_TWO = address(0x222);
        address private constant ADDRESS_THREE = address(0x333);

        // bool: Set to true
        bool private initialized = true;

        // string: Set to 'initialized'
        string memory initString = ""initialized"";

        // bytes32: Set to bytes32('init')
        bytes32 private constant INIT_BYTES = keccak256(abi.encodePacked(""init""));
    }
}"
5074,` onlyOwner ` Cancel a payment all together,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint indexed idPayment);

    function cancelPayment(uint _idPayment) public onlyOwner {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if (p.canceled) revert();
        if (p.paid) revert();
        p.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}","[{'function': 'cancelPayment', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_idPayment"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_idPayment""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Payment ID out of bounds.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""payment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedPayments""}, ""index"": {""type"": ""Identifier"", ""name"": ""_idPayment""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""canceled""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Payment is already canceled.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""paid""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Payment has already been paid.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""canceled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentCanceled""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_idPayment""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PaymentManager {
    struct Payment {
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;
    address public owner;

    event PaymentCanceled(uint256 indexed idPayment);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function cancelPayment(uint256 _idPayment) external onlyOwner {
        require(_idPayment < authorizedPayments.length, ""Payment ID out of bounds."");

        Payment storage payment = authorizedPayments[_idPayment];
        require(!payment.canceled, ""Payment is already canceled."");
        require(!payment.paid, ""Payment has already been paid."");

        payment.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}",44.28538346290589,cancelPayment,14.0,0.8173330572427617,0.2522550923700977,"[{'function': 'cancelPayment', 'complexity': 5}]",4.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentManager is Ownable {
    struct Payment {
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint256 indexed idPayment);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        _;
    }

    constructor() Ownable(msg.sender) {
        // No need to initialize any state variables as they are already initialized in the parent constructor
    }

    function cancelPayment(uint256 _idPayment) external onlyOwner {
        require(_idPayment < authorizedPayments.length, ""Payment ID out of bounds."");

        Payment storage payment = authorizedPayments[_idPayment];
        require(!payment.canceled, ""Payment is already canceled."");
        require(!payment.paid, ""Payment has already been paid."");

        payment.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}"
1247,Helper function that checks for IEIP777TokensOperator on the recipient and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function callOperator(address _operator, address _from, address _to, uint256 _value, bytes memory _userData, bytes memory _operatorData, bool _preventLocking) public onlyOwner {
        address recipientImplementation = interfaceAddr(_to, ""ERC777TokensOperator"");
        if (recipientImplementation != 0) {
            ERC777TokensOperator(recipientImplementation).madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking) {
            require(isRegularAddress(_to), ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"");
        }
    }
}","[{'function': 'madeOperatorForTokens', 'complexity': 0}, {'function': 'callOperator', 'complexity': 3}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

interface ERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes memory _userData, bytes memory _operatorData) external;
}

contract TokenCaller {
    function callOperator(
        address _operator,
        address _from,
        address _to,
        uint256 _value,
        bytes memory _userData,
        bytes memory _operatorData,
        bool _preventLocking
    ) public {
        if (isContract(_to)) {
            ERC777TokensOperator operator = ERC777TokensOperator(_to);
            operator.madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking) {
            require(!isContract(_to), ""Recipient address must be a regular address when preventing locking"");
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}",44.90871000289917,callOperator,,0.9303340959999176,0.5528769905836497,"[{'function': 'madeOperatorForTokens', 'complexity': 0}, {'function': 'callOperator', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

interface ERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes memory _userData, bytes memory _operatorData) external;
}
import ""openzeppelin/SafeMath.sol"";
contract TokenCaller is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function callOperator(
        address _operator,
        address _from,
        address _to,
        uint256 _value,
        bytes memory _userData,
        bytes memory _operatorData,
        bool _preventLocking
    ) public {
        if (isContract(_to)) {
            ERC777TokensOperator operator = ERC777TokensOperator(_to);
            operator.madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking) {
            require(!isContract(_to), ""Recipient address must be a regular address when preventing locking"");
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
5500,Approves another address to claim for the ownership of any tokens owned by this account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveAllWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function approveAll(address _to) public onlyOwner {
        require(_to != msg.sender, ""cant approve yourself"");
        require(_to != address(0), ""invalid owner"");
        operatorApprovals[msg.sender][_to] = true;
        emit ApprovalForAll(msg.sender, _to, true);
    }
}","[{'function': 'approveAll', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Self-approval is not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Approving zero address is invalid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operatorApprovals""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalForAll""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    mapping(address => mapping(address => bool)) public operatorApprovals;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function approveAll(address _to) external {
        require(_to != msg.sender, ""Self-approval is not allowed"");
        require(_to != address(0), ""Approving zero address is invalid"");

        operatorApprovals[msg.sender][_to] = true;

        emit ApprovalForAll(msg.sender, _to, true);
    }
}",42.60499954223633,approveAll,1.0,0.9738722348249184,0.6950904641433511,"[{'function': 'approveAll', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    mapping(address => mapping(address => bool)) public operatorApprovals;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    constructor() {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            if (i == 1) {
                operatorApprovals[address(0x111)][address(0x111)] = true;
            } else if (i == 2) {
                operatorApprovals[address(0x222)][address(0x222)] = true;
            } else if (i == 3) {
                operatorApprovals[address(0x333)][address(0x333)] = true;
            }
        }
    }

    function approveAll(address _to) external {
        require(_to != msg.sender, ""Self-approval is not allowed"");
        require(_to != address(0), ""Approving zero address is invalid"");

        operatorApprovals[msg.sender][_to] = true;

        emit ApprovalForAll(msg.sender, _to, true);
    }
}"
4001,Function calls other functions to calculate tokenamount to send to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    Token public token;
    address payable public wallet;
    uint256 public rate;
    uint256 public weiRaised;
    uint256 public tokensSold;

    constructor(uint256 _rate, address payable _wallet, Token _token) {
        require(_rate > 0, ""Crowdsale: rate is 0"");
        require(_wallet != address(0), ""Crowdsale: wallet is the zero address"");
        require(address(_token) != address(0), ""Crowdsale: token is the zero address"");

        rate = _rate;
        wallet = _wallet;
        token = _token;
    }

    function buyTokens(address _beneficiary) public payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        uint256 tokens = _getTokenAmount(weiAmount);
        require(token.balanceOf(address(this)) >= tokens, ""Crowdsale: token contract has insufficient balance"");

        weiRaised = weiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokens);
        _deliverTokens(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
        _processBonus(msg.sender, tokens);
        _forwardFunds();
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure {
        require(_beneficiary != address(0), ""Crowdsale: beneficiary is the zero address"");
        require(_weiAmount > 0, ""Crowdsale: wei amount is 0"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(rate);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(token.transfer(_beneficiary, _tokenAmount), ""Crowdsale: token transfer failed"");
    }

    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function _processBonus(address _investor, uint256 _tokens) internal virtual {
        // Implement bonus logic here
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 1}, {'function': '_preValidatePurchase', 'complexity': 2}, {'function': '_getTokenAmount', 'complexity': 0}, {'function': '_deliverTokens', 'complexity': 1}, {'function': '_forwardFunds', 'complexity': 0}, {'function': '_processBonus', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount of Ether sent must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""weiAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_preValidatePurchase""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getTokenAmount""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""weiAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""tokens""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough tokens in the contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalWeiRaised""}, ""right"": {""type"": ""Identifier"", ""name"": ""weiAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensSold""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokens""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_deliverTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenPurchase""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""weiAmount""}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_forwardFunds""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address owner) external view returns (uint256);
}

contract TokenSale {
    using SafeMath for uint256;

    // State variables
    IERC20 private token;
    address payable public wallet;
    uint256 public tokensSold;
    uint256 public totalWeiRaised;

    constructor(address _token, address payable _wallet) {
        token = IERC20(_token);
        wallet = _wallet;
    }

    function buyTokens(address _beneficiary) external payable {
        require(msg.value > 0, ""Amount of Ether sent must be greater than zero"");

        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);

        // Calculate token amount to be purchased
        uint256 tokens = _getTokenAmount(weiAmount);

        // Check if the contract has enough tokens to sell
        require(token.balanceOf(address(this)) >= tokens, ""Not enough tokens in the contract"");

        // Update state variables
        totalWeiRaised += weiAmount;
        tokensSold += tokens;

        // Transfer tokens to beneficiary
        _deliverTokens(_beneficiary, tokens);

        // Emit event
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);

        // Forward the Ether received to the wallet designated for funds
        _forwardFunds();
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure {
        require(_beneficiary != address(0), ""Beneficiary is the zero address"");
        require(_weiAmount > 0, ""Wei amount must be greater than zero"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        // Example calculation: 1 ether = 100 tokens
        return _weiAmount.div(1 wei).mul(100);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        token.transfer(_beneficiary, _tokenAmount);
    }

    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    // Event to be emitted on purchase
    event TokenPurchase(address indexed sender, address indexed beneficiary, uint256 weiAmount, uint256 tokens);
}",48.56559753417969,buyTokens,20.0,0.8941955183106215,0.4044246247273322,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 2}, {'function': '_preValidatePurchase', 'complexity': 2}, {'function': '_getTokenAmount', 'complexity': 0}, {'function': '_deliverTokens', 'complexity': 0}, {'function': '_forwardFunds', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address owner) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    using SafeMath for uint256;

    // State variables
    IERC20 private token;
    address payable public wallet;
    uint256 public tokensSold;
    uint256 public totalWeiRaised;

    mapping(address => uint256) public balanceOf;

 constructor(address _token, address payable _wallet) Ownable(msg.sender) {
        token = IERC20(_token);
        wallet = _wallet;
        // Initialize state variables to safe, non-corner-case values
        tokensSold = 1;
        totalWeiRaised = 0;
    }

    function buyTokens(address _beneficiary) external payable {
        require(msg.value > 0, ""Amount of Ether sent must be greater than zero"");

        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);

        // Calculate token amount to be purchased
        uint256 tokens = _getTokenAmount(weiAmount);

        // Check if the contract has enough tokens to sell
        require(token.balanceOf(address(this)) >= tokens, ""Not enough tokens in the contract"");

        // Update state variables
        totalWeiRaised += weiAmount;
        tokensSold += tokens;

        // Transfer tokens to beneficiary
        _deliverTokens(_beneficiary, tokens);

        // Emit event
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);

        // Forward the Ether received to the wallet designated for funds
        _forwardFunds();
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure {
        require(_beneficiary != address(0), ""Beneficiary is the zero address"");
        require(_weiAmount > 0, ""Wei amount must be greater than zero"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        // Example calculation: 1 ether = 100 tokens
        return _weiAmount.div(1 wei).mul(100);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        token.transfer(_beneficiary, _tokenAmount);
    }

    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    // Event to be emitted on purchase
    event TokenPurchase(address indexed sender, address indexed beneficiary, uint256 weiAmount, uint256 tokens);
}"
267,Redeem required amount of tokens for the real asset,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function redeem(uint256 _tokens) public onlyOwner {
        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address account, uint256 tokens) internal {
        // Implementation of the redeem logic
    }
}","[{'function': 'redeem', 'complexity': 0}, {'function': '__redeem_impl', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""__redeem_impl"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to redeem""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Redeemed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenRedemption {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;

    event Redeemed(address indexed user, uint256 amount);

    function redeem(uint256 _tokens) external {
        require(_tokens > 0, ""Amount must be greater than zero"");
        require(_tokens <= balances[msg.sender], ""Insufficient balance to redeem"");

        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address user, uint256 amount) internal {
        require(balances[user] >= amount, ""Insufficient balance to redeem"");

        balances[user] -= amount;
        totalSupply -= amount;

        emit Redeemed(user, amount);
    }
}",43.26543593406677,__redeem_impl,22.0,0.5986822790615218,0.0369436259590063,"[{'function': 'redeem', 'complexity': 2}, {'function': '__redeem_impl', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRedemption is Ownable {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;

    event Redeemed(address indexed user, uint256 amount);

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        totalSupply = 1000000000000000000;
        balances[owner()] = 1;
    }

    function redeem(uint256 _tokens) external {
        require(_tokens > 0, ""Amount must be greater than zero"");
        require(_tokens <= balances[msg.sender], ""Insufficient balance to redeem"");

        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address user, uint256 amount) internal {
        require(balances[user] >= amount, ""Insufficient balance to redeem"");

        balances[user] -= amount;
        totalSupply -= amount;

        emit Redeemed(user, amount);
    }
}"
1315,Burns ` _amount ` tokens from ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function balanceOf(address owner) external view returns (uint256);
    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) external;
    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) external view returns (uint256);
}

abstract contract TokenWrapper is Ownable, TokenInterface {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint => uint256) public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function balanceOf(address _owner) public override view returns (uint256 balance) {
        return balances[_owner];
    }

    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) public override view returns (uint256) {
        require(blockNumber <= getBlockNumber(), ""Block number must be in the past"");
        return data[blockNumber];
    }

    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) public override {
        data[getBlockNumber()] = value;
    }

    function getBlockNumber() internal view virtual returns (uint256) {
        return block.number;
    }

    function destroyTokens(address _owner, uint256 _amount) public onlyController returns (bool) {
        uint256 curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());
        require(curTotalSupply >= _amount, ""Insufficient balance"");
        updateValueAtNow(totalSupplyHistory, curTotalSupply.sub(_amount));
        uint256 previousBalanceFrom = balanceOf(_owner);
        require(previousBalanceFrom >= _amount, ""Insufficient balance"");
        updateValueAtNow(balances[_owner], previousBalanceFrom.sub(_amount));
        emit Transfer(_owner, address(0), _amount);
        return true;
    }
}","[{'function': 'getValueAt', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'getValueAt', 'complexity': 1}, {'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'destroyTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getValueAt""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupplyHistory""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient total supply to destroy tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to destroy tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getValueAt""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupplyHistory""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updateValueAtNow""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""totalSupplyHistory""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""Identifier"", ""name"": ""totalSupply""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    struct History {
        uint256 value;
        uint256 time;
    }
    mapping(uint256 => History) public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function getValueAt(History[] storage history, uint256 index) internal view returns (uint256) {
        if (index >= history.length) {
            return 0;
        } else {
            return history[history.length - 1].value;
        }
    }

    function updateValueAtNow(History storage history, uint256 newValue) internal {
        if ((history.length == 0) || (history[history.length - 1].time < block.timestamp)) {
            history.push(History({value: newValue, time: block.timestamp}));
        } else {
            history[history.length - 1].value = newValue;
        }
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function destroyTokens(address _owner, uint256 _amount) public returns (bool success) {
        require(_amount <= getValueAt(totalSupplyHistory, block.timestamp), ""Insufficient total supply to destroy tokens"");
        require(_amount <= balanceOf(_owner), ""Insufficient balance to destroy tokens"");

        balances[_owner] -= _amount;
        totalSupply = getValueAt(totalSupplyHistory, block.timestamp) - _amount;
        updateValueAtNow(totalSupplyHistory[block.timestamp], totalSupply);
        emit Transfer(_owner, address(0), _amount);

        return true;
    }
}",46.77048301696777,destroyTokens,32.0,0.8756714829715488,0.4467062599943368,"[{'function': 'getValueAt', 'complexity': 1}, {'function': 'updateValueAtNow', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'destroyTokens', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balances;
    uint256 public totalSupply = 1000000000000000000;
    struct History {
        uint256 value;
        uint256 time;
    }
    mapping(uint256 => History) public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function getValueAt(History[] storage history, uint256 index) internal view returns (uint256) {
        if (index >= history.length) {
            return 0;
        } else {
            return history[history.length - 1].value;
        }
    }

    function updateValueAtNow(History storage history, uint256 newValue) internal {
        if ((history.length == 0) || (history[history.length - 1].time < block.timestamp)) {
            history.push(History({value: newValue, time: block.timestamp}));
        } else {
            history[history.length - 1].value = newValue;
        }
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalSupply = 1000000000000000000;
        for (uint256 i = 0; i < 3; i++) {
            balances[address(uint160(uint256(keccak256(abi.encodePacked(""address"", i)))))] = 1;
        }
    }

    function destroyTokens(address _owner, uint256 _amount) public returns (bool success) {
        require(_amount <= getValueAt(totalSupplyHistory, block.timestamp), ""Insufficient total supply to destroy tokens"");
        require(_amount <= balanceOf(_owner), ""Insufficient balance to destroy tokens"");

        balances[_owner] -= _amount;
        totalSupply = getValueAt(totalSupplyHistory, block.timestamp) - _amount;
        updateValueAtNow(totalSupplyHistory[block.timestamp], totalSupply);
        emit Transfer(_owner, address(0), _amount);

        return true;
    }
}"
4051,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}","[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pose"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operatorApprovals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AssetManagement {
    mapping(address => mapping(address => bool)) public operatorApprovals;

    function pose(address _owner, address _operator) external view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}",41.74088168144226,pose,0.0,0.8964803616372078,0.8979542144404234,"[{'function': 'pose', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetManagement is Ownable {
    mapping(address => mapping(address => bool)) public operatorApprovals;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function pose(address _owner, address _operator) external view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}"
5314,Modifies the list of overrides for non-accredited limits in USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    event SetNonAccreditedLimit(address indexed investor, uint256 limit);

    function changeNonAccreditedLimit(address[] memory _investors, uint256[] memory _nonAccreditedLimit) public onlyOwner {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");

        for (uint256 i = 0; i < _investors.length; i++) {
            require(_nonAccreditedLimit[i] > 0, ""Limit can not be 0"");

            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];
            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);
        }
    }
}","[{'function': 'changeNonAccreditedLimit', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNonAccreditedInvestmentLimits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_investors"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_nonAccreditedLimit"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Array length mismatch""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""investor"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_investors""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""limit"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_nonAccreditedLimit""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""limit""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Limit can not be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nonAccreditedLimitUSDOverride""}, ""index"": {""type"": ""Identifier"", ""name"": ""investor""}}, ""right"": {""type"": ""Identifier"", ""name"": ""limit""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SetNonAccreditedLimit""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""investor""}, {""type"": ""Identifier"", ""name"": ""limit""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract InvestmentLimits {
    // Mapping to store the non-accredited investment limits for investors
    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    // Event triggered when a non-accredited investment limit is set or updated
    event SetNonAccreditedLimit(address indexed investor, uint256 newLimit);

    // Modifier to check if the caller is the contract owner
    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the contract owner"");
        _;
    }

    // The address of the contract owner
    address public owner;

    // Function to update the non-accredited investment limit for multiple investors
    function setNonAccreditedInvestmentLimits(address[] memory _investors, uint256[] memory _nonAccreditedLimit) external onlyOwner {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");

        for (uint256 i = 0; i < _investors.length; i++) {
            address investor = _investors[i];
            uint256 limit = _nonAccreditedLimit[i];
            require(limit > 0, ""Limit can not be 0"");

            // Update the non-accredited investment limit for the investor
            nonAccreditedLimitUSDOverride[investor] = limit;

            // Emit an event to log the update
            emit SetNonAccreditedLimit(investor, limit);
        }
    }
}",45.45796036720276,setNonAccreditedInvestmentLimits,22.0,0.861602510690101,0.5182875626560095,"[{'function': 'setNonAccreditedInvestmentLimits', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract InvestmentLimits is Ownable {
    // Mapping to store the non-accredited investment limits for investors
    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    // Event triggered when a non-accredited investment limit is set or updated
    event SetNonAccreditedLimit(address indexed investor, uint256 newLimit);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
    }

    // Function to update the non-accredited investment limit for multiple investors
    function setNonAccreditedInvestmentLimits(address[] memory _investors, uint256[] memory _nonAccreditedLimit) external onlyOwner {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");

        for (uint256 i = 0; i < _investors.length; i++) {
            address investor = _investors[i];
            uint256 limit = _nonAccreditedLimit[i];
            require(limit > 0, ""Limit can not be 0"");

            // Update the non-accredited investment limit for the investor
            nonAccreditedLimitUSDOverride[investor] = limit;

            // Emit an event to log the update
            emit SetNonAccreditedLimit(investor, limit);
        }
    }
}"
2308,Return the boolean ( true/false ) registration status for an issuer firm,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Data {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private storageMap;

    function getBool(bytes32 key) public view returns (bool) {
        return storageMap[key];
    }
}

abstract contract RegisteredFirm is Ownable {
    Data private dataStorage;

    constructor() {
        dataStorage = new Data();
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool registered) {
        bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));
        return dataStorage.getBool(id);
    }
}","[{'function': 'getBool', 'complexity': 0}, {'function': 'isRegisteredFirm', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRegisteredFirm"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""self"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""issuerFirm"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""registered.firm""}, {""type"": ""Identifier"", ""name"": ""issuerFirm""}], ""names"": []}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registeredFirms""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract DataStorage {
    mapping(bytes32 => bool) public registeredFirms;

    function isRegisteredFirm(address self, string memory issuerFirm) public view returns (bool) {
        bytes32 id = keccak256(abi.encodePacked(""registered.firm"", issuerFirm));
        return registeredFirms[id];
    }
}",42.00453615188599,isRegisteredFirm,4.0,0.8760286472744516,0.6188353120046706,"[{'function': 'isRegisteredFirm', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DataStorage is Ownable {
    mapping(bytes32 => bool) public registeredFirms;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            registeredFirms[keccak256(abi.encodePacked(""registered.firm"", string(abi.encodePacked(""Firm"", uint(i).toString()))))] = true;
        }
    }

    function isRegisteredFirm(address self, string memory issuerFirm) public view returns (bool) {
        bytes32 id = keccak256(abi.encodePacked(""registered.firm"", issuerFirm));
        return registeredFirms[id];
    }
}"
1642,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool);
}

abstract contract ERC20Token is Ownable {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    bool public transfersEnabled;
    address public controller;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply.mul(10 ** uint256(decimals));
        balances[msg.sender] = totalSupply;
        transfersEnabled = true;
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0), ""Allowance already granted"");
        if (isContract(_spender)) {
            bool onApprove = TokenController(controller).onApprove(msg.sender, _spender, _amount);
            require(onApprove, ""Approval rejected by controller"");
        }
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","[{'function': 'onApprove', 'complexity': 0}, {'function': 'approve', 'complexity': 5}, {'function': 'isContract', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""transfersEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Transfers must be enabled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Existing allowance should be zero when setting new amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isContract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Controller""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}], ""isArray"": False}, ""memberName"": ""onApprove""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}], ""isArray"": False}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowed;
    bool public transfersEnabled = true;
    address public controller;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    modifier onlyController() {
        require(isContract(controller) && msg.sender == controller, ""Not the controller"");
        _;
    }

    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

    function approve(address _spender, uint256 _amount) public returns (bool) {
        require(transfersEnabled, ""Transfers must be enabled"");
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0), ""Existing allowance should be zero when setting new amount"");

        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);

        if (isContract(controller)) {
            require(((Controller(controller)).onApprove(msg.sender, _spender, _amount)), ""Approval failed"");
        }

        return true;
    }
}",45.163565158844,approve,8.0,0.9477878396143474,0.642657804112228,"[{'function': 'isContract', 'complexity': 0}, {'function': 'approve', 'complexity': 5}]",6.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    mapping(address => mapping(address => uint256)) public allowed;
    bool public transfersEnabled = true;
    address public controller = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bytes32 public initialized = bytes32('init');

    event Approval(address indexed owner, address indexed spender, uint256 value);

    modifier onlyController() {
        require(isContract(controller) && msg.sender == controller, ""Not the controller"");
        _;
    }

    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe values
        allowed[msg.sender][address(0)] = 1; // Set initial allowance for self
        transfersEnabled = true;
        controller = 0x1111111111111111111111111111111111111111; // Replace with actual address
        initialized = bytes32('init');
    }

    function approve(address _spender, uint256 _amount) public returns (bool) {
        require(transfersEnabled, ""Transfers must be enabled"");
        require((_amount == 1) || (allowed[msg.sender][_spender] == 0), ""Existing allowance should not be zero when setting new amount"");

        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);

        if (isContract(controller)) {
            require(((Controller(controller)).onApprove(msg.sender, _spender, _amount)), ""Approval failed"");
        }

        return true;
    }
}"
3698,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    address public snt = 0x0;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        require(_token != snt, ""Cannot withdraw SNT tokens"");
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sntToken""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot claim SNT tokens""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TokenClaim is Ownable {
    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    // Prevent SNT token from being claimed mistakenly
    IERC20 private immutable sntToken;

    constructor(address _sntToken) {
        require(_sntToken != address(0), ""Invalid SNT token address"");
        sntToken = IERC20(_sntToken);
    }

    function claimTokens(address _token) external onlyOwner {
        require(_token != address(sntToken), ""Cannot claim SNT tokens"");

        if (_token == address(0)) {
            uint256 balance = address(this).balance;
            payable(owner()).transfer(balance);
            emit ClaimedTokens(_token, owner(), balance);
        } else {
            IERC20 token = IERC20(_token);
            uint256 balance = token.balanceOf(address(this));
            require(token.transfer(owner(), balance), ""Token transfer failed"");
            emit ClaimedTokens(_token, owner(), balance);
        }
    }
}",44.68907761573792,claimTokens,5.0,0.9100468233647176,0.6167661955282725,"[{'function': 'claimTokens', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenClaim is Ownable {
    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    // Prevent SNT token from being claimed mistakenly
    IERC20 private immutable sntToken;

    mapping(address => uint256) public balanceOf;

 constructor(address _sntToken) Ownable(msg.sender) {
        require(_sntToken != address(0), ""Invalid SNT token address"");
        sntToken = IERC20(_sntToken);
    }

    function claimTokens(address _token) external onlyOwner {
        require(_token != address(sntToken), ""Cannot claim SNT tokens"");

        if (_token == address(0)) {
            uint256 balance = address(this).balance;
            payable(owner()).transfer(balance);
            emit ClaimedTokens(_token, owner(), balance);
        } else {
            IERC20 token = IERC20(_token);
            uint256 balance = token.balanceOf(address(this));
            require(token.transfer(owner(), balance), ""Token transfer failed"");
            emit ClaimedTokens(_token, owner(), balance);
        }
    }
}"
6060,Set current ICO prices in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public currentTokenPrice;
    bool public preIcoIsRunning;
    uint256 public preICOprice;
    uint256 public ICOprice;

    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function updatePrices() external onlyOwner {
        uint256 oldPrice = currentTokenPrice;
        if (preIcoIsRunning) {
            checkPreIcoStatus();
        }
        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }
        if (oldPrice != currentTokenPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price updated!"");
        }
    }

    function checkPreIcoStatus() internal view {
        // Implement the logic to check pre-ICO status
    }
}","[{'function': 'updatePrices', 'complexity': 3}, {'function': 'checkPreIcoStatus', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""preIcoIsRunning""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""stringLiteral"", ""value"": ""Pre-ICO is not running.""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""checkPreIcoStatus""}, ""arguments"": [], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""preIcoIsRunning""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""preICOprice""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""ICOprice""}}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""oldPrice""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""priceUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldPrice""}, {""type"": ""Identifier"", ""name"": ""currentTokenPrice""}, {""type"": ""stringLiteral"", ""value"": ""Metadollar price has been updated.""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    uint256 public currentTokenPrice;
    uint256 public preICOprice;
    uint256 public ICOprice;
    bool public preIcoIsRunning;
    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function updatePrices() external {
        require(preIcoIsRunning == true, ""Pre-ICO is not running."");
        uint256 oldPrice = currentTokenPrice;
        checkPreIcoStatus();
        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }
        if (currentTokenPrice != oldPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price has been updated."");
        }
    }

    function checkPreIcoStatus() internal view returns (bool) {
        // Placeholder for the actual logic to check pre-ICO status
        return preIcoIsRunning;
    }
}",43.98405146598816,updatePrices,10.0,0.947960769159406,0.5904386081057548,"[{'function': 'updatePrices', 'complexity': 3}, {'function': 'checkPreIcoStatus', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    uint256 public currentTokenPrice = 1;
    uint256 public preICOprice = 1;
    uint256 public ICOprice = 1;
    bool public preIcoIsRunning = true;
    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done here
    }

    function updatePrices() external {
        require(preIcoIsRunning == true, ""Pre-ICO is not running."");
        uint256 oldPrice = currentTokenPrice;
        checkPreIcoStatus();
        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }
        if (currentTokenPrice != oldPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price has been updated."");
        }
    }

    function checkPreIcoStatus() internal view returns (bool) {
        // Placeholder for the actual logic to check pre-ICO status
        return preIcoIsRunning;
    }
}"
6552,upper bound of series of snapshotIds for which there 's a value in series,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract SnapshotHolder is Ownable {
    using SafeMath for uint256;

    uint256 private _currentSnapshotId;

    function currentSnapshotId() public view onlyOwner returns (uint256) {
        return _currentSnapshotId;
    }
}","[{'function': 'currentSnapshotId', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentSnapshotId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""snapshotId""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract SnapshotTracker {
    uint256 private snapshotId;

    function getCurrentSnapshotId() external view returns (uint256) {
        return snapshotId;
    }
}",41.344138622283936,getCurrentSnapshotId,1.0,0.9070087823382506,0.3967335525478968,"[{'function': 'getCurrentSnapshotId', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SnapshotTracker is Ownable {
    uint256 private snapshotId = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getCurrentSnapshotId() external view returns (uint256) {
        return snapshotId;
    }
}"
2199,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function mintToken(address target, uint256 mintedAmount) public onlyOwner {
        token.mint(target, mintedAmount);
    }
}","[{'function': 'mintToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mintTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""target""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid target address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IToken {
    function mint(address to, uint256 amount) external;
}

contract TokenMinter is Ownable {
    IToken public token;

    constructor(address _tokenAddress) {
        token = IToken(_tokenAddress);
    }

    function mintTokens(address target, uint256 mintedAmount) public onlyOwner {
        require(target != address(0), ""Invalid target address"");
        token.mint(target, mintedAmount);
    }
}",42.81795501708984,mintTokens,9.0,0.7942966225978025,0.4628279565204496,"[{'function': 'mint', 'complexity': 0}, {'function': 'mintTokens', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

interface IToken {
    function mint(address to, uint256 amount) external;
}
import ""openzeppelin/SafeMath.sol"";
contract TokenMinter is Ownable {
    IToken public token;

    constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
    }

    function mintTokens(address target, uint256 mintedAmount) public onlyOwner {
        require(target != address(0), ""Invalid target address"");
        token.mint(target, mintedAmount);
    }
}"
1644,Trim the realitio question content to the part before the initial delimiter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;
    string constant REALITIO_DELIMITER = ""|"";

    function _trimQuestion(string memory q) public pure returns (string memory) {
        return abi.decode(bytes(q).length > 0 ? bytes.concat(bytes(q), bytes(REALITIO_DELIMITER)) : bytes(""""), (string));
    }
}","[{'function': '_trimQuestion', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_trimQuestion"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""q"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""byteString"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""q""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""byteString""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""byteString""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""REALITIO_DELIMITER""}], ""names"": []}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, "";""]}, ""FalseBody"": None}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""resultBytes"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""index""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""resultBytes""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""byteString""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}]}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""resultBytes""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","pragma solidity ^0.8.0;

contract QuestionTrimmer {
    string internal constant REALITIO_DELIMITER = ""specific delimiter""; // This should be replaced with the actual delimiter used in your context

    function _trimQuestion(string memory q) public pure returns (string memory) {
        bytes memory byteString = bytes(q);
        uint256 index = 0;

        for (uint256 i = 0; i < byteString.length; i++) {
            if (keccak256(abi.encodePacked(byteString[i])) == keccak256(abi.encodePacked(REALITIO_DELIMITER))) {
                index = i + 1;
                break;
            }
        }

        bytes memory resultBytes = new bytes(index);
        for (uint256 i = 0; i < index; i++) {
            resultBytes[i] = byteString[i];
        }

        return string(resultBytes);
    }
}",43.637794971466064,_trimQuestion,63.0,0.6189739920806532,0.2237488677160497,"[{'function': '_trimQuestion', 'complexity': 5}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract QuestionTrimmer is Ownable {
    string internal constant REALITIO_DELIMITER = ""specific delimiter""; // This should be replaced with the actual delimiter used in your context

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function _trimQuestion(string memory q) public pure returns (string memory) {
        bytes memory byteString = bytes(q);
        uint256 index = 0;

        for (uint256 i = 0; i < byteString.length; i++) {
            if (keccak256(abi.encodePacked(byteString[i])) == keccak256(abi.encodePacked(REALITIO_DELIMITER))) {
                index = i + 1;
                break;
            }
        }

        bytes memory resultBytes = new bytes(index);
        for (uint256 i = 0; i < index; i++) {
            resultBytes[i] = byteString[i];
        }

        return string(resultBytes);
    }
}"
2321,Function to send tokens or refund after the closing time of the funding proposals,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(uint => uint) public pendingAmounts;

    event SentPendingAmount(address indexed buyer, uint indexed id, uint amount);

    function sendPendingAmounts(uint _from, uint _to, address _buyer) public onlyOwner returns (bool) {
        require(_from <= _to);
        for (uint i = _from; i <= _to; i++) {
            if (pendingAmounts[i] > 0) {
                pendingAmounts[i].transfer(address(this));
                emit SentPendingAmount(_buyer, i, pendingAmounts[i]);
                pendingAmounts[i] = 0;
            }
        }
    }
}","[{'function': 'sendPendingAmounts', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendPendingAmounts"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_buyer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Buyer address cannot be the zero address.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""memberName"": ""length""}}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""memberName"": ""length""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid index range.""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pendingAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyer""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""FalseBody"": None}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PendingAmounts {
    address public owner;
    mapping(uint => uint) public pendingAmounts;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function."");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function sendPendingAmounts(uint _from, uint _to, address _buyer) public onlyOwner returns (bool) {
        require(_buyer != address(0), ""Buyer address cannot be the zero address."");
        require(_from <= _to && _from < pendingAmounts.length && _to < pendingAmounts.length, ""Invalid index range."");

        for (uint i = _from; i <= _to; i++) {
            uint amount = pendingAmounts[i];
            if (amount > 0) {
                pendingAmounts[i] = 0; // Reset the pending amount to zero after transfer.
                payable(_buyer).transfer(amount);
            }
        }
        return true;
    }
}",44.10922813415527,sendPendingAmounts,29.0,0.8966572579425258,0.4164331592888216,"[{'function': 'sendPendingAmounts', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PendingAmounts is Ownable {
    mapping(uint => uint) public pendingAmounts;

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        pendingAmounts[0] = 1; // Example value for demonstration purposes
    }

    function sendPendingAmounts(uint _from, uint _to, address _buyer) public onlyOwner returns (bool) {
        require(_buyer != address(0), ""Buyer address cannot be the zero address."");
        require(_from <= _to && _from < pendingAmounts.length && _to < pendingAmounts.length, ""Invalid index range."");

        for (uint i = _from; i <= _to; i++) {
            uint amount = pendingAmounts[i];
            if (amount > 0) {
                pendingAmounts[i] = 0; // Reset the pending amount to zero after transfer.
                payable(_buyer).transfer(amount);
            }
        }
        return true;
    }
}"
5497,Returns asset balance for a particular holder id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IAsset {
    function balanceOf(uint _holderId, bytes32 _symbol) external view returns (uint);
}

abstract contract AssetWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => Asset) public assets;

    struct Asset {
        mapping(uint => Wallet) wallets;
    }

    struct Wallet {
        uint balance;
    }

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol].wallets[_holderId].balance;
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': '_balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""_balanceOf"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_holderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_symbol"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_symbol""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_holderId""}}, ""memberName"": ""balance""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract AssetManagement {
    struct Wallet {
        uint balance;
    }

    mapping(bytes32 => mapping(uint => Wallet)) public assets;

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol][_holderId].balance;
    }
}",42.09127068519592,_balanceOf,1.0,0.9272810605466528,0.8979542144404234,"[{'function': '_balanceOf', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetManagement is Ownable {
    struct Wallet {
        uint balance;
    }

    mapping(bytes32 => mapping(uint => Wallet)) public assets;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        bytes32 initialSymbol = bytes32('init');
        uint initialHolderId = 1;
        assets[initialSymbol][initialHolderId] = Wallet({balance: 1});
    }

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol][_holderId].balance;
    }
}"
124,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender; // Simplified ownership check for demonstration purposes
    }
}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allStarIndexToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwnerOf"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract StarToken {
    mapping(uint256 => address) public allStarIndexToApproved;
    address owner;

    event Approval(address indexed owner, address indexed approved, uint256 tokenId);

    modifier onlyOwnerOf(uint256 _tokenId) {
        require(ownerOf(_tokenId) == msg.sender, ""Not the owner of this token"");
        _;
    }

    function ownerOf(uint256 _tokenId) internal view returns (address) {
        // Implement your logic to get the owner of a specific token ID
        return address(0); // Placeholder for actual implementation
    }

    function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }
}",43.7911262512207,ownerOf,10.0,0.5944536441384336,0.0413915671187785,"[{'function': 'ownerOf', 'complexity': 0}, {'function': 'approve', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract StarToken is Ownable {
    mapping(uint256 => address) public allStarIndexToApproved;
    address owner;

    event Approval(address indexed owner, address indexed approved, uint256 tokenId);

    modifier onlyOwnerOf(uint256 _tokenId) {
        require(ownerOf(_tokenId) == msg.sender, ""Not the owner of this token"");
        _;
    }

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        allStarIndexToApproved[1] = address(0x1111111111111111111111111111111111111111); // Set a fixed value for the first index
        allStarIndexToApproved[2] = address(0x2222222222222222222222222222222222222222); // Set a fixed value for the second index
    }

    function ownerOf(uint256 _tokenId) internal view returns (address) {
        // Implement your logic to get the owner of a specific token ID
        return address(0); // Placeholder for actual implementation
    }

    function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }
}"
467,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    mapping(address => Beneficiary) public beneficiaries;
    IERC20 public token;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        require(token.transfer(owner, balance), ""Token transfer failed"");
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        emit BeneficiaryDestroyed(_beneficiary);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyVesting"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isBeneficiary""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, {""type"": ""stringLiteral"", ""value"": ""Beneficiary not found""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainingBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestedAmount""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""releasedAmount""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""remainingBalance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}, {""type"": ""Identifier"", ""name"": ""remainingBalance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalReleased""}, ""right"": {""type"": ""Identifier"", ""name"": ""remainingBalance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""releasedAmount""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestedAmount""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isBeneficiary""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""FalseBody"": None}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BeneficiaryDestroyed""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract VestingDestroyer is Ownable {
    IERC20 public token;
    mapping(address => uint256) public vestedAmount;
    mapping(address => uint256) public releasedAmount;
    mapping(address => bool) public isBeneficiary;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _token, address[] memory beneficiaries, uint256[] memory amounts) {
        token = IERC20(_token);
        for (uint i = 0; i < beneficiaries.length; i++) {
            vestedAmount[beneficiaries[i]] = amounts[i];
            isBeneficiary[beneficiaries[i]] = true;
        }
    }

    function destroyVesting(address _beneficiary) public onlyOwner {
        require(isBeneficiary[_beneficiary], ""Beneficiary not found"");

        uint256 remainingBalance = vestedAmount[_beneficiary] - releasedAmount[_beneficiary];
        if (remainingBalance > 0) {
            token.transfer(owner(), remainingBalance);
            totalReleased += remainingBalance;
            releasedAmount[_beneficiary] = vestedAmount[_beneficiary];
            isBeneficiary[_beneficiary] = false;
        }

        emit BeneficiaryDestroyed(_beneficiary);
    }
}",45.8803870677948,destroyVesting,37.0,0.7911625710835133,0.2772288957243001,"[{'function': 'destroyVesting', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VestingDestroyer is Ownable {
    IERC20 public token;
    mapping(address => uint256) public vestedAmount;
    mapping(address => uint256) public releasedAmount;
    mapping(address => bool) public isBeneficiary;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _token, address[] memory beneficiaries, uint256[] memory amounts) Ownable(msg.sender) {
        token = IERC20(_token);
        for (uint i = 0; i < beneficiaries.length; i++) {
            vestedAmount[beneficiaries[i]] = amounts[i];
            isBeneficiary[beneficiaries[i]] = true;
        }
    }

    function destroyVesting(address _beneficiary) public onlyOwner {
        require(isBeneficiary[_beneficiary], ""Beneficiary not found"");

        uint256 remainingBalance = vestedAmount[_beneficiary] - releasedAmount[_beneficiary];
        if (remainingBalance > 0) {
            token.transfer(owner(), remainingBalance);
            totalReleased += remainingBalance;
            releasedAmount[_beneficiary] = vestedAmount[_beneficiary];
            isBeneficiary[_beneficiary] = false;
        }

        emit BeneficiaryDestroyed(_beneficiary);
    }
}"
3604,Adds a co-owner for an asset with provided symbol .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetWrapper {
    using SafeMath for uint256;

    struct Asset {
        mapping(uint => bool) partowners;
    }

    bytes32[] public symbols;
    mapping(bytes32 => Asset) public assets;
    address public eventsHistory;
    uint constant OK = 1;

    modifier onlyOneOfOwners(bytes32 _symbol) {
        require(_isPartowner(_symbol, msg.sender), ""Not a part owner"");
        _;
    }

    function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {
        uint holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);
        return OK;
    }

    function _isPartowner(bytes32 _symbol, address _partowner) internal view returns (bool) {
        for (uint i = 0; ; ++i) {
            if (!assets[_symbol].partowners[i]) {
                return false;
            }
            if (_partowner == address(0)) {
                break;
            }
        }
        return true;
    }

    function _createHolderId(address _partowner) internal pure returns (uint holderId) {
        holderId = uint256(_partowner);
    }
}","[{'function': 'addAssetPartOwner', 'complexity': 0}, {'function': '_isPartowner', 'complexity': 7}, {'function': '_createHolderId', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addPartOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_symbol"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_partowner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""holderId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_createHolderId""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_partowner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""assets""}, ""index"": {""type"": ""Identifier"", ""name"": ""_symbol""}}, ""memberName"": ""partowners""}, ""index"": {""type"": ""Identifier"", ""name"": ""holderId""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OwnershipChange""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}, {""type"": ""Identifier"", ""name"": ""_partowner""}, {""type"": ""Identifier"", ""name"": ""_symbol""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOneOfOwners"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_symbol""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract AssetRegistry {
    struct Asset {
        mapping(uint => bool) partowners;
    }

    mapping(bytes32 => Asset) public assets;
    uint public holderIdCounter = 1; // Start from 1 as 0 might be used for some purpose

    modifier onlyOneOfOwners(bytes32 _symbol) {
        require(assets[_symbol].partowners[holderIdCounter] == true, ""Not an owner"");
        _;
    }

    function addPartOwner(bytes32 _symbol, address _partowner) public onlyOneOfOwners(_symbol) {
        uint holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        emit OwnershipChange(0x0, _partowner, _symbol);
    }

    function _createHolderId(address _partowner) internal returns (uint holderId) {
        // This is a simple implementation. In practice, you might want to use more complex logic to generate unique IDs.
        return holderIdCounter++;
    }

    event OwnershipChange(address indexed previousOwner, address indexed newOwner, bytes32 indexed symbol);
}",44.21252655982971,addPartOwner,8.0,0.6895818438671496,0.1510017810183114,"[{'function': 'addPartOwner', 'complexity': 0}, {'function': '_createHolderId', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract AssetRegistry is Ownable {
    struct Asset {
        mapping(uint => bool) partowners;
    }

    mapping(bytes32 => Asset) public assets;
    uint public holderIdCounter = 1; // Start from 1 as 0 might be used for some purpose

    modifier onlyOneOfOwners(bytes32 _symbol) {
        require(assets[_symbol].partowners[holderIdCounter] == true, ""Not an owner"");
        _;
    }

    function addPartOwner(bytes32 _symbol, address _partowner) public onlyOneOfOwners(_symbol) {
        uint holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        emit OwnershipChange(0x1111111111111111111111111111111111111111, 0x1111111111111111111111111111111111111111, _symbol);
    }

    function _createHolderId(address _partowner) internal returns (uint holderId) {
        // This is a simple implementation. In practice, you might want to use more complex logic to generate unique IDs.
        return holderIdCounter++;
    }

    event OwnershipChange(address indexed previousOwner, address indexed newOwner, bytes32 indexed symbol);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        holderIdCounter = 1;
    }
}"
5691,allows participants in the Atonomi network to claim their rewards,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWithdrawal is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public rewards;
    IERC20 public token;
    bool public paused = false;

    event TokensWithdrawn(address indexed user, uint256 amount);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function withdrawTokens() public whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");
        rewards[msg.sender] = rewards[msg.sender].sub(amount);
        emit TokensWithdrawn(msg.sender, amount);
        require(token.transfer(msg.sender, amount), ""token transfer failed"");
        return true;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawTokens', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""amount is zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensWithdrawn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""success""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""token transfer failed""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract RewardTokenContract {
    mapping(address => uint256) public rewards;
    IERC20 public token;
    bool public paused = false;

    event TokensWithdrawn(address indexed user, uint256 amount);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function withdrawTokens() external whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");

        rewards[msg.sender] = 0;

        emit TokensWithdrawn(msg.sender, amount);

        bool success = token.transfer(msg.sender, amount);
        if (!success) {
            revert(""token transfer failed"");
        }

        return true;
    }
}",44.22825622558594,withdrawTokens,15.0,0.8996084624454397,0.6620871027578075,"[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawTokens', 'complexity': 3}]",3.0,"pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract RewardTokenContract is Ownable {
    mapping(address => uint256) public rewards;
    IERC20 public token;
    bool public paused = false;

    event TokensWithdrawn(address indexed user, uint256 amount);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    constructor(address _tokenAddress) Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
        rewards[msg.sender] = 1; // Initialize the reward for the owner to a non-zero value
        paused = true; // Set pause state to true by default
    }

    function withdrawTokens() external whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");

        rewards[msg.sender] = 0;

        emit TokensWithdrawn(msg.sender, amount);

        bool success = token.transfer(msg.sender, amount);
        if (!success) {
            revert(""token transfer failed"");
        }

        return true;
    }
}"
2271,Deposit Ether where the contribution is credited to the address specified in the parameter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public isOpen = true;
    address[] public swimmersList;
    mapping(address => bool) public invested;
    mapping(address => uint256) public swimmers;
    uint256 public weiRaised;

    event Deposit(address indexed user, uint256 amount);

    modifier depositIsConfigCompliant() {
        require(isOpen, ""Deposit is not open"");
        _;
    }

    modifier canDeposit(address _user) {
        // Assuming some logic for checking if the user can deposit
        require(/* some condition */, ""User cannot deposit at this time"");
        _;
    }

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            swimmersList.push(_user);
            invested[_user] = true;
        }
        weiRaised = weiRaised.add(msg.value);
        swimmers[_user] = swimmers[_user].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }
}","[{'function': 'deposit', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""invested""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""invested""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""swimmersList""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_user""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""weiRaised""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""swimmers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_user""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Deposit""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""isOpen"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""depositIsConfigCompliant"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""canDeposit"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_user""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","pragma solidity ^0.8.0;

contract DepositContract {
    mapping(address => bool) public invested;
    mapping(address => uint256) public swimmers;
    address[] public swimmersList;
    uint256 public weiRaised;

    modifier isOpen() {
        require(isDepositPeriodOpen(), ""Deposit period is not open"");
        _;
    }

    modifier depositIsConfigCompliant() {
        require(depositConfigurationComplies(), ""Deposit configuration does not comply"");
        _;
    }

    modifier canDeposit(address _user) {
        require(canUserDeposit(_user), ""User is not allowed to deposit"");
        _;
    }

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            invested[_user] = true;
            swimmersList.push(_user);
        }

        weiRaised += msg.value;
        swimmers[_user] += msg.value;

        emit Deposit(msg.sender, msg.value);
    }

    function isDepositPeriodOpen() internal view returns (bool) {
        // Implement logic to check if deposit period is open
        return true; // Placeholder
    }

    function depositConfigurationComplies() internal view returns (bool) {
        // Implement logic to check deposit configuration compliance
        return true; // Placeholder
    }

    function canUserDeposit(address _user) internal view returns (bool) {
        // Implement logic to determine if user is allowed to deposit
        return true; // Placeholder
    }

    event Deposit(address indexed sender, uint256 value);
}",45.95156979560852,deposit,8.0,0.8638233717151514,0.6183979281390294,"[{'function': 'deposit', 'complexity': 2}, {'function': 'isDepositPeriodOpen', 'complexity': 0}, {'function': 'depositConfigurationComplies', 'complexity': 0}, {'function': 'canUserDeposit', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DepositContract is Ownable {
    mapping(address => bool) public invested;
    mapping(address => uint256) public swimmers;
    address[] public swimmersList;
    uint256 public weiRaised;

    modifier isOpen() {
        require(isDepositPeriodOpen(), ""Deposit period is not open"");
        _;
    }

    modifier depositIsConfigCompliant() {
        require(depositConfigurationComplies(), ""Deposit configuration does not comply"");
        _;
    }

    modifier canDeposit(address _user) {
        require(canUserDeposit(_user), ""User is not allowed to deposit"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        weiRaised = 0;
    }

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            invested[_user] = true;
            swimmersList.push(_user);
        }

        weiRaised += msg.value;
        swimmers[_user] += msg.value;

        emit Deposit(msg.sender, msg.value);
    }

    function isDepositPeriodOpen() internal view returns (bool) {
        // Implement logic to check if deposit period is open
        return true; // Placeholder
    }

    function depositConfigurationComplies() internal view returns (bool) {
        // Implement logic to check deposit configuration compliance
        return true; // Placeholder
    }

    function canUserDeposit(address _user) internal view returns (bool) {
        // Implement logic to determine if user is allowed to deposit
        return true; // Placeholder
    }

    event Deposit(address indexed sender, uint256 value);
}"
2948,The auction contract variable ( saleAuction ) is defined in MasterpieceBase to allow us to refer to them in MasterpieceOwnership to prevent accidental transfers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    SaleClockAuction public saleAuction;

    function setSaleAuctionAddress(address _address) external onlyCEO {
        SaleClockAuction candidateContract = SaleClockAuction(_address);
        require(candidateContract.isSaleClockAuction());
        saleAuction = candidateContract;
    }
}","[{'function': 'setSaleAuctionAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setSaleAuctionAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""SaleClockAuction""}, ""name"": ""candidateContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SaleClockAuction""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""candidateContract""}, ""memberName"": ""isSaleClockAuction""}, ""arguments"": [], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Provided address is not a valid SaleClockAuction contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""saleAuction""}, ""right"": {""type"": ""Identifier"", ""name"": ""_address""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    address public saleAuction;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor(address _owner) {
        owner = _owner;
    }

    function setSaleAuctionAddress(address _address) external onlyOwner {
        SaleClockAuction candidateContract = SaleClockAuction(_address);
        require(candidateContract.isSaleClockAuction(), ""Provided address is not a valid SaleClockAuction contract"");
        saleAuction = _address;
    }
}",42.561336278915405,setSaleAuctionAddress,1.0,0.9604745540995896,0.5755122955249581,"[{'function': 'setSaleAuctionAddress', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    address public saleAuction;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor(address _owner) {
        owner = _owner;
    }

    function setSaleAuctionAddress(address _address) external onlyOwner {
        SaleClockAuction candidateContract = SaleClockAuction(_address);
        require(candidateContract.isSaleClockAuction(), ""Provided address is not a valid SaleClockAuction contract"");
        saleAuction = _address;
    }
}"
4839,"Returns the loan metadata , hashed with keccak256 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataHashWrapper is Ownable {
    using SafeMath for uint256;

    struct Loan {
        bytes32 metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadataHash(uint2atural index) public view returns (bytes32) {
        require(index < totalLoans(), ""Index out of bounds"");
        return keccak256(abi.encodePacked(loans[index].metadata));
    }

    function setLoanMetadata(uint256 index, bytes32 metadata) public onlyOwner {
        require(index < totalLoans(), ""Index out of bounds"");
        loans[index].metadata = metadata;
    }

    function totalLoans() internal view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(loans)));
    }
}","[{'function': 'tokenMetadataHash', 'complexity': 1}, {'function': 'setLoanMetadata', 'complexity': 1}, {'function': 'totalLoans', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""tokenMetadataHash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loans""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Index out of bounds""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""loans""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""metadata""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","pragma solidity ^0.8.0;

contract LoanContract {
    struct Loan {
        bytes32 metadata;
    }

    Loan[] public loans;

    function tokenMetadataHash(uint256 index) public view returns (bytes32) {
        require(index < loans.length, ""Index out of bounds"");
        return keccak256(abi.encodePacked(loans[index].metadata));
    }
}",42.02904796600342,tokenMetadataHash,2.0,0.9278467168424888,0.7983310165251871,"[{'function': 'tokenMetadataHash', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoanContract is Ownable {
    struct Loan {
        bytes32 metadata;
    }

    Loan[] public loans;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        loans = [Loan({metadata: bytes32('init')})];
    }

    function tokenMetadataHash(uint256 index) public view returns (bytes32) {
        require(index < loans.length, ""Index out of bounds"");
        return keccak256(abi.encodePacked(loans[index].metadata));
    }
}"
1398,Performs transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transferWithReference(address _to, uint _value, string memory _reference, address _sender) public onlyProxy returns (bool) {
        require(_checkTransferAllowance(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        require(_isValidCountryLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        if (!super.transferWithReference(_to, _value, _reference, _sender)) {
            return false;
        }
        _updateTransferLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender);
        _contractFallbackERC223(_sender, _to, _value);
        return true;
    }

    function _checkTransferAllowance(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for checking transfer allowance
        require(false, ""Not implemented"");
        return false;
    }

    function _isValidCountryLimits(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for validating country limits
        require(false, ""Not implemented"");
        return false;
    }

    function _updateTransferLimits(address _to, uint8 _role, uint _value, address _sender) internal {
        // Implement the logic to update transfer limits
        require(false, ""Not implemented"");
    }

    function _contractFallbackERC223(address _from, address _to, uint _value) internal {
        // Implement the fallback logic for ERC223 contract
        require(false, ""Not implemented"");
    }

    function _getParticipantRoles(address _sender, address _to) internal pure returns (uint8[2] memory roles) {
        // Implement the logic to get participant roles
        require(false, ""Not implemented"");
        return [uint8(0), uint8(0)];
    }
}","[{'function': 'transferWithReference', 'complexity': 4}, {'function': '_checkTransferAllowance', 'complexity': 1}, {'function': '_isValidCountryLimits', 'complexity': 1}, {'function': '_updateTransferLimits', 'complexity': 1}, {'function': '_contractFallbackERC223', 'complexity': 1}, {'function': '_getParticipantRoles', 'complexity': 1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_reference"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getParticipantRoles""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": None, ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_getParticipantRoles""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_checkTransferAllowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer not allowed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_isValidCountryLimits""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Invalid country limits""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferSuccess"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""__transferWithReference""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""_reference""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""transferSuccess""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_updateTransferLimits""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_contractFallbackERC223""}, ""arguments"": [], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenTransfer {
    // Assuming _getParticipantRoles, _checkTransferAllowance, _isValidCountryLimits, __transferWithReference, _updateTransferLimits, and _contractFallbackERC223 are defined elsewhere in the contract or imported libraries

    function transferTokens(address _to, uint256 _value, string memory _reference, address _sender) public returns (bool success) {
        // Step 1: Retrieve roles of both sender and recipient
        (, , , , , , , ) = _getParticipantRoles(_to); // Assuming this function returns multiple values including role information
        (, , , , , , , ) = _getParticipantRoles(_sender); // Similarly for the sender

        // Step 2: Check if transfer is allowed
        require(_checkTransferAllowance(_sender, _value), ""Transfer not allowed"");

        // Step 3: Validate country limits
        require(_isValidCountryLimits(_to, _value), ""Invalid country limits"");

        // Step 4: Perform the actual token transfer with reference
        bool transferSuccess = __transferWithReference(_to, _value, _reference);
        if (!transferSuccess) {
            return false;
        }

        // Step 5: Update transfer limits for the recipient
        _updateTransferLimits(_to, _value);

        // Step 6: Trigger fallback function on ERC223 contract
        _contractFallbackERC223();

        return true;
    }
}",45.10609436035156,transferTokens,40.0,0.8520980805242748,0.2450985258538169,"[{'function': 'transferTokens', 'complexity': 4}]",8.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    // Assuming _getParticipantRoles, _checkTransferAllowance, _isValidCountryLimits, __transferWithReference, _updateTransferLimits, and _contractFallbackERC223 are defined elsewhere in the contract or imported libraries

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(address _to, uint256 _value, string memory _reference, address _sender) public returns (bool success) {
        // Step 1: Retrieve roles of both sender and recipient
        (, , , , , , , ) = _getParticipantRoles(_to); // Assuming this function returns multiple values including role information
        (, , , , , , , ) = _getParticipantRoles(_sender); // Similarly for the sender

        // Step 2: Check if transfer is allowed
        require(_checkTransferAllowance(_sender, _value), ""Transfer not allowed"");

        // Step 3: Validate country limits
        require(_isValidCountryLimits(_to, _value), ""Invalid country limits"");

        // Step 4: Perform the actual token transfer with reference
        bool transferSuccess = __transferWithReference(_to, _value, _reference);
        if (!transferSuccess) {
            return false;
        }

        // Step 5: Update transfer limits for the recipient
        _updateTransferLimits(_to, _value);

        // Step 6: Trigger fallback function on ERC223 contract
        _contractFallbackERC223();

        return true;
    }
}"
883,Buy from multiple sellers at once to fill a single large order .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITrade {
    function execute(address seller, uint256 quantity, uint256 price) external returns (uint256);
    function isAllowedTrade(address user) external view returns (bool);
}

abstract contract TradeWrapper is Ownable {
    using SafeMath for uint256;

    bool public enforceKyc = false;
    mapping(address => TradeOrder) public orderBook;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
    }

    function setEnforceKyc(bool _enforceKyc) external onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setTradeOrder(address seller, uint256 quantity, uint256 price) external onlyOwner {
        orderBook[seller] = TradeOrder({quantity: quantity, price: price});
    }

    function multiExecute(address[] memory sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {
        require(!enforceKyc || ITrade(this).isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        totalVouchers = 0;
        for (uint i = 0; i < sellers.length; i++) {
            TradeOrder memory to = orderBook[sellers[i]];
            if (i == sellers.length - 1) {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), lastQuantity, to.price);
                totalVouchers += voucherCount;
            } else {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), to.quantity, to.price);
                totalVouchers += voucherCount;
            }
        }
        return totalVouchers;
    }
}","[{'function': 'isAllowedTrade', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setTradeOrder', 'complexity': 0}, {'function': 'multiExecute', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""multiExecute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""sellers"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""lastQuantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVouchers""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""seller"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TradeOrder""}, ""name"": ""order"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""Identifier"", ""name"": ""seller""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellers""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVouchers""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""lastQuantity""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""order""}, ""memberName"": ""price""}}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalVouchers""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""order""}, ""memberName"": ""quantity""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""order""}, ""memberName"": ""price""}}}}]}}]}}, {""type"": ""Identifier"", ""name"": ""totalVouchers""}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAllowed"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TradeExecutor {
    bool public enforceKyc = true;
    mapping(address => bool) allowedTraders;
    uint public totalVouchers;
    struct TradeOrder {
        uint quantity;
        uint price;
    }
    mapping(address => TradeOrder) public orderBook;

    modifier onlyAllowed() {
        if (enforceKyc && !isAllowedTrade(msg.sender)) {
            revert(""You are unknown and not allowed to trade."");
        }
        _;
    }

    function isAllowedTrade(address trader) internal view returns (bool) {
        return allowedTraders[trader];
    }

    function setAllowance(address trader, bool allowed) public {
        allowedTraders[trader] = allowed;
    }

    function addToOrderBook(address seller, uint quantity, uint price) public {
        orderBook[seller] = TradeOrder({quantity: quantity, price: price});
    }

    function multiExecute(address[] memory sellers, uint lastQuantity) public onlyAllowed returns (uint) {
        totalVouchers = 0;
        for (uint i = 0; i < sellers.length; i++) {
            address seller = sellers[i];
            TradeOrder memory order = orderBook[seller];
            if (i == sellers.length - 1) {
                // Execute trade with the specified lastQuantity and price
                totalVouchers += lastQuantity * order.price;
            } else {
                // Execute trade using the full quantity from their TradeOrder
                totalVouchers += order.quantity * order.price;
            }
        }
        return totalVouchers;
    }
}",45.99716019630432,multiExecute,40.0,0.6765535030363848,0.2817426871509095,"[{'function': 'isAllowedTrade', 'complexity': 0}, {'function': 'setAllowance', 'complexity': 0}, {'function': 'addToOrderBook', 'complexity': 0}, {'function': 'multiExecute', 'complexity': 3}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TradeExecutor is Ownable {
    bool public enforceKyc = true;
    mapping(address => bool) allowedTraders;
    uint public totalVouchers;
    struct TradeOrder {
        uint quantity;
        uint price;
    }
    mapping(address => TradeOrder) public orderBook;

    modifier onlyAllowed() {
        if (enforceKyc && !isAllowedTrade(msg.sender)) {
            revert(""You are unknown and not allowed to trade."");
        }
        _;
    }

    function isAllowedTrade(address trader) internal view returns (bool) {
        return allowedTraders[trader];
    }

    function setAllowance(address trader, bool allowed) public onlyOwner {
        allowedTraders[trader] = allowed;
    }

    function addToOrderBook(address seller, uint quantity, uint price) public onlyOwner {
        orderBook[seller] = TradeOrder({quantity: quantity, price: price});
    }

    function multiExecute(address[] memory sellers, uint lastQuantity) public onlyAllowed returns (uint) {
        totalVouchers = 0;
        for (uint i = 0; i < sellers.length; i++) {
            address seller = sellers[i];
            TradeOrder memory order = orderBook[seller];
            if (i == sellers.length - 1) {
                // Execute trade with the specified lastQuantity and price
                totalVouchers += lastQuantity * order.price;
            } else {
                // Execute trade using the full quantity from their TradeOrder
                totalVouchers += order.quantity * order.price;
            }
        }
        return totalVouchers;
    }

    constructor() Ownable(msg.sender) {
        enforceKyc = true;
        allowedTraders[address(0x111)] = true;
        allowedTraders[address(0x222)] = false;
        allowedTraders[address(0x333)] = true;
        orderBook[address(0x444)] = TradeOrder({quantity: 1, price: 1});
        orderBook[address(0x555)] = TradeOrder({quantity: 2, price: 2});
    }
}"
2617,Set current mtdAmount price in wei for one token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MTDContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdAmount;

    function setMtdAmount(uint256 mtdAmountInWei) public onlyOwner {
        require(mtdAmountInWei > 0, ""MTD amount must be greater than zero"");
        require(mtdAmount != mtdAmountInWei, ""MTD amount has not changed"");
        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices function
    }
}","[{'function': 'setMtdAmount', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMtdAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mtdAmountInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmountInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmountInWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""mtdAmount""}}, {""type"": ""stringLiteral"", ""value"": ""New amount must be different from current amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""mtdAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""mtdAmountInWei""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""updatePrices""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract MyContract {
    uint256 public mtdAmount;

    function setMtdAmount(uint256 mtdAmountInWei) external {
        require(mtdAmountInWei > 0, ""Amount must be greater than zero"");
        require(mtdAmountInWei != mtdAmount, ""New amount must be different from current amount"");

        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Additional logic to recalculate prices based on new mtdAmount
    }
}",42.46948003768921,setMtdAmount,1.0,0.9548269536847588,0.6083724826248552,"[{'function': 'setMtdAmount', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public mtdAmount;

    constructor() Ownable(msg.sender) {
        mtdAmount = 1; // Set to a non-zero, safe value
    }

    function setMtdAmount(uint256 mtdAmountInWei) external {
        require(mtdAmountInWei > 0, ""Amount must be greater than zero"");
        require(mtdAmountInWei != mtdAmount, ""New amount must be different from current amount"");

        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Additional logic to recalculate prices based on new mtdAmount
    }
}"
191,"Change period duration to ` @ transformTime ( _periodDuration ) ` , effective for next accounting period","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISettings {
    function periodDuration() external view returns (uint64);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Settings {
        uint64 periodDuration;
    }

    Settings public settings;

    event ChangePeriodDuration(uint64 indexed periodDuration);

    error ERROR_SET_PERIOD_TOO_SHORT();

    function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE, arr(uint256(_periodDuration), uint256(settings.periodDuration))) transitionsPeriod {
        require(_periodDuration >= 1 days, ERROR_SET_PERIOD_TOO_SHORT);
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }
}","[{'function': 'periodDuration', 'complexity': 0}, {'function': 'setPeriodDuration', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPeriodDuration"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint64""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}, {""type"": ""stringLiteral"", ""value"": ""ERROR_SET_PERIOD_TOO_SHORT""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""settings""}, ""memberName"": ""periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ChangePeriodDuration""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_periodDuration""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""authP"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""transitionsPeriod"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract PeriodDurationSetter {
    struct Settings {
        uint64 periodDuration;
    }

    Settings public settings;
    bytes32 public constant CHANGE_PERIOD_ROLE = keccak256(""CHANGE_PERIOD_ROLE"");

    event ChangePeriodDuration(uint64 newPeriodDuration);

    modifier authP() {
        require(hasRole(CHANGE_PERIOD_ROLE, msg.sender), ""Not authorized"");
        _;
    }

    modifier transitionsPeriod() {
        // Additional logic for transitioning between periods can be added here
        _;
    }

    function setPeriodDuration(uint64 _periodDuration) external authP transitionsPeriod {
        require(_periodDuration >= 1 days, ""ERROR_SET_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }
}",43.50686597824097,setPeriodDuration,11.0,0.7123479932361545,0.4999174641340916,"[{'function': 'setPeriodDuration', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PeriodDurationSetter is Ownable {
    struct Settings {
        uint64 periodDuration;
    }

    Settings public settings;
    bytes32 public constant CHANGE_PERIOD_ROLE = keccak256(""CHANGE_PERIOD_ROLE"");

    event ChangePeriodDuration(uint64 newPeriodDuration);

    modifier authP() {
        require(hasRole(CHANGE_PERIOD_ROLE, msg.sender), ""Not authorized"");
        _;
    }

    modifier transitionsPeriod() {
        // Additional logic for transitioning between periods can be added here
        _;
    }

    constructor() Ownable(msg.sender) {
        settings = Settings({periodDuration: 1 days});
    }

    function setPeriodDuration(uint64 _periodDuration) external authP transitionsPeriod {
        require(_periodDuration >= 1 days, ""ERROR_SET_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }
}"
243,Allows resetting the entire bid decryption/appending process in case a mistake was made and it is not possible to continue appending further bids .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum state { active, ended }

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
    }

    mapping(uint => Bid) public bids;
    uint[] public bids_decrypted;
    uint public bids_reset_count;
    uint public bids_decrypted_count;
    uint public bids_sorted_count;
    uint public bids_ignored_count;
    uint public bids_burned_count;
    state public status;

    function resetAppendDecryptedBids(uint _count) public onlyOwner {
        require(status == state.ended);
        require(bids_decrypted_count > 0);
        require(_count > 0);

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted_count;
        }

        uint count = _count;
        if (bids_reset_count < count) {
            count = bids_reset_count;
        }

        do {
            bids_reset_count--;
            bids[bids_decrypted[bids_reset_count]].is_decrypted = false;
            bids[bids_decrypted[bids_reset_count]].is_burned = false;
            bids[bids_decrypted[bids_reset_count]].will_compute = false;
            count--;
        } while (count > 0);

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}","[{'function': 'resetAppendDecryptedBids', 'complexity': 6}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""resetBids"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_count"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""status""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""ContractStatus""}, ""memberName"": ""Ended""}}, {""type"": ""stringLiteral"", ""value"": ""Contract status must be ended to reset bids""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids_decrypted""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""There must be at least one decrypted bid""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Count must be greater than zero""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids_decrypted""}, ""memberName"": ""length""}}}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""countToReset"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_count""}, ""right"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}}, ""TrueExpression"": {""type"": ""Identifier"", ""name"": ""_count""}, ""FalseExpression"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""countToReset""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids_decrypted""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""is_decrypted""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""is_burned""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""memberName"": ""will_compute""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""--"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""isPrefix"": False}}]}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_reset_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_sorted_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_ignored_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_decrypted_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""bids_burned_count""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract BidManager {
    address public owner;
    uint public bids_reset_count;
    mapping(uint => Bid) public bids;
    uint[] public bids_decrypted;

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function resetBids(uint _count) public onlyOwner {
        require(status == ContractStatus.Ended, ""Contract status must be ended to reset bids"");
        require(bids_decrypted.length > 0, ""There must be at least one decrypted bid"");
        require(_count > 0, ""Count must be greater than zero"");

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted.length;
        }

        uint countToReset = _count < bids_reset_count ? _count : bids_reset_count;

        for (uint i = 0; i < countToReset; i++) {
            uint index = bids_decrypted[bids_reset_count - 1];
            bids[index].is_decrypted = false;
            bids[index].is_burned = false;
            bids[index].will_compute = false;
            bids_reset_count--;
        }

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}",46.42622327804565,resetBids,31.0,0.901393257850265,0.4143176840665829,"[{'function': 'resetBids', 'complexity': 7}]",7.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BidManager is Ownable {
    address public owner = msg.sender;
    uint public bids_reset_count;
    mapping(uint => Bid) public bids;
    uint[] public bids_decrypted;

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        bids_reset_count = 1;
        for (uint i = 0; i < bids_decrypted.length; i++) {
            bids[i].is_decrypted = false;
            bids[i].is_burned = false;
            bids[i].will_compute = false;
        }
    }

    function resetBids(uint _count) public onlyOwner {
        require(status == ContractStatus.Ended, ""Contract status must be ended to reset bids"");
        require(bids_decrypted.length > 0, ""There must be at least one decrypted bid"");
        require(_count > 0, ""Count must be greater than zero"");

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted.length;
        }

        uint countToReset = _count < bids_reset_count ? _count : bids_reset_count;

        for (uint i = 0; i < countToReset; i++) {
            uint index = bids_decrypted[bids_reset_count - 1];
            bids[index].is_decrypted = false;
            bids[index].is_burned = false;
            bids[index].will_compute = false;
            bids_reset_count--;
        }

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}"
6808,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public buyPrice;
    uint256 public sellPrice;

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBuyPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newSellPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""buyPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""sellPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

contract PriceSetter is Ownable {
    uint256 public buyPrice;
    uint256 public sellPrice;

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) external onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}",41.91799116134644,setPrices,0.0,0.9798183617952976,0.8492326635760689,"[{'function': 'setPrices', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceSetter is Ownable {
    uint256 public buyPrice;
    uint256 public sellPrice;

    constructor() Ownable(msg.sender) {
        buyPrice = 1;
        sellPrice = 2;
    }

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) external onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}"
4005,Buy quantity of tokens depending on the amount of sent ethers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event SoldToken(address indexed buyer, uint256 value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function BuyToken(address _buyer, uint256 _value, string memory note) public onlyOwner {
        require(balances[msg.sender] >= _value && balances[_buyer].add(_value) > balances[_buyer], ""Insufficient balance or overflow"");
        SoldToken(_buyer, _value, note);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_buyer] = balances[_buyer].add(_value);
        Transfer(msg.sender, _buyer, _value);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'BuyToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_buyer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""note"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance to cover the transfer amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}}, {""type"": ""stringLiteral"", ""value"": ""Buyer""s balance overflow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_buyer""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SoldToken""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_value""}, {""type"": ""Identifier"", ""name"": ""note""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_buyer""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract TokenContract {
    mapping(address => uint256) public balances;
    address public owner;

    event SoldToken(address indexed buyer, uint256 value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function buyToken(address _buyer, uint256 _value, string memory note) public onlyOwner {
        require(balances[msg.sender] >= _value, ""Insufficient balance to cover the transfer amount"");
        require(balances[_buyer] + _value > balances[_buyer], ""Buyer's balance overflow"");

        balances[msg.sender] -= _value;
        balances[_buyer] += _value;

        emit SoldToken(_buyer, _value, note);
        emit Transfer(msg.sender, _buyer, _value);
    }
}",44.37646818161011,buyToken,30.0,0.8066015664747699,0.5651745639599187,"[{'function': 'buyToken', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenContract is Ownable {
    mapping(address => uint256) public balances;

    event SoldToken(address indexed buyer, uint256 value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        balances[owner()] = 1; // Initialize balance to a non-zero safe value
    }

    function buyToken(address _buyer, uint256 _value, string memory note) public onlyOwner {
        require(balances[msg.sender] >= _value, ""Insufficient balance to cover the transfer amount"");
        require(balances[_buyer] + _value > balances[_buyer], ""Buyer's balance overflow"");

        balances[msg.sender] -= _value;
        balances[_buyer] += _value;

        emit SoldToken(_buyer, _value, note);
        emit Transfer(msg.sender, _buyer, _value);
    }
}"
5639,Transfers asset balance from the caller to specified receiver .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return _transferWithReference(_to, _value, """");
        }
    }
}","[{'function': 'transfer', 'complexity': 1}]",2.0,{},"pragma solidity ^0.8.0;

contract TokenTransfer {
    function transferTokens(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        return _transferWithReference(_to, _value, """");
    }

    function _transferWithReference(address _to, uint256 _value, string memory _reference) internal returns (bool success) {
        // Implement the logic for transferring tokens with a reference here.
        // This is a placeholder for the actual implementation of '_transferWithReference'.
        require(_to != address(0), ""Invalid recipient address"");
        // Transfer the tokens to the specified address and return the result.
        (bool sent, ) = _to.call{value: _value}("""");
        require(sent, ""Failed to send tokens"");
        return sent;
    }
}",43.43910527229309,_transferWithReference,16.0,0.8385073502485103,0.1531424835896511,"[{'function': 'transferTokens', 'complexity': 1}, {'function': '_transferWithReference', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    // Fixed, safe values for instance variables
    uint256 public constant DEFAULT_VALUE = 1;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        uint256Value = DEFAULT_VALUE;
        addressAddress = DEFAULT_ADDRESS;
        boolBool = DEFAULT_BOOL;
        stringString = DEFAULT_STRING;
        bytes32Bytes32 = DEFAULT_BYTES32;

        // Call parent contract's constructor
        Ownable(msg.sender);
    }

    uint256 public Value;
    address public Address;
    bool public Bool;
    string public String;
    bytes32 public Bytes32;

    function transferTokens(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient address"");
        return _transferWithReference(_to, _value, """");
    }

    function _transferWithReference(address _to, uint256 _value, string memory _reference) internal returns (bool success) {
        // Implement the logic for transferring tokens with a reference here.
        require(_to != address(0), ""Invalid recipient address"");
        // Transfer the tokens to the specified address and return the result.
        (bool sent, ) = _to.call{value: _value}("""");
        require(sent, ""Failed to send tokens"");
        return sent;
    }
}"
971,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","[{'function': 'approve', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Allowance already granted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool) {
        require((_value == 0) || (allowances[msg.sender][_spender] == 0), ""Allowance already granted"");
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",42.747294187545776,approve,18.0,0.7316767528235739,0.5481767321112002,"[{'function': 'approve', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool) {
        require((_value == 0) || (allowances[msg.sender][_spender] == 0), ""Allowance already granted"");
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract MyToken is Token {
    address public owner;

    constructor() {
        owner = msg.sender;
    }
}"
2396,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract OfferWrapper is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    bool public enforceKyc = false;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed user, uint256 quantity, uint256 price, uint256 expiry);

    function offer(uint256 quantity, uint256 price, uint256 expiry) public {
        require(enforceKyc == false || isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = ERC20Interface(_tokenContract);
    }

    function setEnforceKyc(bool _enforceKyc) public onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setSellFloor(uint256 _sellFloor) public onlyOwner {
        sellFloor = _sellFloor;
    }

    function setSellCeiling(uint256 _sellCeiling) public onlyOwner {
        sellCeiling = _sellCeiling;
    }

    function isAllowedTrade(address user) internal view returns (bool) {
        // Implement your KYC logic here
        return true; // Placeholder for actual implementation
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'offer', 'complexity': 10}, {'function': 'setTokenContract', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setSellFloor', 'complexity': 0}, {'function': 'setSellCeiling', 'complexity': 0}, {'function': 'isAllowedTrade', 'complexity': 0}]",14.0,"{""type"": ""FunctionDefinition"", ""name"": ""offer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""quantity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""expiry"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Quantity must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""expiry""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Expiry must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellFloor""}}, {""type"": ""stringLiteral"", ""value"": ""Price must meet or exceed sell floor""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""sellCeiling""}}, {""type"": ""stringLiteral"", ""value"": ""Price must not exceed sell ceiling""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Token allowance too low""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""quantity""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient token balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orderBook""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TradeOrder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": [""quantity"", ""price"", ""expiry""]}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokensOffered""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""quantity""}, {""type"": ""Identifier"", ""name"": ""price""}, {""type"": ""Identifier"", ""name"": ""expiry""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""enforceKycCheck"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

contract TokenTrade {
    struct TradeOrder {
        uint quantity;
        uint price;
        uint expiry;
    }

    mapping(address => TradeOrder) public orderBook;
    bool public enforceKyc = true;
    address public admin;
    ERC20Interface public tokenContract;
    uint public sellFloor;
    uint public sellCeiling;

    event TokensOffered(address indexed user, uint quantity, uint price, uint expiry);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier enforceKycCheck() {
        if (enforceKyc) {
            require(isAllowedTrade(msg.sender), ""KYC check failed"");
        }
        _;
    }

    constructor(address _tokenContract, uint _sellFloor, uint _sellCeiling) {
        admin = msg.sender;
        tokenContract = ERC20Interface(_tokenContract);
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function offer(uint quantity, uint price, uint expiry) public enforceKycCheck {
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(price > 0, ""Price must be greater than zero"");
        require(expiry > block.timestamp, ""Expiry must be in the future"");
        require(price >= sellFloor, ""Price must meet or exceed sell floor"");
        if (sellCeiling != 0) {
            require(price <= sellCeiling, ""Price must not exceed sell ceiling"");
        }
        require(tokenContract.allowance(msg.sender, address(this)) >= quantity, ""Token allowance too low"");
        require(tokenContract.balanceOf(msg.sender) >= quantity, ""Insufficient token balance"");

        orderBook[msg.sender] = TradeOrder({quantity: quantity, price: price, expiry: expiry});
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function isAllowedTrade(address user) public view returns (bool) {
        // Implement KYC logic here
        return true; // Placeholder for actual KYC check implementation
    }
}",48.48530197143555,offer,47.0,0.8785165275872866,0.3293085825330978,"[{'function': 'balanceOf', 'complexity': 0}, {'function': 'offer', 'complexity': 8}, {'function': 'isAllowedTrade', 'complexity': 0}]",10.0,"pragma solidity ^0.8.0;

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTrade is Ownable {
    struct TradeOrder {
        uint quantity;
        uint price;
        uint expiry;
    }

    mapping(address => TradeOrder) public orderBook;
    bool public enforceKyc = true;
    address public admin;
    ERC20Interface public tokenContract;
    uint public sellFloor;
    uint public sellCeiling;

    event TokensOffered(address indexed user, uint quantity, uint price, uint expiry);

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    modifier enforceKycCheck() {
        if (enforceKyc) {
            require(isAllowedTrade(msg.sender), ""KYC check failed"");
        }
        _;
    }

    mapping(address => uint256) public balanceOf;

 constructor(address _tokenContract, uint _sellFloor, uint _sellCeiling) Ownable(msg.sender) {
        tokenContract = ERC20Interface(_tokenContract);
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function offer(uint quantity, uint price, uint expiry) public enforceKycCheck {
        require(quantity > 0, ""Quantity must be greater than zero"");
        require(price > 0, ""Price must be greater than zero"");
        require(expiry > block.timestamp, ""Expiry must be in the future"");
        require(price >= sellFloor, ""Price must meet or exceed sell floor"");
        if (sellCeiling != 0) {
            require(price <= sellCeiling, ""Price must not exceed sell ceiling"");
        }
        require(tokenContract.allowance(msg.sender, address(this)) >= quantity, ""Token allowance too low"");
        require(tokenContract.balanceOf(msg.sender) >= quantity, ""Insufficient token balance"");

        orderBook[msg.sender] = TradeOrder({quantity: quantity, price: price, expiry: expiry});
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function isAllowedTrade(address user) public view returns (bool) {
        // Implement KYC logic here
        return true; // Placeholder for actual KYC check implementation
    }
}"
2112,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed receiver, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No Ether to transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""controller""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to transfer""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""controller""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Token transfer failed""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}, {""type"": ""Identifier"", ""name"": ""controller""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

contract TokenClaimable {
    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    event ClaimedTokens(address indexed token, address indexed to, uint256 amount);

    constructor(address _controller) {
        controller = _controller;
    }

    function claimTokens(address _token) external onlyController {
        if (_token == address(0)) {
            require(address(this).balance > 0, ""No Ether to transfer"");
            payable(controller).transfer(address(this).balance);
            emit ClaimedTokens(_token, controller, address(this).balance);
        } else {
            ERC20 token = ERC20(_token);
            uint256 balance = token.balanceOf(address(this));
            require(balance > 0, ""No tokens to transfer"");
            bool success = token.transfer(controller, balance);
            require(success, ""Token transfer failed"");
            emit ClaimedTokens(_token, controller, balance);
        }
    }
}",44.502432107925415,claimTokens,20.0,0.8819901349802577,0.4160869120106105,"[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

interface ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}
import ""openzeppelin/SafeMath.sol"";
contract TokenClaimable is Ownable {
    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    event ClaimedTokens(address indexed token, address indexed to, uint256 amount);

    mapping(address => uint256) public balanceOf;

 constructor(address _controller) Ownable(msg.sender) {
        controller = _controller;
    }

    function claimTokens(address _token) external onlyController {
        if (_token == address(0)) {
            require(address(this).balance > 0, ""No Ether to transfer"");
            payable(controller).transfer(address(this).balance);
            emit ClaimedTokens(_token, controller, address(this).balance);
        } else {
            ERC20 token = ERC20(_token);
            uint256 balance = token.balanceOf(address(this));
            require(balance > 0, ""No tokens to transfer"");
            bool success = token.transfer(controller, balance);
            require(success, ""Token transfer failed"");
            emit ClaimedTokens(_token, controller, balance);
        }
    }
}"
5098,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public withdrawalRequests;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        if (withdrawalRequests[_from] > 0) revert();
        if (withdrawalRequests[_to] > 0) revert();
        if (balanceOf[_from].sub(balanceOf[_from]) != balanceOf[_from]) revert();
        if (balanceOf[_to].add(_value) < balanceOf[_to]) revert();
        if (_value.add(allowance[_from][msg.sender]) != allowance[_from][msg.sender]) revert();
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Transfer amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Allowance insufficient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract Token {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value > 0, ""Transfer amount must be greater than zero"");
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(allowance[_from][msg.sender] >= _value, ""Allowance insufficient"");

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }
}",43.63386559486389,transferFrom,59.0,0.543526571181318,0.266281709122475,"[{'function': 'transferFrom', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[owner()] = 1; // Set initial balance for the owner
        allowance[owner()][address(this)] = type(uint256).max; // Infinite allowance for this contract
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value > 0, ""Transfer amount must be greater than zero"");
        require(balanceOf[_from] >= _value, ""Insufficient balance"");
        require(allowance[_from][msg.sender] >= _value, ""Allowance insufficient"");

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);
        return true;
    }
}"
3297,Used by a staker to withdraw their initial stake,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    enum StakeStateEnum { staked, released }

    struct Stake {
        uint256 initialStake;
        StakeStateEnum state;
    }

    mapping(address => mapping(uint256 => Stake)) public stakes;
    uint256 public activeStakes;
    mapping(address => uint256) public internalRTCBalances;
    IERC20 public RTI;

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staked, ""Invalid stake state"");
        _;
    }

    function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {
        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.released;
        activeStakes = activeStakes.sub(1);
        internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
        require(RTI.transfer(msg.sender, initialStake), ""Unable to transfer tokens likely due to incorrect balance"");
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawInitialStake', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawInitialStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_stakeNumber"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_stakeNumber""}}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""StakeStateEnum""}, ""memberName"": ""staked""}}, {""type"": ""stringLiteral"", ""value"": ""Stake is already staked""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Stake""}, ""name"": ""stake"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_stakeNumber""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stake""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No initial stake found for this number""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_stakeNumber""}}, ""memberName"": ""state""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""StakeStateEnum""}, ""memberName"": ""staked""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""Identifier"", ""name"": ""activeStakes""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""internalRTCBalances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stake""}, ""memberName"": ""amount""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""InitialStakeWithdrawn""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_stakeNumber""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stake""}, ""memberName"": ""amount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""RTI""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stake""}, ""memberName"": ""amount""}], ""names"": []}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""validInitialStakeRelease"", ""arguments"": [{""type"": ""Identifier"", ""name"": ""_stakeNumber""}]}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

contract StakingContract {
    enum StakeStateEnum { staked, released }

    struct Stake {
        uint256 amount;
        StakeStateEnum state;
    }

    mapping(address => mapping(uint256 => Stake)) public stakes;
    mapping(address => uint256) public internalRTCBalances;
    uint256 public activeStakes;

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(_stakeNumber < activeStakes, ""Invalid stake number"");
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.released, ""Stake is not released yet"");
        _;
    }

    function withdrawInitialStake(uint256 _stakeNumber) external validInitialStakeRelease(_stakeNumber) returns (bool) {
        require(stakes[msg.sender][_stakeNumber].state != StakeStateEnum.staked, ""Stake is already staked"");

        Stake memory stake = stakes[msg.sender][_stakeNumber];
        require(stake.amount > 0, ""No initial stake found for this number"");

        // Update the state of the stake to 'staked'
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.staked;

        // Decrease the count of active stakes
        activeStakes -= 1;

        // Reduce the internal RTC balance of the sender by the withdrawn stake amount
        internalRTCBalances[msg.sender] -= stake.amount;

        // Emit an event with details of the withdrawal
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, stake.amount);

        // Transfer the initial stake amount to the sender
        if (!RTI.transfer(msg.sender, stake.amount)) {
            revert(""Transfer failed"");
        }

        return true;
    }
}",46.877790689468384,withdrawInitialStake,38.0,0.8768580940945148,0.1798814787355144,"[{'function': 'withdrawInitialStake', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract StakingContract is Ownable {
    enum StakeStateEnum { staked, released }

    struct Stake {
        uint256 amount;
        StakeStateEnum state;
    }

    mapping(address => mapping(uint256 => Stake)) public stakes;
    mapping(address => uint256) public internalRTCBalances;
    uint256 public activeStakes;

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(_stakeNumber < activeStakes, ""Invalid stake number"");
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.released, ""Stake is not released yet"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        activeStakes = 0;
    }

    function withdrawInitialStake(uint256 _stakeNumber) external validInitialStakeRelease(_stakeNumber) returns (bool) {
        require(stakes[msg.sender][_stakeNumber].state != StakeStateEnum.staked, ""Stake is already staked"");

        Stake memory stake = stakes[msg.sender][_stakeNumber];
        require(stake.amount > 0, ""No initial stake found for this number"");

        // Update the state of the stake to 'staked'
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.staked;

        // Decrease the count of active stakes
        activeStakes -= 1;

        // Reduce the internal RTC balance of the sender by the withdrawn stake amount
        internalRTCBalances[msg.sender] -= stake.amount;

        // Emit an event with details of the withdrawal
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, stake.amount);

        // Transfer the initial stake amount to the sender
        if (!RTI.transfer(msg.sender, stake.amount)) {
            revert(""Transfer failed"");
        }

        return true;
    }
}"
1877,A function which allows the caller to approve the max amount of any given token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeERC20 {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 value) internal returns (bool) {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(ERC20.approve.selector, spender, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""SafeERC20: approve failed"");
        return true;
    }
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function approveAddress(address addressToApprove, address token) public onlyOwner {
        if (ERC20(token).allowance(address(this), addressToApprove) == 0) {
            require(SafeERC20.safeApprove(token, addressToApprove, uint256(-1)));
        }
    }
}","[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 3}, {'function': 'approveAddress', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addressToApprove"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""addressToApprove""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Allowance already set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addressToApprove""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": ""type"", ""arguments"": [{""type"": ""ElementaryTypeName"", ""name"": ""uint256""}], ""names"": []}, ""memberName"": ""max""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","pragma solidity ^0.8.0;

interface ERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
}

contract TokenApprover {
    function approveAddress(address addressToApprove, address token) public {
        require(ERC20(token).allowance(address(this), addressToApprove) == 0, ""Allowance already set"");
        ERC20(token).approve(addressToApprove, type(uint256).max);
    }
}",42.51281213760376,approveAddress,35.0,0.822389359611686,0.0185683610692941,"[{'function': 'allowance', 'complexity': 0}, {'function': 'approveAddress', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenApprover {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function approveAddress(address addressToApprove, address token) public {
        require(ERC20(token).allowance(address(this), addressToApprove) == 0, ""Allowance already set"");
        ERC20(token).approve(addressToApprove, type(uint256).max);
    }
}"
